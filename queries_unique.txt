""""
"&"
'&#;'
''''
("**" || "***")
(())?(())
() != ()
() < ()
() <<
() <<< ()
() <= ()
() = ()
() > ()
() >= ()
() >>
() >>> ()
() | ()
(.)
*:
---..---
.
/*/
/*/.
/.
//
///
/>
<
<!
<!-
<!--
<!-- -- -->
<!---
<!----
<!----->
<!---->
<!-->
</>
<<
<< ()
<<<
<?
<??>
>
>>
>> ()
>>>
@
[]?*
[]?*?*
_
}
} }
("%$" || "#@!")
$a, function($a) { "lala", $a }
$NOTEXIST
$NOTEXIST + 1
($staff/staff[1]/employee[1]/empnum[1]) is $works/works[1]/employee[1]/empnum[1]
($works//empnum,$staff//empname)
$works/works[1]/employee[1]/empnum[1] << $staff/staff[1]/employee[1]/empnum[1]
$works/works[1]/employee[1]/empnum[1] >> ($staff/staff[1]/employee[1]/empnum[1])
(($works/works[1]/employee[1]/empnum[1] << $staff/staff[1]/employee[1]/empnum[1])           and ($works/works[1]/employee[1]/empnum[1] << $staff/staff[1]/employee[2]/empnum[1])           and ($works/works[1]/employee[1]/empnum[1] << $staff/staff[1]/employee[3]/empnum[1]))           or (($works/works[1]/employee[1]/empnum[1] >> $staff/staff[1]/employee[1]/empnum[1])           and ($works/works[1]/employee[1]/empnum[1] >> $staff/staff[1]/employee[2]/empnum[1])           and ($works/works[1]/employee[1]/empnum[1] >> $staff/staff[1]/employee[3]/empnum[1]))
(($works/works[1]/employee[1]/empnum[1] >> $staff/staff[1]/employee[1]/empnum[1])           and ($works/works[1]/employee[2]/empnum[1] >> $staff/staff[1]/employee[2]/empnum[1])           and ($works/works[1]/employee[3]/empnum[1] >> $staff/staff[1]/employee[3]/empnum[1]))           or (($works/works[1]/employee[1]/empnum[1] << $staff/staff[1]/employee[1]/empnum[1])           and ($works/works[1]/employee[2]/empnum[1] << $staff/staff[1]/employee[2]/empnum[1])           and ($works/works[1]/employee[3]/empnum[1] << $staff/staff[1]/employee[3]/empnum[1]))
$works/works[1]/employee[1]/empnum[1] is $staff/staff[1]/employee[1]/empnum[1]
() != ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
() < ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
() <= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
() = ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
() > ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
() >= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) != ()
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) < ()
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) <= ()
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) = ()
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) > ()
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) >= ()
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) != ($works/works/employee[1]/hours[1])
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) < ($works/works/employee[1]/hours[1])
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) <= ($works/works/employee[1]/hours[1])
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) =          ($works/works/employee[1]/hours[1])
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) > ($works/works/employee[1]/hours[1])
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) >= ($works/works/employee[1]/hours[1])
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) != ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) < ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) <= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) = ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) >= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) != ($works/works/employee[1]/hours[1],$works/works/employee[6]/hours[1])
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) < ($works/works/employee[1]/hours[1],$works/works/employee[6]/hours[1])
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) <= ($works/works/employee[1]/hours[1],$works/works/employee[6]/hours[1])
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) = ($works/works/employee[1]/hours[1],$works/works/employee[6]/hours[1])
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) > ($works/works/employee[1]/hours[1],$works/works/employee[6]/hours[1])
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) >= ($works/works/employee[1]/hours[1],$works/works/employee[6]/hours[1])
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) != 10000
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) < 10000
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) <= 10000
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) = 10000
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) > 10000
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) >= 10000
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) != (10000,50000)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) < (10000,50000)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) <= (10000,50000)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) = (10000,50000)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) > (10000,50000)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) >= (10000,50000)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) != (50000)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) < (50000)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) <= (50000)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) = (50000)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) > (50000)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) >= (50000)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) != (<a>10000</a>)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) != <a>10000</a>
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) < (<a>10000</a>)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) < <a>10000</a>
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) <= (<a>10000</a>)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) <= <a>10000</a>
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) = (<a>10000</a>)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) = <a>10000</a>
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) > (<a>10000</a>)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) > <a>10000</a>
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) >= (<a>10000</a>)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) >= <a>10000</a>
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) != (<a>10000</a>,<b>50000</b>)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) < (<a>10000</a>,<b>50000</b>)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) <= (<a>10000</a>,<b>50000</b>)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) = (<a>10000</a>,<b>50000</b>)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) > (<a>10000</a>,<b>50000</b>)
($works/works/employee[1]/hours[1],$staff/staff/employee[6]/hours[1]) >= (<a>10000</a>,<b>50000</b>)
($works/works/employee[1]/hours[1]) != ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
($works/works/employee[1]/hours[1]) < ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
($works/works/employee[1]/hours[1]) <= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
($works/works/employee[1]/hours[1]) = ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
($works/works/employee[1]/hours[1]) > ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
($works/works/employee[1]/hours[1]) >= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
($works/works/employee[1]/hours[1],$works/works/employee[6]/hours[1]) != ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
($works/works/employee[1]/hours[1],$works/works/employee[6]/hours[1]) < ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
($works/works/employee[1]/hours[1],$works/works/employee[6]/hours[1]) <= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
($works/works/employee[1]/hours[1],$works/works/employee[6]/hours[1]) =           ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
($works/works/employee[1]/hours[1],$works/works/employee[6]/hours[1]) > ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
($works/works/employee[1]/hours[1],$works/works/employee[6]/hours[1]) >= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
$xs:NOTEXIST
$xs:NOTEXIST + 1
-0
-0.0
0.0
0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001e10
0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
"&#0000045;"
"-0000-05" castable as xs:gYearMonth
"0000-05" castable as xs:gYearMonth
"-0000-05" cast as xs:gYearMonth
"-0000" castable as xs:gYear
"0000" castable as xs:gYear
"-0000" cast as xs:gYear
"-00" castable as xs:nonNegativeInteger
"+00" castable as xs:nonPositiveInteger
"-00" castable as xs:unsignedByte
"-00" castable as xs:unsignedInt
"-00" castable as xs:unsignedLong
"-00" castable as xs:unsignedShort
+.0.1
-.0.1
..01
.0.1
(0, 1)[1] eq 0
(0, 1, 2)[1] eq 0
(0, 1, 2)[1 eq position()]
(0, 1, 2)[2] eq 1
0 < (1, 2, 3)
(0, 1, 2)[3] eq 2
(0, 1, 2)[3 eq position()]
(0, 1, 2, "a", "b", "c")[. instance of xs:integer][. eq "c"] eq 0
(0, 1, 2)[. eq 0]
(0, 1, 2)[. eq 1]
(0, 1, 2)[. eq 2]
(0, 1, "2")[last()]
(0, 1, 2)[last()]
(0, 1, 2)[position() eq 3]
(0, 1, 2)[remove((1, "a string"), 2)]
(0, 1, 2)[true()][1] eq 0
(0)[1] eq 0
0[1] eq 0
(0, 2, 4, 5)[1][1][1][true()][1][true()][1] eq 0
0.3 eq .3
"0" and ''
(0) and ()
0 and 0
(0) and (0)
0 and -1
0 and 1
(0) and (1)
(0) and (/bib/book/price/text())
0 castable as xs:negativeInteger
"0" castable as xs:negativeInteger
0 castable as xs:positiveInteger
"0" castable as xs:positiveInteger
'0' cast as xs:boolean eq false()
0 < count((1, 2, 3, timezone-from-time(current-time()), 4))
0 != count((1, 2, timezone-from-time(current-time())))
0 = count(//node())
(0 div 0E0) idiv xs:integer(2)
-0e0
0e0
+0e0 div +0e0
+0e0 div -0e0
-0e0 div +0e0
-0e0 div -0e0
0 eq (if(xs:anyURI("")) then 1 else 0)
0 gt xs:double("-INF")
0 gt xs:float("-INF")
0 lt count((1, 2, 3, timezone-from-time(current-time()), 4))
0 lt xs:double("INF")
0 lt xs:float("INF")
0 ne count((1, 2, timezone-from-time(current-time())))
"0" or ''
(0) or ()
0 or 0
(0) or (0)
0 or -1
0 or 1
(0) or (1)
(0) or (/bib/book/price/text())
0 or current-date()
0 or xs:anyURI("example.com/")
0 or xs:untypedAtomic("a string")
0x20
"&#0xA;"
0 * xs:dayTimeDuration("P3DT4H3M3.100S") eq xs:dayTimeDuration("PT0S")
0 - xs:double(0)
0 - xs:float(0)
0 * xs:yearMonthDuration("P3Y36M") eq xs:yearMonthDuration("P0M")
(1)
<< 1
>> 1
{1}
1 * ()
1 + ()
1 - ()
1 <<
1 >>
1 + $NOTEXIST
1 + $xs:NOTEXIST
() != 10000
() < 10000
() <= 10000
() = 10000
() > 10000
() >= 10000
10000 != ()
10000 < ()
10000 <= ()
10000 = ()
10000 > ()
10000 >= ()
10000 != ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
10000 < ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
10000 <= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
10000 = ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
10000 > ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
10000 >= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
'&#100000000'
10000000000000000000000000000.0 div 0.1 gt 0
'&#100000000x'
10000 != (10000,50000)
10000 < (10000,50000)
10000 <= (10000,50000)
10000 = (10000,50000)
10000 > (10000,50000)
10000 >= (10000,50000)
() != (10000,50000)
() < (10000,50000)
() <= (10000,50000)
() = (10000,50000)
() > (10000,50000)
() >= (10000,50000)
(10000,50000) != ()
(10000,50000) < ()
(10000,50000) <= ()
(10000,50000) = ()
(10000,50000) > ()
(10000,50000) >= ()
10000 != (50000)
10000 < (50000)
10000 <= (50000)
10000 > (50000)
10000 >= (50000)
(10000,50000) != ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(10000,50000) < ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(10000,50000) <= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(10000,50000) = ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(10000,50000) > ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(10000,50000) >= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(10000,50000) != 10000
(10000,50000) < 10000
(10000,50000) <= 10000
(10000,50000) = 10000
(10000,50000) > 10000
(10000,50000) >= 10000
(10000,50000) != (10000,50000)
(10000,50000) < (10000,50000)
(10000,50000) <= (10000,50000)
(10000,50000) = (10000,50000)
(10000,50000) > (10000,50000)
(10000,50000) >= (10000,50000)
(10000,50000) != (50000)
(10000,50000) < (50000)
(10000,50000) <= (50000)
(10000,50000) = (50000)
(10000,50000) > (50000)
(10000,50000) >= (50000)
(10000,50000) != (<a>10000</a>)
(10000,50000) != <a>10000</a>
(10000,50000) < (<a>10000</a>)
(10000,50000) < <a>10000</a>
(10000,50000) <= (<a>10000</a>)
(10000,50000) <= <a>10000</a>
(10000,50000) = (<a>10000</a>)
(10000,50000) = <a>10000</a>
(10000,50000) > (<a>10000</a>)
(10000,50000) > <a>10000</a>
(10000,50000) >= (<a>10000</a>)
(10000,50000) >= <a>10000</a>
(10000,50000) != (<a>10000</a>,<b>50000</b>)
(10000,50000) < (<a>10000</a>,<b>50000</b>)
(10000,50000) <= (<a>10000</a>,<b>50000</b>)
(10000,50000) = (<a>10000</a>,<b>50000</b>)
(10000,50000) > (<a>10000</a>,<b>50000</b>)
(10000,50000) >= (<a>10000</a>,<b>50000</b>)
(10000,50000) != (/works/employee[1]/hours[1])
(10000,50000) < (/works/employee[1]/hours[1])
(10000,50000) <= (/works/employee[1]/hours[1])
(10000,50000) = (/works/employee[1]/hours[1])
(10000,50000) > (/works/employee[1]/hours[1])
(10000,50000) >= (/works/employee[1]/hours[1])
(10000,50000) != (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(10000,50000) < (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(10000,50000) <= (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(10000,50000) = (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(10000,50000) > (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(10000,50000) >= (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
10000 != (<a>10000</a>)
10000 != <a>10000</a>
10000 < (<a>10000</a>)
10000 < <a>10000</a>
10000 <= (<a>10000</a>)
10000 <= <a>10000</a>
10000 = (<a>10000</a>)
10000 = <a>10000</a>
10000 > (<a>10000</a>)
10000 > <a>10000</a>
10000 >= (<a>10000</a>)
10000 >= <a>10000</a>
10000 != (<a>10000</a>,<b>50000</b>)
10000 < (<a>10000</a>,<b>50000</b>)
10000 <= (<a>10000</a>,<b>50000</b>)
10000 = (<a>10000</a>,<b>50000</b>)
10000 > (<a>10000</a>,<b>50000</b>)
10000 >= (<a>10000</a>,<b>50000</b>)
10000 != (/works/employee[1]/hours[1])
10000 < (/works/employee[1]/hours[1])
10000 <= (/works/employee[1]/hours[1])
10000 = (/works/employee[1]/hours[1])
10000 > (/works/employee[1]/hours[1])
10000 >= (/works/employee[1]/hours[1])
10000 != (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
10000 < (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
10000 <= (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
10000 = (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
10000 > (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
10000 >= (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
1000 = 1 to year-from-date(current-date())[. gt 3000]
(10, 1 to 4)
10.3 and "non-zero length string"
10 || '/' || 6
(10)/attribute::*
1.0 castable as xs:language
(10)/child::*
(10)/descendant::*
(10)/descendant-or-self::*
10 div3
10div 3
10div3
1.0e0 idiv 0.0e0
-1.0e0 mod -1.0e0
-1.0e0 mod xs:double(-9223372036854775808)
-1.0e0 mod xs:float(-1.0e0)
1.0 idiv 0.0
10 idiv3
10idiv 3
10idiv3
10 idiv 3 eq 3
((10)idiv(3)) instance of xs:integer
-1.0 mod -1.0
10 mod3
10mod 3
10mod3
10 mod 3 eq 1
((10)mod(3)) instance of xs:integer
-1.0 mod -9223372036854775808.0
(10)/parent::*
(10)/self::*
10 to 10
"1" = 1
(1, /)[1]
1 !! 1
1 != "1"
1 * '1'
1 + '1'
1 - '1'
1 ; 1
1 << 1
1 <= 1
1 = "1"
1 = 1
1 =< 1
1 == 1
1 =>; 1
1 >= 1
1 >> 1
(1, 1 + 1, 3, 4, 5)
1.1.1.E2
1.1.1e2
(1.1, (), 1) instance of xs:decimal+
1 + 1.1 to 5
1 + (1, 2)
(1+1), (2-2)
1 != (1, 2, 3)
1 < (1, 2, 3)
1 = (1, 2, 3)
(1.1,3.2,4.5) instance of xs:decimal*
1+1 eq 2
(1.1 idiv 1) instance of xs:integer
1.1 instance of xs:decimal
1.1 instance of xs:decimal and not(1.1 instance of xs:integer)
11 to 11 to 12
1.1 to 3
1.1 to 3.3
(1.1 - xs:untypedAtomic("3")) instance of xs:double
()?12
(/, 1)[2]
(1) , (2)
1 != "2"
1 != 2
1 < 2
(1, 2) + 1
(1, 2) + (1, 2)
(1, 2 * 1, 3, 4, 5)
(1, 2, 2)
(1,2,2),(1,2,3),(123,""),(),("")
(1.2,2.1) castable as xs:decimal?
(1, 2) != (2, 3)
(1, 2) = (2, 3)
(1 + 2) * 3
(1, 2, 3)[
(1, 2, 3)[]
(1, 2, 3)]
1 + (2 * 3)
1|2|3
123[..]
(1, 2, 3) > 0
[1, 2, 3]?0
(1, 2, 3) != 1
(1, 2, 3) = 1
(1, 2, 3) > 1
[1, 2, 3](-1)
(1, 2, 3)[1.0e0] eq 1
(1, 2, 3)[1.0] eq 1
[1, 2, 3](1.1)
-1231.123e3 instance of xs:double
1231.123e3 instance of xs:double
(1, 2, 3)[1]/(1, 2)[last()]/"a string"
'12312' cast as xs:boolean eq false()
(1, 2, 3)[1] eq 1
(1, 2, 3) != 2
(1, 2, 3) < 2
(1, 2, 3) = 2
(1, 2, 3) > 2
([1, [2], [3]], [[2], 2, [4]])[ .?1 = .?2 ]
([1, [2], [3]], [[2], 2, [4]])[ ?1 = ?2 ]
([1, [2], [3]], [[2], 2, [4]])?3 = 3
(1, 2, 3) != 3
(1, 2, 3) < 3
(1, 2, 3) = 3
(1, 2, 3)[3.0e0] eq 3
(1, 2, 3)[3.0] eq 3
(1, 2, 3)[3] eq 3
(1, 2, (), 3, 4)
(1, 2, 3) < 4
[1, 2, 3]?4
(1, (2, (3, 4)), (5))
(1,(2,3),4,5)
(1,2,3,4,5)
12 || 34 - 50
1 => ([2,3],[4,5][6])()
((1,2,3,4,5,6,7,8,9,10,11)[fn:true()])
((1,2,3,4,5,6,7,8,9,10,11)[(. gt 1) and (. gt 2)][(. gt 5) and (. gt 6)])
((1,2,3,4,5,6,7,8,9,10,11)[. gt 1][. gt 5])
((1,2,3,4,5,6,7,8,9,10,11)[(xs:string(.) eq "3")])
(1, 2, 3, 4, 5) instance of item()+
(1, 2, 3, 4, 5) instance of xs:integer*
(1, 2, 3, 4, 5) instance of xs:integer+
"1234" eq 12 || 34
(1, 2, 3, 4) => Q{http://www.w3.org/2005/xpath-functions}sum()
(1, 2, 3, 4) => (Q{http://www.w3.org/2005/xpath-functions}sum#1)()
(1, 2, 3, 4) => (Q{http://www.w3.org/2005/xpath-functions}sum#2(?, 'foo'))()
(1, 2, 3)["a string", 1]
1.23E2 mod 0.6E1 eq 3.0E0
(1 ||  "2" ||  3) eq "123"
(1 ||  2 ||  3) eq "123"
(1, 2, 3) eq 3
(1, 2, 3) except (1, 2, 3)
(1,2,3)[fn:avg((.,2,3)) gt 2]
(1,2,3)[fn:min((.,2)) eq 2]
(1,2,3)[fn:min((.,3)) eq 3]
(1, 2, 3) ge 3
(1,2,3)[(. + .) gt 1]
(1, 2, 3) gt 3
(1, 2, 3)[id("ncname")]
(1, 2, 3)[id("ncname", .)]
(1, 2, 3)[idref("ncname")]
(1, 2, 3)[idref("ncname", .)]
(1, 2, 3)[if(1) then 1 else last()]
(1, 2, 3)[if(1) then 1 else position()]
(1,2,3) instance of xs:integer*
(1, 2, 3) intersect (1, 2, 3)
(1, 2, 3)[(last(), last())[2]]
(1, 2, 3) le 3
(1, 2, 3) lt 3
[[1, 2, 3], map:entry(3, 5)]?*?3
(1, 2, 3) ne 3
(1, 2, 3)[position() eq 2 or position() eq 3][2] eq 3
(1, 2, 3)[root()]
(1, 2, 3) union (1, 2, 3)
(1, 2, 3)[(xs:anyURI("example.com/"), xs:anyURI("example.com/"))]
(1,2,3)[xs:decimal(.)]
(1,2,3)[xs:double(.)]
(1,2,3)[xs:float(.)]
(1, 2, 3)[xs:hexBinary("FF")]
(1,2,3)[xs:integer(.)]
(1, 2, 3)[(xs:untypedAtomic("content"), xs:untypedAtomic("content"))]
1 + 2 * 4 + (1 + 2 + 3 * 4) eq 24
((1,2,4,5,6,7,8,9,10,11)[(. * 2 eq 10)])
((1,2,4,5,6,7,8,9,10,11)[(. + 2 eq 10)])
((1,2,4,5,6,7,8,9,10,11)[(. - 2 eq 6)])
((1,2,4,5,6,7,8,9,10,11)[(. div 2 eq 5)])
((1,2,4,5,6,7,8,9,10,11)[(. idiv 2 eq 3)])
1267.43233E12 instance of xs:anyURI
1267.43233E12 instance of xs:boolean
1267.43233E12 instance of xs:date
1267.43233E12 instance of xs:dateTime
1267.43233E12 instance of xs:decimal
1267.43233E12 instance of xs:double
1267.43233E12 instance of xs:float
1267.43233E12 instance of xs:int
1267.43233E12 instance of xs:integer
1267.43233E12 instance of xs:string
1267.43233E12 instance of xs:time
12678967.543233 instance of xs:anyURI
12678967543233 instance of xs:anyURI
12678967.543233 instance of xs:boolean
12678967543233 instance of xs:boolean
12678967.543233 instance of xs:date
12678967543233 instance of xs:date
12678967.543233 instance of xs:dateTime
12678967543233 instance of xs:dateTime
12678967.543233 instance of xs:decimal
12678967543233 instance of xs:decimal
12678967.543233 instance of xs:double
12678967543233 instance of xs:double
12678967.543233 instance of xs:float
12678967543233 instance of xs:float
12678967.543233 instance of xs:int
12678967543233 instance of xs:int
12678967.543233 instance of xs:integer
12678967543233 instance of xs:integer
12678967.543233 instance of xs:string
12678967543233 instance of xs:string
12678967.543233 instance of xs:time
12678967543233 instance of xs:time
128 castable as xs:byte
"128" castable as xs:byte
-129 castable as xs:byte
"-129" castable as xs:byte
(1, 2, "a string", 4, 5) instance of xs:anyAtomicType*
(1.2) castable as xs:decimal?
(1,2) castable as xs:integer?
(1, 2) cast as xs:integer
(1, 2, count("one"), 4, 5) instance of xs:integer+
(1,2) instance of xs:integer+
(1,2) instance of xs:integer?
((1+2) to (2+2))
((1*2) to (3*2))
(1, 2 to 5)
1 * "3"
1 := 3
1/3
(1, 3 - 1, 3, 4, 5)
13e0 eq 12e0+1
13e0 eq /works/@id
1.3e-3 instance of xs:double
13 eq 12+1
13 eq /works/@id
-1.3!floor(.)
[1](4294967297)
(1, 4 div 2, 3, 4, 5)
(1, 4 idiv 2, 3, 4, 5)
(1, 5 * /)[1]
-1.7976931348623157E+308 castable as xs:decimal
1.7976931348623157E+308 castable as xs:decimal
-1.7976931348623157E+308 castable as xs:integer
1.7976931348623157E+308 castable as xs:integer
"18446744073709551616-05-15" cast as xs:date
"18446744073709551616-05-15T16:15:00" cast as xs:dateTime
18446744073709551616 castable as xs:unsignedLong
"18446744073709551616" castable as xs:unsignedLong
"18446744073709551616-QQ-15" cast as xs:date
"18446744073709551616-QQ-15T16:15:00" cast as xs:dateTime
1 * <a/>
1 + <a/>
1 - <a/>
1 * <a> 2 </a>
1 + <a> 2 </a>
1 * <a> <b> 2 </b> </a>
1+<a> <b> 2 </b> </a>
1 * <a> <b> 2</b> <c> 2</c> </a>
1 + <a> <b> 2</b> <c> 2</c> </a>
(-1)=>abs()
-1=>abs()
(1) and ()
1 and 0
1 AND 0
(1) and (0)
-1 and 1
1 and 1
(1) and (1)
1 and 5
1 and current-date()
1, attribute name {"content"}/ancestor::node(), 1
1, (attribute name {"content"}/ancestor-or-self::node() instance of attribute(name)), 1
1 * <a> x </a>
1 + <a> x </a>
1 - <a> x </a>
1, <b attr="fo"/>/child::node(), 1
1 castable as xs:error
(1) castable as xs:integer?
-1 castable as xs:nonNegativeInteger
"-1" castable as xs:nonNegativeInteger
1 castable as xs:nonPositiveInteger
"1" castable as xs:nonPositiveInteger
-1 castable as xs:unsignedByte
"-1" castable as xs:unsignedByte
-1 castable as xs:unsignedInt
"-1" castable as xs:unsignedInt
-1 castable as xs:unsignedLong
"-1" castable as xs:unsignedLong
-1 castable as xs:unsignedShort
"-1" castable as xs:unsignedShort
('1' cast as xs:boolean) cast as xs:string eq 'true'
'1' cast as xs:boolean eq true()
1 cast as xs:date
1 cast as xs:error
1, <!-- content -->/ancestor::node(), 1
1 <= count((1, 2, 3, timezone-from-time(current-time()), 4))
(1, current-time())[1]
1!data()
(1, data#0)[data()]
(1)[deep-equal(1, subsequence((1, 2, current-time()), 1, 1))] eq 1
(1 div 0) castable as xs:string
-1 div 0e0
1 div 0e0
1 div '1'
1 div <a/>
1 div <a> 2 </a>
1 div <a> <b> 2 </b> </a>
1 div <a> <b> 2</b> <c> 2</c> </a>
1 div <a> x </a>
1 div math:tan(-math:pi() div 2)
1 div math:tan(math:pi() div 2)
1 div xs:double("-0") ne 1 div xs:double("0")
-1 div xs:float(0)
1 div xs:float(0)
1 div xs:float("-0") ne 1 div xs:float("0")
1 div xs:integer('1')
(1, <e/>)[..]
1 e 2
1 e2
1 E 2
1 E2
1e 2
1E 2
1e-2.1.1
1e2.1.1
1E2.1.1
1e2e3
(1E3,2E3,3E3) instance of xs:double*
(1E3,2E3) castable as xs:double?
(1E3) castable as xs:double?
1.e+3 instance of xs:double
1.e3 instance of xs:double
1.E3 instance of xs:double
1e3 to 3
1, <e attr=""/>/descendant::node(), 1
1, <e/>/descendant::node(), 1
1ee2
1eE2
1EE2
1[element()]
1, <element/>/ancestor::node(), 1
1 eq (0 + remove((current-time(), 1), 1))
1 eq <!--1-->
<!--1--> eq 1
1 eq "a string"
1 eq (for $a in 1 return $a)
1 eq (for $foo in 1 return $foo)
1 eq (for $i at $p in 0 return $p)
1 eq (for $i at $p in subsequence((1, 2, 3, current-time()), 1, 1) return $p)
1 eq (for $xs:a in 1 return $xs:a)
1 eq (if(xs:anyURI("example.com/")) then 1 else 0)
1 eq (remove((current-time(), 1), 1) + 0)
1 eq (remove((current-time(), 1), 1) - 0)
1 eq subsequence(("1", 2, 3.1, "four"), 1, 1)
1 eq <?target 1?>
1 except 2 except 3
1fd()
(1, fn:count((1, 2)), 3, 4, 5)
(., 1) ! fn:has-children(.)
(1, fn:string-length("AB"), 3, 4, 5)
1 + "foo"
-1[. gt 0]
1 idiv 0
1 idiv +0.0
1 idiv -0.0
1 idiv 0.0
-1 idiv 0e0
1 idiv 0e0
1 idiv '1'
1 idiv <a/>
1 idiv <a> <b> 2 </b> </a>
1 idiv <a> x </a>
1 idiv xs:double("NaN")
-1 idiv xs:float(0)
1 idiv xs:float(0)
1 idiv xs:float("NaN")
1 idiv xs:integer('1')
1 instance of document()
1 instance of document(*)
1 instance of item()
1 instance of xs:decimal
1 instance of xs:integer
1 instance of xs:integer*
1 instance of xs:integer+
1 instance of xs:integer?
(1) instance of xs:integer?
1 intersect 2 intersect 3
1 is 1
1 le count((1, 2, 3, timezone-from-time(current-time()), 4))
1 &lt;= 3
-1 mod -1
1 mod '1'
-1 mod -9223372036854775808
1 mod <a/>
1 mod <a> 2 </a>
1 mod <a> <b> 2 </b> </a>
1 mod <a> <b> 2</b> <c> 2</c> </a>
1 mod <a> x </a>
1 mod xs:integer('1')
/*/*[1]/name()
(1)[number()] eq 1
(1) or ()
1 or 0
1 OR 0
(1) or (0)
-1 or 1
1 or 1
(1) or (1)
1 or 5
1 => Q{http://www.w3.org/2005/xpath-functions}sum()
(1 + remove((5, 1e0), 2)) eq 6
1 + remove(("foo", 2), 2)asdasdad
1, <root> <child/> </root>/following-sibling::node(), 1
1, <root/>/following-sibling::node(), 1
1 + subsequence("a string", 1, 1)
1, <?target data?>/ancestor::node(), 1
1, text {""}/ancestor::node(), 1
1, text {""}/ancestor-or-self::node(), 1
(1 to 10)!(.*.)
(1 to 100)[fn:root()]
(1 to 100)[string-length() = 3]
(1 to 100)[string-length(.) = 3]
(1 to 10)?1
(1 to 10)[.?1 = 3]
(1 to 10)[?1 = 3]
(1 to 10)/count()
(1 to 10)[fn:idref("argument1")]
(1 to (10 idiv 2))
((1 to 11)[(. eq 10) and (. mod 5 eq 0)])
((1 to 11)[(. eq 10) or (. eq 5)])
((1 to 11)[. ne 10])
1 to 1 eq 1
(1 to 20)[. = filter(1 to position(), function($x){$x idiv 2 * 2 = $x})]
(1 to 20)[fn:last() - 1]
((1 to 25)[25])
((1 to 25)[. eq 10])
((1 to 25)[. ge 10])
((1 to 25)[. le 10])
((1 to 25)[. lt 10])
((1 to 25)[. mod 2 eq 0])
(1 to (3 - 2))
(1 to (3*2))
(1 to 4) !          (let $add := function($x){$x + .} return $add(4))
(1 to 5000)[position() = 2001 to 2020]
1 to 5000 = year-from-date(current-date())[. gt 3000]
(1 to 5) ! (1 to .)
(1 to 5) ! ((1 to .) ! position())
(1 to 5) ! (1 to .) ! position()
(1 to 5)[ fn:id("argument1",.)]
(1 to 5)[fn:id("argument1")]
(1 to 6)[last()] eq 6
1 to <value>5</value>, 5 to <value>5</value>, <value>1</value> to 5, <value>1</value> to <value>5</value>, let $i := <e>5</e> return $i to $i, count(5 to 10), count(1000 to 2000), count(<e>5</e> to 10), count(3 to <e>10</e>), count(<e>3</e> to <e>10</e>), count(<e>5</e> to 10), count(3 to <e>10</e>), count(<e>3</e> to <e>10</e>), count(4294967295 to 4294967298)
(1 to xs:integer(5))
1[true()] eq 1
1 union 2 union 3
1 < xs:anyURI("0")
1 > xs:anyURI("2")
1 * xs:integer('1')
1 + xs:integer('1')
1 - xs:integer('1')
1 = xs:untypedAtomic("1")
[]?2
"&#+20;"
"&#-20;"
(200)/ancestor::*
(200)/ancestor-or-self::*
(200)/following::*
(200)/following-sibling::*
(200)/preceding::*
(200)/preceding-sibling::*
(-20 to -5)[last() - 3]
"2" != 1
-2!(.+1)
2 > 1
2 != (1, 2, 3)
2 < (1, 2, 3)
2 = (1, 2, 3)
2 > (1, 2, 3)
2147483648 castable as xs:int
"2147483648" castable as xs:int
-2147483649 castable as xs:int
"-2147483649" castable as xs:int
((2 - 1) to (7 - 1))
2 + 3!#
(2, 3) = (3, 4)
2 < 3 < 4
2 + 4 * 5 eq 22
(2 + 4) * 5 eq 30
(2, 4, 6)!function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'last'), 0)()
(2, 4, 6)!function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'position'), 0)()
(2, 4, 6)!Q{http://www.w3.org/2005/xpath-functions}last#0()
(2, 4, 6)!Q{http://www.w3.org/2005/xpath-functions}position#0()
2 + (4 idiv 2)
(2 + 4) idiv 2
(-2) + 5
-(2 + 5)
"-25252734927766555-06-06" cast as xs:date
"-25252734927766555-06-06T00:00:00Z" cast as xs:dateTime
"25252734927766555-07-29" cast as xs:date
"25252734927766555-07-29T00:00:00Z" cast as xs:dateTime
256 castable as xs:unsignedByte
"256" castable as xs:unsignedByte
2 * (5 mod 3)
(2 * 5) mod 3
"&#2A0;"
(2) castable as xs:integer?
2e308
2 eq (0, 1, "2")[last()]
2 eq 1+1
2 eq (1 + remove((1, "two"), 2))
2 eq (1 + remove((xs:untypedAtomic("1"), "two"), 2))
2 eq (for $foo in 1 return $foo + 1)
2 eq (xs:untypedAtomic("1") + remove((1, "two"), 2))
2=>(map{1:2, 2:4, 3:6})()
2*math:pi()
2 + (/ works ! employee[2] ! hours[2]) ! number() ! (-.)
2 != xs:untypedAtomic("1")
3}
3.0 idiv 4 eq 0
3 + 10 div 2
3 != (1, 2, 3)
3 = (1, 2, 3)
3 > (1, 2, 3)
3.1E1 idiv 6 eq 5
3.1E1 idiv 7 eq 4
3+1 to 4+1
32768 castable as xs:short
-32769 castable as xs:short
"-32769" castable as xs:short
"32769" castable as xs:short
((3 - 2) to 10)
((3*2) to 10)
"3" * "3"
"3" + "3"
"3" - "3"
33"
3.3e1 instance of xs:double
3.3 instance of xs:decimal
[3, 4, 5] < []
[3, 4, 5] = []
[3, 4, 5] < 4
[3, 4, 5] = 4
[[3, 4], 5] < [4, [5, 6]]
[[3, 4], 5] = [4, [5, 6]]
(3,4,5)[(xs:integer(5) - xs:integer(.)) gt 1]
(3,4,5)[(xs:integer(.) * xs:integer(.)) gt 2]
[3,4] eq 3
-3 + 5 * 3
3 - 5 * 3
-3.5 idiv 3 eq -1
(: 3.7.3.1 Computed Element Constructor per XQ.E19 XQDY0096 if namespace prefix is not 'xml' and its namespace URI is 'http://www.w3.org/XML/1998/namespace' Mary Holstege :) element { fn:QName("http://www.w3.org/XML/1998/namespace","foo:error") } {}
(: 3.7.3.1 Computed Element Constructor per XQ.E19 XQDY0096 if namespace prefix is 'xml' and namespace URI is not 'http://www.w3.org/XML/1998/namespace' Mary Holstege :) element { fn:QName("http://example.com/not-XML-uri","xml:error") } {}
(: 3.7.3.1 Computed Element Constructor per XQ.E19 XQDY0096 if namespace prefix is 'xmlns' Mary Holstege :) element { fn:QName("http://example.com/some-uri","xmlns:error") } {}
(: 3.7.3.1 Computed Element Constructor per XQ.E19 XQDY0096 if namespace URI is 'http://www.w3.org/2000/xmlns/' Mary Holstege :) element { fn:QName("http://www.w3.org/2000/xmlns/","error")} {}
(: 3.7.3.1 Computed Element Constructor per XQ.E19 XQDY0096 if namespace URI is 'http://www.w3.org/2000/xmlns/' Mary Holstege :) element { fn:QName("http://www.w3.org/2000/xmlns/","foo:error")} {}
(: 3.7.3.2 Computed Attribute Constructor per XQ.E19 XQDY0044 if namespace prefix is not 'xml' and namespace URI is 'http://www.w3.org/XML/1998/namespace' Mary Holstege :) <result>{ attribute { fn:QName("http://www.w3.org/XML/1998/namespace","foo:error")} {} }</result>
(: 3.7.3.2 Computed Attribute Constructor per XQ.E19 XQDY0044 if namespace prefix is 'xml' and namespace URI is not 'http://www.w3.org/XML/1998/namespace' Mary Holstege :) <result>{ attribute { fn:QName("http://example.com/not-XML-uri","xml:error") } {} }</result>
(: 3.7.3.2 Computed Attribute Constructor per XQ.E19 XQDY0044 if namespace prefix is 'xmlns' Mary Holstege :) <result>{attribute {fn:QName("http://example.com/some-uri","xmlns:error")} {}}</result>
(: 3.7.3.2 Computed Attribute Constructor per XQ.E19 XQDY0044 if namespace prefix is 'xmlns' Mary Holstege :) <result>{attribute {"xmlns:error"} {}}</result>
(: 3.7.3.2 Computed Attribute Constructor per XQ.E19 XQDY0044 if namespace URI is 'http://www.w3.org/2000/xmlns/' Mary Holstege :) <result>{ attribute { fn:QName("http://www.w3.org/2000/xmlns/","error")} {} }</result>
(: 3.7.3.2 Computed Attribute Constructor per XQ.E19 XQDY0044 if namespace URI is 'http://www.w3.org/2000/xmlns/' Mary Holstege :) <result>{ attribute { fn:QName("http://www.w3.org/2000/xmlns/","foo:error")} {} }</result>
(: 3.7.3.2 Computed Attribute Constructor per XQ.E19 XQDY0044 if no namespace prefix and local name is 'xmlns' Mary Holstege :) <result>{attribute {"xmlns"} {}}</result>
3 - <a> 2 </a>
3 - <a> <b> 2 </b> </a>
3 - <a> <b> 2</b> <c> 2</c> </a>
3=>(['a','b','c','d','e'])()
3 cast as prefixDoesNotExist:integer
+3 div +0e0
+3 div -0e0
-3 div +0e0
-3 div -0e0
"3" div "3"
3 div xs:dayTimeDuration("P3D")
3 div xs:duration("P1Y3M")
3 div xs:yearMonthDuration("P1Y3M")
3 < <e>1.1</e>
3. < <e>1.1</e>
3 >E 2
3e3 < <e>1.1</e>
3 eq (1, 2, 3)
+++++++++++3 eq 3
+++3 eq ++3
+-+-+-+-+-+-+-+3 eq -3
-+-+-+-+-+-++-+-++-+-+-+-+++3 eq 3
-+-+-+-+-+-+-+-3 eq 3
----+-+-++-+-+-+-+++-+--+--3 eq -3
----------3 eq 3
---------3 eq -3
---3 eq -3
-3 eq -3
.3 eq .3
(+3) eq +(3)
(+3) eq +3
(+3) eq 3
(-3) eq -3
+(-3) eq -3
+(3) eq +3
+(3) eq 3
-(+3) eq -3
-(3) eq -3
[3] eq 3
3. eq 3.
3 eq (for $foo in 1, $foo in 3 return $foo)
3 eq (for $foo in 1 return 3)
3 eq (for $foo in 1 return for $bar in 2 return $bar + $foo)
3 eq (for $foo in 1 return for $foo in 3 return $foo)
3 ge (1, 2, 3)
3 gt (1, 2, 3)
3 idiv 1.1 eq 2
-3 idiv -2 eq 1
-3 idiv 2 eq -1
3 idiv -2 eq -1
"3" idiv "3"
3 idiv <a> 2 </a>
3 idiv <a> <b> 2</b> <c> 2</c> </a>
"3" idiv xs:float(3)
3 instance of none
3 instance of none()
3 instance of prefixDoesNotExist:integer
3 instance of void
3 instance of void()
3 instance of xs:doesNotExist
3 instance of xs:integer
3 instance of xs:qname
3 le (1, 2, 3)
[3] le [3]
3 lt (1, 2, 3)
"3" mod 1.1
"3" mod "3"
3 mod xs:double("-0")
3 mod xs:double("0")
3 mod xs:double("-INF")
3 mod xs:double("INF")
3 mod xs:double("NaN")
3 mod xs:float("-0")
3 mod xs:float("0")
3 mod xs:float("-INF")
3 mod xs:float("INF")
3 mod xs:float("NaN")
3 ne (1, 2, 3)
(+3) ne -3
-(3) ne 3
3 to 1.1
3 to 1e3
3 * xs:duration("P1Y3M")
"3" + xs:untypedAtomic("3")
(3 - xs:untypedAtomic("3")) eq 0
(3 + xs:untypedAtomic("3")) eq 6
(3 * xs:untypedAtomic(3)) eq 9
3 != xs:untypedAtomic("three")
3 = xs:untypedAtomic("three")
3 * xs:yearMonthDuration("P3Y36M") eq xs:yearMonthDuration("P18Y")
40e0 eq number(/works/employee[1]/hours)
40e0 eq xs:double(/works/employee[1]/hours)
40e0 eq xs:double(/works/employee[830]/hours)
40e0 eq xs:integer(/works/employee[830]/hours)
40 eq number(/works/employee[1]/hours)
40 eq xs:double(/works/employee[1]/hours)
40 eq xs:double(/works/employee[830]/hours)
40 eq xs:integer(/works/employee[1]/hours)
40 eq xs:integer(/works/employee[830]/hours)
40 gt count(//node())
4 > (1, 2, 3)
4294967296 castable as xs:unsignedInt
"4294967296" castable as xs:unsignedInt
432f542
(-4, -3 to -1)
(-4,-3 to 2)
4 + / * 5
"4.54"=>ceiling()
4.54=>ceiling()
4.54=>((ceiling#1, floor#1, round#1, abs#1) => head())()
4.54=>(head((ceiling#1, floor#1, round#1, abs#1)))
4.54=>(head((ceiling#1, floor#1, round#1, abs#1)))()
(4, 5)[position() = 2][last() = 1]
(4, 5)[position() = 2][last() = 1][last() = 1][last()]
465.
4 eq (for $foo in 1, $bar in 2, $moo in 3 return 4)
. 5
.5
/ * 5
/*5
() != (50000)
() < (50000)
() <= (50000)
() = (50000)
() > (50000)
() >= (50000)
(50000) != ()
(50000) < ()
(50000) <= ()
(50000) = ()
(50000) > ()
(50000) >= ()
(50000) != ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(50000) < ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(50000) <= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(50000) = ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(50000) > ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(50000) >= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(50000) != 10000
(50000) < 10000
(50000) <= 10000
(50000) = 10000
(50000) > 10000
(50000) >= 10000
(50000) != (10000,50000)
(50000) < (10000,50000)
(50000) <= (10000,50000)
(50000) = (10000,50000)
(50000) > (10000,50000)
(50000) >= (10000,50000)
(50000) != (50000)
(50000) < (50000)
(50000) <= (50000)
(50000) = (50000)
(50000) > (50000)
(50000) >= (50000)
(50000) != (<a>10000</a>)
(50000) != <a>10000</a>
(50000) < (<a>10000</a>)
(50000) < <a>10000</a>
(50000) <= (<a>10000</a>)
(50000) <= <a>10000</a>
(50000) = (<a>10000</a>)
(50000) = <a>10000</a>
(50000) > (<a>10000</a>)
(50000) > <a>10000</a>
(50000) >= (<a>10000</a>)
(50000) >= <a>10000</a>
(50000) != (<a>10000</a>,<b>50000</b>)
(50000) < (<a>10000</a>,<b>50000</b>)
(50000) <= (<a>10000</a>,<b>50000</b>)
(50000) = (<a>10000</a>,<b>50000</b>)
(50000) > (<a>10000</a>,<b>50000</b>)
(50000) >= (<a>10000</a>,<b>50000</b>)
(50000) != (/works/employee[1]/hours[1])
(50000) < (/works/employee[1]/hours[1])
(50000) <= (/works/employee[1]/hours[1])
(50000) = (/works/employee[1]/hours[1])
(50000) > (/works/employee[1]/hours[1])
(50000) >= (/works/employee[1]/hours[1])
(50000) != (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(50000) < (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(50000) <= (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(50000) = (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(50000) > (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(50000) >= (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
5.0 div 2.0 eq 2.5
5.0 div 2.0 ne 2.6
5.0 idiv 2.0 eq 2
5 - 10 div 2
5 + 10 idiv 4
5 - 10 idiv 4
5 + 10 mod 4
5 - 10 mod 4
.54.45
5.4=>ceil()
(5 + 5) cast as xs:boolean
(5 + 5) cast as xs:decimal
(5 + 5) cast as xs:double
(5 + 5) cast as xs:float
(5 + 5) cast as xs:integer
(5 + 5) cast as xs:string
5 castable as xs:normalizedString
5 castable as xs:token
5 div 2 ne 2.6
5 eq remove((5, 1e0), 2)
5 = false()
((5 idiv 5) to (8 idiv 2))
60 * (math:pi() div 180)
(6,10,14)[(xs:integer(.) div xs:integer(3)) gt 2]
(6,10,14)[(xs:integer(.) idiv xs:integer(3)) gt 2]
(6,10,14)[(xs:integer(.) mod xs:integer(3)) gt 1]
+.65535032
-.65535032
-65535032
.65535032
65535032
65535032.001.01
65535032.0023
+.65535032e-2
+.65535032e2
-.65535032e-2
-.65535032e2
-65535.032e-2
.65535032e-2
.65535032e2
65535.032e-2
+.65535032E-2
+.65535032E2
-.65535032E-2
-.65535032E2
.65535032E-2
.65535032E2
65535.032E-2
65536 castable as xs:unsignedShort
"65536" castable as xs:unsignedShort
6 eq (for $foo in 1, $foo in 3 return $foo + $foo)
((6 idiv 2) to 10)
6 mod -2 eq 0
6 = remove(("a string", 6), 2)
6 = (remove(("a string", xs:untypedAtomic("6")), 1))
-+7
-79228162514264337593543950335.0 - 1.0 lt 0.0
-79228162514264337593543950335 - 1 lt 0
(7 eq 7) eq xs:boolean("false")
((7 eq 7) eq xs:boolean("true")) and (xs:boolean("false") eq xs:boolean("true"))
((7 eq 7) eq xs:boolean("true")) or (xs:boolean("false") eq xs:boolean("true"))
(7 eq 7) ge xs:boolean("false")
(7 eq 7) ge xs:boolean("true")
(7 eq 7) gt xs:boolean("false")
(7 eq 7) gt xs:boolean("true")
(7 eq 7) le xs:boolean("false")
(7 eq 7) le xs:boolean("true")
(7 eq 7) lt xs:boolean("false")
(7 eq 7) lt xs:boolean("true")
(7 lt 7) eq xs:boolean("true")
"&#8364;"
8 eq (for $foo in 1, $foo in 3, $moo in 5 return $moo + $foo)
9.0 idiv 3 eq 3
9223372036854775808 castable as xs:long
"9223372036854775808" castable as xs:long
-9223372036854775809 castable as xs:long
"-9223372036854775809" castable as xs:long
"99999999999999999999999999999-01" cast as xs:gYearMonth
-999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999
999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999
999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999.1
-999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999E100000000000000000000000000000000000000000000000000000000
999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999E100000000000000000000000000000000000000000000000000000000
"99999999999999999999999999999" cast as xs:gYear
"99999999999999999999999999999-XX" castable as xs:gYearMonth
"99999999999999999999999999999-XX" cast as xs:gYearMonth
<a/>/.
(<a>0</a>,<a>1</a>) except (<a>3</a>,<a>4</a>)
(<a>0</a>,<a>1</a>) except (<a>3</a>,<a>4</a>,<a>0</a>)
() != (<a>10000</a>)
() != <a>10000</a>
() < (<a>10000</a>)
() < <a>10000</a>
() <= (<a>10000</a>)
() <= <a>10000</a>
() = (<a>10000</a>)
() = <a>10000</a>
() > (<a>10000</a>)
() > <a>10000</a>
() >= (<a>10000</a>)
() >= <a>10000</a>
(<a>10000</a>) != ()
(<a>10000</a>) < ()
(<a>10000</a>) <= ()
(<a>10000</a>) = ()
(<a>10000</a>) > ()
(<a>10000</a>) >= ()
<a>10000</a> != ()
<a>10000</a> < ()
<a>10000</a> <= ()
<a>10000</a> = ()
<a>10000</a> > ()
<a>10000</a> >= ()
(<a>10000</a>) != ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(<a>10000</a>) < ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(<a>10000</a>) <= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(<a>10000</a>) = ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(<a>10000</a>) > ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(<a>10000</a>) >= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
<a>10000</a> != ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
<a>10000</a> < ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
<a>10000</a> <= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
<a>10000</a> = ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
<a>10000</a> > ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
<a>10000</a> >= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(<a>10000</a>) != 10000
(<a>10000</a>) < 10000
(<a>10000</a>) <= 10000
(<a>10000</a>) = 10000
(<a>10000</a>) > 10000
(<a>10000</a>) >= 10000
<a>10000</a> != 10000
<a>10000</a> < 10000
<a>10000</a> <= 10000
<a>10000</a> = 10000
<a>10000</a> > 10000
<a>10000</a> >= 10000
(<a>10000</a>) != (10000,50000)
(<a>10000</a>) < (10000,50000)
(<a>10000</a>) <= (10000,50000)
(<a>10000</a>) = (10000,50000)
(<a>10000</a>) > (10000,50000)
(<a>10000</a>) >= (10000,50000)
<a>10000</a> != (10000,50000)
<a>10000</a> < (10000,50000)
<a>10000</a> <= (10000,50000)
<a>10000</a> = (10000,50000)
<a>10000</a> > (10000,50000)
<a>10000</a> >= (10000,50000)
(<a>10000</a>) != (50000)
(<a>10000</a>) < (50000)
(<a>10000</a>) <= (50000)
(<a>10000</a>) = (50000)
(<a>10000</a>) > (50000)
(<a>10000</a>) >= (50000)
<a>10000</a> != (50000)
<a>10000</a> < (50000)
<a>10000</a> <= (50000)
<a>10000</a> = (50000)
<a>10000</a> > (50000)
<a>10000</a> >= (50000)
(<a>10000</a>) != (<a>10000</a>)
(<a>10000</a>) != <a>10000</a>
(<a>10000</a>) < (<a>10000</a>)
(<a>10000</a>) < <a>10000</a>
(<a>10000</a>) <= (<a>10000</a>)
(<a>10000</a>) <= <a>10000</a>
(<a>10000</a>) = (<a>10000</a>)
(<a>10000</a>) = <a>10000</a>
(<a>10000</a>) > (<a>10000</a>)
(<a>10000</a>) > <a>10000</a>
(<a>10000</a>) >= (<a>10000</a>)
(<a>10000</a>) >= <a>10000</a>
<a>10000</a> != (<a>10000</a>)
<a>10000</a> != <a>10000</a>
<a>10000</a> < (<a>10000</a>)
<a>10000</a> < <a>10000</a>
<a>10000</a> <= (<a>10000</a>)
<a>10000</a> <= <a>10000</a>
<a>10000</a> = (<a>10000</a>)
<a>10000</a> = <a>10000</a>
<a>10000</a> > (<a>10000</a>)
<a>10000</a> > <a>10000</a>
<a>10000</a> >= (<a>10000</a>)
<a>10000</a> >= <a>10000</a>
(<a>10000</a>) != (<a>10000</a>,<b>50000</b>)
(<a>10000</a>) < (<a>10000</a>,<b>50000</b>)
(<a>10000</a>) <= (<a>10000</a>,<b>50000</b>)
(<a>10000</a>) = (<a>10000</a>,<b>50000</b>)
(<a>10000</a>) > (<a>10000</a>,<b>50000</b>)
(<a>10000</a>) >= (<a>10000</a>,<b>50000</b>)
<a>10000</a> != (<a>10000</a>,<b>50000</b>)
<a>10000</a> < (<a>10000</a>,<b>50000</b>)
<a>10000</a> <= (<a>10000</a>,<b>50000</b>)
<a>10000</a> = (<a>10000</a>,<b>50000</b>)
<a>10000</a> > (<a>10000</a>,<b>50000</b>)
<a>10000</a> >= (<a>10000</a>,<b>50000</b>)
() != (<a>10000</a>,<b>50000</b>)
() < (<a>10000</a>,<b>50000</b>)
() <= (<a>10000</a>,<b>50000</b>)
() = (<a>10000</a>,<b>50000</b>)
() > (<a>10000</a>,<b>50000</b>)
() >= (<a>10000</a>,<b>50000</b>)
(<a>10000</a>,<b>50000</b>) != ()
(<a>10000</a>,<b>50000</b>) < ()
(<a>10000</a>,<b>50000</b>) <= ()
(<a>10000</a>,<b>50000</b>) = ()
(<a>10000</a>,<b>50000</b>) > ()
(<a>10000</a>,<b>50000</b>) >= ()
(          <a>10000</a>,<b>50000</b>) < ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(<a>10000</a>,<b>50000</b>) != ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(<a>10000</a>,<b>50000</b>) <= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(<a>10000</a>,<b>50000</b>) = ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(<a>10000</a>,<b>50000</b>) > ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(<a>10000</a>,<b>50000</b>) >= ($works/works/employee[1]/hours[1],$staff/staff/employee[6]/grade[1])
(<a>10000</a>,<b>50000</b>) != 10000
(<a>10000</a>,<b>50000</b>) < 10000
(<a>10000</a>,<b>50000</b>) <= 10000
(<a>10000</a>,<b>50000</b>) = 10000
(<a>10000</a>,<b>50000</b>) > 10000
(<a>10000</a>,<b>50000</b>) >= 10000
(<a>10000</a>,<b>50000</b>) != (10000,50000)
(<a>10000</a>,<b>50000</b>) < (10000,50000)
(<a>10000</a>,<b>50000</b>) <= (10000,50000)
(<a>10000</a>,<b>50000</b>) = (10000,50000)
(<a>10000</a>,<b>50000</b>) > (10000,50000)
(<a>10000</a>,<b>50000</b>) >= (10000,50000)
(<a>10000</a>,<b>50000</b>) != (50000)
(<a>10000</a>,<b>50000</b>) < (50000)
(<a>10000</a>,<b>50000</b>) <= (50000)
(<a>10000</a>,<b>50000</b>) = (50000)
(<a>10000</a>,<b>50000</b>) > (50000)
(<a>10000</a>,<b>50000</b>) >= (50000)
(<a>10000</a>,<b>50000</b>) != (<a>10000</a>)
(<a>10000</a>,<b>50000</b>) != <a>10000</a>
(<a>10000</a>,<b>50000</b>) < (<a>10000</a>)
(<a>10000</a>,<b>50000</b>) < <a>10000</a>
(<a>10000</a>,<b>50000</b>) <= (<a>10000</a>)
(<a>10000</a>,<b>50000</b>) <= <a>10000</a>
(<a>10000</a>,<b>50000</b>) = (<a>10000</a>)
(<a>10000</a>,<b>50000</b>) = <a>10000</a>
(<a>10000</a>,<b>50000</b>) > (<a>10000</a>)
(<a>10000</a>,<b>50000</b>) > <a>10000</a>
(<a>10000</a>,<b>50000</b>) >= (<a>10000</a>)
(<a>10000</a>,<b>50000</b>) >= <a>10000</a>
(<a>10000</a>,<b>50000</b>) != (<a>10000</a>,<b>50000</b>)
(<a>10000</a>,<b>50000</b>) < (<a>10000</a>,<b>50000</b>)
(<a>10000</a>,<b>50000</b>) <= (<a>10000</a>,<b>50000</b>)
(<a>10000</a>,<b>50000</b>) = (<a>10000</a>,<b>50000</b>)
(<a>10000</a>,<b>50000</b>) > (<a>10000</a>,<b>50000</b>)
(<a>10000</a>,<b>50000</b>) >= (<a>10000</a>,<b>50000</b>)
(<a>10000</a>,<b>50000</b>) != (/works/employee[1]/hours[1])
(<a>10000</a>,<b>50000</b>) < (/works/employee[1]/hours[1])
(<a>10000</a>,<b>50000</b>) <= (/works/employee[1]/hours[1])
(<a>10000</a>,<b>50000</b>) = (/works/employee[1]/hours[1])
(<a>10000</a>,<b>50000</b>) > (/works/employee[1]/hours[1])
(<a>10000</a>,<b>50000</b>) >= (/works/employee[1]/hours[1])
(<a>10000</a>,<b>50000</b>) != (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(<a>10000</a>,<b>50000</b>) < (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(<a>10000</a>,<b>50000</b>) <= (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(<a>10000</a>,<b>50000</b>) = (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(<a>10000</a>,<b>50000</b>) > (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(<a>10000</a>,<b>50000</b>) >= (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(<a>10000</a>) != (/works/employee[1]/hours[1])
(<a>10000</a>) < (/works/employee[1]/hours[1])
(<a>10000</a>) <= (/works/employee[1]/hours[1])
(<a>10000</a>) = (/works/employee[1]/hours[1])
(<a>10000</a>) > (/works/employee[1]/hours[1])
(<a>10000</a>) >= (/works/employee[1]/hours[1])
<a>10000</a> != (/works/employee[1]/hours[1])
<a>10000</a> < (/works/employee[1]/hours[1])
<a>10000</a> <= (/works/employee[1]/hours[1])
<a>10000</a> = (/works/employee[1]/hours[1])
<a>10000</a> > (/works/employee[1]/hours[1])
<a>10000</a> >= (/works/employee[1]/hours[1])
(<a>10000</a>) != (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(<a>10000</a>) < (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(<a>10000</a>) <= (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(<a>10000</a>) = (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(<a>10000</a>) > (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(<a>10000</a>) >= (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
<a>10000</a> != (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
<a>10000</a> < (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
<a>10000</a> <= (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
<a>10000</a> = (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
<a>10000</a> > (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
<a>10000</a> >= (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
<a> 1 </a> * <b> 2 </b>
<a> 1 </a> + <b> 2 </b>
<a>1</a> + <b>2</b>
(<a>1</a>,<b>2</b>)/(if(position() eq 1) then . else data(.))
<a> 1 </a> div <b> 2 </b>
<a> 1 </a> idiv <b> 2 </b>
<a> 1 </a> mod <b> 2 </b>
<a/>/1/node()
<a/>/20[text()]
'a'[2147483649]
<a>&#223;</a>
<a> 2 </a> - <b> 1 </b>
'a'[4294967296]
'a'[4294967297]
<a>50000</a> << <a>50000</a>
<a>50000</a> >> <a>50000</a>
<a>50000</a> is <a>50000</a>
<a>50000</a> is (/staff[1]/employee[1]/empnum[1])
<a>50000</a> is /works[1]/employee[1]/empnum[1]
<a>50000</a> << (/staff[1]/employee[1]/empnum[1])
<a>50000</a> >> (/staff[1]/employee[1]/empnum[1])
<a>50000</a> << /works[1]/employee[1]/empnum[1]
<a>50000</a> >> /works[1]/employee[1]/empnum[1]
<a></a>
<a> { <a b="blah"/>/@*/self::attribute(b) } </a>
<a>abc</a>/text()/node-name()
<a>{<!-- a comment -->/*}</a>
"a" and '0'
<a attr
<a attr=
<a attr="a" attr="a" />
<a attr="con
<a attr='con
<a attr="content"
<a attr='content'
<a>{attribute name{"content"}/*}</a>
<a> { attribute { 'prefix:localName' } { } } </a>
<a> { attribute xml:id {"1"} } </a>
<a> { attribute { 'xmlns' } { 'http://www.w3.org/' } } </a>
<a> { attribute xml:space {"DEFAULT"} } </a>
<?a?><?b ?>
<a b='1'/
<a b="1"/a="1"/>
<a b="1">a="1"/>
<a b='1'/a='1'/>
<a b='1'>a='1'/>
<a b="1" c="1"/>
<a b='1' c='1'/>
<a b="3"/>/(@b, upper-case#1)
(<a b="3"/>/(string(@b), upper-case#1, 17))[. instance of xs:anyAtomicType]
<a><b/></a>/(b instance of element(), * instance of element())
<a> { <b />, attribute foo { 'bar' } } </a>
<a/>/<b>{.}</b>
<a b=``[c]``/>
[ "a", "b", "c" ]
['A', 'B', 'C']?*
(<a/>, <b/>, <c/>)[1][1]
['A', 'B', 'C']?(2 to 3)
("abc" || "abc") and ("abc" || "abc")
("abc" || "abc" ||  fn:concat#3)
["a", "b", "c"] => array:get(2)
["a", ["b", "c"]] => array:get(2)
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])?()
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])?*
[['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b']]?*?*
[['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b']]!.?*!.?1
[['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b']]!?*!?1
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])?(1.0)
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])?1.0
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[.?(1.0) = 'a']
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[.?1.0 = 'a']
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[?(1.0) = 'a']
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[?1.0 = 'a']
[['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b']]?*[.?1 = 'a']
[['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b']]?*[?1 = 'a']
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])?(1 to 2)
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[ .?(1 to 2) = 'b']
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[ ?(1 to 2) = 'b']
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[ .?* = 'c']
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[ ?* = 'c']
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[contains(.?1, ?)('a')]
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[contains(?1, ?)('a')]
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[exists(.?())]
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[exists(?())]
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b']) ?first
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[ .?first = 'b']
(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[ ?first = 'b']
<a><b><c/><b/><d/>
("abc") castable as xs:integer?
("abc") castable as xs:string?
<a> <b c=""> <c/> </b> <d/> </a>/b/c/ancestor::*
<a> <b c=""> <c/> </b> <d/> </a>/b/c/(ancestor::*)[1]
<a> <b c=""> <c/> </b> <d/> </a>/b/c/ancestor::*[1]
<a> <b c=""> <c/> </b> <d/> </a>/b/c/ancestor::*[fn:last()]
<a> <b c=""> <c/> </b> <d/> </a>/b/c/(ancestor::*)[last()]
<a> <b c=""> <c/> </b> <d/> </a>//count(ancestor::*)
<a> <b c=""> <c/> </b> <d/> </a>//count(ancestor-or-self::*)
( ["a", "b", "c"], "d" )
[ ("a", "b", "c"), "d" ]
[["a", "b", "c"], "d" ]
("AB" || "CD")
(['a', 'b'], ['c', 'd'])?0
(['a', 'b'], ['c', 'd'])? 001
(['a', 'b'], ['c', 'd'])[ .? 001 eq 'c']
(['a', 'b'], ['c', 'd'])[ ? 001 eq 'c']
(['a', 'b'], ['c', 'd'])[ .?0 eq 'c']
(['a', 'b'], ['c', 'd'])[ ?0 eq 'c']
(['a', 'b'], ['c', 'd'])? -1
(['a', 'b'], ['c', 'd'])?1
(['a', 'b'], ['c', 'd'])[ .? -1 eq 'c']
(['a', 'b'], ['c', 'd'])[ ? -1 eq 'c']
(['a', 'b'], ['c', 'd'])[.?1 eq 'c']
(['a', 'b'], ['c', 'd'])[?1 eq 'c']
<a><b><c/><d/><a/>
<a> <b c=""/> <d/> </a>/descendant-or-self::node()[last()]
<a> <b c=""/> <d/> </a>/descendant-or-self::node()[last()]/ancestor::*
<a> <b c=""/> <d/> </a>//node()/../count(.)
("abc" || "de")
[['A', 'B', 'C'], ['D', 'E'], []]?1?2
(['a', 'b'], ['c', 'd'], ['e'])?2
(['A', 'B', 'C'], ['D', 'E'])?2
(['A', 'B', 'C'], ['D', 'E'], [])?2
(['a', 'b'], ['c', 'd'], ['e'])[ .?2 eq 'b']
(['a', 'b'], ['c', 'd'], ['e'])[ ?2 eq 'b']
("ABCDE" || "abcde")
("ABC", "DEF","A")[fn:string-length(.) gt 2]
("abc","def") castable as xs:integer?
("abc","def") castable as xs:string?
('a' ||  'b' ||  'c' ||  () ||  'd' ||  'e' ||  'f' ||  'g' ||  'h' ||  ' ' ||  'i' ||  'j' ||  'k l') eq "abcdefgh ijk l"
("ab","cde","fgh") instance of xs:integer*
("ab","cde","fgh") instance of xs:string*
("ab" ||  "c") eq "abc"
"abc" eq concat("a", "bc")
"abc" eq string(/works/@id)
"abc" eq /works/@id
"abc" eq xs:string(/works/@id)
'abc' ge 'a'
'abc' ge 'abc'
'abc' gt 'a'
( (<a><b>cheese</b></a>)/b )[1]
( (<a><b>cheese</b></a>)/b )[last()]
("ab" ||  "c") instance of xs:string
'abc' le 'abc'
"abc" ne concat("a", "bc")
"abc" ne string(/works/@id)
"abc" ne /works/@id
"abc" ne xs:string(/works/@id)
'abc'=>substring(1,2)
['a', 'b', 'c'] treat as array(*) ? 1
['a', 'b', 'c'] treat as array(*)??1
'abc'=>upper-case()
("A","B","C")[xs:string(.)]
<a> <b id="person0"> <c/> </b> </a>/*[attribute::id eq "person0"]/c
<a> <b id="person0"> <c/> </b> </a>/*[@id eq "person0"]/c
(<a/>, <b/>)/(if (position() mod 2 = 1) then position() else .)
<a><b name="C"/><b name= "D"/></a>//b[@name="D"][last() = 1]
abs()
abs(-10.5) eq 10.5
abs(10.5) eq 10.5
abs(1, 2)
(abs(3.5))
(abs(3.5), abs(-4), abs(xs:float('-INF')))
(abs(-4))
abs("a string")
abs(xs:byte(.)) instance of xs:byte
(abs(xs:float('-INF')))
abs(xs:int(.)) instance of xs:int
abs(xs:long(.)) instance of xs:long
abs(xs:negativeInteger(.)) instance of xs:negativeInteger
abs(xs:nonNegativeInteger(.)) instance of          xs:nonNegativeInteger
abs(xs:nonPositiveInteger(.)) instance of          xs:nonPositiveInteger
abs(xs:positiveInteger(.)) instance of xs:positiveInteger
abs(xs:short(.)) instance of xs:short
abs(xs:unsignedByte(.)) instance of xs:unsignedByte
abs(xs:unsignedInt(.)) instance of xs:unsignedInt
abs(xs:unsignedLong(.)) instance of xs:unsignedLong
abs(xs:unsignedShort(.)) instance of xs:unsignedShort
<a> <![CDATA[ ]]> {"abc"}</a>
<a>{comment {"content"}/*}</a>
<!-- a comment --> instance of comment()
<a> <!-- content --> {attribute name{"content"}} </a>
<a>{<e foo="content2" bar="content1"/>/attribute(foo)}</a>
<a> { element { 'prefix:localName' } { } } </a>
<a:elem xmlns:a="http://example.com/NS" xmlns:b="http://example.com/NS"></b:elem>
<a/> except <b/>
<a />/fn:idref('id')
<a foo="1"fb="1"/>
<a foo='1'fb='1'/>
<a foo="1"/>/@foo + <b foo="2"/>/@foo
'a' le 'abc'
(//*:all-of)[1] ! fn:path()
(<?alpha?>, <?beta?>, <?gamma?>)/processing-instruction(Q{}alpha)
'a' lt 'abc'
<(:a misplaced comment:)ncname/>
"&amp;"
"" and ''
() and ()
() and (0)
() and (1)
"" and 'a'
"a" or '0'
"&apos;"
<a>{processing-instruction name {"content"}/*}</a>
<a> { processing-instruction { 'xml' } { 'content' } } </a>
array()
array { "a", "b", "c" }
array {["a", "b", "c"], "d" }
array:append([], [])
array:append([],"3")
array:append(["a","b"],())
array:append(["a","b"],"3")
array:append(["a",["b"]],[3])
array:append(["a", "b", "c"], "d")
array:append(["a","b"],("c","d"))
array:append(["a", "b", "c"], ("d", "e"))
array:append(["a", "b", "c"], ["d", "e"])
array:append(array:append(["a","b"],"c"),"d")
array:filter([10, 20, 30, 0], function($x){ 20 idiv $x eq 5})
array:filter([[2,3],[],[4,5,6,7],[6,7],[3]], function($a){array:size($a) gt 1})
array:filter([4,5,6],function($n) {$n > 4})
array:filter([4,5,6],function($n) {$n > 6})
array:filter(["A", "B", "", 0, 1], boolean#1)
array:filter(["A", "B", 1, 2], function($x) {$x instance of xs:integer})
array:filter(["A", "B", 1, 2], function($z) {$z instance of xs:integer})
array:filter(["ab","aa","xy"],starts-with#2(?,"a"))
array:filter(['apple', 'banana', 'cherry', 17], substring-after(?, "e"))
array:filter(['apple', 'banana', 'cherry'], contains(?, "e"))
array:filter(['apple', 'banana', 'cherry'], substring-after#2)
array:filter([], contains(?, ""))
array:filter(["the cat", "sat", "on the mat"], function($s){count(tokenize($s, " ")) gt 1})
array:filter(["the cat", "sat", "on the mat"], function($s){fn:count(fn:tokenize($s)) gt 1})
array:flatten(())
array:flatten([])
array:flatten([(1,0), (1,1), (0,1), (0,0)])
array:flatten(([1, 2, 5], [[10, 11], 12], [], 13))
array:flatten([1, 4, 6, 5, 3])
array:flatten(([1, [4, [6, 9]]]))
array:flatten((1, 4, 6, 9))
array:flatten( ("a", "b", "c") )
array:flatten(["a", "b", "c"])
array:flatten( (["a", "b"],["c", "d"]) )
array:flatten( (["a", "b"],["c", ["d"],["e"]]) )
array:flatten((map{}, map{1:[2,3]}, map{1:[2], 2:[3]}))
array:flatten((map{}, map{1:2}, map{1:2, 2:3}))
array:fold-left([], 0, function($a, $b) { $a + $b })
array:fold-left([1,2,3], 0, function($a, $b) { $a + $b })
array:fold-left([1,2,3,4,5,6], 0, function($a, $b) { $a + $b })
array:fold-left([1,2,3,4,5,6], 0, function($z,$a){$z + $a})
array:fold-left([1,2,3], [], function($x, $y){[$x, $y]})
array:fold-left(["+2", "*3"], "10", function($z,$a){concat("(", $z, $a, ")")})
array:fold-left([[2,3],[],[4,5,6,7],[6,7],[3]], 0, function($z,$a){$z + array:size($a)})
array:fold-left( ["a","b","c"], "", concat(?,?) )
array:fold-left(["a","b","c"], "", function($a, $b) { concat($a,$b) })
array:fold-left(["a","b","c"], "", function($a, $b) { concat($b,$a) })
array:fold-left(["a","b","c"], "x", function($a, $b) { concat($a,',',$b) })
array:fold-left([function($x){$x+2}, function($x){$x*3}], 10, function($z,$a){$a($z)})
array:fold-left(["the cat", "sat", "on the mat"], "", function($z,$a){concat($z, " ", $a)})
array:fold-left([true(), true(), false()], false(), function($x, $y){$x or $y})
array:fold-left([true(), true(), false()], true(), function($x, $y){$x and $y})
array:fold-right([], 0, function($a, $b) { $a + $b })
array:fold-right([1,2,3], 0, function($a, $b) { $a + $b })
array:fold-right([1,2,3,4,5,6], 0, function($a, $b) { $a + $b })
array:fold-right([1,2,3,4,5,6], 0, function($a,$z){$a + $z})
array:fold-right([true(), true(), false()], false(), function($x, $y){$x or $y})
array:fold-right([true(), true(), false()], true(), function($x, $y){$x and $y})
array:for-each([10,20,30,40], remove#2)
array:for-each([10,20,30,40], upper-case#1)
array:for-each([[2,3],[4,5,6,7],[6,7],[],[3]], array:insert-before(?,1,1))
array:for-each([[2,3],[4,5,6,7],[6,7],[],[3]], array:size(?))
array:for-each(["A", "B", 1, 2], function($z) {$z instance of xs:integer})
array:for-each( ["a","b","c"], function($x) {$x,"x"} )
array:for-each( ["a","b","c"], function($x) {concat($x,"x")} )
array:for-each( ["a","b","c"], string-to-codepoints(?) )
array:for-each-pair([1,2,3,4,5], [1,2,3,4,5], function($a, $b){$a * $b})
array:for-each-pair([1,2,3,4,5], [2,4,6,8,10,12,14], function($a,$b){$a + $b})
array:for-each-pair([], [1, 2], contains#2)
array:for-each-pair(['a', 'b'], [1, 2], contains#2)
array:for-each-pair(['a', 'b'], [1, 2], true#0)
array:for-each-pair(["A", "B", "C"], [1, 2, 3], function($x, $y) {[$x, $y]})
array:for-each-pair(["A", "B", "C"], [1, 2, 3], function($x, $y) { array {$x, $y}})
array:for-each-pair([["a","b","c"],["d","e","f"],["g","h","i"]], [1,2,3], array:remove#2)
array:for-each-pair(["a", "b", "c", "d", "e"], ["x", "y", "z"], concat#2)
array:for-each-pair(["a", "b", "c"], ["x", "y", "z"], concat#2)
array:for-each-pair(["a", "b", "c"], ["x", "y", "z"], function($a, $b){$a, $b})
array:for-each-pair([], [], contains#2)
array:for-each-pair([function($x){$x+2},function($x){$x*2},function($x){$x*$x}], [3,4,5], function($a,$b){$a($b)})
array:for-each(["the cat", "sat", "on the mat"], fn:tokenize#1)
array:for-each(["the cat", "sat", "on the mat"], tokenize(?, " "))
array:for-each([], tokenize(?, " "))
array:get((), 1)
array:get([], 1)
array:get([1,2,3], ())
array:get([1,2,3], 1.2)
array:get([1,2,3], 1 to 2)
array:get([1], 4294967297)
array:get([5,6,7], 0)
array:get([5,6,7], -1)
array:get([5,6,7], 1)
array:get([5,[6,7]], 2)
array:head([])
array:head([(), 1])
array:head([[1,[2],3], [4,5,6]])
array:head([(1, [<e><f>g</f></e>, "b"], 2)])
array:head([5, 6, 7, 8])
array:head([5,6,7,8])
array:head(["abc"])
array:head([("a", "b"), ("c", "d")])
array:head([["a", "b"], ["c", "d"]])
array:head(["abc","def","ghi"])
array:head(array { (1 to 100) [. eq year-from-date(current-date())] })
array:head(array { (), (27, 17, 0) })
array:insert-before([], 1, ())
array:insert-before([1], 4294967297, 22)
array:insert-before([], 2, ())
array:insert-before([4,5,[6]], 0, "a")
array:insert-before(["a", "b", "c", "d"], 1, ([],[]))
array:insert-before(["a", "b", "c", "d"], 3, ("x", "y"))
array:insert-before(["a", "b", "c", "d"], 3, ["x", "y"])
array:insert-before(["a", "b", "c", "d"], 5, ("x", "y"))
array:join(())
array:join(([()], [()], [()]))
array:join(([], [], []))
array:join([()])
array:join([])
array:join(([],[1,2],[]))
array:join([1,2])
array:join([1, 2, 3])
array:join(([1,2],[3,4]))
array:join((               [[(1,2)]],               [[(3,4)],(5,6)],               [7],            []            ))
array:join(([], [()], [], [4], [], [<e>f</e>, <!-- 234 -->], [], [] ))
array:join((["a", "b"], ["c", "d"]))
array:join((["a", "b"], ["c", "d"], [ ]))
array:join((["a", "b"], ["c", "d"], [["e", "f"]]))
array:join((["a","b","c"], ["d"], [["e","f"]]))
array { //product,( "a", "b", "c"),"d"}
array:put([1], 1, ())
array:put([1], 4294967297, 2)
array:put([], 2, ())
array:put([4,5,[6]], 0, "a")
array:put([4,5,[6]], 4, "a")
array:put([4,5,[6]], -842, "a")
array:put(["a"], 1, ["d", "e"])
array:put(["a", "b", "c"], 2, "d")
array:put(["a", "b", "c"], 2, ("d", "e"))
array:put(["a", "b", "c", "d"], 1, ([],[]))
array:put(["a", "b", "c", "d"], 3, ("x", "y"))
array:put(["a", "b", "c", "d"], 3, ["x", "y"])
array:put(["a", "b", "c", "d"], 4, ("x", "y"))
array:remove([], 1)
array:remove([[(1,2)]], 1)
array:remove([[(1,2)],[(1,2)]], 1)
array:remove([[(1,2)],[(1,2)]], 3)
array:remove([[(1,2)]], -3)
array:remove([1], 4294967297)
array:remove([4,5,6], 0)
array:remove([4,5,6], 4)
array:remove(["a"], 1)
array:remove(["a", "b", "c", "d"], ())
array:remove(["a", "b", "c", "d"], 1)
array:remove(["a", "b", "c", "d"], (1 to 3))
array:remove(["a", "b", "c", "d"], 1 to 3)
array:remove(["a", "b", "c", "d"], 2)
array:remove(["a", "b", "c", "d"], (3, 2, 1, 2))
array:remove(["a", "b", "c", "d"], (4 to 5))
array:remove(["a", ["b", ()], ["d"]], 2)
array:reverse([ ])
array:reverse([])
array:reverse([(1 to 5)])
array:reverse(["abc"])
array:reverse([("a","b","c")])
array:reverse(["a", "b", "c", "d"])
array:reverse([("a", "b"), ("c", "d")])
array:reverse(["abc","def","ghi"])
array:size([ ])
array:size([[ ]])
array:size([[],[]])
array:size([])
array:size([1, 2, 3])
array:size([(),(2,3), ()])
array:size([2,[3,4]])
array:size([2,3,4])
array:size(["a", "b", "c"])
array:size(["a", ["b", "c"]])
array:size(["a","b","c","d"])
array:size([(), ('A', 'B', 'C'), 'D'])
array:size(["abc", ["def", "ghi"]])
array:size(["a","","c",""])
array:size(array{(), ('A', 'B', 'C'), 'D'})
array:sort([(1,0), (1,1), (0,1), (0,0)])
array:sort([1, 4, 6, 5, 3])
array:sort([6,2,4])
array:sort([("a","c","b"), ("a","b","f")])
array:subarray([1, (2,[2]), 3], 2, 20)
array:subarray([1, (2,2), 3], 3, 0)
array:subarray([[[1]],(2,2),3], 3, 1)
array:subarray([1, (2,[2]), 3], 4, 1)
array:subarray([1,2,3], 0)
array:subarray([1,2,3], 2, -1)
array:subarray([1,2,3], 2, 3)
array:subarray([1,2,3,4,5], 1, 4294967297)
array:subarray([1,2,3,4,5], 4294967297, 2)
array:subarray(["a", (1,2,3,4), [(),0], "d", (), ""], 2, 4)
array:subarray(["a", "b", "c", "d"], 2)
array:subarray(["a", "b", "c", "d"], 2, 0)
array:subarray(["a", "b", "c", "d"], 2, 1)
array:subarray(["a", "b", "c", "d"], 2, 2)
array:subarray(["a", "b", "c", "d"], 2, 3)
array:tail([()])
array:tail([])
array:tail([          [1,[[2]]],          <e/>,             (<f/>,<g/>)           ])
array:tail([5])
array:tail([5, 6, 7, 8])
array:tail([5,6,7,8])
array:tail(["abc"])
array:tail([["a", "b"], ["c", "d"]])
array:tail(["abc","def","ghi"])
as
< asd />
"a string &"
"a string &#;"
"a string &;"
"a string" }
"a string &#1233 98;"
"a string &#1233.98;"
"a string &#1233a98;"
"a string" = "a string"
"a string" != "a stringDIFF"
"A String" cast as xs:string
"a string" eq xs:untypedAtomic("a string")
"A String Function" instance of xs:anyURI
"A String Function" instance of xs:boolean
"A String Function" instance of xs:date
"A String Function" instance of xs:dateTime
"A String Function" instance of xs:decimal
"A String Function" instance of xs:double
"A String Function" instance of xs:float
"A String Function" instance of xs:int
"A String Function" instance of xs:integer
"A String Function" instance of xs:string
"A String Function" instance of xs:time
"a string" instance of xs:string
"a string is ok" and QName("", "local")
"a string is ok" or QName("", "local")
"a string &LT;"
"a string &lte;"
"a string &#x;"
"a string &#x543 3;"
"a string &#x543.3;"
"a string &#x543g3;"
"a string" = xs:untypedAtomic("a string")
"a string" != xs:untypedAtomic("a stringDIFF")
<a>{(<?target content?>, attribute name{"content"})[2]} </a>
<a> <?target content?> {<b>{attribute name{"content"}}</b>} </a>
<a>{<?target data?>/*}</a>
<a>{text{()}}</a>
(/atomic:root/atomic:base64Binary/text()) | (/atomic:root/atomic:base64Binary/text())
(/atomic:root/atomic:base64Binary/text()) except (/atomic:root/atomic:base64Binary/text())
(/atomic:root/atomic:base64Binary/text()) intersect (/atomic:root/atomic:base64Binary/text())
(/atomic:root/atomic:date/text()) | (/atomic:root/atomic:date/text())
(/atomic:root/atomic:date/text()) except (/atomic:root/atomic:date/text())
(/atomic:root/atomic:date/text()) intersect (/atomic:root/atomic:date/text())
(/atomic:root/atomic:duration/text()) | (/atomic:root/atomic:duration/text())
(/atomic:root/atomic:duration/text()) except (/atomic:root/atomic:duration/text())
(/atomic:root/atomic:duration/text()) intersect (/atomic:root/atomic:duration/text())
(/atomic:root/atomic:idrefs/text()) | (/atomic:root/atomic:idrefs/text())
(/atomic:root/atomic:idrefs/text()) intersect (/atomic:root/atomic:idrefs/text())
(/atomic:root/atomic:integer) | (/atomic:root/atomic:string)
(/atomic:root/atomic:integer) except (/atomic:root/atomic:integer)
(/atomic:root/atomic:integer) intersect (/atomic:root/atomic:integer)
(/atomic:root/atomic:integer) intersect (/atomic:root/atomic:string)
(/atomic:root/atomic:integer) union (/atomic:root/atomic:integer)
(/atomic:root/atomic:QName/text()) | (/atomic:root/atomic:QName/text())
(/atomic:root/atomic:QName/text()) except (/atomic:root/atomic:QName/text())
(/atomic:root/atomic:QName/text()) intersect (/atomic:root/atomic:QName/text())
attribute(1)
attribute { 1 } { 1 }
attribute a { avg#1 }
attribute {"aPrefix:localName"} {"content"}
attribute aPrefix:localName {"content"}
attribute e{"content"} instance of attribute()
attribute e{"content"} instance of attribute(*)
attribute e{"content"} instance of attribute(e)
attribute e{"content"} instance of attribute(name)
attribute e{"content"} instance of element()
attribute e{"content"} instance of element(*)
attribute e{"content"} instance of element(e)
attribute "name" {"content"}
attribute(notBound:ncname)
attribute xmlns {}
attribute {"xmlns"} {"content"}
attribute xmlns {"content"}
attribute {"xmlns:localName"} {"content"}
attribute xmlns:localName {"content"}
attribute {xs:untypedAtomic("aPrefix::localName")} {"content"}
//author | ()
//author except ()
//author except //nonexisting
//author intersect ()
//author intersect //nonexisting
//author union //nonexisting
avg()
avg((1, 1))
(avg( (1, 2, 3, (), 4, 5) ))
(avg( (1, 2, 3, 4, 5) ))
avg((1, 2, 3, xs:anyURI("a string"), xs:double("NaN")))
avg((1, 2, xs:untypedAtomic("3"))) eq 2
avg((1, 2, xs:untypedAtomic("3"))) instance of xs:double
avg(1, "wrong param")
avg((-3, -3, -3)) eq -3
avg((3, 3, 3)) eq 3
avg((3, 4, 5)) eq 4.0
avg((-5, -0, -3, -6)) eq -3.5
avg("a string")
avg(xs:anyURI("a string"))
avg((xs:double("NaN"), current-date() - xs:date("1997-01-01") ))
avg((xs:double("NaN"), day-from-date(current-date())))
avg(xs:duration("P1Y1M1D"))
avg((xs:float(1), 2, xs:untypedAtomic("3"))) eq 2
avg((xs:float(1), 2, xs:untypedAtomic("3"))) instance of xs:double
avg((xs:float(1), xs:integer(0), xs:float(5))) eq 2.0
avg((xs:float(1), xs:integer(0), xs:untypedAtomic(3))) instance of xs:double
avg((xs:float(1), xs:integer(0), xs:untypedAtomic(-4))) eq -1
avg((xs:float(1), xs:integer(3), xs:decimal(3))) instance of xs:float
avg((xs:float(1), xs:integer(3), xs:double(3))) instance of xs:double
avg((xs:float(1), xs:integer(3), xs:float(3))) instance of xs:float
avg((xs:float(2), xs:integer(3), "a string", xs:double(2)))
avg((xs:float('NaN'), 2, 3.3, 4, xs:double('NaN'))) instance of xs:double
avg((xs:float('NaN'), 2, 3, 4, xs:double('NaN'))) instance of xs:double
avg((xs:float("NaN"), day-from-date(current-date())))
avg((xs:integer(1), xs:integer(3), xs:decimal(3))) instance of xs:decimal
avg((xs:string(1), xs:integer(3), xs:untypedAtomic(3)))
avg(xs:untypedAtomic("3")) instance of xs:double
avg((xs:untypedAtomic(3), xs:integer(0), xs:decimal(1))) instance of xs:double
avg((xs:untypedAtomic(3), xs:integer(3), xs:string(1)))
avg((xs:yearMonthDuration("P1Y"), xs:dayTimeDuration("P1D")))
avg((xs:yearMonthDuration("P20Y"), (3, 4, 5)))
<a xml:id="1"/>
<a xmlns="{1}" />
<a xmlns="http://www.w3.org/" xmlns="http://www.w3.org/" />
<a xmlns:prefix="{1}" />
<a xmlns:prefix="http://www.w3.org/" xmlns:prefix="http://www.w3.org/" />
<a xmlns:p="urn:abbrev:NS"><b p:c="" p:d=""/></a>
<a xml:space="   preserve"/>
<a xml:space="PRESERVE"/>
<a xml:space="space"/>
"a xs:string" instance of xs:string
<bad-character-reference>&#xa999999999999999a;</bad-character-reference>
()?banana
<b attr="f"/>[1]
/bib/book[1]/title except /bib/book[1]/title
(/bib/book[1]/title intersect /bib/book[1]/title)/string()
(/bib/book[3] except root(exactly-one(/bib/book[3]/title)))/string(@year)
/bib/book[3]/title intersect root(exactly-one(/bib/book[3]/title))
/bib/book[3]/title | root(fn:exactly-one(/bib/book[3]/title))
/bib/book[3]/title/text() | /bib/book[1]/title
/bib/book[3]/title/text() except /bib/book/title/text()
/bib/book[3]/title/text() intersect /bib/book/title/text()
/bib/book[3]/title/text() union /bib/book[1]/title
/bib/book[3]/title union /bib/book[1]/title
/bib/book except /bib/book
(/bib/book intersect /bib/book)/string(@year)
(/bib/book/price/text()) and (1)
(/bib/book/price/text()) and (/bib/book/price/text())
(/bib/book/price/text()) or (1)
(/bib/book/price/text()) or (/bib/book/price/text())
(/bib/book/title | /bib/book)/local-name()
/bib/book/title except /bib/book[1]/title
/bib/book/title intersect /bib/book[1]/title
<bib> {         for $b in /bib/book         where $b/publisher = "Addison-Wesley" and $b/@year > 1991         return <book year="{ $b/@year }">{ $b/title }</book> }         </bib>
<bib> {         for $b in //book[author]         return <book>         { $b/title } { $b/author } </book> }         { for $b in //book[editor]         return <reference> { $b/title } {$b/editor/affiliation} </reference> }         </bib>
<bib> {         for $b in //book         where $b/publisher = "Addison-Wesley" and $b/@year > 1991         order by exactly-one($b/title)         return <book> { $b/@year } { $b/title } </book> }         </bib>
<bib> {         for $b in //book         where count($b/author) > 0         return <book>         { $b/title }         { for $a in $b/author[position()<=2] return $a }         { if (count($b/author) > 2) then <et-al/> else () }         </book> }         </bib>
"boo" cast as xs:error
//book/price, (), (1)
//book/price, //book/title
<books-with-prices> {          for $b in $bib//book, $a in $reviews//entry          where $b/title = $a/title          return <book-with-prices> { $b/title } <price-bstore2>{ $a/price/text() }</price-bstore2> <price-bstore1>{ $b/price/text() }</price-bstore1> </book-with-prices> } </books-with-prices>
boolean('""')
boolean()
boolean(-1)
boolean(1)
boolean((1, 0))
boolean(1.1)
boolean(1.1e1)
boolean((1, 2))
boolean(1, "wrong param")
boolean((/, 93.7))
boolean((93.7, /))
boolean(("", "a"))
boolean(array{})
boolean(avg(()))
boolean(boolean#1)
boolean(//employee[location = "Denver"] | //employee[last()])
boolean(//employee[location = "Denver"] except //employee[last()])
boolean(//employee[location = "Denver"] intersect //employee[last()])
boolean(//employee[location = "Denver"] union //employee[last()])
boolean(empty(for $x in (1 to 10)[. mod 2 = 0] return "blah"))
boolean( exactly-one( remove( (<a/>, 1), 1 ) ) )
boolean((for $i in (false(), true(), true(), false(), true(), false()) order by $i return $i)[1])
boolean(index-of((1 to 10)[. mod 2 = 0],4))
boolean(index-of((1 to 10)[. mod 2 = 0],5))
boolean(map{})
boolean(map{0:"false", 1:"true"})
boolean('nada')
boolean(//*:NotAtAllOpen)
boolean(one-or-more((1 to 10)[. mod 2 = 0]))
boolean(one-or-more(for $x in (1 to 10)[. div 2 = 1] return true()))
boolean(one-or-more(for $x in 1 to month-from-date(current-date()) return <a/>))
boolean(one-or-more(month-from-date(current-date()) to 0))
boolean(//*:Open)
boolean("string")
boolean(string(false()))
boolean(sum((1 to 10)[. mod 2 = 0]))
boolean(translate(string-join(for $x in 1 to 10 return "blah","-"),exactly-one(("--","==")[position() mod 2 = 0]),"__"))
boolean([true()])
boolean(true())
boolean((true(), //aspidistra))
boolean((true(), false()))
boolean(typeswitch (current-time(), 1, 3e3, "foo") case node() return 0 case xs:integer return 3 case xs:anyAtomicType return true() default return -1)
boolean(unordered(reverse((1 to 10)[. div 2 = 2])))
boolean(xs:anyURI("example.com/"))
boolean(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext"))
boolean(xs:base64Binary("aaaa"))
boolean(xs:boolean("true"))
boolean(xs:date("2004-10-13"))
boolean(xs:dateTime("2002-10-10T12:00:00-05:00"))
boolean(xs:dayTimeDuration("P3DT2H"))
boolean(xs:decimal("10.01"))
boolean(xs:double("3.3e3"))
boolean(xs:duration("P1Y2M3DT10H30M"))
boolean(xs:float("3.4e5"))
boolean(xs:gDay("---03"))
boolean(xs:gMonth("--11"))
boolean(xs:gMonthDay("--11-13"))
boolean(xs:gYear("1999"))
boolean(xs:gYearMonth("1999-11"))
boolean(xs:hexBinary("03"))
boolean(xs:hexBinary("0FB7"))
boolean(xs:integer("6789"))
boolean(xs:QName("ncname"))
boolean(xs:QName("valid-local-name"))
boolean(xs:string("an arbitrary string"))
boolean(xs:time("03:20:00-05:00"))
boolean(xs:untypedAtomic("an arbitrary string(untypedAtomic source)"))
boolean(xs:untypedAtomic("string"))
boolean(xs:yearMonthDuration("P1Y12M"))
<b/>[self::b][last()]
() castable as xs:error?
() castable as xs:integer?
() castable as xs:NOTATION
() castable as xs:NOTATION?
() castable as xs:QName?
() cast as xs:error?
() cast as xs:integer
() cast as xs:NOTATION
() cast as xs:NOTATION?
() cast as xs:QName
. cast as xs:QName
(/ catalog/product[last()])
<c b="a    string literal  "/>
<![CDATA[a string]]>
<![CDATA[content]]>
(ceiling( () ))
ceiling()
ceiling(0.0)
ceiling(0.000000001)
ceiling(0.000000001e0)
ceiling(0.0e0)
ceiling(-0.1)
ceiling(-0.1e0)
ceiling(-10.5) eq -10
ceiling(10.5) eq 11
ceiling(1, 2)
ceiling(-12345678.567890)
ceiling(-12345678.567890e0)
ceiling(-1234567891234567.2)
ceiling(-1234567891234567.2e0)
ceiling(12.5)
ceiling(12.5e0)
ceiling(12.9)
ceiling(12.9e0)
(ceiling(5))
(ceiling(5.1))
(ceiling(-5.5))
(ceiling(5.5))
(ceiling(-5.51))
(ceiling(5), ceiling(5.1), ceiling(5.5), ceiling(-5.5), ceiling(-5.51), ceiling( () ))
ceiling("a string")
ceiling(xs:byte(.)) instance of xs:integer
ceiling(xs:double('-0'))
ceiling(xs:double('-INF'))
ceiling(xs:double('INF'))
ceiling(xs:double('NaN'))
ceiling(xs:float(0.000000001e0))
ceiling(xs:float(0.0e0))
ceiling(xs:float(-0.1e0))
ceiling(xs:float(-1234567.2e0))
ceiling(xs:float(-12345678.1e0))
ceiling(xs:float(12.5e0))
ceiling(xs:float(12.9e0))
ceiling(xs:float(xs:float('-0')))
ceiling(xs:float(xs:float('-INF')))
ceiling(xs:float(xs:float('INF')))
ceiling(xs:float(xs:float('NaN')))
ceiling(xs:int(.)) instance of xs:integer
ceiling(xs:long(.)) instance of xs:integer
ceiling(xs:negativeInteger(.)) instance of xs:integer
ceiling(xs:nonNegativeInteger(.)) instance of xs:integer
ceiling(xs:nonPositiveInteger(.)) instance of xs:integer
ceiling(xs:positiveInteger(.)) instance of xs:integer
ceiling(xs:short(.)) instance of xs:integer
ceiling(xs:unsignedByte(.)) instance of xs:integer
ceiling(xs:unsignedInt(.)) instance of xs:integer
ceiling(xs:unsignedLong(.)) instance of xs:integer
ceiling(xs:unsignedShort(.)) instance of xs:integer
child:
child::element
child::local:b(:ada
/child::works/child::employee[fn:position() = 5]/child::hours[fn:position() = 2]
('Ciao!' || ())
(codepoint-equal('abc', ()))
(codepoint-equal('abc', 'ab c'))
(codepoint-equal('abc', 'abc'))
(codepoint-equal('abc', 'abc'), codepoint-equal('abc', 'ab c'), codepoint-equal('abc', ()))
codepoint-equal(lower-case(concat("B STRING", current-time())),                              lower-case(concat("b string", current-time())))
codepoint-equal(lower-case(concat("B STRING", current-time())),                              lower-case(concat("no match", current-time())))
codepoint-equal(lower-case(concat("B STRING", current-time())),                              upper-case(concat("no match", current-time())))
codepoint-equal(upper-case(concat("B STRING", current-time())),                              lower-case(concat("no match", current-time())))
codepoint-equal(upper-case(concat("B STRING", current-time())),                              upper-case(concat("b string", current-time())))
codepoint-equal(upper-case(concat("B STRING", current-time())),                              upper-case(concat("no match", current-time())))
<codepoints>{string-to-codepoints(<elem>1 2</elem>)}</codepoints>
<codepoints>{string-to-codepoints(<elem>1&#xa;2</elem>) }</codepoints>
<codepoints>{string-to-codepoints(<elem>&#xD;</elem>)}</codepoints>
<codepoints>{string-to-codepoints(<elem>&#xD;&#xA;</elem>)}</codepoints>
(codepoints-to-string(()))
codepoints-to-string(())
codepoints-to-string((),())
codepoints-to-string()
codepoints-to-string(0)
codepoints-to-string(10) eq " "
codepoints-to-string(11)
codepoints-to-string(1114111) eq ""
codepoints-to-string(1114112)
codepoints-to-string((119070, 119070, 119070, 119070) (:treble clef:)) castable as xs:base64Binary
codepoints-to-string(12)
codepoints-to-string(13) eq "&#xD;"
codepoints-to-string(27637) eq ""
codepoints-to-string(32) eq " "
codepoints-to-string(-500)
codepoints-to-string(55295) eq ""
codepoints-to-string(55296)
codepoints-to-string(57343)
codepoints-to-string(57344) eq ""
codepoints-to-string(589823) eq ""
codepoints-to-string(61438) eq ""
codepoints-to-string(65533) eq ""
codepoints-to-string(65534)
codepoints-to-string(65535)
codepoints-to-string(65536) eq ""
codepoints-to-string(8)
codepoints-to-string((84, 104), "INVALID")
codepoints-to-string((87, 36, 56, 87, 102, 96)) eq "W$8Wf`"
(codepoints-to-string(97))
(codepoints-to-string((97, 32, 98, 32, 99)))
(codepoints-to-string((97, 32, 98, 32, 99)), codepoints-to-string(97), codepoints-to-string(()))
codepoints-to-string((97, 98, 99, 119126, 100, 101, 102))
codepoints-to-string((98,223,1682,12365,63744))
codepoints-to-string(9) eq " "
codepoints-to-string(()) eq ""
codepoints-to-string('hello')
codepoints-to-string(one-or-more(string-to-codepoints("foo")))
codepoints-to-string(xs:NMTOKENS('30 31 32 33'))
/comment()
<!--com--ment-->
<!--comment--->
<!--comment-->
comment {()}
comment {., .}
comment(*)
comment{}
comment(1)
comment {1,'',2}
comment {1,<a/>,2}
comment {1,'string',3.14,xs:float('1.2345e-2'),xs:dateTime('2002-04-02T12:00:00-01:00')}
/comment() | /bib/book[1]/title
comment {'com','-','-','ment'}
comment {comment {'one', comment {'two'}}, 'three', comment {'four'}}
comment {<elem>123</elem>, (<elem attr='456'/>)/@attr, (<elem>789</elem>)/text()}
/comment() except /comment()
comment {"name"} {"content"}
comment name {"content"}
comment {/root}
/comment() union /bib/book[1]/title
(compare('a', ()))
(compare('a', 'a'))
(compare('a', 'b'))
(compare('a', 'B'))
(compare('ab', 'abc'))
(compare('a', 'b'), compare('a', 'a'), compare('b', 'a'), compare('ab', 'abc'), compare('a', 'B'), compare(upper-case('a'), upper-case('B')), compare('a', ()))
compare('a', 'b', 'http://www.cbcl.co.u,/collation')
(compare('b', 'a'))
(compare(upper-case('a'), upper-case('B')))
concat()
concat("1", "2", "3", ("a", "b"), "c")
concat("1", "2", "3", "c", ("a", "b"))
concat(1, "2", 3) eq "123"
concat(1, 2, 3) eq "123"
concat#2("one", ?, "three")
concat#3("one", "two")
concat#4("one", ?, "three")
(concat('a', 'b'))
(concat('a', 'b', 'c'))
(concat('a', (), 'b', '', 'c'))
concat(("a", "b"), "c")
concat('a', 'b', 'c', (), 'd', 'e', 'f', 'g', 'h', ' ', 'i', 'j', 'k l') eq "abcdefgh ijk l"
concat("ab", "c") eq "abc"
concat("ab", "c") instance of xs:string
(concat('a', 'b'), concat('a', 'b', 'c'), concat('a', (), 'b', '', 'c'), concat('a', <x>b</x>, 'c'))
concat("a string")
concat(<a>X</a>, <a>Y</a>)
(concat('a', <x>b</x>, 'c'))
concat("b", xs:anyURI(" "), "b")
("concat" || "concat")
concat((), ()) eq ""
concat('#', fn:substring(./concepts/@id, string-length(./concepts/@id) - 18, 1), '#')
concat("http://www.example.com/", encode-for-uri("100% organic"))
concat("http://www.example.com/", encode-for-uri("100% organic")) eq "http://www.example.com/100%25%20organic"
concat("http://www.example.com/",                   encode-for-uri("~bb"))
concat("http://www.example.com/", encode-for-uri("~bb")) eq "http://www.example.com/~b%C3%A9b%C3%A9"
concat((), ()) instance of xs:string
(concat("one ", ?, " three"), substring-before("one two three", ?), matches(?, "t.*o"), xs:NCName(?))("two")
construction gt construction
contains("", ())
contains(())
contains()
contains("a string", ())
contains("a string", "a string", "http://www.example.com/COLLATION/NOT/SUPPORTED")
contains("foo", "foo")
contains((), (), "http://www.w3.org/2005/xpath-functions/collation/codepoint", "wrong param")
(contains( (), 'q'))
(contains('query', ''))
(contains('query', ()))
(contains('query', 'e'))
(contains('query', 'e'), contains('query', 'ery'), contains('query', 'query'), contains('query', 'x'), contains('query', ''), contains('query', ()), contains( (), 'q'))
(contains('query', 'ery'))
(contains('query', 'query'))
(contains('query', 'x'))
contains("tattoo", "t")
<!-- content
<!-- content -
count(() << ())
count(() >> ())
count()
count((0, current-time())) ge 1
count((0, current-time())) ne 0
count((0, timezone-from-time(current-time()))) != 0
count((0, timezone-from-time(current-time()))) >= 1
count(0 to 4) eq 5
count(1, ())
count((10, 1 to 4)) eq 5
count([1, 2, 3])
count( (1, 2, 3) ) eq 3
count((1, 2, 3, "four")) eq 4
count((1, 2, 3, timezone-from-time(current-time()), 4)) > 0
count((1, 2, 3, timezone-from-time(current-time()), 4)) >= 0
count((1, 2, 3, timezone-from-time(current-time()), 4)) and count((1, 2, 3, timezone-from-time(current-time()), 4))
count((1, 2, 3, timezone-from-time(current-time()), 4)) and true()
count((1, 2, 3, timezone-from-time(current-time()), 4)) ge 1
count((1, 2, 3, timezone-from-time(current-time()), 4)) gt 0
count((1, 2, 3, timezone-from-time(current-time()), 4)) or count((1, 2, 3, timezone-from-time(current-time()), 4))
count((1, 2, 3, timezone-from-time(current-time()), 4)) or false()
count( (1, 2, ()) ) eq 2
count((1, 2)) eq 2
count((15 to 10))
count(1 to 3) eq 3
count(1 to 4) eq 4
count(-5 to -0) eq 6
count((<a>0</a>,<a>1</a>) intersect (<a>3</a>,<a>4</a>))
count(() << <a>50000</a>)
count(() >> <a>50000</a>)
count(<a>50000</a> << ())
count(<a>50000</a> >> ())
count(<a>50000</a> is ())
count(<a></a>/node())
count(<a><b/></a>/*/subsequence(.,1,1)/..)
count(<a><b/><b/></a>/b[1]/following-sibling::*)
count(<a><b/><b/></a>/b[1]/preceding-sibling::b)
count(<a><b/><b/></a>/b[2]/preceding-sibling::*)
count(<a><b/><b/></a>/b[2]/preceding-sibling::b)
count(<a b="blah"/>/child::attribute(b))
count(<a> <b c=""> <c/> </b> <d/> </a>/b/c/(ancestor::*))
count(<a> <b c=""> <c/> </b> <d/> </a>/b/c/(ancestor-or-self::*))
count(<a> <b c=""/> <d/> </a>/descendant-or-self::node())
count(<a> <b c=""/> <d/> </a>//node())
count((<a/>, <!--comment-->)/3)
count(<a/>/node())
count(<a>{text {''}}<b/>{text {''}}<b/>{text {''}}</a>/text())
count((attribute attr {})/..)
count((comment {'comment'})/..)
count(data((1, 2, 3, 4, 5))) eq 5
count(<e/>/(a except attribute {"name"} {()}))
count(<e/>/(a except attribute name {()}))
count(<e/>/(a except comment {()}))
count(<e/>/(a except element {"name"} {()}))
count(<e/>/(a except element name {()}))
count(<e/>/(a except processing-instruction {"name"} {()}))
count(<e/>/(a except processing-instruction name {}))
count(<e/>/(a except text {()}))
count((<elem/>)/..)
count((<elem>{1,'a',3.5,4e2}</elem>)/text())
count((<elem>{1,'a',<a/>,3.5,4e2}</elem>)/text())
count((<elem>a{1,2,3}b</elem>)/text())
count((<elem>a{1,<a/>,3}b</elem>)/text())
count(<elem><![CDATA[]]></elem>/text())
count((<elem>{''}</elem>)/text())
count((<elem>{()}</elem>)/text())
count((element elem {})/..)
count((element elem {1, 2, <a/>, 3, 4, <b/>, 5, 6})/text())
count((element elem {1, 'string', 1,2e3})/text())
count((element elem {1, //text(), 'string'})/text())
count(element elem {text {''}}/text())
count(<elem>str{""}asdas{"asd", "asd", "''", ""}{''}asd{''}{''}</elem>/text())
count((<elem>text<![CDATA[cdata]]></elem>)/text())
count((<elem>text</elem>)/text())
count(<elem>{text {'te'}, text {'xt'}}</elem>/text())
count(<e/>/(let $i := . return (string($i), data($i))))
count(//employee[if (salary castable as xs:integer) then xs:integer(salary) gt 65000 else false()])
count(//employee[@name='John Doe 4']) > 0
count(//employee[@name='John Doe 4']) = 1
count(//employee[@name='John Doe 4']) < 2
count(//employee[@name='John Doe 4']/@name) > 0.5
count(//employee[salary castable as xs:integer][xs:integer(salary) gt 65000])
count( (((), (), ()), (), (), (), ()) ) eq 0
count( () ) eq 0
count(((((()))))) eq 0
count(()) eq 0
count(exactly-one( "one" )) eq 1
count(() except (<a>3</a>,<a>4</a>,<a>0</a>))
count(<e xmlns="http://example.com/"><a xmlns=""/></e>/namespace-uri(exactly-one(*)))
count(for $e in unordered(reverse(/works/employee)) return $e/@gender)
count((for $fo in (1, 2, 3) where xs:time("08:08:23Z") return $fo)) eq 3
count(for $i in (1, 2, current-time()) return ($i, $i)) eq 6
count(for $i in (1, 2, timezone-from-time(current-time())) return ($i, $i)) eq 6 or count(for $i in (1, 2, timezone-from-time(current-time())) return ($i, $i)) eq 4
count(for $s in ("red", "blue", "green") return string-to-codepoints($s))
count((for $x in 1 to 10 return $x * $x)[position() < 3])
count(index-of((1, 2, 3, 2, 1), 1)) eq 2
count(index-of((1, 2, 3, 2, 1), 2)) eq 2
count(index-of((1, 2, 3, 2, 1), 3)) eq 1
count(index-of((1, 2, 3, 2, 1), 4)) eq 0
count(insert-before((), 1, (1, 2, 3))) eq 3
count(insert-before((1, 2, 3), 1, (4, 5, 6))) eq 6
count(insert-before((1, 2, 3), 30, (4, 5, 6))) eq 6
count(insert-before((1, 2, 3, 4), 1, ())) eq 4
count(insert-before((1, 2, 3, 4), 30, ())) eq 4
count(insert-before((), 30, (1, 2, 3))) eq 3
count(() intersect ())
count(() is ())
count(() is <a>50000</a>)
count(() is (/staff[1]/employee[1]/empnum[1]))
count(() is /works[1]/employee[1]/empnum[1])
count( let $N := <n x="this ain't no date"/> return $N[if (@x castable as xs:date) then xs:date(@x) gt xs:date("2000-01-01") else false()] )
count(map{'decimal':true(), 'integer':true(), 'polygon':false()}?*[.])
count(//*[@name='John Doe 498']) eq 0
count(//*[@name='John Doe 4']) eq 0
count(//*[@name='John Doe 4']) eq 0.3
count(//*[@name='John Doe 4']) gt -5
count(//*[@name='John Doe 4']) lt 1000000000000
count(//*[@name='John Doe 4']) lt 1.5
count(//node()) gt 40
count(//node()) ne -1
count( ("one", (2, "three")) ) eq 3
count( ((), "one", 2, "three")) eq 3
count(one-or-more( (1, 2, 3, "four") )) eq 4
count(one-or-more( "one" )) eq 1
count((processing-instruction pi {()})/..)
count(remove((1, 2, 3), 0)) eq 3
count(remove((1, 2, 3), -4)) eq 3
count(remove((1, 2, "three"), 3)) eq 2
count(remove((1, "two", 3), 2)) eq 2
count(remove(current-time(), 1)) eq 0
count(remove(("one", 2, 3), 1)) eq 2
count(remove(remove((current-time(), 1), 1), 1)) = 0
count(remove(remove((current-time(), 1), 1), 1)) eq 0
count(reverse((1, 2, 3)))
count(reverse((1, 2, 3))) eq 3
count(reverse(1 to 4)) eq 4
count(reverse(-5 to -0)) eq 6
count(reverse(-5 to -2)) eq 4
count(<root> <child/> <child/> <child attr="foo" attr2="foo"/> </root>/child[1]/following-sibling::node())
count(<root> <child/> </root>/following-sibling::node())
count(() << /staff[1]/employee[1]/empnum[1])
count(() >> (/staff[1]/employee[1]/empnum[1]))
count((/staff[1]/employee[1]/empnum[1]) << ())
count((/staff[1]/employee[1]/empnum[1]) >> ())
count((/staff[1]/employee[1]/empnum[1]) is ())
count(string-to-codepoints("123")) eq 3
count(string-to-codepoints("")) eq 0
count(subsequence((1, 2, 2, current-time()), 2, 2)) eq 2
count(subsequence((1, 2), 2)) eq 1
count(subsequence((1, 2, 3), 1, 1)) eq 1
count(subsequence((1, 2, 3), 1, 3)) eq 3
count(subsequence((1, 2, 3, "four"), 2, 2)) eq 2
count(subsequence((1, 2, 3, "four"), 2)) eq 3
count(subsequence((1, 2, 3, "four"), 4, 1)) eq 1
count(subsequence((1, 2, 3, "four"), 4)) eq 1
count(subsequence(1 to 100, -2147483648, 20))
count(subsequence(1 to 10, 2, xs:double("NaN")))
count(subsequence(1 to 10, xs:double("-INF")))
count(subsequence(1 to 10, xs:double("-INF"), xs:double("INF")))
count(subsequence(1 to 10, xs:double("NaN")))
count(subsequence(1 to 10, xs:double("NaN"), 4))
count(subsequence(1 to 3000000000, -2147483649))
count(subsequence(1 to 3, 1, 1)) eq 1
count(subsequence((current-time(), 1), 4)) eq 0
count(subsequence((current-time(), 2 , 3), 1)) eq 3
count(subsequence((current-time(), 2 , 3), 3)) eq 1
count(subsequence((current-time(), 2 , 3, 4), 2, 2)) eq 2
count(subsequence(remove(current-time(), 1), 1, 1)) eq 0
count(tail("a"))
count(text {''})
count(text {()})
count((text {'text'})/..)
count(unordered((1, 2, 3))) eq 3
count(unordered((1, 2, current-time()))) eq 3
count(unordered(for $e in reverse(/works/employee) return $e/@gender))
count(unordered(reverse(for $i in (1,2,1) return /works/employee)))
count(unordered(reverse(/works/employee[@name] | /works/employee[@gender])))
count(/ ! works)
count(() << /works[1]/employee[1]/empnum[1])
count(() >> /works[1]/employee[1]/empnum[1])
count(/works[1]/employee[1]/empnum[1] << ())
count(/works[1]/employee[1]/empnum[1] >> ())
count(/works[1]/employee[1]/empnum[1] is ())
count((/works//day)[last()]/unordered(ancestor-or-self::*))
count(/works/employee[last()]/unordered(preceding::*))
count(/works/employee[last()]/unordered(preceding-sibling::*))
count(xs:base64Binary(()))
count(xs:float(()))
count(xs:hexBinary(()))
count(xs:hexBinary(xs:hexBinary("03"))) eq 1
count(xs:untypedAtomic("1") to 3) eq 3
count(zero-or-one( () )) eq 0
count(zero-or-one( "one" )) eq 1
<critical_sequence> { let $proc := //section[section.title="Procedure"][1], $i1 := ($proc//incision)[1], $i2 := ($proc//incision)[2] for $n in $proc//node() except $i1//node() where $n >> $i1 and $n << $i2 return $n } </critical_sequence>
current()
current-date() and 1
current-date() and current-date()
current-date()[current-date() => string() => string-length()] => string() => translate("0123456789", "xxxxxxxxxx")
current-date() eq current-date()
current-date() or 0
current-date() or current-date()
current-date() => string() => substring(1, 10) => translate("0123456789", "xxxxxxxxxx")
current-dateTime() eq current-dateTime()
current-dateTime("WRONG PARAM")
current-date("WRONG PARAM")
current-date() = xs:date(current-dateTime())
current-grouping-key()
current-time() eq current-time()
current-time("WRONG PARAM")
current-time() = xs:time(current-dateTime())
data()
data([])
data(1, 2)
data([1,2,3])
data(123)
data([[1,2],[3,4]])
data((123, 456))
data([(1,2), (3,4), (5,6)])
data([[1,2], [3,4], [5,6], []])
data([[1,2], [3,4], [5,6], [map{1:2}]])
data(1, "wrong param")
data([<a>1</a>, <a>2</a>, <a>3</a>])
data(abs#1)
data(<!-- a comment -->) instance of xs:string
data(attribute foo {"content"}) instance of xs:untypedAtomic
data(comment {"content"}) instance of xs:string
data(<e>dsa</e>)
data(<e>dsa</e>) instance of xs:untypedAtomic
data(<e foo="content"/>/@*) instance of xs:untypedAtomic
data(element foo {"dsa"})
data(element foo {"dsa"}) instance of xs:untypedAtomic
data(<e>text</e>)
data(function($a, $b) {$a + $b})
data(<name>some text</name>) instance of xs:untypedAtomic
data(processing-instruction name {"content"}) instance of xs:string
data(<?target content?>) instance of xs:string
data(<?target data?>) instance of xs:string
data(text {"content"}) instance of xs:untypedAtomic
data(text{"content"}) instance of xs:untypedAtomic
dateTime()
dateTime(xs:date('2001-01-01-14:00'), xs:time('01:01:01+14:00'))
dateTime(xs:date("2004-03-04"))
dateTime(xs:date("2004-03-04-00:00"), xs:time("08:05:23+00:00")) eq xs:dateTime("2004-03-04T08:05:23Z")
dateTime(xs:date("2004-03-04-00:01"), xs:time("08:05:23+00:01"))
dateTime(xs:date("2004-03-04-00:01"), xs:time("08:05:23Z"))
dateTime(xs:date("2004-03-04+11:00"), xs:time("08:05:23+11:00")) eq xs:dateTime("2004-03-04T08:05:23+11:00")
dateTime(xs:date("2004-03-04+11:00"), xs:time("08:05:23")) eq xs:dateTime("2004-03-04T08:05:23+11:00")
dateTime(xs:date("2004-03-04+13:07"), xs:time("08:05:23")) eq xs:dateTime("2004-03-04T08:05:23+13:07")
dateTime(xs:date("2004-03-04"), xs:time("08:05:23"), ())
dateTime(xs:date("2004-03-04"), xs:time("08:05:23-05:00")) eq xs:dateTime("2004-03-04T08:05:23-05:00")
dateTime(xs:date("2004-03-04"), xs:time("08:05:23+13:07")) eq xs:dateTime("2004-03-04T08:05:23+13:07")
dateTime(xs:date("2004-03-04"), xs:time("08:05:23")) eq xs:dateTime("2004-03-04T08:05:23")
dateTime(xs:date("2004-03-04"), xs:time("08:05:23Z")) eq xs:dateTime("2004-03-04T08:05:23Z")
dateTime(xs:date("2004-03-04Z"), xs:time("08:05:23")) eq xs:dateTime("2004-03-04T08:05:23Z")
dateTime(xs:date("2004-03-04Z"), xs:time("08:05:23Z")) eq xs:dateTime("2004-03-04T08:05:23Z")
(dateTime(xs:date('2006-08-15'), xs:time('12:30:45-05:00')))
day-from-date()
day-from-date(()) instance of xs:integer?
day-from-dateTime()
day-from-dateTime(()) instance of xs:integer?
day-from-dateTime((), "Wrong param")
day-from-dateTime(xs:dateTime("2001-02-03T08:23:12.43")) eq 3
(day-from-dateTime( xs:dateTime('2006-08-15T10:30:23')))
day-from-date((), "Wrong param")
day-from-date(xs:date("2000-02-03")) eq 3
(day-from-date(xs:date('2006-08-15')))
days-from-duration()
days-from-duration(()) instance of xs:integer?
days-from-duration((), "Wrong param")
(days-from-duration( xs:dayTimeDuration('P1DT36H')))
days-from-duration(xs:dayTimeDuration("-P45678DT8H2M1.03S")) eq -45678
days-from-duration(xs:dayTimeDuration("P45678DT8H2M1.03S")) eq 45678
(days-from-duration( xs:dayTimeDuration('P5D')))
(days-from-duration( xs:dayTimeDuration('P5D')), days-from-duration( xs:dayTimeDuration('-PT24H')), days-from-duration( xs:dayTimeDuration('PT23H')), days-from-duration( xs:dayTimeDuration('P1DT36H')), days-from-duration( xs:dayTimeDuration('PT1440M')))
(days-from-duration( xs:dayTimeDuration('PT1440M')))
(days-from-duration( xs:dayTimeDuration('PT23H')))
(days-from-duration( xs:dayTimeDuration('-PT24H')))
days-from-duration(xs:duration("-P3Y4M8DT1H23M2.34S")) eq -8
declare
declare boundary-space preserve; xquery version "1.0"; 1,2
declare(::)construction(::)Preserve;(::)1(::)eq(::)1
declare context item as xs:integer+ := (1 to 17)[position() = 5];         .
declare context item external;         . instance of document-node()
declare context item := last() + 1; .
declare context item := position() + 1; .
declare decimal-format local:df minus-sign="-" currency-symbol="" decimal-separator=".";        format-number(95.4857,'###.####', "local:df")
declare default decimal-format decimal-sprtr = ".";        true()
declare default decimal-format NaN = ``[not-a-number]``; 12
declare default function namespace "";         declare function foo ($n as xs:integer, $m as xs:integer) { $n };         foo(4, 1)
declare default function namespace ""; declare function foo() { 1 }; 1
declare default function namespace "%gg"; fn:true()
declare default function namespace "http://example.com";         declare function _() { 1 };         _()
declare default function namespace "http://example.com"; <e a="{count()}" xmlns="http://www.w3.org/2001/XMLSchema"/>
declare default function namespace "http://example.com"; <e a="{nametest}" xmlns="http://www.w3.org/2001/XMLSchema"/>
declare default function namespace "http://example.com"; <e a="{p:count()}" xmlns:p="http://www.w3.org/2001/XMLSchema"/>
declare default function namespace "http://example.com"; <e p:p="{p:nametest}" xmlns:p="http://www.w3.org/2001/XMLSchema"/>
declare default function namespace "http://example.com"; <e xmlns="http://www.w3.org/2001/XMLSchema" a="{count()}"/>
declare default function namespace "http://example.com"; <e xmlns="http://www.w3.org/2001/XMLSchema" a="{nametest}"/>
declare default function namespace "http://example.com"; <e xmlns:p="http://www.w3.org/2001/XMLSchema" a="{p:count()}"/>
declare default function namespace "http://example.com"; <e xmlns:p="http://www.w3.org/2001/XMLSchema" p:p="{p:nametest}"/>
declare default function namespace "http://example.com/functions";         declare variable $f := (if (fn:current-date() gt xs:date('1900-01-01')) then plus#2 else fn:round#2);         declare function plus($x, $y) {           $x + $y         };         $f(5, 7)
declare default function namespace "http://example.com/hof-006";        declare function g($x as xs:integer) as xs:integer { $x + 1 };        let $f := g#1 return $f(21)
declare default function namespace "http://www.example.com/"; declare function unordered() { 1 }; unordered()
declare default function namespace "http://www.example.com/"; declare namespace e = "http://www.example.com/"; declare function element() { 1 }; e:element()
declare default function namespace "http://www.example.org/"; declare default function namespace "http://www.w3.org/2005/xpath-functions/collation/codepoint"; 1 + 2
declare default function namespace "http://www.w3.org/2001/XMLSchema";        let $f := date#1 return $f('2008-01-31')
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function attribute() { fn:true() }; local:attribute()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function comment() { fn:true() }; local:comment()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function document-node() { fn:true() }; local:document-node()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function element() { fn:true() }; local:element()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function empty-sequence() { fn:true() }; local:empty-sequence()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions";          declare function exponent-separator () {110};          exponent-separator()          eq 110
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function function() { fn:true() }; local:function()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function if() { fn:true() }; local:if()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function item() { fn:true() }; local:item()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function local:array() { fn:true() }; array()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function local:attribute($arg) { fn:true() }; attribute(1)
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function local:comment($arg) { fn:true() }; comment(1)
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function local:document-node($arg) { fn:true() }; document-node(1)
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function local:element($arg) { fn:true() }; element(1)
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function local:empty-sequence() { fn:true() }; empty-sequence()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function local:function() { fn:true() }; function()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function local:if() { fn:true() }; if()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions";         declare function local:is() as xs:integer { 1 };         is() eq 1
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function local:item($arg) { fn:true() }; item(1)
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function local:map() { fn:true() }; map()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function local:namespace-node($arg) { fn:true() }; namespace-node(1)
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function local:node($arg) { fn:true() }; node(1)
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function local:processing-instruction($arg) { fn:true() }; processing-instruction(1)
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function local:schema-attribute() { fn:true() }; schema-attribute()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function local:schema-element() { fn:true() }; schema-element()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function local:switch() { fn:true() }; switch()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function local:text($arg) { fn:true() }; text(1)
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function local:typeswitch() { fn:true() }; typeswitch()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function namespace-node() { fn:true() }; local:namespace-node()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions";                    declare function NaN () {1};          declare function allowing () {2};          declare function ancestor-or-self () {3};          declare function ancestor () {4};          declare function and () {5};          declare function as () {6};          declare function ascending () {7};          declare function at () {8};          declare function base-uri () {9};          declare function boundary-space () {10};          declare function by () {11};          declare function case () {12};          declare function cast () {13};          declare function castable () {14};          declare function catch () {15};          declare function child () {16};          declare function collation () {17};          declare function construction () {18};          declare function context () {19};          declare function copy-namespaces () {20};          declare function count () {21};          declare function decimal-format () {22};          declare function decimal-separator () {23};          declare function declare () {24};          declare function default () {25};          declare function descendant-or-self () {26};          declare function descendant () {27};          declare function descending () {28};          declare function digit () {29};          declare function div () {30};          declare function document () {31};          declare function else () {32};          declare function empty () {33};          declare function encoding () {34};          declare function end () {35};          declare function eq () {36};          declare function every () {37};          declare function except () {38};          declare function external () {39};          declare function following-sibling () {40};          declare function following () {41};          declare function for () {42};          declare function ge () {43};          declare function greatest () {44};          declare function group () {45};          declare function grouping-separator () {46};          declare function gt () {47};          declare function idiv () {48};          declare function import () {49};          declare function in () {50};          declare function infinity () {51};          declare function inherit () {52};          declare function instance () {53};          declare function intersect () {54};          declare function is () {55};          declare function lax () {56};          declare function le () {57};          declare function least () {58};          declare function let () {59};          declare function lt () {60};          declare function minus-sign () {61};          declare function mod () {62};          declare function module () {63};          declare function namespace () {64};          declare function ne () {65};          declare function next () {66};          declare function no-inherit () {67};          declare function no-preserve () {68};          declare function of () {69};          declare function only () {70};          declare function option () {71};          declare function or () {72};          declare function order () {73};          declare function ordered () {74};          declare function ordering () {75};          declare function parent () {76};          declare function pattern-separator () {77};          declare function per-mille () {78};          declare function percent () {79};          declare function preceding-sibling () {80};          declare function preceding () {81};          declare function preserve () {82};          declare function previous () {83};          declare function return () {84};          declare function satisfies () {85};          declare function schema () {86};          declare function self () {87};          declare function sliding () {88};          declare function some () {89};          declare function stable () {90};          declare function start () {91};          declare function strict () {92};          declare function strip () {93};          declare function then () {94};          declare function to () {95};          declare function treat () {96};          declare function try () {97};          declare function tumbling () {98};          declare function type () {99};          declare function union () {100};          declare function unordered () {101};          declare function validate () {102};          declare function variable () {103};          declare function version () {104};          declare function when () {105};          declare function where () {106};          declare function window () {107};          declare function xquery () {108};          declare function zero-digit () {109};                    NaN() +          allowing() +          ancestor-or-self() +          ancestor() +          and() +          as() +          ascending() +          at() +          base-uri() +          boundary-space() +          by() +          case() +          cast() +          castable() +          catch() +          child() +          collation() +          construction() +          context() +          copy-namespaces() +          count() +          decimal-format() +          decimal-separator() +          declare() +          default() +          descendant-or-self() +          descendant() +          descending() +          digit() +          div() +          document() +          else() +          empty() +          encoding() +          end() +          eq() +          every() +          except() +          external() +          following-sibling() +          following() +          for() +          ge() +          greatest() +          group() +          grouping-separator() +          gt() +          idiv() +          import() +          in() +          infinity() +          inherit() +          instance() +          intersect() +          is() +          lax() +          le() +          least() +          let() +          lt() +          minus-sign() +          mod() +          module() +          namespace() +          ne() +          next() +          no-inherit() +          no-preserve() +          of() +          only() +          option() +          or() +          order() +          ordered() +          ordering() +          parent() +          pattern-separator() +          per-mille() +          percent() +          preceding-sibling() +          preceding() +          preserve() +          previous() +          return() +          satisfies() +          schema() +          self() +          sliding() +          some() +          stable() +          start() +          strict() +          strip() +          then() +          to() +          treat() +          try() +          tumbling() +          type() +          union() +          unordered() +          validate() +          variable() +          version() +          when() +          where() +          window() +          xquery() +          zero-digit()          eq (109 * (109 + 1)) div 2
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function node() { fn:true() }; local:node()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function processing-instruction() { fn:true() }; local:processing-instruction()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function schema-attribute() { fn:true() }; local:schema-attribute()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function schema-element() { fn:true() }; local:schema-element()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function switch() { fn:true() }; local:switch()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function text() { fn:true() }; local:text()
declare default function namespace "http://www.w3.org/2005/xquery-local-functions"; declare function typeswitch() { fn:true() }; local:typeswitch()
declare function fn:count($var) { fn:count($var) };         1
declare function foo ($n as xs:integer) { $n };         foo(4)
declare function foo() { 1 }; foo()
declare function foo() external; 1
declare function local:_($arg as attribute()?) { 1 };         local:_(1)
declare function local:_($arg as node()) { $arg };         local:_(1)
declare function local:_() { 1 };         local:_()
declare function local:aaa() { 1 };         declare variable $x external := local:bbb() + local:aaa();         declare function local:bbb() { 2 };         $x
declare function local:add($arg1, $arg2, $arg3)         {            $arg1 + $arg2 + $arg3         }; fn:function-name( local:add#3 )
declare function local:addNamespace($argElement as element(), $argPrefix as xs:string, $namespaceURI as xs:string) as element() {              element { QName($namespaceURI, concat($argPrefix, ":x")) }{$argElement}/*          };          local:addNamespace(<a><b/></a>, "prefix", "http://example.com/")
declare function local:aFunction() { (1, 2, 3, (4, <e/>/(<e/>, 2))) }; 1, local:aFunction()
declare function local:aFunction() { <e/>/(1, <e/>) }; 1, local:aFunction()
declare function local:aFunction() { (<e/>/(., 4, 5, <e/>/((<e/>, 2)))) }; 1, local:aFunction()
declare function local:aFunction() { <e/>/(<e/>, 2) }; 1, local:aFunction()
declare function local:aFunction() { (<e/>/., <e/>/((<e/>, 2), 1, 2)) }; 1, local:aFunction()
declare function local:apply($fns as (function(xs:string) as xs:string)*, $s as xs:string) as xs:string*          { for $f in $fns return $f($s) };          let $ops := (upper-case#1, lower-case#1, function($x as xs:double){string($x)})          return string-join(local:apply($ops, 'Michael Kay'), '~')
declare function local:apply($fns as (function(xs:string) as xs:string)*, $s as xs:string) as xs:string*          { for $f in $fns return $f($s) };          let $ops := (upper-case#1, lower-case#1, function($x){translate($x, 'e', 'i')},              string-length#1)          return string-join(local:apply($ops, 'Michael Kay'), '~')
declare function local:apply($fns as (function(xs:string) as xs:string)*, $s as xs:string) as xs:string* { for $f in $fns return $f($s) };        let $ops := (upper-case#1, lower-case#1, function($x){translate($x, 'e', 'i')}, substring-before(?, ' '))        return string-join(local:apply($ops, 'Michael Kay'), '~')
declare function local:bar($c, $d, $e, $f, $g, $h, $i, $j, $a, $b) { 1 };          declare function local:moo($k) { $k };          local:moo(1)
declare function local:base64Binary-value($arg as xs:boolean) as xs:base64Binary {         if ($arg) then xs:base64Binary('aGVsbG8=') else xs:base64Binary('Z29vZGJ5ZQ==')        };        local:base64Binary-value(true()) eq local:base64Binary-value(false())
declare function local:base64Binary-value($arg as xs:boolean) as xs:base64Binary {         if ($arg) then xs:base64Binary('aGVsbG8=') else xs:base64Binary('Z29vZGJ5ZQ==')         };         not(local:base64Binary-value(true()) eq local:base64Binary-value(false()))
declare function local:base64Binary-value($arg as xs:boolean) as xs:base64Binary {         if ($arg) then xs:base64Binary('aGVsbG8=') else xs:base64Binary('Z29vZGJ5ZQ==')         };         not(local:base64Binary-value(true()) ne local:base64Binary-value(false()))
declare function local:case($x as function(*), $y as xs:string) as xs:string { $x($y) };        local:case(upper-case#1, "Mike"), local:case(lower-case#1, "Mike")
declare function local:case($x as function(xs:string?) as xs:string, $y as xs:string) as xs:string { $x($y) };        local:case(upper-case#1, "Mike"), local:case(lower-case#1, "Mike")
declare function local:case($x as xs:boolean) as function(*)         { if ($x) then fn:upper-case#1 else fn:lower-case#1 };        local:case(true())("Mike"), local:case(false())("Mike")
declare function local:case($x as xs:boolean) as function(xs:string?) as xs:string         { if ($x) then fn:upper-case#1 else fn:lower-case#1 };        local:case(true())("Mike"), local:case(false())("Mike")
declare function local:children($n as node()) as node()*                  { $n/child::node() };              declare function local:attributes($e as node()) as node()*                  { $e/attribute::node() };              declare function local:self($e as node()) as node()                  { $e };              declare function local:union(                         $f as function(node()) as node()*,                          $g as function(node()) as node()*) as function(node()) as node()* {                  function($a) {$f($a) | $g($a)} };             let $data := (/a),                  $f := local:union(local:children#1, local:union(local:attributes#1, local:self#1))              return for-each($data/*, $f)[not(. instance of attribute())]
declare function local:clarkname($q as xs:QName) as xs:string {        concat('{', namespace-uri-from-QName($q), '}', local-name-from-QName($q))        };        local:clarkname(xs:QName("xs:integer"))
declare function local:compare($arg1 as xs:string, $arg2 as xs:string) {              let $cps1 := string-to-codepoints($arg1),              $cps2 := string-to-codepoints($arg2)              return abs(count($cps1) - count($cps2)) + sum(for $x in 1 to min((count($cps1), count($cps2)))                                                            return if ($cps1[$x] ne $cps2[$x]) then 1 else ()) };          local:compare("", ""),          local:compare("a", ""),          local:compare("", "a"),          local:compare("a", "a"),          local:compare("", "aa"),          local:compare("aa", "ab"),          local:compare("ba", "ba"),          local:compare("bab", "bbb"),          local:compare("aba", "bab")
declare function local:computeSum() { $myVariable };         declare variable $myVariable := 1;         1
declare function local:computeSum() { $prefix:myVariable };         declare namespaces prefix = "example.com/Anamespace";         1
declare function local:count($x) { count($x) }; local:count((1 to 100000, 1 to 100000))
declare function local:curry($f as function(item()*, item()*) as item()*) as function(item()*) as function(item()*) as item()*          {            function($a) { $f($a, ?) }          };                    local:curry(substring-after#2)("foobar")("foo")
declare function local:date($date as xs:date, $null as xs:boolean) { if ($null) then () else $date }; exists(local:date(xs:date("1972-12-15"), fn:true()) eq xs:date("1972-12-15"))
declare function local:date($date as xs:date, $null as xs:boolean) { if ($null) then () else $date };         exists(local:date(xs:date("1972-12-15"), fn:true()) ge xs:date("1972-12-15"))
declare function local:date($date as xs:date, $null as xs:boolean) { if ($null) then () else $date };         exists(local:date(xs:date("1972-12-15"), fn:true()) gt xs:date("1972-12-15"))
declare function local:date($date as xs:date, $null as xs:boolean) { if ($null) then () else $date };         exists(local:date(xs:date("1972-12-15"), fn:true()) le xs:date("1972-12-15"))
declare function local:date($date as xs:date, $null as xs:boolean) { if ($null) then () else $date };         exists(local:date(xs:date("1972-12-15"), fn:true()) lt xs:date("1972-12-15"))
declare function local:date($date as xs:date, $null as xs:boolean) { if ($null) then () else $date }; exists(local:date(xs:date("1972-12-15"), fn:true()) ne xs:date("1972-12-15"))
declare function local:date($date as xs:date, $null as xs:boolean) { if ($null) then () else $date }; local:date(xs:date("1972-12-15"), fn:false()) eq xs:date("1972-12-15")
declare function local:date($date as xs:date, $null as xs:boolean) { if ($null) then () else $date };         local:date(xs:date("1972-12-15"), fn:false()) ge xs:date("1972-12-15")
declare function local:date($date as xs:date, $null as xs:boolean) { if ($null) then () else $date };         local:date(xs:date("1972-12-15"), fn:false()) gt xs:date("1972-12-15")
declare function local:date($date as xs:date, $null as xs:boolean) { if ($null) then () else $date };         local:date(xs:date("1972-12-15"), fn:false()) le xs:date("1972-12-15")
declare function local:date($date as xs:date, $null as xs:boolean) { if ($null) then () else $date };         local:date(xs:date("1972-12-15"), fn:false()) lt xs:date("1972-12-15")
declare function local:date($date as xs:date, $null as xs:boolean) { if ($null) then () else $date }; local:date(xs:date("1972-12-15"), fn:false()) ne xs:date("1972-12-15")
declare function local:dateTime($dateTime as xs:dateTime, $null as xs:boolean) { if ($null) then () else $dateTime }; exists(local:dateTime(xs:dateTime("1972-12-15T12:00:00"), fn:true()) eq xs:dateTime("1972-12-15T12:00:00"))
declare function local:dateTime($dateTime as xs:dateTime, $null as xs:boolean) { if ($null) then () else $dateTime }; exists(local:dateTime(xs:dateTime("1972-12-15T12:00:00"), fn:true()) ge xs:dateTime("1972-12-15T12:00:00"))
declare function local:dateTime($dateTime as xs:dateTime, $null as xs:boolean) { if ($null) then () else $dateTime }; exists(local:dateTime(xs:dateTime("1972-12-15T12:00:00"), fn:true()) gt xs:dateTime("1972-12-15T12:00:00"))
declare function local:dateTime($dateTime as xs:dateTime, $null as xs:boolean) { if ($null) then () else $dateTime }; exists(local:dateTime(xs:dateTime("1972-12-15T12:00:00"), fn:true()) le xs:dateTime("1972-12-15T12:00:00"))
declare function local:dateTime($dateTime as xs:dateTime, $null as xs:boolean) { if ($null) then () else $dateTime }; exists(local:dateTime(xs:dateTime("1972-12-15T12:00:00"), fn:true()) lt xs:dateTime("1972-12-15T12:00:00"))
declare function local:dateTime($dateTime as xs:dateTime, $null as xs:boolean) { if ($null) then () else $dateTime }; exists(local:dateTime(xs:dateTime("1972-12-15T12:00:00"), fn:true()) ne xs:dateTime("1972-12-15T12:00:00"))
declare function local:dateTime($dateTime as xs:dateTime, $null as xs:boolean) { if ($null) then () else $dateTime }; local:dateTime(xs:dateTime("1972-12-15T12:00:00"), fn:false()) eq xs:dateTime("1972-12-15T12:00:00")
declare function local:dateTime($dateTime as xs:dateTime, $null as xs:boolean) { if ($null) then () else $dateTime }; local:dateTime(xs:dateTime("1972-12-15T12:00:00"), fn:false()) ge xs:dateTime("1972-12-15T12:00:00")
declare function local:dateTime($dateTime as xs:dateTime, $null as xs:boolean) { if ($null) then () else $dateTime }; local:dateTime(xs:dateTime("1972-12-15T12:00:00"), fn:false()) gt xs:dateTime("1972-12-15T12:00:00")
declare function local:dateTime($dateTime as xs:dateTime, $null as xs:boolean) { if ($null) then () else $dateTime }; local:dateTime(xs:dateTime("1972-12-15T12:00:00"), fn:false()) le xs:dateTime("1972-12-15T12:00:00")
declare function local:dateTime($dateTime as xs:dateTime, $null as xs:boolean) { if ($null) then () else $dateTime }; local:dateTime(xs:dateTime("1972-12-15T12:00:00"), fn:false()) lt xs:dateTime("1972-12-15T12:00:00")
declare function local:dateTime($dateTime as xs:dateTime, $null as xs:boolean) { if ($null) then () else $dateTime }; local:dateTime(xs:dateTime("1972-12-15T12:00:00"), fn:false()) ne xs:dateTime("1972-12-15T12:00:00")
declare function local:dayTimeDuration($days as xs:integer, $hours as xs:integer ) { xs:dayTimeDuration(concat('P', $days, 'DT', $hours, 'H')) }; local:dayTimeDuration(1, 1) + local:dayTimeDuration(1, 1)
declare function local:dayTimeDuration($days as xs:integer, $hours as xs:integer ) { xs:dayTimeDuration(concat('P', $days, 'DT', $hours, 'H')) }; local:dayTimeDuration(1, 1) - local:dayTimeDuration(1, 1)
declare function local:dayTimeDuration($days as xs:integer, $hours as xs:integer ) { xs:dayTimeDuration(concat('P', $days, 'DT', $hours, 'H')) }; local:dayTimeDuration(1, 1) + xs:dayTimeDuration("P0D")
declare function local:dayTimeDuration($days as xs:integer, $hours as xs:integer ) { xs:dayTimeDuration(concat('P', $days, 'DT', $hours, 'H')) }; local:dayTimeDuration(1, 1) - xs:dayTimeDuration("P0D")
declare function local:dayTimeDuration($days as xs:integer, $hours as xs:integer ) { xs:dayTimeDuration(concat('P', $days, 'DT', $hours, 'H')) }; not(local:dayTimeDuration(1, 1) eq xs:dayTimeDuration("P0D"))
declare function local:dayTimeDuration($days as xs:integer, $hours as xs:integer ) { xs:dayTimeDuration(concat('P', $days, 'DT', $hours, 'H')) };           not(local:dayTimeDuration(1, 1) ge xs:dayTimeDuration("P0D"))
declare function local:dayTimeDuration($days as xs:integer, $hours as xs:integer ) { xs:dayTimeDuration(concat('P', $days, 'DT', $hours, 'H')) };           not(local:dayTimeDuration(1, 1) gt xs:dayTimeDuration("P0D"))
declare function local:dayTimeDuration($days as xs:integer, $hours as xs:integer ) { xs:dayTimeDuration(concat('P', $days, 'DT', $hours, 'H')) }; not(local:dayTimeDuration(1, 1) le xs:dayTimeDuration("P0D"))
declare function local:dayTimeDuration($days as xs:integer, $hours as xs:integer ) { xs:dayTimeDuration(concat('P', $days, 'DT', $hours, 'H')) }; not(local:dayTimeDuration(1, 1) lt xs:dayTimeDuration("P0D"))
declare function local:dayTimeDuration($days as xs:integer, $hours as xs:integer ) { xs:dayTimeDuration(concat('P', $days, 'DT', $hours, 'H')) }; not(local:dayTimeDuration(1, 1) ne xs:dayTimeDuration("P0D"))
declare function local:dayTimeDuration($days as xs:integer, $hours as xs:integer ) { xs:dayTimeDuration(concat('P', $days, 'DT', $hours, 'H')) }; xs:dayTimeDuration("P0D") + local:dayTimeDuration(1, 1)
declare function local:dayTimeDuration($days as xs:integer, $hours as xs:integer ) { xs:dayTimeDuration(concat('P', $days, 'DT', $hours, 'H')) }; xs:dayTimeDuration("-P5000000000000000000D") - local:dayTimeDuration(5000000000000000000, 1)
declare function local:dayTimeDuration($days as xs:integer) as xs:dayTimeDuration { xs:dayTimeDuration(concat("P", $days, "D")) }; 0 * local:dayTimeDuration(2)
declare function local:dayTimeDuration($days as xs:integer) as xs:dayTimeDuration { xs:dayTimeDuration(concat("P", $days, "D")) }; 1 * local:dayTimeDuration(2)
declare function local:dayTimeDuration($days as xs:integer) as xs:dayTimeDuration { xs:dayTimeDuration(concat("P", $days, "D")) }; local:dayTimeDuration(2) * 0
declare function local:dayTimeDuration($days as xs:integer) as xs:dayTimeDuration { xs:dayTimeDuration(concat("P", $days, "D")) }; local:dayTimeDuration(2) * 1
declare function local:dayTimeDuration($days as xs:integer) as xs:dayTimeDuration { xs:dayTimeDuration(concat("P", $days, "D")) }; local:dayTimeDuration(2) div 0
declare function local:dayTimeDuration($days as xs:integer) as xs:dayTimeDuration { xs:dayTimeDuration(concat("P", $days, "D")) }; local:dayTimeDuration(2) div 1
declare function local:dayTimeDuration($days as xs:integer) as xs:dayTimeDuration { xs:dayTimeDuration(concat("P", $days, "D")) }; local:dayTimeDuration(2) * xs:double("NaN")
declare function local:dayTimeDuration($days as xs:integer) as xs:dayTimeDuration { xs:dayTimeDuration(concat("P", $days, "D")) }; xs:double("NaN") * local:dayTimeDuration(2)
declare function local:dayTimeDuration($dayTimeDuration as xs:dayTimeDuration, $null as xs:boolean) { if ($null) then () else $dayTimeDuration }; exists(local:dayTimeDuration(xs:dayTimeDuration("P0D"), fn:true()) eq xs:dayTimeDuration("P0D"))
declare function local:dayTimeDuration($dayTimeDuration as xs:dayTimeDuration, $null as xs:boolean) { if ($null) then () else $dayTimeDuration };           exists(local:dayTimeDuration(xs:dayTimeDuration("P0D"), fn:true()) gt xs:dayTimeDuration("P0D"))
declare function local:dayTimeDuration($dayTimeDuration as xs:dayTimeDuration, $null as xs:boolean) { if ($null) then () else $dayTimeDuration };           exists(local:dayTimeDuration(xs:dayTimeDuration("P0D"), fn:true()) le xs:dayTimeDuration("P0D"))
declare function local:dayTimeDuration($dayTimeDuration as xs:dayTimeDuration, $null as xs:boolean) { if ($null) then () else $dayTimeDuration }; exists(local:dayTimeDuration(xs:dayTimeDuration("P0D"), fn:true()) le xs:dayTimeDuration("P0D"))
declare function local:dayTimeDuration($dayTimeDuration as xs:dayTimeDuration, $null as xs:boolean) { if ($null) then () else $dayTimeDuration }; exists(local:dayTimeDuration(xs:dayTimeDuration("P0D"), fn:true()) lt xs:dayTimeDuration("P0D"))
declare function local:dayTimeDuration($dayTimeDuration as xs:dayTimeDuration, $null as xs:boolean) { if ($null) then () else $dayTimeDuration }; exists(local:dayTimeDuration(xs:dayTimeDuration("P0D"), fn:true()) ne xs:dayTimeDuration("P0D"))
declare function local:dayTimeDuration($dayTimeDuration as xs:dayTimeDuration, $null as xs:boolean) { if ($null) then () else $dayTimeDuration }; local:dayTimeDuration(xs:dayTimeDuration("P0D"), fn:false()) eq xs:dayTimeDuration("P0D")
declare function local:dayTimeDuration($dayTimeDuration as xs:dayTimeDuration, $null as xs:boolean) { if ($null) then () else $dayTimeDuration };           local:dayTimeDuration(xs:dayTimeDuration("P0D"), fn:false()) gt xs:dayTimeDuration("P0D")
declare function local:dayTimeDuration($dayTimeDuration as xs:dayTimeDuration, $null as xs:boolean) { if ($null) then () else $dayTimeDuration };           local:dayTimeDuration(xs:dayTimeDuration("P0D"), fn:false()) le xs:dayTimeDuration("P0D")
declare function local:dayTimeDuration($dayTimeDuration as xs:dayTimeDuration, $null as xs:boolean) { if ($null) then () else $dayTimeDuration }; local:dayTimeDuration(xs:dayTimeDuration("P0D"), fn:false()) le xs:dayTimeDuration("P0D")
declare function local:dayTimeDuration($dayTimeDuration as xs:dayTimeDuration, $null as xs:boolean) { if ($null) then () else $dayTimeDuration }; local:dayTimeDuration(xs:dayTimeDuration("P0D"), fn:false()) lt xs:dayTimeDuration("P0D")
declare function local:dayTimeDuration($dayTimeDuration as xs:dayTimeDuration, $null as xs:boolean) { if ($null) then () else $dayTimeDuration }; local:dayTimeDuration(xs:dayTimeDuration("P0D"), fn:false()) ne xs:dayTimeDuration("P0D")
declare function local:distinct-nodes-stable ($arg as node()*) as xs:boolean* { for $a in $arg return $a };         local:distinct-nodes-stable((<element1/>,<element2/>))
declare function local:distinct-nodes-stable($seq as node()*) {                  fold-left( $seq, (), function($foundSoFar as node()*, $this as node()) as node()* {                 if ($foundSoFar intersect $this)                 then $foundSoFar                 else ($foundSoFar, $this) })             };              let $nodes := (<a/>, <b/>, <c/>, <d/>, <e/>, <f/>)              let $perm := ($nodes[1], $nodes[2], $nodes[4], $nodes[1], $nodes[2], $nodes[3], $nodes[2], $nodes[1])              return local:distinct-nodes-stable($perm)/local-name()
declare function local:do() as xs:integer { (local:f#1)(5) };          declare function local:f($x as xs:integer) as xs:integer { $x + 1 };          local:do()
declare function local:duration($days as xs:integer, $hours as xs:integer) { xs:duration(concat('P', $days, 'DT', $hours, 'H')) }; not(local:duration(1, 1) eq xs:dayTimeDuration("P0D"))
declare function local:duration($days as xs:integer, $hours as xs:integer) { xs:duration(concat('P', $days, 'DT', $hours, 'H')) }; not(local:duration(1, 1) ne xs:dayTimeDuration("P0D"))
declare function local:duration($duration as xs:duration, $null as xs:boolean) { if ($null) then () else $duration }; exists(local:duration(xs:duration("P1DT1H"), fn:true()) eq xs:duration("P1DT1H"))
declare function local:duration($duration as xs:duration, $null as xs:boolean) { if ($null) then () else $duration }; exists(local:duration(xs:duration("P1DT1H"), fn:true()) ne xs:duration("P1DT1H"))
declare function local:duration($duration as xs:duration, $null as xs:boolean) { if ($null) then () else $duration }; local:duration(xs:duration("P1DT1H"), fn:false()) eq xs:duration("P1DT1H")
declare function local:duration($duration as xs:duration, $null as xs:boolean) { if ($null) then () else $duration }; local:duration(xs:duration("P1DT1H"), fn:false()) ne xs:duration("P1DT1H")
declare function local:durationOrFloat($i as xs:integer) { (xs:float(123), xs:float(234), xs:duration("P1D"))[$i] }; for $x in (xs:untypedAtomic("123"), xs:untypedAtomic("234")) for $y in (for $z in (1,2) return local:durationOrFloat($z)) where $x = $y return $x
declare function local:error() as none() { 1 };         local:error()
declare function local:error() as xs:error             {       1             };        local:error()
declare function local:even-range($arg as xs:integer) as xs:integer* { (1 to $arg)[. mod 2 = 9] };         <element> { attribute { 'attr' } { local:even-range(0) } } </element>
declare function local:exponent-separator () {126};          local:exponent-separator()          eq 126
declare function local:f($arg as xs:anyAtomicType?) { $arg };         local:f(index-of((1,2,3,2),2))
declare function local:f($in as xs:boolean) as xs:boolean { $in };          local:f(<a>0</a>)
declare function local:f($v as xs:double*) as xs:double+ { if (empty($v)) then 0 else $v };         declare function local:g($v as xs:double*) as xs:double+ { local:f($v) };         local:g((1,2,3))
declare function local:f($x, $y) {           let $a := $x           where empty($y)   (every $i in $x satisfies $i = $y)           return $a         };         local:f("x", ())
declare function local:f($x, $y) {             let $a := $x             where (every $i in $x satisfies $i = $y) or empty($y)             return $a         };         local:f("x", ())
declare function local:f($x, $y) {             let $a := $x             where (every $i in $x satisfies $i = $y) or empty($y)             return true()         };         local:f((current-date(), current-date(), current-date()), (current-date()))
declare function local:f($x as xs:integer, $y as xs:long) as xs:integer { $x + $y };        let $f as function(xs:integer, xs:long) as xs:integer := local:f#2        return $f(2, xs:long(5))
declare function local:f($x as xs:integer) as xs:integer { $x + 1 };         exists(data(local:f#1))
declare function local:f($x as xs:integer) as xs:integer { $x + 1 };        let $f as function(*) := local:f#1 return $f(2)
declare function local:f($x as xs:integer) as xs:integer {             $x + 1         };         let $f as function(xs:integer) := local:f#1         return $f(3)
declare function local:f($x as xs:integer) as xs:integer { $x + 1 };         let $f := concat#1 return $f('2008-03-01')
declare function local:f($x as xs:integer) as xs:integer { $x + 1 };          let $f := local:f#1 return $f(2)
declare function local:f($x as xs:integer) as xs:integer { $x + 1 };         let $f := local:f#3 return $f(2)
declare function local:f($x as xs:integer) as xs:integer { $x + 1 };         let $f := local:g#1 return $f(2)
declare function local:f($x as xs:integer) as xs:integer { $x + 1 };         let $f := xs:date#2 return $f('2008-03-01')
declare function local:f($x as xs:integer) as xs:integer { $x + 1 };         local:f#1 eq 3
declare function local:f($x as xs:integer) as xs:integer { $x + 1 };         number(local:f#1)
declare function local:f($x as xs:integer) as xs:integer { $x + 1 };         string(local:f#1)
declare function local:f($x as xs:integer) as xs:integer { $x + 3 };        declare function local:g($x as xs:integer) as xs:integer { $x + 4 };        declare function local:h($x as xs:integer) as xs:integer { $x + 5 };        let $f as (function(xs:integer) as xs:integer)* := (local:f#1, local:g#1, local:h#1) return $f[3](2)[1]
declare function local:f($x as xs:integer) as xs:integer { $x + 3 };        let $f as function(xs:integer) as xs:integer := local:f#1        return $f(2)
declare function local:f($x as xs:integer) as xs:integer { $x };         max(local:f(4) to local:f(10))
declare function local:f($x as xs:integer) as xs:integer { $x };         min(local:f(4) to local:f(10))
declare function local:f($x as xs:integer) as xs:integer { $x };         not(not(local:f(1)))
declare function local:f($x as xs:integer) as xs:integer* { 1 to $x }; deep-equal((local:f(3), 2), (local:f(3), 2, local:f(1)))
declare function local:f($x as xs:integer) as xs:integer* { 1 to $x };         not(exists(local:f(0)))
declare function local:f($x as xs:integer) { if ($x = 0) then false() else true() };         min(for $x in (1,2,3) return local:f($x))
declare function local:f($x as xs:integer) {         if ($x = 0) then true() else false()         };         max(for $x in (1,2,3) return local:f($x))
declare function local:f($x as xs:integer) { if ($x = 2) then false() else true() };         min(for $x in (1,2,3) return local:f($x))
declare function local:f($x as xs:integer) {         if ($x = 2) then true() else false()         };         max(for $x in (1,2,3) return local:f($x))
declare function local:f($x as xs:integer) { if ($x = 2) then xs:dateTime("1996-12-01T12:00:00") else current-dateTime() };         min(for $x in (1,2,3) return local:f($x))
declare function local:f($x as xs:integer) {         if ($x = 2) then xs:dateTime("3000-12-01T12:00:00") else current-dateTime()         };         max(for $x in (1,2,3) return local:f($x))
declare function local:f($x as xs:integer) {         if ($x = 2) then xs:time("12:00:00-01:00") else xs:time("12:00:00+01:00")         };         max(for $x in (1,2,3) return local:f($x))
declare function local:f($x as xs:integer) { if ($x = 2) then xs:time("12:00:00-01:00") else xs:time("12:00:00+01:00") };         min(for $x in (1,2,3) return local:f($x))
declare function local:f($x as xs:integer) { if ($x = 2) then xs:yearMonthDuration("P11M") else xs:yearMonthDuration("P1Y") };         min(for $x in (1,2,3) return local:f($x))
declare function local:f($x as xs:integer) {         if ($x = 2) then xs:yearMonthDuration("P13M") else xs:yearMonthDuration("P1Y")         };        max(for $x in (1,2,3) return local:f($x))
declare function local:f($x as xs:integer) {         if ($x = 3) then $x else false()         };         max(for $x in (1,2,3) return local:f($x))
declare function local:f($x as xs:integer) { if ($x = 3) then $x else false() };         min(for $x in (1,2,3) return local:f($x))
declare function local:f($x as xs:integer) {         if ($x < 3) then current-date() else current-time()         };         max(for $x in (1,2,3) return local:f($x))
declare function local:f($x as xs:integer) { if ($x < 3) then current-date() else current-time() };         min(for $x in (1,2,3) return local:f($x))
declare function local:f($x as xs:integer) {         if ($x < 3) then current-dateTime() else xs:dayTimeDuration("PT3S")         };         max(for $x in (1,2,3) return local:f($x))
declare function local:f($x as xs:integer) { if ($x < 3) then current-dateTime() else xs:dayTimeDuration("PT3S") };         min(for $x in (1,2,3) return local:f($x))
declare function local:f($x as xs:integer) {         if ($x < 3) then current-time() else xs:dayTimeDuration("PT3S")         };         max(for $x in (1,2,3) return local:f($x))
declare function local:f($x as xs:integer) { if ($x < 3) then current-time() else xs:dayTimeDuration("PT3S") };         min(for $x in (1,2,3) return local:f($x))
declare function local:f($x as xs:integer) {         (xs:decimal(1.1), xs:float(1.2), xs:double(0.4), xs:integer("-3"))[$x]         };         max(for $x in (4,2,1,3) return local:f($x)) instance of xs:double
declare function local:f($x as xs:integer) { (xs:decimal(1.1), xs:float(1.2), xs:double(0.4), xs:integer("-3"))[$x] };         min(for $x in (4,2,1,3) return local:f($x)) instance of xs:double
declare function local:f($x as xs:integer) {         (xs:decimal(1.1), xs:float(1.2), xs:double(0.4), xs:string("2"))[$x]         };         max(for $x in (1,4,2,3) return local:f($x))
declare function local:f($x as xs:integer) { (xs:decimal(1.1), xs:float(1.2), xs:double(0.4), xs:string("2"))[$x] };         min(for $x in (1,4,2,3) return local:f($x))
declare function local:f($x as xs:integer) {         (xs:decimal(1.1), xs:float(2.2), xs:double(1.4), xs:integer(2))[$x]         };         max(for $x in (1,2,3) return local:f($x)) instance of xs:double
declare function local:f($x as xs:integer) { (xs:decimal(1.1), xs:float(2.2), xs:double(1.4), xs:integer(2))[$x] };         min(for $x in (1,2,3) return local:f($x)) instance of xs:double
declare function local:f($x as xs:integer) {         (xs:decimal(1.3), xs:float(1.2), xs:double(1.4), xs:integer(2))[$x]         };         max(for $x in (1,2,3) return local:f($x)) instance of xs:double
declare function local:f($x as xs:integer) { (xs:decimal(1.3), xs:float(1.2), xs:double(1.4), xs:integer(2))[$x] };         min(for $x in (1,2,3) return local:f($x)) instance of xs:double
declare function local:f($x) { if ($x mod 2 = 1) then <a/> else "a" };         let $y := for $x in (1 to 10) return <e>{$x}</e> return $y/local:f(.)/a
declare function local:f($x) { if ($x) then true() else () }; declare function local:g($x) { if ($x) then "true" else "false" }; let $x := local:g(true()) for $y in local:f($x) return ($y, $x)
declare function local:f($x) { if ($x) then true() else () }; empty(for $x in local:f(false()), $y in 1 to 10 return ($x, $y))
declare function local:f($x) { if ($x) then true() else () }; for $x in local:f(true()), $y in 1 to 10 return ($x, $y)
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") };         declare function local:g($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(false()) + local:g(false())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") }; declare function local:g($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") }; local:f(false()) - local:g(false())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") };         declare function local:g($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(true()) + local:g(true())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") }; declare function local:g($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") }; local:f(true()) - local:g(true())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") }; local:f(false()) div 2
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") }; local:f(false()) div xs:dayTimeDuration("PT1H")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") };         local:f(false()) + local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") }; local:f(false()) - local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") }; local:f(false()) - xs:date("1997-01-01")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") }; local:f(false()) - xs:dateTime("1997-01-01T12:00:00")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") };         local:f(false()) + xs:dayTimeDuration("PT1H")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") }; local:f(false()) - xs:dayTimeDuration("PT1H")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") }; local:f(true()) div xs:dayTimeDuration("PT1H")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") };         local:f(true()) + local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") }; local:f(true()) - local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") };         local:f(true()) + xs:date("1997-01-01")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") }; local:f(true()) - xs:date("1997-01-01")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") };         local:f(true()) + xs:dateTime("1997-01-01T12:00:00")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") }; local:f(true()) - xs:dateTime("1997-01-01T12:00:00")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") };         local:f(true()) + xs:dayTimeDuration("PT1H")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") }; local:f(true()) - xs:dayTimeDuration("PT1H")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") };         xs:date("1997-01-01") + local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") }; xs:date("1997-01-01") - local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") };         xs:dateTime("1997-01-01T12:00:00") + local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") }; xs:dateTime("1997-01-01T12:00:00") - local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") };         xs:dayTimeDuration("PT1H") + local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") }; xs:dayTimeDuration("PT1H") - local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") };         xs:dayTimeDuration("PT1H") + local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1D") }; xs:dayTimeDuration("PT1H") - local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1H") }; local:f(true()) - xs:time("12:00:00")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1H") };         xs:time("12:00:00") + local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("P1H") }; xs:time("12:00:00") - local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("PT1H") }; local:f(false()) - xs:time("12:00:00")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:dayTimeDuration("PT1H") };         local:f(true()) + xs:time("12:00:00")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:yearMonthDuration("P1M") }; local:f(false()) - xs:date("1997-01-01")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:yearMonthDuration("P1M") }; local:f(false()) - xs:dateTime("1997-01-01T12:00:00")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:yearMonthDuration("P1M") };         local:f(true()) + xs:date("1997-01-01")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:yearMonthDuration("P1M") }; local:f(true()) - xs:date("1997-01-01")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:yearMonthDuration("P1M") };         local:f(true()) + xs:dateTime("1997-01-01T12:00:00")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:yearMonthDuration("P1M") }; local:f(true()) - xs:dateTime("1997-01-01T12:00:00")
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:yearMonthDuration("P1M") };         xs:date("1997-01-01") + local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:yearMonthDuration("P1M") }; xs:date("1997-01-01") - local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:yearMonthDuration("P1M") };         xs:dateTime("1997-01-01T12:00:00") + local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1D") else xs:yearMonthDuration("P1M") }; xs:dateTime("1997-01-01T12:00:00") - local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("P1D") };         2 * local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("P1D") };         2 * local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("P1D") };         local:f(false()) * 2
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("P1D") };         local:f(true()) * 2
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("P1D") }; local:f(true()) div 2
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") }; local:f(false()) div local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") }; local:f(false()) div local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") };         local:f(false()) ge local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") };         local:f(false()) ge local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") };         local:f(false()) ge xs:dayTimeDuration("P1D")
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") };         local:f(false()) gt local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") };         local:f(false()) gt local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") };         local:f(false()) gt xs:dayTimeDuration("P1D")
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") };         local:f(false()) le local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") };         local:f(false()) le local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") };         local:f(false()) le xs:dayTimeDuration("P1D")
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") };         local:f(true()) ge xs:dayTimeDuration("P1D")
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") };         local:f(true()) gt xs:dayTimeDuration("P1D")
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") };         local:f(true()) le xs:dayTimeDuration("P1D")
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") }; xs:dayTimeDuration("P1D") div local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") }; xs:dayTimeDuration("P1D") div local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") };         xs:dayTimeDuration("P1D") ge local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") };         xs:dayTimeDuration("P1D") ge local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") };         xs:dayTimeDuration("P1D") gt local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") };         xs:dayTimeDuration("P1D") gt local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") };         xs:dayTimeDuration("P1D") le local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:dayTimeDuration("PT1H") };         xs:dayTimeDuration("P1D") le local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         2 * local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         2 * local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(false()) * 2
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") }; local:f(false()) div local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(false()) ge local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(false()) ge xs:yearMonthDuration("P1Y")
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(false()) gt local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(false()) gt xs:yearMonthDuration("P1Y")
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(false()) le local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(false()) le xs:yearMonthDuration("P1Y")
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(false()) + local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") }; local:f(false()) - local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(false()) + xs:yearMonthDuration("P1Y")
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") }; local:f(false()) - xs:yearMonthDuration("P1Y")
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(true()) * 2
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") }; local:f(true()) div local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(true()) ge local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(true()) ge xs:yearMonthDuration("P1Y")
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(true()) gt local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(true()) gt xs:yearMonthDuration("P1Y")
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(true()) le local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(true()) le xs:yearMonthDuration("P1Y")
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(true()) + local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") }; local:f(true()) - local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         local:f(true()) + xs:yearMonthDuration("P1Y")
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") }; local:f(true()) - xs:yearMonthDuration("P1Y")
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") }; xs:yearMonthDuration("P1Y") div local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") }; xs:yearMonthDuration("P1Y") div local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         xs:yearMonthDuration("P1Y") ge local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         xs:yearMonthDuration("P1Y") ge local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         xs:yearMonthDuration("P1Y") gt local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         xs:yearMonthDuration("P1Y") gt local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         xs:yearMonthDuration("P1Y") le local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         xs:yearMonthDuration("P1Y") le local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         xs:yearMonthDuration("P1Y") + local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") }; xs:yearMonthDuration("P1Y") - local:f(false())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") };         xs:yearMonthDuration("P1Y") + local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1M") else xs:yearMonthDuration("P1M") }; xs:yearMonthDuration("P1Y") - local:f(true())
declare function local:f($x) { if ($x) then xs:duration("P1Y") else xs:yearMonthDuration("P1Y") }; local:f(false()) div xs:yearMonthDuration("P1M")
declare function local:f($x) { if ($x) then xs:duration("P1Y") else xs:yearMonthDuration("P1Y") }; local:f(true()) div xs:yearMonthDuration("P1M")
declare function local:f($x) { if ($x) then xs:duration("P2M") else xs:yearMonthDuration("P2M") }; local:f(false()) div 2
declare function local:f($x) { if ($x) then xs:duration("P2M") else xs:yearMonthDuration("P2M") }; local:f(true()) div 2
declare function local:f1() {$a};         declare function local:f2() {$a};         declare variable $a := 19;               local:f1() + local:f2()
declare function local:f() { (<a/>, "a") }; boolean(local:f())
declare function local:fact($n as xs:integer) as xs:integer { if ($n < 2) then 1 else $n * local:fact(($n)-1) };         <table> { for $i in 1 to 10 return <tr> <td>{$i}! = {local:fact($i)}</td> </tr> } </table>
declare function local:factorial($arg as xs:integer) as xs:integer {         if ($arg le 1) then 1 else $arg * local:factorial($arg - 1)         };         <element> { attribute { fn:QName("http://www.example.com/", "sgml:foo") } { local:factorial(5) } } </element>
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return $x + 1 ge 121
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return $x - 1 ge 121
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return $x + 1 gt 121
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return $x - 1 gt 121
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return $x + 1 le 121
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return $x - 1 le 121
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return $x + 1 lt 121
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return $x - 1 lt 121
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return $x - 2 ge 12
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return $x + 2 ge 121
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return $x - 2 lt 12
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return $x + 2 lt 121
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 1 + $x gt 121
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 1 + $x le 121
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 ge $x + 1
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 ge $x + 2
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 ge 1 + $x
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 ge 2 + $x
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 gt $x + 1
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 gt $x - 1
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 gt 1 + $x
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 le $x + 1
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 le $x - 1
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 le 1 + $x
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 lt $x + 1
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 lt $x + 2
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 lt 1 + $x
declare function local:factorial($arg as xs:integer) as xs:integer { if ($arg lt 1) then 1 else $arg * local:factorial($arg - 1) }; let $x := local:factorial(5) return 121 lt 2 + $x
declare function local:factorial($n as xs:integer) as xs:integer { if ($n le 1) then 1 else $n * local:factorial($n - 1) }; declare function local:is-divisible($n as xs:integer, $d as xs:integer) { $n mod $d eq 0 }; not(local:is-divisible(local:factorial(5), 3)) and not(local:is-divisible(local:factorial(5), 2))
declare function local:factorial($n as xs:integer) as xs:integer { if ($n le 1) then 1 else $n * local:factorial($n - 1) }; declare function local:is-divisible($n as xs:integer, $d as xs:integer) { $n mod $d eq 0 }; not(local:is-divisible(local:factorial(5), 3)) or not(local:is-divisible(local:factorial(5), 2))
declare function local:factorial($n as xs:integer) as xs:integer? { if ($n lt 1) then () else if ($n eq 1) then 1 else $n * local:factorial($n - 1) }; (every $x in local:factorial(5) satisfies ($x mod 3 eq 0)) or (every $y in local:factorial(5) satisfies ($y mod 5 eq 0))
declare function local:f() as node() { <a/> };         local:f() is local:f()
declare function local:f() as xs:double* {            if (day-from-date(current-date()) < 32) then xs:integer(3) else -1         };         local:f() + 1
declare function local:f() as xs:integer { 42 };         declare function local:f($x as xs:integer) as xs:integer { $x + 1 };         let $f := local:f#0 return $f()
declare function local:fn1 ($n as xs:integer) as xs:integer { local:fn2($n) };         declare function local:fn2 ($n as xs:integer) as xs:integer { if ($n = 1) then 1 else $n + local:fn1($n - 1) };         local:fn1(4)
declare function local:fold-left(           $seq as item()*,           $zero as item()*,           $f as function(item()*, item()) as item()*)         as item()* {             if (fn:empty($seq))             then $zero             else fn:fold-left(fn:tail($seq), $f($zero, fn:head($seq)), $f)         };         local:fold-left(1 to 5, 0, function($a, $b) { $a + $b })
declare function local:fold-left(           $seq as item()*,           $zero as item()*,           $f as function(item()*, item()) as item()*)         as item()* {             if (fn:empty($seq))             then $zero             else fn:fold-left(fn:tail($seq), $f($zero, fn:head($seq)), $f)         };         local:fold-left((2,3,5,7), 1, function($a, $b) { $a * $b })
declare function local:fold-left(           $seq as item()*,           $zero as item()*,           $f as function(item()*, item()) as item()*)         as item()* {             if (fn:empty($seq))             then $zero             else fn:fold-left(fn:tail($seq), $f($zero, fn:head($seq)), $f)         };         local:fold-left((true(), false(), false()), false(), function($a, $b) { $a and $b })
declare function local:fold-left(           $seq as item()*,           $zero as item()*,           $f as function(item()*, item()) as item()*)         as item()* {             if (fn:empty($seq))             then $zero             else fn:fold-left(fn:tail($seq), $f($zero, fn:head($seq)), $f)         };         local:fold-left((true(), false(), false()), false(), function($a, $b) { $a or $b })
declare function local:fold-right(           $seq as item()*,            $zero as item()*,            $f as function(item(), item()*) as item()*)            as item()* {             if (fn:empty($seq))             then $zero             else $f(fn:head($seq), fn:fold-right(fn:tail($seq), $zero, $f))           };           local:fold-right(1 to 5, 0,function($a, $b) { $a + $b })
declare function local:fold-right(           $seq as item()*,            $zero as item()*,            $f as function(item(), item()*) as item()*)            as item()* {             if (fn:empty($seq))             then $zero             else $f(fn:head($seq), fn:fold-right(fn:tail($seq), $zero, $f))           };           local:fold-right((2,3,5,7), 1,function($a, $b) { $a * $b })
declare function local:fold-right(           $seq as item()*,            $zero as item()*,            $f as function(item(), item()*) as item()*)            as item()* {             if (fn:empty($seq))             then $zero             else $f(fn:head($seq), fn:fold-right(fn:tail($seq), $zero, $f))           };           local:fold-right((true(), false(), false()), false(),function($a, $b) { $a and $b })
declare function local:fold-right(           $seq as item()*,            $zero as item()*,            $f as function(item(), item()*) as item()*)            as item()* {             if (fn:empty($seq))             then $zero             else $f(fn:head($seq), fn:fold-right(fn:tail($seq), $zero, $f))           };           local:fold-right((true(), false(), false()), false(),function($a, $b) { $a or $b })
declare function local:foo($a as xs:integer) { if($a = 3) then $a else let $a := $a return local:foo($a + 1) }; local:foo(1)
declare function local:foo($arg as item()) { $arg[@arg] }; local:foo(<e arg="">result</e>)
declare function local:foo($arg as item()) { string($arg/@arg) }; local:foo(<e arg="result"/>)
declare function local:foo($arg ) as xs:boolean* { $arg };         local:foo(current-date())
declare function local:foo($arg) as xs:boolean { $arg };         local:foo(<e/>)
declare function local:foo($arg ) as xs:boolean* { $arg };         local:foo((<e>true</e>, true(), xs:untypedAtomic("false"), false(), <e> true </e>))
declare function local:foo($arg) as xs:boolean* { $arg };         local:foo((<e>true</e>, true(), xs:untypedAtomic("false"), false(), <e> true </e>))
declare function local:foo($arg) as xs:boolean* { $arg };         local:foo((true(), xs:untypedAtomic("false"))), local:foo((false(), xs:untypedAtomic("false")))
declare function local:foo($arg) as xs:boolean { $arg };         local:foo(xs:untypedAtomic("false"))
declare function local:foo($arg) as xs:boolean* { $arg };         local:foo(xs:untypedAtomic("false"))
declare function local:foo($arg) { local:foo(local:foo(1)) }; 1
declare function local:foo ($n as xs:integer) as xs:string { $n };         local:foo(4)
declare function local:foo($n as xs:integer) { <tr> {$n} </tr> };         local:foo(4)
declare function local:foo() {           $x         };         declare variable $x external := 5;         local:foo()
declare function local:foo2($i as xs:string) as xs:string {local:foo($i)};         declare function local:foo($i as xs:string) as xs:string {$i};         local:foo2("abc")
declare function local:foo() as xs:boolean { text {local:doesNotExist()} };         1
declare function local:foo() external;
declare function local:fun() {1 to 5}; array{local:fun()}?1
declare function local:func($a as xs:integer, $b as xs:integer, $unused) { $a + $b };         local:func(1, 2, 3)
declare function local:func($a as xs:integer, $unused, $c as xs:integer) { $a + $c };         local:func(1, 2, 3)
declare function local:func($arg as element()* ) as element()* { for $n in $arg/attribute return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/castable return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/child return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/comment return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/declare return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/document-node return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/document return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/element return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/following-sibling return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/for return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/if return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/import return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/instance return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/item return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/let return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/ordered return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/processing-instruction return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/schema-attribute return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/schema-element return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/some return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/text return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/typeswitch return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/unordered return $n }; 1
declare function local:func($arg as element()* ) as element()* { for $n in $arg/validate return $n }; 1
declare function local:func($choose, $whenTrue, $whenFalse) { if($choose) then $whenTrue else $whenFalse };         local:func(true(), current-time(), current-date()) instance of xs:time and local:func(false(), current-time(), current-date()) instance of xs:date
declare function local:func($unused, $b as xs:integer, $c as xs:integer) { $b + $c };         local:func(1, 2, 3)
declare function local:func1($a1, $a2, $a3) { 1 };         local:func1(1, 2, 3)
declare function local:func1() { if(local:func2('b')) then 3 else local:func1() };          declare function local:func2($a) { if(matches("",$a)) then () else 4 };          local:func1()
declare function local:func() as xs:integer { <!--1--> };         local:func()
declare function local:func() as xs:integer { attribute name {"1"} };         local:func()
declare function local:func() as xs:integer { <e>1</e> };         local:func()
declare function local:func() as xs:integer { <?target 1?> };         local:func()
declare function local:func() as xs:integer? { text {"1"} };         local:func()
declare function local:function($x as xs:integer) as xs:integer { (:there is nothing here:) };          local:function(3)
declare function local:function() { let $b := (i/a) return 1 }; local:function()
declare function local:function() { let $b := (i/a) return () }; empty(local:function())
declare function local:gDay($day as xs:integer) { if ($day lt 10) then xs:gDay(concat("---0", $day)) else xs:gDay(concat("---", $day)) }; not(local:gDay(1) eq xs:gDay("---31"))
declare function local:gDay($day as xs:integer) { if ($day lt 10) then xs:gDay(concat("---0", $day)) else xs:gDay(concat("---", $day)) }; not(local:gDay(1) ne xs:gDay("---31"))
declare function local:gDay($gDay as xs:gDay, $null as xs:boolean) { if ($null) then () else $gDay }; exists(local:gDay(xs:gDay("---31"), fn:true()) eq xs:gDay("---31"))
declare function local:gDay($gDay as xs:gDay, $null as xs:boolean) { if ($null) then () else $gDay }; exists(local:gDay(xs:gDay("---31"), fn:true()) ne xs:gDay("---31"))
declare function local:gDay($gDay as xs:gDay, $null as xs:boolean) { if ($null) then () else $gDay }; local:gDay(xs:gDay("---31"), fn:false()) eq xs:gDay("---31")
declare function local:gDay($gDay as xs:gDay, $null as xs:boolean) { if ($null) then () else $gDay }; local:gDay(xs:gDay("---31"), fn:false()) ne xs:gDay("---31")
declare function local:generate($arg as xs:boolean) as xs:string+ { if ($arg) then ('a', 'b', 'c') else ('A', 'B', 'C') }; ( for $x in local:generate(true()) return 3)[1]
declare function local:generate($arg as xs:boolean) as xs:string+ { if ($arg) then ('a', 'b', 'c') else ('A', 'B', 'C') }; ( for $x in local:generate(true()) return 3)[last()]
declare function local:generate($arg as xs:integer?) as xs:integer? { $arg }; ( if (local:generate(0) = 0) then () else 1, for $x in local:generate(0) return -$x)[1]
declare function local:generate($arg as xs:integer?) as xs:integer? { $arg };         ( if (local:generate(0) = 0) then () else 1, for $x in local:generate(0) return -$x)[last()]
declare function local:generate($arg as xs:integer?) as xs:integer? { if ($arg = 0) then 0 else () }; ( local:generate(()), for $x in local:generate(0) return $x + 2 )[1]
declare function local:generate($arg as xs:integer?) as xs:integer? { if ($arg = 0) then 0 else () };         ( local:generate(()), for $x in local:generate(0) return $x + 2 )[last()]
declare function local:generate($arg as xs:integer?) as xs:integer* { if ($arg = 0) then ( 1, 2, 3 ) else ( $arg ) }; ( local:generate(()), for $x at $p in local:generate(0) return $p + $x)[1]
declare function local:generate($arg as xs:integer?) as xs:integer* { if ($arg = 0) then ( 1, 2, 3 ) else ( $arg ) };         ( local:generate(()), for $x at $p in local:generate(0) return $p + $x)[last()]
declare function local:generate($arg as xs:integer?) as xs:integer* { if ($arg = 0) then (1, 2, 3) else $arg }; ( local:generate(()), for $x in local:generate(0) return $x + 2 )[1]
declare function local:generate($arg as xs:integer?) as xs:integer* { if ($arg = 0) then (1, 2, 3) else $arg };         ( local:generate(()), for $x in local:generate(0) return $x + 2 )[last()]
declare function local:generate($arg as xs:integer?) as xs:integer? { if ($arg = 0) then 1 else $arg }; ( local:generate(()), for $x at $p in local:generate(0) return $p + $x)[1]
declare function local:generate($arg as xs:integer?) as xs:integer? { if ($arg = 0) then 1 else $arg };         ( local:generate(()), for $x at $p in local:generate(0) return $p + $x)[last()]
declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then ('a', 'b', 'c') else () }; boolean(local:generate(0)[1])
declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then ('a', 'b', 'c') else () };         boolean(local:generate(0)[last()])
declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then ('a', 'b', 'c') else () }; boolean(local:generate(1)[1])
declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then ('a', 'b', 'c') else () }; boolean(local:generate(1)[last()])
declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then ('a', 'b', 'c') else ('d' ) }; ( if (local:generate(1) = 'd') then () else 1, for $x in local:generate(0) return fn:lower-case($x))[1]
declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then ('a', 'b', 'c') else ('d' ) };         ( if (local:generate(1) = 'd') then () else 1, for $x in local:generate(0) return fn:lower-case($x))[last()]
declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then ('a', 'b', 'c') else () }; ( local:generate(()), for $x in local:generate(0) return 3)[1]
declare function local:generate($arg as xs:integer?) as xs:string* { if ($arg = 0) then ('a', 'b', 'c') else () };         ( local:generate(()), for $x in local:generate(0) return 3)[last()]
declare function local:generate($arg as xs:integer?) { if ($arg = 0) then (1, 2, 3) else $arg }; fn:count( ( (), local:generate( () ), local:generate( 0 ), (1 to 10000000), local:generate( () ), local:generate(1)) )
declare function local:generate($arg as xs:integer?) { if ($arg = 0) then (1, 2, 3) else $arg };         fn:empty( fn:zero-or-one(fn:unordered( local:generate( () ) )) )
declare function local:generate($arg as xs:integer?) { if ($arg = 0) then (1, 2, 3) else $arg };         fn:empty( ((), local:generate( () ), local:generate( 0 ), (1 to 10000000), local:generate( () ), local:generate(1)) )
declare function local:generate($arg as xs:integer) { if ($arg = 0) then (1, 2, 3) else $arg };         fn:exactly-one(fn:unordered( local:generate(1) ))
declare function local:generate($arg as xs:integer?) { if ($arg = 0) then (1, 2, 3) else $arg };         fn:exists( ( (), local:generate( () ), local:generate( 0 ), (1 to 10000000), local:generate( () ), local:generate(1)) )
declare function local:generate($arg as xs:integer?) { if ($arg = 0) then (1, 2, 3) else $arg };         fn:one-or-more(fn:reverse( local:generate( 0 ) ))
declare function local:generate($arg as xs:integer?) { if ($arg = 0) then (1, 2, 3) else $arg };         fn:one-or-more(fn:zero-or-one( local:generate( () ) ))
declare function local:generate($arg as xs:integer?) { if ($arg = 0) then (1, 2, 3) else () }; ( local:generate(0), 1, local:generate(0) )[1]
declare function local:generate($arg as xs:integer?) { if ($arg = 0) then (1, 2, 3) else () };         ( local:generate(0), 1, local:generate(0) )[last()]
declare function local:generate($arg as xs:integer?) { if ($arg = 0) then () else if ($arg = 1) then $arg else ($arg, $arg) };         1 + fn:exactly-one(fn:one-or-more( local:generate( 1 ) ))
declare function local:generate($arg as xs:integer?) { if ($arg = 0) then () else if ($arg = 1) then $arg else ($arg, $arg) };         1 + fn:exactly-one(fn:zero-or-one( local:generate( 1 ) ))
declare function local:generate($arg as xs:integer?) { if ($arg = 0) then () else if ($arg = 1) then $arg else ($arg, $arg) };         1 + fn:zero-or-one(fn:one-or-more( local:generate( 1 ) ))
declare function local:generate($count as xs:integer) {        for $x in 1 to $count         return         if ($x mod 3 = 0) then <a />         else if ($x mod 3 = 1) then <b />         else <c />         };         fn:boolean(fn:count( local:generate(5) ))
declare function local:generate($count as xs:integer) {        if ($count < 0) then "string"         else for $x in 1 to $count          return           if ($x mod 3 = 0) then <a />           else if ($x mod 3 = 1) then <b />           else <c />         };         fn:boolean(fn:reverse( local:generate(5) ))
declare function local:gMonth($gMonth as xs:gMonth, $null as xs:boolean) { if ($null) then () else $gMonth }; exists(local:gMonth(xs:gMonth("--12"), fn:true()) eq xs:gMonth("--12"))
declare function local:gMonth($gMonth as xs:gMonth, $null as xs:boolean) { if ($null) then () else $gMonth }; exists(local:gMonth(xs:gMonth("--12"), fn:true()) ne xs:gMonth("--12"))
declare function local:gMonth($gMonth as xs:gMonth, $null as xs:boolean) { if ($null) then () else $gMonth }; local:gMonth(xs:gMonth("--12"), fn:false()) eq xs:gMonth("--12")
declare function local:gMonth($gMonth as xs:gMonth, $null as xs:boolean) { if ($null) then () else $gMonth }; local:gMonth(xs:gMonth("--12"), fn:false()) ne xs:gMonth("--12")
declare function local:gMonth($month as xs:integer) { if ($month lt 10) then xs:gMonth(concat("--0", $month)) else xs:gMonth(concat("--", $month)) }; not(local:gMonth(1) eq xs:gMonth("--06"))
declare function local:gMonth($month as xs:integer) { if ($month lt 10) then xs:gMonth(concat("--0", $month)) else xs:gMonth(concat("--", $month)) }; not(local:gMonth(1) ne xs:gMonth("--06"))
declare function local:gMonthDay($day as xs:integer) { if ($day lt 10) then xs:gMonthDay(concat("--12-0", $day)) else xs:gMonthDay(concat("--12-", $day)) }; not(local:gMonthDay(1) eq xs:gMonthDay("--12-31"))
declare function local:gMonthDay($day as xs:integer) { if ($day lt 10) then xs:gMonthDay(concat("--12-0", $day)) else xs:gMonthDay(concat("--12-", $day)) }; not(local:gMonthDay(1) ne xs:gMonthDay("--12-31"))
declare function local:gMonthDay($gMonthDay as xs:gMonthDay, $null as xs:boolean) { if ($null) then () else $gMonthDay }; exists(local:gMonthDay(xs:gMonthDay("--12-31"), fn:true()) eq xs:gMonthDay("--12-31"))
declare function local:gMonthDay($gMonthDay as xs:gMonthDay, $null as xs:boolean) { if ($null) then () else $gMonthDay }; exists(local:gMonthDay(xs:gMonthDay("--12-31"), fn:true()) ne xs:gMonthDay("--12-31"))
declare function local:gMonthDay($gMonthDay as xs:gMonthDay, $null as xs:boolean) { if ($null) then () else $gMonthDay }; local:gMonthDay(xs:gMonthDay("--12-31"), fn:false()) eq xs:gMonthDay("--12-31")
declare function local:gMonthDay($gMonthDay as xs:gMonthDay, $null as xs:boolean) { if ($null) then () else $gMonthDay }; local:gMonthDay(xs:gMonthDay("--12-31"), fn:false()) ne xs:gMonthDay("--12-31")
declare function local:gYear($gYear as xs:gYear, $null as xs:boolean) { if ($null) then () else $gYear }; exists(local:gYear(xs:gYear("1972"), fn:true()) eq xs:gYear("1972"))
declare function local:gYear($gYear as xs:gYear, $null as xs:boolean) { if ($null) then () else $gYear }; exists(local:gYear(xs:gYear("1972"), fn:true()) ne xs:gYear("1972"))
declare function local:gYear($gYear as xs:gYear, $null as xs:boolean) { if ($null) then () else $gYear }; local:gYear(xs:gYear("1972"), fn:false()) ne xs:gYear("1972")
declare function local:gYear($year as xs:integer) { xs:gYear(string(2000 + $year)) }; not(local:gYear(7) eq xs:gYear("2008"))
declare function local:gYear($year as xs:integer) { xs:gYear(string(2000 + $year)) }; not(local:gYear(7) ne xs:gYear("2008"))
declare function local:gYearMonth($gYearMonth as xs:gYearMonth, $null as xs:boolean) { if ($null) then () else $gYearMonth }; exists(local:gYearMonth(xs:gYearMonth("1972-12"), fn:true()) eq xs:gYearMonth("1972-12"))
declare function local:gYearMonth($gYearMonth as xs:gYearMonth, $null as xs:boolean) { if ($null) then () else $gYearMonth }; exists(local:gYearMonth(xs:gYearMonth("1972-12"), fn:true()) ne xs:gYearMonth("1972-12"))
declare function local:gYearMonth($gYearMonth as xs:gYearMonth, $null as xs:boolean) { if ($null) then () else $gYearMonth }; local:gYearMonth(xs:gYearMonth("1972-12"), fn:false()) eq xs:gYearMonth("1972-12")
declare function local:gYearMonth($gYearMonth as xs:gYearMonth, $null as xs:boolean) { if ($null) then () else $gYearMonth }; local:gYearMonth(xs:gYearMonth("1972-12"), fn:false()) ne xs:gYearMonth("1972-12")
declare function local:gYearMonth($year as xs:integer) { xs:gYearMonth(concat(string(2000 + $year), "-01")) }; not(local:gYearMonth(7) eq xs:gYearMonth("2008-01"))
declare function local:gYearMonth($year as xs:integer) { xs:gYearMonth(concat(string(2000 + $year), "-01")) }; not(local:gYearMonth(7) ne xs:gYearMonth("2008-01"))
declare function local:hexBinary-value($arg as xs:boolean) as xs:hexBinary {              if ($arg) then xs:hexBinary('68656c6c6f') else xs:hexBinary('676f6f64627965')           };           local:hexBinary-value(true()) eq local:hexBinary-value(false())
declare function local:hexBinary-value($arg as xs:boolean) as xs:hexBinary {              if ($arg) then xs:hexBinary('68656c6c6f') else xs:hexBinary('676f6f64627965')           };           not(local:hexBinary-value(true()) eq local:hexBinary-value(false()))
declare function local:hexBinary-value($arg as xs:boolean) as xs:hexBinary {              if ($arg) then xs:hexBinary('68656c6c6f') else xs:hexBinary('676f6f64627965')           };           not(local:hexBinary-value(true()) ne local:hexBinary-value(false()))
declare function local:hof($s, $f as function(*)) {            $f($s[1], $s[2])          };                    local:hof(('1', '2'), concat#2)
declare function local:identity($arg as xs:error)             {               $arg             };        local:identity(1)
declare function local:index-of($seq, $item) as xs:double? { for $x at $p in $seq return if ($x eq $item) then $p else () };         local:index-of((1, 2.0, xs:float(3), 2), 2)
declare function local:index-of($seq as xs:double*, $item as xs:double) { for $x at $p in $seq return if ($x eq $item) then $p else () };         declare function local:sequence($x as xs:integer) { ("string", 1, 2.0, xs:float(3))[$x] };         local:index-of(for $x in (2,3,4) return local:sequence($x), 2)
declare function local:index-of($seq as xs:integer*, $item as xs:integer?) as xs:float* {            if (empty($item))              then -1             else for $x at $p in $seq return if ($x eq $item) then $p else ()          };         local:index-of(1 to 10, 3)
declare function local:integer($x as xs:decimal) { if ($x mod 1 eq 0) then xs:integer($x) else $x };         (local:integer(2) idiv local:integer(2)) instance of xs:integer
declare function local:integer($x as xs:decimal) { if ($x mod 1 eq 0) then xs:integer($x) else $x };         (local:integer(2) * local:integer(2)) instance of xs:integer
declare function local:integer($x as xs:decimal) { if ($x mod 1 eq 0) then xs:integer($x) else $x };         (local:integer(2) - local:integer(2)) instance of xs:integer
declare function local:integer($x as xs:decimal) { if ($x mod 1 eq 0) then xs:integer($x) else $x };         -(local:integer(2)) - -(local:integer(4))
declare function local:integer($x as xs:decimal) { if ($x mod 1 eq 0) then xs:integer($x) else $x };         -(local:integer(2)) - local:integer(4)
declare function local:integer($x as xs:decimal) { if ($x mod 1 eq 0) then xs:integer($x) else $x };         local:integer(2) - -(local:integer(4))
declare function local:integer($x as xs:decimal) { if ($x mod 1 eq 0) then xs:integer($x) else $x };         (local:integer(3.5) mod local:integer(2)) instance of xs:integer
declare function local:integer($x as xs:decimal) { if ($x mod 1 eq 0) then xs:integer($x) else $x };         (local:integer(3) mod local:integer(2)) instance of xs:integer
declare function local:isComplexType($typeID) { string($typeID) };          "|", //*/local:isComplexType(@type), "|"
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        fn:false() eq local:is-even(17)
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        fn:false() ge local:is-even(17)
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        fn:false() gt local:is-even(17)
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        fn:false() le local:is-even(17)
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        fn:false() lt local:is-even(17)
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        fn:true() ge local:is-even(17)
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        fn:true() gt local:is-even(17)
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        fn:true() le local:is-even(17)
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        fn:true() lt local:is-even(17)
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        fn:true() ne local:is-even(17)
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        local:is-even(17) ge fn:false()
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        local:is-even(17) ge fn:true()
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        local:is-even(17) gt fn:false()
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        local:is-even(17) gt fn:true()
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        local:is-even(17) le fn:false()
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        local:is-even(17) le fn:true()
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        local:is-even(17) lt fn:false()
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        local:is-even(17) lt fn:true()
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        local:is-even(17) ne fn:false()
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        local:is-even(17) ne fn:true()
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        not(local:is-even(13) eq local:is-even(17))
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        not(local:is-even(15) ge local:is-even(17))
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        not(local:is-even(15) gt local:is-even(17))
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        not(local:is-even(15) le local:is-even(17))
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        not(local:is-even(15) lt local:is-even(17))
declare function local:is-even($arg as xs:integer) as xs:boolean { (($arg mod 2) eq 0) };        not(not(local:is-even(17) eq local:is-even(16)))
declare function local:levenshtein($arg1 as xs:string, $arg2 as xs:string) as xs:decimal { if(string-length($arg1) = 0) then string-length($arg2) else if(string-length($arg2) = 0) then string-length($arg1) else min((local:levenshtein(substring($arg1, 2), $arg2) + 1, local:levenshtein($arg1, substring($arg2, 2)) + 1, local:levenshtein(substring($arg1, 2), substring($arg2, 2)) + (if(substring($arg1, 1, 1) = substring($arg2, 1, 1)) then 0 else 1))) };         local:levenshtein("a", "a"), local:levenshtein("aa", "aa"), local:levenshtein("aaa", "aaa"), local:levenshtein("aa a", "aa a"), local:levenshtein("a a a", "aaa"), local:levenshtein("aaa", "a a a"), local:levenshtein("aaa", "aaab"), local:levenshtein("978", "abc")
declare function local:lower-case($x as xs:string) as xs:string { concat("'", fn:lower-case($x), "'") };          declare function local:ops() as (function(xs:string) as xs:string)*           { (upper-case#1, local:lower-case#1, function($x){translate($x, 'e', 'i')}, substring-before(?, ' ')) };          string-join(for $f in local:ops() return $f(<a name="Michael Kay"/>/@name), '~')
declare function local:multiplySequence($input as xs:integer*) as xs:integer { if (empty($input)) then 1 else $input[1] * local:multiplySequence($input[position() != 1]) };         local:multiplySequence((1, 2, 3, 4, 5))
declare function local:myFunc($arg as node()) { let $v := aNameTest return $arg/$v }; 1
declare function local:myFunc($arg as node()) { let $v := aNameTest return $arg/$v }; local:myFunc(<e/>)
declare function local:myFunc($arg as node()) { let $v := . return $arg/$v }; local:myFunc(<e/>)
declare function local:myFunc($recurse as xs:integer) as item() { <nested> { if ($recurse = 0) then () else local:myFunc($recurse - 1) } </nested> }; <b> {local:myFunc(3)} {attribute name {"content"}} </b>
declare function local:myFunc($recurse as xs:integer) { attribute {concat("name", $recurse)} {"content"} , if ($recurse = 0) then () else local:myFunc($recurse - 1) }; <b> {local:myFunc(2)} {attribute name {"content"}} </b>
declare function local:myFunc($recurse as xs:integer) { <nested> { if ($recurse = 0) then () else local:myFunc($recurse - 1) } </nested> }; <b> {local:myFunc(3)} {attribute name {"content"}} </b>
declare function local:myFunc() { <a/> }; <b> {local:myFunc()} {attribute name {"content"}} </b>
declare function local:myFunc() as attribute(foo) { <foo/> };         local:myFunc()
declare function local:myFunc() as element()+ { <a/> }; <b> {local:myFunc()} {attribute name {"content"}} </b>
declare function local:myFunc() as item() { <a/> }; <b> {local:myFunc()} {attribute name {"content"}} </b>
declare function local:myFunc() { attribute n2 {"content"} }; <b> {local:myFunc()} {attribute name {"content"}} </b>
declare function local:myFunc() { attribute name {"content"}, <elem/> }; <b> {local:myFunc()} </b>
declare function local:myFunc() { comment {"content"} }; <b> {local:myFunc()} {attribute name {"content"}} </b>
declare function local:myFunc() { e[1] }; local:myFunc()
declare function local:myFunc() { e[928] }; local:myFunc()
declare function local:myFunc() { e };         <e/>/local:myFunc()/1
declare function local:myFunc() { e[last()] }; local:myFunc()
declare function local:myFunc() { <elem/>, attribute name {"content"} }; <b> {local:myFunc()[2]} </b>
declare function local:myFunc() { <elem/>, attribute name {"content"} }; <b> {local:myFunc()} </b>
declare function local:myFunc() { e[true()] }; local:myFunc()
declare function local:myFunc() { for $i at $p in (1, 2, 3) return position() }; 1
declare function local:myFunc() { for $i at $p in (1, 2, 3) return position() }; local:myFunc()
declare function local:myFunc() { for $i in (1, 2, 3) return position() }; 1
declare function local:myFunc() { for $i in (1, 2, 3) return position() };          local:myFunc()
declare function local:myFunc() { let $v := . return $v }; local:myFunc()
declare function local:myFunc() { .. }; local:myFunc()
declare function local:myFunction($arg) { $arg };         local:myFunction()
declare function local:myFunction($arg := 1) {1};         true()
declare function local:myFunction($arg = 1) {1};         true()
declare function local:myFunction($arg := 1 as xs:integer) {1};         true()
declare function local:myFunction($arg = 1 as xs:integer) {1};         true()
declare function local:myFunction($arg as empty-sequence()) { $arg };         empty(local:myFunction(()))
declare function local:myFunction($arg as empty-sequence()+) { $arg };         local:myFunction(())
declare function local:myFunction($arg as empty-sequence()?) { $arg };         local:myFunction(())
declare function local:myFunction($arg as item(), $arg2 as xs:integer) { $arg, $arg2 };         local:myFunction("3", ())
declare function local:myFunction($arg as item(), $arg2 as xs:integer) { $arg, $arg2 };         local:myFunction("3", "3")
declare function local:myFunction($arg as item()?, $arg2 as xs:integer) { $arg, $arg2 };         local:myFunction((), 4.1)
declare function local:myFunction($arg as xs:integer) { $arg };         local:myFunction(1.0)
declare function local:myFunction($arg as xs:integer) as xs:integer { if($arg eq 1) then $arg else local:myFunction3($arg - 1) };         declare function local:myFunction2($arg as xs:integer) as xs:integer { local:myFunction($arg) };         declare function local:myFunction3($arg as xs:integer) as xs:integer { local:myFunction2($arg) };         local:myFunction3(3) eq 1
declare function local:myFunction($local:arg) as item() { 1, $local:arg };         local:myFunction(()), local:myFunction(1)
declare function local:myFunction($local:myVar) { $local:myVar + 1 };         local:myFunction(1), local:myFunction("this will fail")
declare function local:myFunction($local:myVar as xs:integer) { for $local:myVar in ($local:myVar, 3) return $local:myVar };         deep-equal(local:myFunction(1), (1, 3))
declare function local:myFunction($unusedArg) { true() };         local:myFunction(1 + "a string")
declare function local:myFunction($usedArg) { $usedArg };         local:myFunction(1 + "a string")
declare function local:MyFunction() { 1 };         local:myFunction()
declare function local:MyFunction() { 1 };         local:myFunctionn()
declare function local:myFunction { 1 };         true()
declare function local:myFunction() as item()* {***};         1
declare function local:myFunction() as item() { () };         local:myFunction()
declare function local:myFunction() { "a string" + 1 };         true()
declare function local:myFunction() as xs:anyURI { 1 };         true()
declare function local:myFunction() as xs:double { "This is not a double, it's an xs:string." };         local:myFunction()
declare function local:myFunction() as xs:float { 4.0 };         (current-time(), 1, 2, "a string", local:myFunction(), 4.0, xs:double("NaN"), current-date())[5] instance of xs:float
declare function local:myFunction() as xs:integer { 1.0 };         local:myFunction()
declare function local:myFunction as xs:integer { 1 };         true()
declare function local:myFunction() as xs:integer { subsequence((1, 2, "a string"), 3 ,1) };         fn:boolean(local:myFunction())
declare function local:myName($var as xs:integer) as xs:integer { $var };         declare function local:myName() as xs:integer { 1 };         (local:myName(4) - 3) eq local:myName()
declare function local:mysum($i as xs:integer, $j as xs:integer) { let $j := $i + $j return $j };         declare function local:invoke_mysum($st as xs:integer) { for $d in (1,2,3,4,5) let $st := local:mysum($d, $st) return $st };         local:invoke_mysum(0)
declare function local:mysum($i as xs:integer, $j as xs:integer) { let $j := $i + $j return $j };         declare function local:invoke_mysum() { let $s := 1 for $d in (1,2,3,4,5) let $s := local:mysum($s, $d) return $s };         local:invoke_mysum()
declare function local:NaN () {1};          declare function local:allowing () {2};          declare function local:ancestor-or-self () {3};          declare function local:ancestor () {4};          declare function local:and () {5};          declare function local:as () {6};          declare function local:ascending () {7};          declare function local:at () {8};          declare function local:attribute () {9};          declare function local:base-uri () {10};          declare function local:boundary-space () {11};          declare function local:by () {12};          declare function local:case () {13};          declare function local:cast () {14};          declare function local:castable () {15};          declare function local:catch () {16};          declare function local:child () {17};          declare function local:collation () {18};          declare function local:comment () {19};          declare function local:construction () {20};          declare function local:context () {21};          declare function local:copy-namespaces () {22};          declare function local:count () {23};          declare function local:decimal-format () {24};          declare function local:decimal-separator () {25};          declare function local:declare () {26};          declare function local:default () {27};          declare function local:descendant-or-self () {28};          declare function local:descendant () {29};          declare function local:descending () {30};          declare function local:digit () {31};          declare function local:div () {32};          declare function local:document-node () {33};          declare function local:document () {34};          declare function local:element () {35};          declare function local:else () {36};          declare function local:empty-sequence () {37};          declare function local:empty () {38};          declare function local:encoding () {39};          declare function local:end () {40};          declare function local:eq () {41};          declare function local:every () {42};          declare function local:except () {43};          declare function local:external () {44};          declare function local:following-sibling () {45};          declare function local:following () {46};          declare function local:for () {47};          declare function local:function () {48};          declare function local:ge () {49};          declare function local:greatest () {50};          declare function local:group () {51};          declare function local:grouping-separator () {52};          declare function local:gt () {53};          declare function local:idiv () {54};          declare function local:if () {55};          declare function local:import () {56};          declare function local:in () {57};          declare function local:infinity () {58};          declare function local:inherit () {59};          declare function local:instance () {60};          declare function local:intersect () {61};          declare function local:is () {62};          declare function local:item () {63};          declare function local:lax () {64};          declare function local:le () {65};          declare function local:least () {66};          declare function local:let () {67};          declare function local:lt () {68};          declare function local:minus-sign () {69};          declare function local:mod () {70};          declare function local:module () {71};          declare function local:namespace-node () {72};          declare function local:namespace () {73};          declare function local:ne () {74};          declare function local:next () {75};          declare function local:no-inherit () {76};          declare function local:no-preserve () {77};          declare function local:node () {78};          declare function local:of () {79};          declare function local:only () {80};          declare function local:option () {81};          declare function local:or () {82};          declare function local:order () {83};          declare function local:ordered () {84};          declare function local:ordering () {85};          declare function local:parent () {86};          declare function local:pattern-separator () {87};          declare function local:per-mille () {88};          declare function local:percent () {89};          declare function local:preceding-sibling () {90};          declare function local:preceding () {91};          declare function local:preserve () {92};          declare function local:previous () {93};          declare function local:processing-instruction () {94};          declare function local:return () {95};          declare function local:satisfies () {96};          declare function local:schema-attribute () {97};          declare function local:schema-element () {98};          declare function local:schema () {99};          declare function local:self () {100};          declare function local:sliding () {101};          declare function local:some () {102};          declare function local:stable () {103};          declare function local:start () {104};          declare function local:strict () {105};          declare function local:strip () {106};          declare function local:switch () {107};          declare function local:text () {108};          declare function local:then () {109};          declare function local:to () {110};          declare function local:treat () {111};          declare function local:try () {112};          declare function local:tumbling () {113};          declare function local:type () {114};          declare function local:typeswitch () {115};          declare function local:union () {116};          declare function local:unordered () {117};          declare function local:validate () {118};          declare function local:variable () {119};          declare function local:version () {120};          declare function local:when () {121};          declare function local:where () {122};          declare function local:window () {123};          declare function local:xquery () {124};          declare function local:zero-digit () {125};                    local:NaN() +          local:allowing() +          local:ancestor-or-self() +          local:ancestor() +          local:and() +          local:as() +          local:ascending() +          local:at() +          local:attribute() +          local:base-uri() +          local:boundary-space() +          local:by() +          local:case() +          local:cast() +          local:castable() +          local:catch() +          local:child() +          local:collation() +          local:comment() +          local:construction() +          local:context() +          local:copy-namespaces() +          local:count() +          local:decimal-format() +          local:decimal-separator() +          local:declare() +          local:default() +          local:descendant-or-self() +          local:descendant() +          local:descending() +          local:digit() +          local:div() +          local:document-node() +          local:document() +          local:element() +          local:else() +          local:empty-sequence() +          local:empty() +          local:encoding() +          local:end() +          local:eq() +          local:every() +          local:except() +          local:external() +          local:following-sibling() +          local:following() +          local:for() +          local:function() +          local:ge() +          local:greatest() +          local:group() +          local:grouping-separator() +          local:gt() +          local:idiv() +          local:if() +          local:import() +          local:in() +          local:infinity() +          local:inherit() +          local:instance() +          local:intersect() +          local:is() +          local:item() +          local:lax() +          local:le() +          local:least() +          local:let() +          local:lt() +          local:minus-sign() +          local:mod() +          local:module() +          local:namespace-node() +          local:namespace() +          local:ne() +          local:next() +          local:no-inherit() +          local:no-preserve() +          local:node() +          local:of() +          local:only() +          local:option() +          local:or() +          local:order() +          local:ordered() +          local:ordering() +          local:parent() +          local:pattern-separator() +          local:per-mille() +          local:percent() +          local:preceding-sibling() +          local:preceding() +          local:preserve() +          local:previous() +          local:processing-instruction() +          local:return() +          local:satisfies() +          local:schema-attribute() +          local:schema-element() +          local:schema() +          local:self() +          local:sliding() +          local:some() +          local:stable() +          local:start() +          local:strict() +          local:strip() +          local:switch() +          local:text() +          local:then() +          local:to() +          local:treat() +          local:try() +          local:tumbling() +          local:type() +          local:typeswitch() +          local:union() +          local:unordered() +          local:validate() +          local:variable() +          local:version() +          local:when() +          local:where() +          local:window() +          local:xquery() +          local:zero-digit()          eq (125 * (125 + 1)) div 2
declare function local:nan() { xs:float("NaN") };         (1 to 10)[not(position() < xs:float("NaN"))]
declare function local:nothing() as empty-sequence() { () }; empty(local:nothing())
declare function local:odd($x as xs:integer) as xs:boolean {if ($x = 0) then false() else local:even($x - 1)};         declare function local:even($x as xs:integer) as xs:boolean {if ($x = 0) then true() else local:odd($x - 1)};         local:even(3)
declare function local:odd($x as xs:integer) as xs:boolean {if ($x = 0) then false() else local:even($x - 1)};         declare function local:even($x as xs:integer) as xs:boolean {if ($x = 0) then true() else local:odd($x - 1)};         local:even(4)
declare function local:odds($arg as xs:integer?) as xs:integer? { $arg[. mod 2 eq 1] }; boolean(for $x in local:odds(2) where $x < 3 return $x + 1)
declare function local:odds($arg as xs:integer*) as xs:integer* { $arg[. mod 2 eq 1] }; boolean(zero-or-one(for $x in local:odds((2,4,8)),$y in local:odds((2,4,8)) return ($x,$y)))
declare function local:ops() as (function(xs:string) as xs:string)*        { (upper-case#1, lower-case#1, function($x){translate($x, 'e', 'i')}, substring-before(?, ' ')) };        string-join(for $f in local:ops() return $f('Michael Kay'), '~')
declare function local:partners($c as xs:string) as element()* {              let $c := $company-data//company[name = $c]              return $c//partner          };          for $item in $string//news_item,              $c in $company-data//company          let $partners := local:partners(exactly-one($c/name))          where contains(string($item), $c/name)            and (some $p in $partners satisfies contains(string($item), $p) and $item/news_agent != $c/name)          return $item
declare function local:plus($x, $y) {           $x + $y         };         function-arity(local:plus#2)
declare function local:plus($x, $y) {           $x + $y         };         function-name(local:plus#2)
declare function local:plus($x, $y) {           $x + $y         };         let $f := (if (current-date() gt xs:date('1900-01-01')) then local:plus#2 else round#2)         return $f(5, 7)
declare function local:price ($i as element()) as element()? { $i/price };         for $j in /bib/book return local:price($j)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; 24.5 eq count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; 24.5 ge count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; 24.5 gt count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; 24.5 le count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; 24.5 lt count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; 24.5 ne count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; 25 eq count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; 25 ge count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; 25 gt count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; 25 le count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; 25 lt count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; 25 ne count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq -1
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq -1.5
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq 25
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq 25.5
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq xs:double("-1.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq xs:double("25.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq xs:double("INF")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq xs:double("NaN")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq xs:float("-1.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq xs:float("25.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq xs:float("INF")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) eq xs:float("NaN")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge -1
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge 1
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge -1.5
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge 25
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge 25.5
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge xs:double("1.0")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge xs:double("-1.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge xs:double("25.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge xs:double("INF")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge xs:double("NaN")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge xs:float("1.0")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge xs:float("-1.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge xs:float("25.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge xs:float("INF")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ge xs:float("NaN")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt -1
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt -1.5
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt 25
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt 25.5
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt xs:double("-1.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt xs:double("25.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt xs:double("INF")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt xs:double("NaN")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt xs:float("-1.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt xs:float("25.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt xs:float("INF")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) gt xs:float("NaN")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le -1
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le -1.5
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le 25
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le 25.5
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le xs:double("-1.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le xs:double("25.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le xs:double("INF")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le xs:double("NaN")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le xs:float("-1.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le xs:float("25.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le xs:float("INF")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) le xs:float("NaN")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt -1
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt -1.5
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt 25
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt 25.5
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt xs:double("-1.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt xs:double("25.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt xs:double("INF")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt xs:double("NaN")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt xs:float("-1.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt xs:float("25.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt xs:float("INF")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) lt xs:float("NaN")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne -1
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne -1.5
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne 25
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne 25.5
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne xs:double("-1.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne xs:double("25.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne xs:double("INF")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne xs:double("NaN")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne xs:float("-1.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne xs:float("25.5")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne xs:float("INF")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(100)) ne xs:float("NaN")
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) eq -local:square(5.0)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) eq local:square(5.1)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) ge 1.0
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) ge -local:square(5.0)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) ge local:square(5.1)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) gt -local:square(5.0)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) gt local:square(5.1)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) le -local:square(5.0)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) le local:square(5.1)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) lt -local:square(5.0)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) lt local:square(5.1)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) ne -local:square(5.0)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:decimal) { $n * $n }; count(local:primes(100)) ne local:square(5.1)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:double) { $n * $n }; count(local:primes(100)) eq -local:square(5.0)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:double) { $n * $n }; count(local:primes(100)) eq local:square(xs:double("4.9"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:double) { $n * $n }; count(local:primes(100)) ge -local:square(5.0)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:double) { $n * $n }; count(local:primes(100)) ge local:square(xs:double("4.9"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:double) { $n * $n }; count(local:primes(100)) gt -local:square(5.0)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:double) { $n * $n }; count(local:primes(100)) gt local:square(xs:double("4.9"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:double) { $n * $n }; count(local:primes(100)) le -local:square(5.0)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:double) { $n * $n }; count(local:primes(100)) le local:square(xs:double("4.9"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:double) { $n * $n }; count(local:primes(100)) lt -local:square(5.0)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:double) { $n * $n }; count(local:primes(100)) lt local:square(xs:double("4.9"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:double) { $n * $n }; count(local:primes(100)) ne -local:square(5.0)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:double) { $n * $n }; count(local:primes(100)) ne local:square(xs:double("4.9"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:float) { $n * $n }; count(local:primes(100)) eq -local:square(5.0)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:float) { $n * $n }; count(local:primes(100)) eq local:square(xs:float("4.9"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:float) { $n * $n }; count(local:primes(100)) ge -local:square(5.0)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:float) { $n * $n }; count(local:primes(100)) ge local:square(xs:float("4.9"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:float) { $n * $n }; count(local:primes(100)) gt -local:square(5.0)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:float) { $n * $n }; count(local:primes(100)) gt local:square(xs:float("4.9"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:float) { $n * $n }; count(local:primes(100)) le -local:square(5.0)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:float) { $n * $n }; count(local:primes(100)) le local:square(xs:float("4.9"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:float) { $n * $n }; count(local:primes(100)) lt -local:square(5.0)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:float) { $n * $n }; count(local:primes(100)) lt local:square(xs:float("4.9"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:float) { $n * $n }; count(local:primes(100)) ne -local:square(5.0)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:float) { $n * $n }; count(local:primes(100)) ne local:square(xs:float("4.9"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:integer) { $n * $n }; count(local:primes(100)) eq -local:square(5)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:integer) { $n * $n }; count(local:primes(100)) eq local:square(5)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:integer) { $n * $n }; count(local:primes(100)) ge -local:square(5)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:integer) { $n * $n }; count(local:primes(100)) ge local:square(5)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:integer) { $n * $n }; count(local:primes(100)) gt -local:square(5)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:integer) { $n * $n }; count(local:primes(100)) gt local:square(5)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:integer) { $n * $n }; count(local:primes(100)) le -local:square(5)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:integer) { $n * $n }; count(local:primes(100)) le local:square(5)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:integer) { $n * $n }; count(local:primes(100)) lt -local:square(5)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:integer) { $n * $n }; count(local:primes(100)) lt local:square(5)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:integer) { $n * $n }; count(local:primes(100)) ne -local:square(5)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:square($n as xs:integer) { $n * $n }; count(local:primes(100)) ne local:square(5)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:double { if ($n) then xs:double('NaN') else xs:double('INF') }; count(local:primes(100)) eq local:strange(false())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:double { if ($n) then xs:double('NaN') else xs:double('INF') }; count(local:primes(100)) eq local:strange(true())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:double { if ($n) then xs:double('NaN') else xs:double('INF') }; count(local:primes(100)) ge local:strange(false())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:double { if ($n) then xs:double('NaN') else xs:double('INF') }; count(local:primes(100)) ge local:strange(true())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:double { if ($n) then xs:double('NaN') else xs:double('INF') }; count(local:primes(100)) gt local:strange(false())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:double { if ($n) then xs:double('NaN') else xs:double('INF') }; count(local:primes(100)) gt local:strange(true())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:double { if ($n) then xs:double('NaN') else xs:double('INF') }; count(local:primes(100)) le local:strange(false())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:double { if ($n) then xs:double('NaN') else xs:double('INF') }; count(local:primes(100)) le local:strange(true())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:double { if ($n) then xs:double('NaN') else xs:double('INF') }; count(local:primes(100)) lt local:strange(false())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:double { if ($n) then xs:double('NaN') else xs:double('INF') }; count(local:primes(100)) lt local:strange(true())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:double { if ($n) then xs:double('NaN') else xs:double('INF') }; count(local:primes(100)) ne local:strange(false())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:double { if ($n) then xs:double('NaN') else xs:double('INF') }; count(local:primes(100)) ne local:strange(true())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:float { if ($n) then xs:float('NaN') else xs:float('INF') }; count(local:primes(100)) eq local:strange(false())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:float { if ($n) then xs:float('NaN') else xs:float('INF') }; count(local:primes(100)) eq local:strange(true())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:float { if ($n) then xs:float('NaN') else xs:float('INF') }; count(local:primes(100)) ge local:strange(false())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:float { if ($n) then xs:float('NaN') else xs:float('INF') }; count(local:primes(100)) ge local:strange(true())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:float { if ($n) then xs:float('NaN') else xs:float('INF') }; count(local:primes(100)) gt local:strange(false())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:float { if ($n) then xs:float('NaN') else xs:float('INF') }; count(local:primes(100)) gt local:strange(true())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:float { if ($n) then xs:float('NaN') else xs:float('INF') }; count(local:primes(100)) le local:strange(false())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:float { if ($n) then xs:float('NaN') else xs:float('INF') }; count(local:primes(100)) le local:strange(true())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:float { if ($n) then xs:float('NaN') else xs:float('INF') }; count(local:primes(100)) lt local:strange(false())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:float { if ($n) then xs:float('NaN') else xs:float('INF') }; count(local:primes(100)) lt local:strange(true())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:float { if ($n) then xs:float('NaN') else xs:float('INF') }; count(local:primes(100)) ne local:strange(false())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; declare function local:strange($n as xs:boolean) as xs:float { if ($n) then xs:float('NaN') else xs:float('INF') }; count(local:primes(100)) ne local:strange(true())
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(24.5 eq count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(24.5 ge count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(24.5 gt count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(24.5 le count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(24.5 lt count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(24.5 ne count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(25 eq count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(25 ge count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(25 gt count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(25 le count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(25 lt count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(25 ne count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) eq 25)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) eq 25.5)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) eq xs:double("25.5"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) eq xs:float("25.5"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) ge 25)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) ge 25.5)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) ge xs:double("25.5"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) ge xs:float("25.5"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) gt 25)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) gt 25.5)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) gt xs:double("25.5"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) gt xs:float("25.5"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) le 25)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) le 25.5)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) le xs:double("25.5"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) le xs:float("25.5"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) lt 25)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) lt 25.5)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) lt xs:double("25.5"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) lt xs:float("25.5"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) ne 25)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) ne 25.5)
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) ne xs:double("25.5"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(100)) ne xs:float("25.5"))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(xs:double("24.5") eq count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(xs:double("24.5") ge count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(xs:double("24.5") gt count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(xs:double("24.5") le count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(xs:double("24.5") lt count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(xs:double("24.5") ne count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(xs:float("24.5") eq count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(xs:float("24.5") ge count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(xs:float("24.5") gt count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(xs:float("24.5") le count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(xs:float("24.5") lt count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(xs:float("24.5") ne count(local:primes(100)))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; xs:double("24.5") eq count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; xs:double("24.5") ge count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; xs:double("24.5") gt count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; xs:double("24.5") le count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; xs:double("24.5") lt count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; xs:double("24.5") ne count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; xs:float("24.5") eq count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; xs:float("24.5") ge count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; xs:float("24.5") gt count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; xs:float("24.5") le count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; xs:float("24.5") lt count(local:primes(100))
declare function local:primes($n as xs:integer) { if ($n lt 2) then 1 else for $i in 2 to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; xs:float("24.5") ne count(local:primes(100))
declare function local:primes($s as xs:integer, $n as xs:integer) { let $start := if ($s lt 2) then 2 else $s return for $i in $s to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(2, 100)) eq count(local:primes(100, 200))
declare function local:primes($s as xs:integer, $n as xs:integer) { let $start := if ($s lt 2) then 2 else $s return for $i in $s to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(2, 100)) ge count(local:primes(100, 200))
declare function local:primes($s as xs:integer, $n as xs:integer) { let $start := if ($s lt 2) then 2 else $s return for $i in $s to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(2, 100)) gt count(local:primes(100, 200))
declare function local:primes($s as xs:integer, $n as xs:integer) { let $start := if ($s lt 2) then 2 else $s return for $i in $s to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(2, 100)) le count(local:primes(100, 200))
declare function local:primes($s as xs:integer, $n as xs:integer) { let $start := if ($s lt 2) then 2 else $s return for $i in $s to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(2, 100)) lt count(local:primes(100, 200))
declare function local:primes($s as xs:integer, $n as xs:integer) { let $start := if ($s lt 2) then 2 else $s return for $i in $s to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; count(local:primes(2, 100)) ne count(local:primes(100, 200))
declare function local:primes($s as xs:integer, $n as xs:integer) { let $start := if ($s lt 2) then 2 else $s return for $i in $s to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(2, 100)) eq count(local:primes(100, 200)))
declare function local:primes($s as xs:integer, $n as xs:integer) { let $start := if ($s lt 2) then 2 else $s return for $i in $s to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(2, 100)) ge count(local:primes(100, 200)))
declare function local:primes($s as xs:integer, $n as xs:integer) { let $start := if ($s lt 2) then 2 else $s return for $i in $s to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(2, 100)) gt count(local:primes(100, 200)))
declare function local:primes($s as xs:integer, $n as xs:integer) { let $start := if ($s lt 2) then 2 else $s return for $i in $s to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(2, 100)) le count(local:primes(100, 200)))
declare function local:primes($s as xs:integer, $n as xs:integer) { let $start := if ($s lt 2) then 2 else $s return for $i in $s to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(2, 100)) lt count(local:primes(100, 200)))
declare function local:primes($s as xs:integer, $n as xs:integer) { let $start := if ($s lt 2) then 2 else $s return for $i in $s to $n return if (every $x in 2 to ($i - 1) satisfies ($i mod $x ne 0)) then $i else () }; not(count(local:primes(2, 100)) ne count(local:primes(100, 200)))
declare function local:prnt($n as xs:integer,$n2 as xs:string, $n3 as xs:date, $n4 as xs:long, $n5 as xs:string, $n6 as xs:decimal) { if ($n < 2) then 1 else concat($n, " ",$n2," ",$n3," ",$n4," ",$n5," ",$n6) };         <table> { <td>Value is = {local:prnt(4,xs:string("hello"),xs:date("2005-02-22"), xs:long(5),xs:string("well"),xs:decimal(1.2))}</td> } </table>
declare function local:QName-value($arg as xs:boolean) as xs:QName { if ($arg) then QName("example.com/", "p:ncname") else QName("example.com/", "q:ncname") };         not(local:QName-value(true()) eq local:QName-value(false()))
declare function local:QName-value($arg as xs:boolean) as xs:QName { if ($arg) then QName("example.com/", "p:ncname") else QName("example.com/", "q:ncname") };         not(local:QName-value(true()) ne local:QName-value(false()))
declare function local:recursiveFunction($i as xs:integer) as xs:integer { if($i eq 5) then $i else local:recursiveFunction($i + 1) };         declare function local:proxy() as xs:integer { local:recursiveFunction(0) + 3 };         local:proxy()
declare function local:repeat($count as xs:integer, $arg as xs:string) as item()* {         if ($count lt 0) then '$count must not be negative'         else text { for $x in 1 to $count return $arg }       };        fn:boolean( local:repeat(0, "string") )
declare function local:repeat($count as xs:integer, $arg as xs:string) as xs:string* { if ($count le 0) then "" else for $x in 1 to $count return $arg };         string-join( for $x in 0 to 4 return local:repeat($x, 'a') , ' ') and string-join( for $x in 0 to 4 return local:repeat($x, 'a') , '')
declare function local:repeat($count as xs:integer, $arg as xs:string) { for $x in 1 to $count return $arg };        fn:boolean( text { local:repeat(0, "string") } )
declare function local:round($x as xs:double, $algorithm as (function(xs:double) as xs:double)) as xs:double { $algorithm($x) };        declare variable $roundToCeiling := local:round(?, ceiling#1); $roundToCeiling(12.4)
declare function local:round($x as xs:double, $algorithm as (function(xs:double) as xs:double)) as xs:double          { $algorithm($x) };          declare variable $roundToCeiling := local:round(?, upper-case#1);          $roundToCeiling(12.4)
declare function local:round($x as xs:double) as xs:double         { fn:floor($x) };        declare function local:ops() as (function(xs:double) as xs:double)*         { (abs#1, local:round#1, function($x){$x+1}, round-half-to-even(?, 2)) };        string-join(for $f in local:ops() return string($f(xs:untypedAtomic('123.456'))), '~')
declare function local:round($x as xs:double) as xs:double { fn:floor($x) };        declare function local:ops() as (function(xs:double) as xs:double)*         { (abs#1, local:round#1, function($x as xs:double){$x+1}, round-half-to-even(?, 2)) };        string-join(for $f in local:ops() return string(round-half-to-even($f(xs:decimal('123.456')), 4)), '~')
declare function local:scramble($x as function(*), $y as xs:string) as xs:string { $x($y) };        declare function local:rot13($x as xs:string) as xs:string { translate($x, "abcdefghijklmnopqrstuvwxyz", "nopqrstuvwxyzabcdefghijklm") };        local:scramble(local:rot13#1, "mike")
declare function local:scramble($x as function(*), $y as xs:string) as xs:string { $x($y) };        local:scramble(function($x){translate($x, "abcdefghijklmnopqrstuvwxyz", "nopqrstuvwxyzabcdefghijklm")}, "john")
declare function local:scramble($x as function(xs:string) as xs:string, $y as xs:string) as xs:string         { $x($y) };        declare function local:rot13($x as xs:string) as xs:string         { translate($x, "abcdefghijklmnopqrstuvwxyz", "nopqrstuvwxyzabcdefghijklm") };        local:scramble(local:rot13#1, "mike")
declare function local:scramble($x as function(xs:string) as xs:string, $y as xs:string) as xs:string { $x($y) };        let $n := function-name(local:scramble#2)        return (local-name-from-QName($n), namespace-uri-from-QName($n), function-arity(local:scramble#2))
declare function local:scramble($x as function(xs:string) as xs:string, $y as xs:string) as xs:string { $x($y) };        local:scramble(function($x){translate($x, "abcdefghijklmnopqrstuvwxyz", "nopqrstuvwxyzabcdefghijklm")}, "john")
declare function local:section-summary($book-or-section as element()*) as element()* {              for $section in $book-or-section              return <section> { $section/@* } { $section/title } <figcount> { count($section/figure) } </figcount> { local:section-summary($section/section) } </section>          };          <toc> {              for $s in /book/section              return local:section-summary($s)          } </toc>
declare function local:sequence($arg as xs:integer) as item()* { if ($arg mod 2 eq 0) then (1, 3, 5, 7, 9, "cheese") else (xs:untypedAtomic("1"), xs:untypedAtomic("2")) }; for $x in local:sequence(2) for $y in local:sequence(3) where $x = $y return ($x, $y)
declare function local:sequence($arg as xs:integer) as item()* { if ($arg mod 2 eq 0) then (1, 3, 5, 7, 9) else ("a", "b", "c") }; for $x in local:sequence(2) for $y in local:sequence(2) where $x = $y return ($x, $y)
declare function local:sequence($arg as xs:integer) as item()* { if ($arg mod 2 eq 0) then (1, 3, 5, 7, 9) else ("a", "b", "c") }; for $x in local:sequence(2) for $y in local:sequence(3) where $x = $y return ($x, $y)
declare function local:splitter($sep as xs:string) as (function(xs:string) as xs:string*)         { function($x as xs:string) { for $i in tokenize($x, $sep) return upper-case($i)} };        string-join(local:splitter("\s")("A nice cup of tea"), '|')
declare function local:splitter($x as xs:string) as (function() as xs:string*)* {              for $sep in ('\s', ',', '!') return function() {                  for $i in tokenize($x, $sep) return                      let $f := function(){ concat($sep, ':', upper-case($i)) }                      return $f() }          };          <out>{              for $f as function(*) in local:splitter("How nice! Thank you, I enjoyed that.")              return <tokens>{ for $t in $f()                               return <t>{$t}</t> }</tokens>          }</out>
declare function local:splitter($x as xs:string) as (function() as xs:string*)* {              for $sep in ('\s', ',', '!')              return function() { for $i in tokenize($x, $sep) return upper-case($i) }          };          <out>{              for $f as function(*) in local:splitter("How nice! Thank you, I enjoyed that.")              return <tokens>{ for $t in $f()                               return <t>{$t}</t>                     }</tokens>         }</out>
declare function local:splitter() as (function(xs:string) as xs:string+)?        { function($x as xs:string) { for $i in tokenize($x, '\s') return upper-case($i)} };        string-join(local:splitter()("A nice cup of tea"), '|')
declare function local:splitter() as (function(xs:string) as xs:string*) { function($x as xs:string) { tokenize($x, '\s') } };        string-join(local:splitter()("A nice cup of tea"), '|')
declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };         0.0 * local:square(7.0)
declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };         -1.0 * local:square(7.0)
declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };         1.0 * local:square(7.0)
declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };         local:square(2.0) * 0.0
declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };         local:square(4294967296.0) idiv 0.0000000000005 gt 0
declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };         local:square(7.0) * -1.0
declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };         local:square(7.0) * 1.0
declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };         local:square(7.0) div -1.0
declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };         local:square(7.0) div 1.0
declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };         local:square(7.5) - 0.0
declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };         local:square(9223372036854775808.1) gt 0
declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };         not( local:square(1.0) eq local:square(2.0) )
declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg }; not( local:square(1.0) ge local:square(2.0) )
declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg }; not( local:square(1.0) gt local:square(2.0) )
declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg }; not( local:square(1.0) le local:square(2.0) )
declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg }; not( local:square(1.0) lt local:square(2.0) )
declare function local:square($arg as xs:decimal) as xs:decimal { $arg * $arg };         not( local:square(1.0) ne local:square(2.0) )
declare function local:square($arg as xs:double) as xs:double { $arg * $arg };         -1e0 * local:square(7)
declare function local:square($arg as xs:double) as xs:double { $arg * $arg };         1e0 * local:square(7)
declare function local:square($arg as xs:double) as xs:double { $arg * $arg };         local:square(7) * -1e0
declare function local:square($arg as xs:double) as xs:double { $arg * $arg };         local:square(7) * 1e0
declare function local:square($arg as xs:double) as xs:double { $arg * $arg };         local:square(7) div -1e0
declare function local:square($arg as xs:double) as xs:double { $arg * $arg };         local:square(7) div 1e0
declare function local:square($arg as xs:double) as xs:double { $arg * $arg };         local:square(7) div xs:double('NaN')
declare function local:square($arg as xs:double) as xs:double { $arg * $arg };         local:square(7) * xs:double('NaN')
declare function local:square($arg as xs:double) as xs:double { $arg * $arg };         not( local:square(1e0) eq local:square(2e0) )
declare function local:square($arg as xs:double) as xs:double { $arg * $arg }; not( local:square(1e0) ge local:square(2e0) )
declare function local:square($arg as xs:double) as xs:double { $arg * $arg }; not( local:square(1e0) gt local:square(2e0) )
declare function local:square($arg as xs:double) as xs:double { $arg * $arg }; not( local:square(1e0) le local:square(2e0) )
declare function local:square($arg as xs:double) as xs:double { $arg * $arg }; not( local:square(1e0) lt local:square(2e0) )
declare function local:square($arg as xs:double) as xs:double { $arg * $arg };         not( local:square(1e0) ne local:square(2e0) )
declare function local:square($arg as xs:double) as xs:double { $arg * $arg }; not(not( local:square(1e0) ge local:square(2e0) ))
declare function local:square($arg as xs:double) as xs:double { $arg * $arg }; not(not( local:square(1e0) gt local:square(2e0) ))
declare function local:square($arg as xs:double) as xs:double { $arg * $arg }; not(not( local:square(1e0) le local:square(2e0) ))
declare function local:square($arg as xs:double) as xs:double { $arg * $arg }; not(not( local:square(1e0) lt local:square(2e0) ))
declare function local:square($arg as xs:double) as xs:double { $arg * $arg };         xs:double('NaN') div local:square(7)
declare function local:square($arg as xs:double) as xs:double { $arg * $arg };         xs:double('NaN') * local:square(7)
declare function local:square($arg as xs:float) as xs:float { $arg * $arg };         local:square(7) div xs:float(-1)
declare function local:square($arg as xs:float) as xs:float { $arg * $arg };         local:square(7) div xs:float(1)
declare function local:square($arg as xs:float) as xs:float { $arg * $arg };         local:square(7) div xs:float('NaN')
declare function local:square($arg as xs:float) as xs:float { $arg * $arg };         local:square(7) * xs:float(-1)
declare function local:square($arg as xs:float) as xs:float { $arg * $arg };         local:square(7) * xs:float(1)
declare function local:square($arg as xs:float) as xs:float { $arg * $arg };         local:square(7) * xs:float('NaN')
declare function local:square($arg as xs:float) as xs:float { $arg * $arg };         not( local:square(xs:float(1e0)) eq local:square(xs:float(2e0)) )
declare function local:square($arg as xs:float) as xs:float { $arg * $arg }; not( local:square(xs:float(1e0)) ge local:square(xs:float(2e0)) )
declare function local:square($arg as xs:float) as xs:float { $arg * $arg }; not( local:square(xs:float(1e0)) gt local:square(xs:float(2e0)) )
declare function local:square($arg as xs:float) as xs:float { $arg * $arg }; not( local:square(xs:float(1e0)) le local:square(xs:float(2e0)) )
declare function local:square($arg as xs:float) as xs:float { $arg * $arg }; not( local:square(xs:float(1e0)) lt local:square(xs:float(2e0)) )
declare function local:square($arg as xs:float) as xs:float { $arg * $arg };         not( local:square(xs:float(1e0)) ne local:square(xs:float(2e0)) )
declare function local:square($arg as xs:float) as xs:float { $arg * $arg }; not(not( local:square(xs:float(1e0)) ge local:square(xs:float(2e0)) ))
declare function local:square($arg as xs:float) as xs:float { $arg * $arg }; not(not( local:square(xs:float(1e0)) gt local:square(xs:float(2e0)) ))
declare function local:square($arg as xs:float) as xs:float { $arg * $arg }; not(not( local:square(xs:float(1e0)) le local:square(xs:float(2e0)) ))
declare function local:square($arg as xs:float) as xs:float { $arg * $arg }; not(not( local:square(xs:float(1e0)) lt local:square(xs:float(2e0)) ))
declare function local:square($arg as xs:float) as xs:float { $arg * $arg };         xs:float(-1) * local:square(7)
declare function local:square($arg as xs:float) as xs:float { $arg * $arg };         xs:float(1) * local:square(7)
declare function local:square($arg as xs:float) as xs:float { $arg * $arg };         xs:float('NaN') div local:square(7)
declare function local:square($arg as xs:float) as xs:float { $arg * $arg };         xs:float('NaN') * local:square(7)
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         0 * local:square(2)
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         -1 * local:square(7)
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         1 * local:square(7)
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         let $x := local:square(4) return 0 eq $x + 1
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         let $x := local:square(4) return 0 eq $x - 1
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         let $x := local:square(4) return 4 eq $x + 1
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         let $x := local:square(4) return 4 eq $x - 1
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         let $x := local:square(4) return 4 eq 1 + $x
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         let $x := local:square(4) return 4 eq 1 - $x
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         let $x := local:square(4) return -52676506002282294014967032012 eq $x + 52676506002282294014967032012
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         let $x := local:square(4) return 52676506002282294014967032012 eq $x - 52676506002282294014967032012
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         let $x := local:square(4) return -52676506002282294014967032012 eq 52676506002282294014967032012 + $x
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         let $x := local:square(4) return -52676506002282294014967032012 eq 52676506002282294014967032012 - $x
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         local:square(2) * 0
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         local:square(7) - 0
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         local:square(7) * -1
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         local:square(7) * 1
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         local:square(7) div -1
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         local:square(7) div 1
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         local:square(9223372036854775808) gt 0
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         not( local:square(1) eq local:square(2) )
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg }; not( local:square(1) ge local:square(2) )
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg }; not( local:square(1) gt local:square(2) )
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg }; not( local:square(1) le local:square(2) )
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg }; not( local:square(1) lt local:square(2) )
declare function local:square($arg as xs:integer) as xs:integer { $arg * $arg };         not( local:square(1) ne local:square(2) )
declare function local:tag($arg) as element() { element { 'tag' } { $arg } };         <element> { processing-instruction { 'pi' } { "content", local:tag('?&gt;') } } </element>
declare function local:test($test as xs:integer) as xs:integer? {            if ($test = 1) then ( 0 ) else if ($test = 2) then ( 9 ) else if ($test = 3) then ( 13 ) else if ($test = 4) then ( 16 ) else ()          };          fn:codepoints-to-string( local:test(1) to 32 )
declare function local:test($test as xs:integer) as xs:integer? {            if ($test = 1) then ( 0 ) else if ($test = 2) then ( 9 ) else if ($test = 3) then ( 13 ) else if ($test = 4) then ( 16 ) else ()          };          fn:codepoints-to-string( local:test(2) to 32 )
declare function local:test($test as xs:integer) as xs:integer? {          if ($test = 1) then ( 0 ) else if ($test = 2) then ( 9 ) else if ($test = 3) then ( 13 )else if ($test = 4) then ( 16 ) else ()        };        fn:codepoints-to-string( local:test(3) to 32 )
declare function local:test($test as xs:integer) as xs:integer? {          if ($test = 1) then ( 0 ) else if ($test = 2) then ( 9 ) else if ($test = 3) then ( 13 ) else if ($test = 4) then ( 16 ) else ()        };        fn:codepoints-to-string( local:test(4) to 32 )
declare function local:tf($i as xs:integer) as function () as xs:boolean {              if ($i) then true#0 else false#0          };          <out>{(local:tf(0)(), local:tf(1)())}</out>
declare function local:times-table($n as xs:integer) as xs:integer* { for $x in 1 to 12 return $x * $n }; (every $x in local:times-table(15) satisfies ($x mod 3 eq 0)) and (every $y in local:times-table(15) satisfies ($y mod 5 eq 0))
declare function local:times-table($n as xs:integer) as xs:integer* { for $x in 1 to 12 return $x * $n }; (some $x in local:times-table(15) satisfies ($x mod 2 eq 0)) or (some $y in local:times-table(15) satisfies ($y mod 3 eq 0))
declare function local:title($a_book as element()) { for $i in $a_book return $i/title };         /bib/book/(local:title(.))
declare function local:toc($book-or-section as element()) as element()* {              for $section in $book-or-section/section              return <section> { $section/@* , $section/title , local:toc($section) } </section> };         <toc> { for $s in /book return local:toc($s) } </toc>
declare function local:t() { text{""}, text{"["}, text{"3"}, text{"]"}, text{""} };          declare variable $var := (text{""}, text{"["}, text{"3"}, text{"]"}, text{""});          <out fromFunction="{local:t()}" fromVariable="{$var}"/>
declare function local:two-digit($number as xs:integer) { let $string := string($number) return if (string-length($string) lt 2) then concat('0', $string) else $string }; declare function local:date($year as xs:integer, $month as xs:integer, $day as xs:integer) { let $m := local:two-digit($month), $d := local:two-digit($day) return xs:date(concat($year, '-', $m, '-', $d)) }; not(local:date(2008, 05, 12) eq xs:date("1972-12-15"))
declare function local:two-digit($number as xs:integer) { let $string := string($number) return if (string-length($string) lt 2) then concat('0', $string) else $string };         declare function local:date($year as xs:integer, $month as xs:integer, $day as xs:integer) { let $m := local:two-digit($month), $d := local:two-digit($day) return xs:date(concat($year, '-', $m, '-', $d)) };         not(local:date(2008, 05, 12) ge xs:date("1972-12-15"))
declare function local:two-digit($number as xs:integer) { let $string := string($number) return if (string-length($string) lt 2) then concat('0', $string) else $string };         declare function local:date($year as xs:integer, $month as xs:integer, $day as xs:integer) { let $m := local:two-digit($month), $d := local:two-digit($day) return xs:date(concat($year, '-', $m, '-', $d)) };         not(local:date(2008, 05, 12) le xs:date("1972-12-15"))
declare function local:two-digit($number as xs:integer) {         let $string := string($number) return if (string-length($string) lt 2) then concat('0', $string) else $string         };         declare function local:date($year as xs:integer, $month as xs:integer, $day as xs:integer) {         let $m := local:two-digit($month), $d := local:two-digit($day) return xs:date(concat($year, '-', $m, '-', $d))         };         not(local:date(2008, 05, 12) lt xs:date("1972-12-15"))
declare function local:two-digit($number as xs:integer) { let $string := string($number) return if (string-length($string) lt 2) then concat('0', $string) else $string }; declare function local:date($year as xs:integer, $month as xs:integer, $day as xs:integer) { let $m := local:two-digit($month), $d := local:two-digit($day) return xs:date(concat($year, '-', $m, '-', $d)) };         not(local:date(2008, 05, 12) lt xs:date("1972-12-15"))
declare function local:two-digit($number as xs:integer) { let $string := string($number) return if (string-length($string) lt 2) then concat('0', $string) else $string }; declare function local:date($year as xs:integer, $month as xs:integer, $day as xs:integer) { let $m := local:two-digit($month), $d := local:two-digit($day) return xs:date(concat($year, '-', $m, '-', $d)) }; not(local:date(2008, 05, 12) ne xs:date("1972-12-15"))
declare function local:two-digit($number as xs:integer) {         let $string := string($number)         return if (string-length($string) lt 2) then concat('0', $string) else $string         };         declare function local:dateTime($year as xs:integer, $month as xs:integer, $day as xs:integer) {         let $m := local:two-digit($month), $d := local:two-digit($day)         return xs:dateTime(concat($year, '-', $m, '-', $d, "T12:00:00"))         };         not(local:dateTime(2008, 05, 12) eq xs:dateTime("1972-12-15T12:00:00"))
declare function local:two-digit($number as xs:integer) { let $string := string($number) return if (string-length($string) lt 2) then concat('0', $string) else $string }; declare function local:dateTime($year as xs:integer, $month as xs:integer, $day as xs:integer) { let $m := local:two-digit($month), $d := local:two-digit($day) return xs:dateTime(concat($year, '-', $m, '-', $d, "T12:00:00")) }; not(local:dateTime(2008, 05, 12) ge xs:dateTime("1972-12-15T12:00:00"))
declare function local:two-digit($number as xs:integer) { let $string := string($number) return if (string-length($string) lt 2) then concat('0', $string) else $string }; declare function local:dateTime($year as xs:integer, $month as xs:integer, $day as xs:integer) { let $m := local:two-digit($month), $d := local:two-digit($day) return xs:dateTime(concat($year, '-', $m, '-', $d, "T12:00:00")) }; not(local:dateTime(2008, 05, 12) gt xs:dateTime("1972-12-15T12:00:00"))
declare function local:two-digit($number as xs:integer) { let $string := string($number) return if (string-length($string) lt 2) then concat('0', $string) else $string }; declare function local:dateTime($year as xs:integer, $month as xs:integer, $day as xs:integer) { let $m := local:two-digit($month), $d := local:two-digit($day) return xs:dateTime(concat($year, '-', $m, '-', $d, "T12:00:00")) }; not(local:dateTime(2008, 05, 12) le xs:dateTime("1972-12-15T12:00:00"))
declare function local:two-digit($number as xs:integer) { let $string := string($number) return if (string-length($string) lt 2) then concat('0', $string) else $string }; declare function local:dateTime($year as xs:integer, $month as xs:integer, $day as xs:integer) { let $m := local:two-digit($month), $d := local:two-digit($day) return xs:dateTime(concat($year, '-', $m, '-', $d, "T12:00:00")) }; not(local:dateTime(2008, 05, 12) lt xs:dateTime("1972-12-15T12:00:00"))
declare function local:two-digit($number as xs:integer) {         let $string := string($number)         return if (string-length($string) lt 2) then concat('0', $string) else $string         };         declare function local:dateTime($year as xs:integer, $month as xs:integer, $day as xs:integer) {         let $m := local:two-digit($month), $d := local:two-digit($day)         return xs:dateTime(concat($year, '-', $m, '-', $d, "T12:00:00"))         };         not(local:dateTime(2008, 05, 12) ne xs:dateTime("1972-12-15T12:00:00"))
declare function local:value($number as xs:boolean) { if ($number) then 1 else xs:string('1') };         +(local:value(true()))
declare function local:value($number as xs:boolean) { if ($number) then 1 else xs:string('1') }; -(local:value(true()))
declare function local:value($number as xs:boolean) { if ($number) then 1 else xs:string('1') };         local:value(true()) idiv local:value(true())
declare function local:value($number as xs:boolean) { if ($number) then 1 else xs:string('1') };         local:value(true()) mod local:value(true())
declare function local:yearMonthDuration($yearMonthDuration as xs:yearMonthDuration, $null as xs:boolean) { if ($null) then () else $yearMonthDuration };         exists(local:yearMonthDuration(xs:yearMonthDuration("P0Y"), fn:true()) ge xs:yearMonthDuration("P0Y"))
declare function local:yearMonthDuration($yearMonthDuration as xs:yearMonthDuration, $null as xs:boolean) { if ($null) then () else $yearMonthDuration };         exists(local:yearMonthDuration(xs:yearMonthDuration("P0Y"), fn:true()) gt xs:yearMonthDuration("P0Y"))
declare function local:yearMonthDuration($yearMonthDuration as xs:yearMonthDuration, $null as xs:boolean) { if ($null) then () else $yearMonthDuration };         exists(local:yearMonthDuration(xs:yearMonthDuration("P0Y"), fn:true()) le xs:yearMonthDuration("P0Y"))
declare function local:yearMonthDuration($yearMonthDuration as xs:yearMonthDuration, $null as xs:boolean) { if ($null) then () else $yearMonthDuration };         exists(local:yearMonthDuration(xs:yearMonthDuration("P0Y"), fn:true()) lt xs:yearMonthDuration("P0Y"))
declare function local:yearMonthDuration($yearMonthDuration as xs:yearMonthDuration, $null as xs:boolean) { if ($null) then () else $yearMonthDuration };         local:yearMonthDuration(xs:yearMonthDuration("P0Y"), fn:false()) ge xs:yearMonthDuration("P0Y")
declare function local:yearMonthDuration($yearMonthDuration as xs:yearMonthDuration, $null as xs:boolean) { if ($null) then () else $yearMonthDuration };         local:yearMonthDuration(xs:yearMonthDuration("P0Y"), fn:false()) gt xs:yearMonthDuration("P0Y")
declare function local:yearMonthDuration($yearMonthDuration as xs:yearMonthDuration, $null as xs:boolean) { if ($null) then () else $yearMonthDuration };         local:yearMonthDuration(xs:yearMonthDuration("P0Y"), fn:false()) le xs:yearMonthDuration("P0Y")
declare function local:yearMonthDuration($yearMonthDuration as xs:yearMonthDuration, $null as xs:boolean) { if ($null) then () else $yearMonthDuration };         local:yearMonthDuration(xs:yearMonthDuration("P0Y"), fn:false()) lt xs:yearMonthDuration("P0Y")
declare function local:yearMonthDuration($years as xs:integer, $months as xs:integer ) { xs:yearMonthDuration(concat('P', $years, 'Y', $months, 'M')) };         local:yearMonthDuration(1, 1) + local:yearMonthDuration(1, 1)
declare function local:yearMonthDuration($years as xs:integer, $months as xs:integer ) { xs:yearMonthDuration(concat('P', $years, 'Y', $months, 'M')) };         local:yearMonthDuration(1, 1) - local:yearMonthDuration(1, 1)
declare function local:yearMonthDuration($years as xs:integer, $months as xs:integer ) { xs:yearMonthDuration(concat('P', $years, 'Y', $months, 'M')) };         local:yearMonthDuration(1, 1) + xs:yearMonthDuration("P0Y")
declare function local:yearMonthDuration($years as xs:integer, $months as xs:integer ) { xs:yearMonthDuration(concat('P', $years, 'Y', $months, 'M')) };         local:yearMonthDuration(1, 1) - xs:yearMonthDuration("P0Y")
declare function local:yearMonthDuration($years as xs:integer, $months as xs:integer ) { xs:yearMonthDuration(concat('P', $years, 'Y', $months, 'M')) };         not(local:yearMonthDuration(1, 1) eq xs:yearMonthDuration("P0Y"))
declare function local:yearMonthDuration($years as xs:integer, $months as xs:integer ) { xs:yearMonthDuration(concat('P', $years, 'Y', $months, 'M')) };         not(local:yearMonthDuration(1, 1) ge xs:yearMonthDuration("P0Y"))
declare function local:yearMonthDuration($years as xs:integer, $months as xs:integer ) { xs:yearMonthDuration(concat('P', $years, 'Y', $months, 'M')) };         not(local:yearMonthDuration(1, 1) gt xs:yearMonthDuration("P0Y"))
declare function local:yearMonthDuration($years as xs:integer, $months as xs:integer ) { xs:yearMonthDuration(concat('P', $years, 'Y', $months, 'M')) };         not(local:yearMonthDuration(1, 1) le xs:yearMonthDuration("P0Y"))
declare function local:yearMonthDuration($years as xs:integer, $months as xs:integer ) { xs:yearMonthDuration(concat('P', $years, 'Y', $months, 'M')) };         not(local:yearMonthDuration(1, 1) lt xs:yearMonthDuration("P0Y"))
declare function local:yearMonthDuration($years as xs:integer, $months as xs:integer ) { xs:yearMonthDuration(concat('P', $years, 'Y', $months, 'M')) };         not(local:yearMonthDuration(1, 1) ne xs:yearMonthDuration("P0Y"))
declare function local:yearMonthDuration($years as xs:integer, $months as xs:integer ) { xs:yearMonthDuration(concat('P', $years, 'Y', $months, 'M')) };         xs:yearMonthDuration("P0Y") + local:yearMonthDuration(1, 1)
declare function local:yearMonthDuration($years as xs:integer, $months as xs:integer ) { xs:yearMonthDuration(concat('P', $years, 'Y', $months, 'M')) };         xs:yearMonthDuration("-P768614336404564650Y") - local:yearMonthDuration(768614336404564650, 1)
declare function local:yearMonthDuration($years as xs:integer) as xs:yearMonthDuration { xs:yearMonthDuration(concat("P", $years, "Y")) };         0 * local:yearMonthDuration(2)
declare function local:yearMonthDuration($years as xs:integer) as xs:yearMonthDuration { xs:yearMonthDuration(concat("P", $years, "Y")) };         1 * local:yearMonthDuration(2)
declare function local:yearMonthDuration($years as xs:integer) as xs:yearMonthDuration { xs:yearMonthDuration(concat("P", $years, "Y")) };         local:yearMonthDuration(2) * 0
declare function local:yearMonthDuration($years as xs:integer) as xs:yearMonthDuration { xs:yearMonthDuration(concat("P", $years, "Y")) };         local:yearMonthDuration(2) * 1
declare function local:yearMonthDuration($years as xs:integer) as xs:yearMonthDuration { xs:yearMonthDuration(concat("P", $years, "Y")) };         local:yearMonthDuration(2) div 0
declare function local:yearMonthDuration($years as xs:integer) as xs:yearMonthDuration { xs:yearMonthDuration(concat("P", $years, "Y")) };         local:yearMonthDuration(2) div 1
declare function local:yearMonthDuration($years as xs:integer) as xs:yearMonthDuration { xs:yearMonthDuration(concat("P", $years, "Y")) };         local:yearMonthDuration(768614336404564650) div 0.5
declare function local:yes-empty($arg as xs:boolean) as xs:string? { if ($arg) then 'yes' else () };        boolean(fn:codepoint-equal( local:yes-empty(fn:false()), local:yes-empty(fn:true()) ) )
declare function local:yes-empty($arg as xs:boolean) as xs:string? { if ($arg) then 'yes' else () };        boolean(fn:codepoint-equal( local:yes-empty(fn:true()), local:yes-empty(fn:false()) ) )
declare function local:yes-empty($arg as xs:boolean) as xs:string? { if ($arg) then 'yes' else () };        empty(fn:codepoint-equal( local:yes-empty(fn:false()), local:yes-empty(fn:true()) ) )
declare function local:yes-empty($arg as xs:boolean) as xs:string? { if ($arg) then 'yes' else () };        empty(fn:codepoint-equal( local:yes-empty(fn:true()), local:yes-empty(fn:false()) ) )
declare function local:yes-no($arg as xs:boolean) as xs:string { if ($arg) then 'yes' else 'no' };        fn:codepoint-equal( local:yes-no(fn:true()), local:yes-no(fn:false()) ) = false()
declare function local:yes-no($arg as xs:boolean) as xs:string { if ($arg) then 'yes' else 'no' };        fn:index-of( (fn:true(), fn:false()), fn:codepoint-equal( local:yes-no(fn:false()), local:yes-no(fn:true()) ) )
declare function name
declare function Q{http://www.example.com/ns/my}fn ($a as xs:integer) as xs:integer { $a + 2 };          <out>{Q{http://www.example.com/ns/my}fn(12)}</out>
declare function wrongNS() { 1 };         1
declare function xml:foo() { 1 }; xml:foo()
declare function xml:wrongNS() { 1 };         1
declare function xs:foo() { 1 }; xs:foo()
declare function xs:gYear($arg as xs:anyAtomicType?) as xs:gYear? { xs:gYear($arg) };         1
declare %local:x variable $foo := "bar";          $foo
declare namespace abc = "gopher://spinaltap.micro.umn.edu/00/Weather/California/somefile"; <abc:someElement>some content</abc:someElement>
declare namespace abc = "http://www.example.com/abc"; let $var := <abc:someElement>some content</abc:someElement> return namespace-uri-from-QName(node-name($var)) eq xs:anyURI("http://www.example.com/abc")
declare namespace abc = "mailto:someuser@someserver.com"; <abc:someElement>some content</abc:someElement>
declare namespace a = "http://a.com"; map:size(<a><a:b>x</a:b></a>/map{self::a:b})
declare namespace a = "http://example.com/A"; declare namespace b = "http://example.com/A"; <e> { attribute a:localName {()}, attribute b:localName {()} } </e>
declare namespace a = "http://example.com";         <dot>           <a:b>key</a:b>           <c>value</c>         </dot>         !         map{a:b:c}         =>         deep-equal(map{"key":<c>value</c>})
declare namespace a = "http://example.com";         <dot>           <a:b>key</a:b>           <c>value</c>         </dot>         !         map{a:*:c}         =>         deep-equal(map{"key":<c>value</c>})
declare namespace a = "http://example.com";         <dot>           <a:b>key</a:b>           <c>value</c>         </dot>         !         map{*:b:c}         =>         deep-equal(map{"key":<c>value</c>})
declare namespace a = "http://example.com";         <dot>           <a:b>key</a:b>         </dot>         !         map{a:b:*}         =>         deep-equal(map{"key":<a:b xmlns:a="http://example.com">key</a:b>})
declare namespace a = "http://example.com";         <dot>           <a:b>key</a:b>         </dot>         !         map{a:*:*}         =>         deep-equal(map{"key":<a:b xmlns:a="http://example.com">key</a:b>})
declare namespace a = "http://example.com";         <dot>           <a:b>key</a:b>         </dot>         !         map{*:b:*}         =>          deep-equal(map{"key":<a:b xmlns:a="http://example.com">key</a:b>})
declare namespace a = "http://www.example.org/annotation";          declare %a:translucent("true") %a:translucent("false") function local:foo() {             "bar"          };          local:foo()
declare namespace a = "http://www.example.org/annotation";          declare %a:translucent("true") %a:translucent("false") variable $foo := "bar";          $foo
declare namespace array="http://www.w3.org/2005/xpath-functions/array";         declare variable $data := map {           "color" : "blue",           "closed" : true(),           "points" : [[10,10], [20,10], [20,20], [10,20]]         };               declare variable $stroke := attribute stroke { $data("color") };         declare variable $points := attribute points { array:flatten($data("points")) };         if ($data("closed")) then <svg><polygon>{ $stroke, $points }</polygon></svg>          else <svg><polyline>{ $stroke, $points }</polyline></svg>
declare namespace b = "http://b.com"; map:size(<a><b:b>x</b:b></a>/map{b:b})
declare namespace b = "http://www.example.com/"; empty(<e xmlns="http://www.example.com/"><d xmlns=""><b/></d></e>/b:d/b:b)
declare namespace cat ='mycat';          <a t='cat:miau'>42</a>
declare namespace dt = "http://www.w3.org/2001/XMLSchema";          <Q3> { //*[@dt:*] } </Q3>
declare namespace eg = "http://example.com";          declare %eg:integer(1+2) function local:foo() { 0 };           local:foo()
declare namespace eg = "http://example.com";          declare %eg:sequential function local:foo() {             "bar"          };          local:foo()
declare namespace eg = "http://example.com";          declare %eg:sequential variable $foo := "bar";          $foo
declare namespace eg = "http://example.com";          %eg:sequential("abc", 3) function () { "bar" } ()
declare namespace eg = "http://example.com";          %eg:sequential function () { "bar" } ()
declare namespace eg = "http://example.com";          %eg:sequential(true())  function () { "bar" } ()
declare namespace eg = "http://example.com";          % Q{http://example.com}sequential("abc", 3) function () { "bar" } ()
declare namespace eg = "http://example.org"; declare function eg:distinct-nodes-stable ($arg as node()*) as node()* { for $a at $apos in $arg let $before_a := fn:subsequence($arg, 1, $apos - 1) where every $ba in $before_a satisfies not($ba is $a) return $a }; let $arg1 := (<element1>some data 1</element1>,<element2>some data 2</element2>) return eg:distinct-nodes-stable($arg1)
declare namespace eg = "http://example.org"; declare function eg:if-absent ( $node as node()?, $value as xs:anyAtomicType) as xs:anyAtomicType* { if ($node) then fn:data($node) else $value }; let $arg1 := <element1>some data</element1> let $arg2 as xs:anyAtomicType := 1 return eg:if-absent($arg1,$arg2)
declare namespace eg = "http://example.org"; declare function eg:if-empty ( $node as node()?, $value as xs:anyAtomicType) as xs:anyAtomicType* { if ($node and $node/child::node()) then fn:data($node) else $value }; let $arg1 := <element1>some data</element1> let $arg2 as xs:anyAtomicType := 1 return eg:if-empty($arg1,$arg2)
declare namespace eg = "http://example.org"; declare function eg:index-of-node($sequence as node()*, $srch as node()) as xs:integer* { for $n at $i in $sequence where ($n is $srch) return $i }; let $arg1 := (<element1>some data 1</element1>,<element2>some data 2</element2>) let $arg2 := $arg1[2] return eg:index-of-node($arg1, exactly-one($arg2))
declare namespace eg = "http://example.org"; declare function eg:noContextFunction() { . }; eg:noContextFunction()
declare namespace eg = "http://example.org";          declare function eg:noContextFunction() { name };          eg:noContextFunction()
declare namespace eg = "http://example.org"; declare function eg:string-pad ( $padString as xs:string?, $padCount as xs:integer) as xs:string { fn:string-join((for $i in 1 to $padCount return $padString), "") }; let $arg1 as xs:string := "A String" let $arg2 as xs:integer := 3 return eg:string-pad($arg1,$arg2)
declare namespace e = "http://example.com/ANamespace"; declare variable $e:exampleComThisVarIsNotRecognized as element(*) external; 1
declare namespace e = "http://example.com/ANamespace"; declare variable $e:exampleComThisVarIsNotRecognized external; 1
declare namespace ex = "http://www.example.com/";           declare function local:userFunction() { document-node(element(local:ncname)) }; 1
declare namespace fn = "http://www.example.com/examples"; let $var := <fn:someElement>some context</fn:someElement> return $var
declare namespace foo:bar = "http://www.example.com/examples"; "aa"
declare namespace foo = "%gg"; true()
declare namespace foo = "http://example.com"; <foo:new/>
declare namespace foo = "http://example.com"; <new/>
declare namespace foo = "http://example.org"; <foo:bar> Lentils </foo:bar>
declare namespace foo="http://localhost/";         <a><foo:b/><foo:c/></a>/foo:b/self::foo:*
declare namespace foo="http://www.example.com/foo"; element elem {attribute foo:attr {'text'}}
declare namespace foo="http://www.example.com/foo"; element foo:elem {'text'}
declare namespace foo="http://www.example.com/prolog"; (<elem xmlns:foo="http://www.example.com/parent"><foo:child/></elem>)//*:child
declare namespace foo="http://www.example.com/prolog"; <foo:elem xmlns:foo="http://www.example.com/element"/>
declare namespace foo = "http://www.example.org"; declare function foo:something($type) as xs:integer { $type }; foo:something('foo')
declare namespace foo = "http://www.example.org"; declare function foo:something($type as xs:integer) as xs:integer { if ($type eq 1) then xs:date('2007-11-28') else $type }; foo:something(1)
declare namespace foo = "http://www.example.org"; declare function foo:something($type as xs:integer) { if ($type eq 1) then xs:date('2007-11-28') else 1.0 }; abs(foo:something(1))
declare namespace foo = "http://www.example.org"; declare function foo:something($type as xs:integer) { if ($type eq 1) then xs:date('2007-11-28') else 'foo' }; <e> { attribute { foo:something(1) } { } } </e>
declare namespace foo = "http://www.example.org"; declare function foo:something($type as xs:integer) { if ($type eq 1) then xs:date('2007-11-28') else 'foo' }; element { foo:something(1) } { }
declare namespace foo = "http://www.example.org"; declare function foo:something($type as xs:integer) { if ($type eq 1) then xs:date('2007-11-28') else 'foo' }; processing-instruction { foo:something(1) } { }
declare namespace foo = "http://www..oracle.com/xquery/test";         declare function foo:price ($b as element()) as element()* { $b/price };         1
declare namespace foo = "http://www..oracle.com/xquery/test";         declare function foo:price () as xs:integer+ { 100 };         declare function foo:price ($z as xs:integer) as xs:integer+ { $z };         declare function foo:price ($x as xs:integer, $y as xs:integer) as xs:integer+ { $x, $y };         declare function foo:price ($x as xs:integer, $y as xs:integer, $z as xs:integer) as xs:integer+ { $x+$y+$z };         foo:price(), foo:price(1), foo:price(2,3), foo:price(4,5,6)
declare namespace foo = "http://www.w3.org/XML/1998/namespace"; "a"
declare namespace foo="http://www.w3.org/XQueryTest/Construct"; <elem foo:attr="value"/>
declare namespace foo="test";         let $x := <a><foo:b/><c/><d/></a> return count($x/foo:* | $x/foo:*)
declare namespace fs="http://www.example.com/filesystem";          for $test as document-node() in (/) return ($test//fs:Folder)[1]/fs:FolderName
declare namespace fs="http://www.example.com/filesystem";          for $test as item() in data( (//fs:Folder)[1]/fs:File/fs:FileName ) return $test
declare namespace fs="http://www.example.com/filesystem";          for $test as item() in (//fs:Folder)[1]/fs:File/fs:FileName return $test
declare namespace fs="http://www.example.com/filesystem";          for $test as node() in (//fs:Folder)[1]/fs:File return $test/fs:FileName
declare namespace fs="http://www.example.com/filesystem";          for $test as processing-instruction() in (//fs:Folder)[1]//processing-instruction() return $test
declare namespace fs="http://www.example.com/filesystem"; for $test as processing-instruction() in (//fs:Folder)[1]//processing-instruction() return $test
declare namespace functx = "http://www.example.com/";                     (:~ : A path to an XML node (or sequence of nodes) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_path-to-node.html : @param $nodes the node sequence :)          declare function functx:path-to-node ( $nodes as node()* ) as xs:string* { $nodes/string-join(ancestor-or-self::*/name(.), '/') } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:path-to-node($in-xml/*[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : A path to an XML node (or sequence of nodes) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_path-to-node.html : @param $nodes the node sequence :)          declare function functx:path-to-node ( $nodes as node()* ) as xs:string* { $nodes/string-join(ancestor-or-self::*/name(.), '/') } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:path-to-node($in-xml//lName[. = 'Doe']))
declare namespace functx = "http://www.example.com/";                     (:~ : A path to an XML node (or sequence of nodes) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_path-to-node.html : @param $nodes the node sequence :)          declare function functx:path-to-node ( $nodes as node()* ) as xs:string* { $nodes/string-join(ancestor-or-self::*/name(.), '/') } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:path-to-node($in-xml//lName[. = 'Doe']), functx:path-to-node($in-xml/*[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : Capitalizes the first character of a string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_capitalize-first.html : @param $arg the word or phrase to capitalize :)          declare function functx:capitalize-first ( $arg as xs:string? ) as xs:string? { concat(upper-case(substring($arg,1,1)), substring($arg,2)) } ;                     (functx:capitalize-first('hello'))
declare namespace functx = "http://www.example.com/";                     (:~ : Capitalizes the first character of a string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_capitalize-first.html : @param $arg the word or phrase to capitalize :)          declare function functx:capitalize-first ( $arg as xs:string? ) as xs:string? { concat(upper-case(substring($arg,1,1)), substring($arg,2)) } ;                     (functx:capitalize-first('hello'), functx:capitalize-first('hello world'), functx:capitalize-first('Hello world'))
declare namespace functx = "http://www.example.com/";                     (:~ : Capitalizes the first character of a string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_capitalize-first.html : @param $arg the word or phrase to capitalize :)          declare function functx:capitalize-first ( $arg as xs:string? ) as xs:string? { concat(upper-case(substring($arg,1,1)), substring($arg,2)) } ;                     (functx:capitalize-first('hello world'))
declare namespace functx = "http://www.example.com/";                     (:~ : Capitalizes the first character of a string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_capitalize-first.html : @param $arg the word or phrase to capitalize :)          declare function functx:capitalize-first ( $arg as xs:string? ) as xs:string? { concat(upper-case(substring($arg,1,1)), substring($arg,2)) } ;                     (functx:capitalize-first('Hello world'))
declare namespace functx = "http://www.example.com/";                     (:~ : Capitalizes the first character of a string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_capitalize-first.html : @param $arg the word or phrase to capitalize :)          declare function functx:capitalize-first ( $arg as xs:string? ) as xs:string? { concat(upper-case(substring($arg,1,1)), substring($arg,2)) } ;                     (:~ : Turns a string of words into camelCase : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_words-to-camel-case.html : @param $arg the string to modify :)          declare function functx:words-to-camel-case ( $arg as xs:string? ) as xs:string { string-join((tokenize($arg,'\s+')[1], for $word in tokenize($arg,'\s+')[position() >                     1] return functx:capitalize-first($word)) ,'') } ;                     (functx:words-to-camel-case('this Is A Term'))
declare namespace functx = "http://www.example.com/";                     (:~ : Capitalizes the first character of a string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_capitalize-first.html : @param $arg the word or phrase to capitalize :)          declare function functx:capitalize-first ( $arg as xs:string? ) as xs:string? { concat(upper-case(substring($arg,1,1)), substring($arg,2)) } ;                     (:~ : Turns a string of words into camelCase : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_words-to-camel-case.html : @param $arg the string to modify :)          declare function functx:words-to-camel-case ( $arg as xs:string? ) as xs:string { string-join((tokenize($arg,'\s+')[1], for $word in tokenize($arg,'\s+')[position() >                     1] return functx:capitalize-first($word)) ,'') } ;                     (functx:words-to-camel-case( 'This is a term'))
declare namespace functx = "http://www.example.com/";                     (:~ : Capitalizes the first character of a string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_capitalize-first.html : @param $arg the word or phrase to capitalize :)          declare function functx:capitalize-first ( $arg as xs:string? ) as xs:string? { concat(upper-case(substring($arg,1,1)), substring($arg,2)) } ;                     (:~ : Turns a string of words into camelCase : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_words-to-camel-case.html : @param $arg the string to modify :)          declare function functx:words-to-camel-case ( $arg as xs:string? ) as xs:string { string-join((tokenize($arg,'\s+')[1], for $word in tokenize($arg,'\s+')[position() >                     1] return functx:capitalize-first($word)) ,'') } ;                     (functx:words-to-camel-case('this Is A Term'), functx:words-to-camel-case( 'This is a term'))
declare namespace functx = "http://www.example.com/";                     (:~ : Changes the namespace of XML elements and its descendants : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-ns-deep.html : @param $nodes the nodes to change : @param $newns the new namespace : @param $prefix the prefix to use for the new namespace :)          declare function functx:change-element-ns-deep ( $nodes as node()* , $newns as xs:string , $prefix as xs:string ) as node()* { for $node in $nodes return if ($node instance of element()) then (element {QName ($newns, concat($prefix, if ($prefix = '') then '' else ':', local-name($node)))} {$node/@*, functx:change-element-ns-deep($node/node(), $newns, $prefix)}) else if ($node instance of document-node()) then functx:change-element-ns-deep($node/node(), $newns, $prefix) else $node } ;                     let $in-xml := <bar:a xmlns:bar="http://bar"> <bar:b>557</bar:b> <bar:c>xyz</bar:c> </bar:a> return (functx:change-element-ns-deep( $in-xml, 'http://foo',''))
declare namespace functx = "http://www.example.com/";                     (:~ : Changes the namespace of XML elements and its descendants : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-ns-deep.html : @param $nodes the nodes to change : @param $newns the new namespace : @param $prefix the prefix to use for the new namespace :)          declare function functx:change-element-ns-deep ( $nodes as node()* , $newns as xs:string , $prefix as xs:string ) as node()* { for $node in $nodes return if ($node instance of element()) then (element {QName ($newns, concat($prefix, if ($prefix = '') then '' else ':', local-name($node)))} {$node/@*, functx:change-element-ns-deep($node/node(), $newns, $prefix)}) else if ($node instance of document-node()) then functx:change-element-ns-deep($node/node(), $newns, $prefix) else $node } ;                     let $in-xml := <bar:a xmlns:bar="http://bar"> <bar:b>557</bar:b> <bar:c>xyz</bar:c> </bar:a> return (functx:change-element-ns-deep( $in-xml, 'http://foo','foo'))
declare namespace functx = "http://www.example.com/";                     (:~ : Changes the namespace of XML elements and its descendants : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-ns-deep.html : @param $nodes the nodes to change : @param $newns the new namespace : @param $prefix the prefix to use for the new namespace :)          declare function functx:change-element-ns-deep ( $nodes as node()* , $newns as xs:string , $prefix as xs:string ) as node()* { for $node in $nodes return if ($node instance of element()) then (element {QName ($newns, concat($prefix, if ($prefix = '') then '' else ':', local-name($node)))} {$node/@*, functx:change-element-ns-deep($node/node(), $newns, $prefix)}) else if ($node instance of document-node()) then functx:change-element-ns-deep($node/node(), $newns, $prefix) else $node } ;                     let $in-xml := <bar:a xmlns:bar="http://bar"> <bar:b>557</bar:b> <bar:c>xyz</bar:c> </bar:a> return (functx:change-element-ns-deep( $in-xml, 'http://foo',''), functx:change-element-ns-deep( $in-xml, 'http://foo','foo'))
declare namespace functx = "http://www.example.com/";                     (:~ : Changes the namespace of XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-ns.html : @param $elements the elements to change : @param $newns the new namespace : @param $prefix the prefix to use for the new namespace :)          declare function functx:change-element-ns ( $elements as element()* , $newns as xs:string , $prefix as xs:string ) as element()? { for $element in $elements return element {QName ($newns, concat($prefix, if ($prefix = '') then '' else ':', local-name($element)))} {$element/@*, $element/node()} } ;                     let $in-xml := <bar:a xmlns:bar="http://bar"> <bar:b>557</bar:b> <bar:c>xyz</bar:c> </bar:a> return (functx:change-element-ns( $in-xml, 'http://foo',''))
declare namespace functx = "http://www.example.com/";                     (:~ : Changes the namespace of XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-ns.html : @param $elements the elements to change : @param $newns the new namespace : @param $prefix the prefix to use for the new namespace :)          declare function functx:change-element-ns ( $elements as element()* , $newns as xs:string , $prefix as xs:string ) as element()? { for $element in $elements return element {QName ($newns, concat($prefix, if ($prefix = '') then '' else ':', local-name($element)))} {$element/@*, $element/node()} } ;                     let $in-xml := <bar:a xmlns:bar="http://bar"> <bar:b>557</bar:b> <bar:c>xyz</bar:c> </bar:a> return (functx:change-element-ns( $in-xml, 'http://foo','foo'))
declare namespace functx = "http://www.example.com/";                     (:~ : Changes the namespace of XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_change-element-ns.html : @param $elements the elements to change : @param $newns the new namespace : @param $prefix the prefix to use for the new namespace :)          declare function functx:change-element-ns ( $elements as element()* , $newns as xs:string , $prefix as xs:string ) as element()? { for $element in $elements return element {QName ($newns, concat($prefix, if ($prefix = '') then '' else ':', local-name($element)))} {$element/@*, $element/node()} } ;                     let $in-xml := <bar:a xmlns:bar="http://bar"> <bar:b>557</bar:b> <bar:c>xyz</bar:c> </bar:a> return (functx:change-element-ns( $in-xml, 'http://foo',''), functx:change-element-ns( $in-xml, 'http://foo','foo'))
declare namespace functx = "http://www.example.com/";                     (:~ : Construct a dayTimeDuration from a number of days, hours, etc. : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_daytimeduration.html : @param $days the number of days : @param $hours the number of hours : @param $minutes the number of minutes : @param $seconds the number of seconds :)          declare function functx:dayTimeDuration ( $days as xs:decimal? , $hours as xs:decimal? , $minutes as xs:decimal? , $seconds as xs:decimal? ) as xs:dayTimeDuration { (xs:dayTimeDuration('P1D') * functx:if-empty($days,0)) + (xs:dayTimeDuration('PT1H') * functx:if-empty($hours,0)) + (xs:dayTimeDuration('PT1M') * functx:if-empty($minutes,0)) + (xs:dayTimeDuration('PT1S') * functx:if-empty($seconds,0)) } ;                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (functx:dayTimeDuration(0,0,0,0))
declare namespace functx = "http://www.example.com/";                     (:~ : Construct a dayTimeDuration from a number of days, hours, etc. : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_daytimeduration.html : @param $days the number of days : @param $hours the number of hours : @param $minutes the number of minutes : @param $seconds the number of seconds :)          declare function functx:dayTimeDuration ( $days as xs:decimal? , $hours as xs:decimal? , $minutes as xs:decimal? , $seconds as xs:decimal? ) as xs:dayTimeDuration { (xs:dayTimeDuration('P1D') * functx:if-empty($days,0)) + (xs:dayTimeDuration('PT1H') * functx:if-empty($hours,0)) + (xs:dayTimeDuration('PT1M') * functx:if-empty($minutes,0)) + (xs:dayTimeDuration('PT1S') * functx:if-empty($seconds,0)) } ;                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (functx:dayTimeDuration(0,0,5,0))
declare namespace functx = "http://www.example.com/";                     (:~ : Construct a dayTimeDuration from a number of days, hours, etc. : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_daytimeduration.html : @param $days the number of days : @param $hours the number of hours : @param $minutes the number of minutes : @param $seconds the number of seconds :)          declare function functx:dayTimeDuration ( $days as xs:decimal? , $hours as xs:decimal? , $minutes as xs:decimal? , $seconds as xs:decimal? ) as xs:dayTimeDuration { (xs:dayTimeDuration('P1D') * functx:if-empty($days,0)) + (xs:dayTimeDuration('PT1H') * functx:if-empty($hours,0)) + (xs:dayTimeDuration('PT1M') * functx:if-empty($minutes,0)) + (xs:dayTimeDuration('PT1S') * functx:if-empty($seconds,0)) } ;                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (functx:dayTimeDuration(1,6,0,0))
declare namespace functx = "http://www.example.com/";                     (:~ : Construct a dayTimeDuration from a number of days, hours, etc. : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_daytimeduration.html : @param $days the number of days : @param $hours the number of hours : @param $minutes the number of minutes : @param $seconds the number of seconds :)          declare function functx:dayTimeDuration ( $days as xs:decimal? , $hours as xs:decimal? , $minutes as xs:decimal? , $seconds as xs:decimal? ) as xs:dayTimeDuration { (xs:dayTimeDuration('P1D') * functx:if-empty($days,0)) + (xs:dayTimeDuration('PT1H') * functx:if-empty($hours,0)) + (xs:dayTimeDuration('PT1M') * functx:if-empty($minutes,0)) + (xs:dayTimeDuration('PT1S') * functx:if-empty($seconds,0)) } ;                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (functx:dayTimeDuration(2.5,0,0,0))
declare namespace functx = "http://www.example.com/";                     (:~ : Converts a string to a sequence of characters : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_chars.html : @param $arg the string to split :)          declare function functx:chars ( $arg as xs:string? ) as xs:string* { for $ch in string-to-codepoints($arg) return codepoints-to-string($ch) } ;                     (functx:chars('a b c'))
declare namespace functx = "http://www.example.com/";                     (:~ : Converts a string to a sequence of characters : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_chars.html : @param $arg the string to split :)          declare function functx:chars ( $arg as xs:string? ) as xs:string* { for $ch in string-to-codepoints($arg) return codepoints-to-string($ch) } ;                     (functx:chars('abc'))
declare namespace functx = "http://www.example.com/";                     (:~ : Converts a string to a sequence of characters : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_chars.html : @param $arg the string to split :)          declare function functx:chars ( $arg as xs:string? ) as xs:string* { for $ch in string-to-codepoints($arg) return codepoints-to-string($ch) } ;                     (functx:chars('abc'), functx:chars('a b c'))
declare namespace functx = "http://www.example.com/";                     (:~ : Copies attributes from one element to another : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_copy-attributes.html : @param $copyTo the element to copy attributes to : @param $copyFrom the element to copy attributes from :)          declare function functx:copy-attributes ( $copyTo as element() , $copyFrom as element() ) as element() { element { node-name($copyTo)} { $copyTo/@*[not(node-name(.) = $copyFrom/@*/node-name(.))], $copyFrom/@*, $copyTo/node() } } ;                     let $in-xml := <in-xml> <a>123</a>> <b x="1" y="2">456</b> <c x="9">123</c> <d z="5">123</d> </in-xml> return (functx:copy-attributes( $in-xml/a, $in-xml/b))
declare namespace functx = "http://www.example.com/";                     (:~ : Copies attributes from one element to another : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_copy-attributes.html : @param $copyTo the element to copy attributes to : @param $copyFrom the element to copy attributes from :)          declare function functx:copy-attributes ( $copyTo as element() , $copyFrom as element() ) as element() { element { node-name($copyTo)} { $copyTo/@*[not(node-name(.) = $copyFrom/@*/node-name(.))], $copyFrom/@*, $copyTo/node() } } ;                     let $in-xml := <in-xml> <a>123</a>> <b x="1" y="2">456</b> <c x="9">123</c> <d z="5">123</d> </in-xml> return (functx:copy-attributes( $in-xml/a, $in-xml/b), functx:copy-attributes( $in-xml/b, $in-xml/c), functx:copy-attributes( $in-xml/d, $in-xml/c))
declare namespace functx = "http://www.example.com/";                     (:~ : Copies attributes from one element to another : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_copy-attributes.html : @param $copyTo the element to copy attributes to : @param $copyFrom the element to copy attributes from :)          declare function functx:copy-attributes ( $copyTo as element() , $copyFrom as element() ) as element() { element { node-name($copyTo)} { $copyTo/@*[not(node-name(.) = $copyFrom/@*/node-name(.))], $copyFrom/@*, $copyTo/node() } } ;                     let $in-xml := <in-xml> <a>123</a>> <b x="1" y="2">456</b> <c x="9">123</c> <d z="5">123</d> </in-xml> return (functx:copy-attributes( $in-xml/b, $in-xml/c))
declare namespace functx = "http://www.example.com/";                     (:~ : Copies attributes from one element to another : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_copy-attributes.html : @param $copyTo the element to copy attributes to : @param $copyFrom the element to copy attributes from :)          declare function functx:copy-attributes ( $copyTo as element() , $copyFrom as element() ) as element() { element { node-name($copyTo)} { $copyTo/@*[not(node-name(.) = $copyFrom/@*/node-name(.))], $copyFrom/@*, $copyTo/node() } } ;                     let $in-xml := <in-xml> <a>123</a>> <b x="1" y="2">456</b> <c x="9">123</c> <d z="5">123</d> </in-xml> return (functx:copy-attributes( $in-xml/d, $in-xml/c))
declare namespace functx = "http://www.example.com/";        declare function functx:leaf-elements ( $root as node()? ) as element()* { $root/descendant-or-self::*[not(*)] } ;         let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author>                                   <author> <fName>John</fName> <lName>Doe</lName> </author>                         </authors>          return (functx:leaf-elements($in-xml))
declare namespace functx = "http://www.example.com/";         declare function functx:leaf-elements ( $root as node()? ) as element()* { $root/descendant-or-self::*[not(*)] } ;         let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author>                                   <author> <fName>John</fName> <lName>Doe</lName> </author>                         </authors>          return (functx:leaf-elements($in-xml/author[1]))
declare namespace functx = "http://www.example.com/";         declare function functx:leaf-elements ( $root as node()? ) as element()* { $root/descendant-or-self::*[not(*)] } ;         let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author>                                   <author> <fName>John</fName> <lName>Doe</lName> </author>                         </authors>          return (functx:leaf-elements($in-xml), functx:leaf-elements($in-xml/author[1]))
declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? {              for $element in $elements              return element { node-name($element)} {                 for $attrName at $seq in $attrNames                 return if ($element/@*[node-name(.) = $attrName]) then () else attribute {$attrName} {$attrValues[$seq]}, $element/@*, $element/node() }              } ;          let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml>           return (functx:add-attributes( $in-xml/a, QName('http://new','new:att1'), 1))
declare namespace functx = "http://www.example.com/";             declare namespace new = "http://new";             (:~                 : Adds attributes to XML elements :                 : @author Priscilla Walmsley, Datypic                 : @version 1.0                 : @see http://www.xqueryfunctions.com/xq/functx_add-attributes.html                 : @param $elements the element(s) to which you wish to add the attribute                 : @param $attrNames the name(s) of the attribute(s) to add                 : @param $attrValues the value(s) of the attribute(s) to add :)             declare function functx:add-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? {                 for $element in $elements return element { node-name($element)} {                    for $attrName at $seq in $attrNames return                                          if ($element/@*[node-name(.) = $attrName]) then () else attribute {$attrName} {$attrValues[$seq]}, $element/@*, $element/node() }              } ;             let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml>              return (functx:add-attributes( $in-xml/a, xs:QName('att1'), 1))
declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";          (:~              : Adds attributes to XML elements :              : @author Priscilla Walmsley, Datypic              : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-attributes.html              : @param $elements the element(s) to which you wish to add the attribute              : @param $attrNames the name(s) of the attribute(s) to add              : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? {              for $element in $elements              return element { node-name($element)} {                 for $attrName at $seq in $attrNames                 return if ($element/@*[node-name(.) = $attrName]) then () else attribute {$attrName} {$attrValues[$seq]}, $element/@*, $element/node() }           } ;          let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml>           return (functx:add-attributes( $in-xml/a, xs:QName('att1'), 1),                    functx:add-attributes( $in-xml/a, (xs:QName('att1'),xs:QName('att2')), (1,2)),                    functx:add-attributes( $in-xml/b, (xs:QName('att1'),xs:QName('att2')), (1,2)),                    functx:add-attributes( $in-xml/a, xs:QName('new:att1'), 1),                    functx:add-attributes( $in-xml/a, QName('http://new','new:att1'), 1))
declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";          (:~              : Adds attributes to XML elements :              : @author Priscilla Walmsley, Datypic              : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-attributes.html              : @param $elements the element(s) to which you wish to add the attribute              : @param $attrNames the name(s) of the attribute(s) to add              : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? {              for $element in $elements              return element { node-name($element)} {                 for $attrName at $seq in $attrNames                 return if ($element/@*[node-name(.) = $attrName]) then () else attribute {$attrName} {$attrValues[$seq]}, $element/@*, $element/node() }           } ;          let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml>           return (functx:add-attributes( $in-xml/a, (xs:QName('att1'),xs:QName('att2')), (1,2)))
declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? {              for $element in $elements return element { node-name($element)} {                 for $attrName at $seq in $attrNames                 return if ($element/@*[node-name(.) = $attrName]) then () else attribute {$attrName} {$attrValues[$seq]}, $element/@*, $element/node() }           } ;          let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml>           return (functx:add-attributes( $in-xml/a, xs:QName('new:att1'), 1))
declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";          (:~              : Adds attributes to XML elements :              : @author Priscilla Walmsley, Datypic              : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-attributes.html              : @param $elements the element(s) to which you wish to add the attribute              : @param $attrNames the name(s) of the attribute(s) to add              : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? {              for $element in $elements              return element { node-name($element)} {                 for $attrName at $seq in $attrNames                 return if ($element/@*[node-name(.) = $attrName]) then () else attribute {$attrName} {$attrValues[$seq]}, $element/@*, $element/node() }           } ;          let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml>           return (functx:add-attributes( $in-xml/b, (xs:QName('att1'),xs:QName('att2')), (1,2)))
declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-or-update-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-or-update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return attribute {$attrName} {$attrValues[$seq]}, $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml> return (functx:add-or-update-attributes( $in-xml/a, QName('http://new','new:att1'), 1))
declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-or-update-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-or-update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return attribute {$attrName} {$attrValues[$seq]}, $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml> return (functx:add-or-update-attributes( $in-xml/a, xs:QName('att1'), 1))
declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-or-update-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-or-update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return attribute {$attrName} {$attrValues[$seq]}, $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml> return (functx:add-or-update-attributes( $in-xml/a, xs:QName('att1'), 1), functx:add-or-update-attributes( $in-xml/a, (xs:QName('att1'),xs:QName('att2')), (1,2)), functx:add-or-update-attributes( $in-xml/b, (xs:QName('att1'),xs:QName('att2')), (1,2)), functx:add-or-update-attributes( $in-xml/a, xs:QName('new:att1'), 1), functx:add-or-update-attributes( $in-xml/a, QName('http://new','new:att1'), 1))
declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-or-update-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-or-update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return attribute {$attrName} {$attrValues[$seq]}, $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml> return (functx:add-or-update-attributes( $in-xml/a, (xs:QName('att1'),xs:QName('att2')), (1,2)))
declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-or-update-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-or-update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return attribute {$attrName} {$attrValues[$seq]}, $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml> return (functx:add-or-update-attributes( $in-xml/a, xs:QName('new:att1'), 1))
declare namespace functx = "http://www.example.com/";          declare namespace new = "http://new";                     (:~ : Adds attributes to XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_add-or-update-attributes.html : @param $elements the element(s) to which you wish to add the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:add-or-update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return attribute {$attrName} {$attrValues[$seq]}, $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml> <a>x</a> <b att1="x">x</b> </in-xml> return (functx:add-or-update-attributes( $in-xml/b, (xs:QName('att1'),xs:QName('att2')), (1,2)))
declare namespace functx = "http://www.example.com/";          declare namespace new = "http://newns";                     (:~ : Wraps a sequence of atomic values in XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_wrap-values-in-elements.html : @param $values the values to wrap in elements : @param $elementName the name of the elements to construct :)          declare function functx:wrap-values-in-elements ( $values as xs:anyAtomicType* , $elementName as xs:QName ) as element()* { for $value in $values return element {$elementName} {$value} } ;                     (functx:wrap-values-in-elements( (1,2,3), QName('http://newns','new:num')))
declare namespace functx = "http://www.example.com/";          declare namespace new = "http://newns";                     (:~ : Wraps a sequence of atomic values in XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_wrap-values-in-elements.html : @param $values the values to wrap in elements : @param $elementName the name of the elements to construct :)          declare function functx:wrap-values-in-elements ( $values as xs:anyAtomicType* , $elementName as xs:QName ) as element()* { for $value in $values return element {$elementName} {$value} } ;                     (functx:wrap-values-in-elements( (1,2,3), QName('http://newns','num')))
declare namespace functx = "http://www.example.com/";          declare namespace new = "http://newns";                     (:~ : Wraps a sequence of atomic values in XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_wrap-values-in-elements.html : @param $values the values to wrap in elements : @param $elementName the name of the elements to construct :)          declare function functx:wrap-values-in-elements ( $values as xs:anyAtomicType* , $elementName as xs:QName ) as element()* { for $value in $values return element {$elementName} {$value} } ;                     (functx:wrap-values-in-elements( (1,2,3), xs:QName('new:num')))
declare namespace functx = "http://www.example.com/";          declare namespace new = "http://newns";                     (:~ : Wraps a sequence of atomic values in XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_wrap-values-in-elements.html : @param $values the values to wrap in elements : @param $elementName the name of the elements to construct :)          declare function functx:wrap-values-in-elements ( $values as xs:anyAtomicType* , $elementName as xs:QName ) as element()* { for $value in $values return element {$elementName} {$value} } ;                     (functx:wrap-values-in-elements( (1,2,3), xs:QName('num')))
declare namespace functx = "http://www.example.com/";          declare namespace new = "http://newns";                     (:~ : Wraps a sequence of atomic values in XML elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_wrap-values-in-elements.html : @param $values the values to wrap in elements : @param $elementName the name of the elements to construct :)          declare function functx:wrap-values-in-elements ( $values as xs:anyAtomicType* , $elementName as xs:QName ) as element()* { for $value in $values return element {$elementName} {$value} } ;                     (functx:wrap-values-in-elements( (1,2,3), xs:QName('num')), functx:wrap-values-in-elements( (1,2,3), xs:QName('new:num')), functx:wrap-values-in-elements( (1,2,3), QName('http://newns','num')), functx:wrap-values-in-elements( (1,2,3), QName('http://newns','new:num')))
declare namespace functx = "http://www.example.com/";                     (:~ : Dynamically evaluates a simple XPath path : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_dynamic-path.html : @param $parent the root to start from : @param $path the path expression :)          declare function functx:dynamic-path ( $parent as node() , $path as xs:string ) as item()* { let $nextStep := functx:substring-before-if-contains($path,'/') let $restOfSteps := substring-after($path,'/') for $child in ($parent/*[functx:name-test(name(),$nextStep)], $parent/@*[functx:name-test(name(), substring-after($nextStep,'@'))]) return if ($restOfSteps) then functx:dynamic-path($child, $restOfSteps) else $child } ;                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     (:~ : Performs substring-before, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-before-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-before($arg,$delim) else $arg } ;                     let $in-xml := <authors> <author test="abc"> <first>Kate</first> <last>Jones</last> </author> <author> <first>John</first> <a:last xmlns:a="http://a">Doe</a:last> </author> </authors> return (functx:dynamic-path( $in-xml,'author'))
declare namespace functx = "http://www.example.com/";                     (:~ : Dynamically evaluates a simple XPath path : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_dynamic-path.html : @param $parent the root to start from : @param $path the path expression :)          declare function functx:dynamic-path ( $parent as node() , $path as xs:string ) as item()* { let $nextStep := functx:substring-before-if-contains($path,'/') let $restOfSteps := substring-after($path,'/') for $child in ($parent/*[functx:name-test(name(),$nextStep)], $parent/@*[functx:name-test(name(), substring-after($nextStep,'@'))]) return if ($restOfSteps) then functx:dynamic-path($child, $restOfSteps) else $child } ;                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     (:~ : Performs substring-before, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-before-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-before($arg,$delim) else $arg } ;                     let $in-xml := <authors> <author test="abc"> <first>Kate</first> <last>Jones</last> </author> <author> <first>John</first> <a:last xmlns:a="http://a">Doe</a:last> </author> </authors> return (functx:dynamic-path( $in-xml,'author/a:last'))
declare namespace functx = "http://www.example.com/";                     (:~ : Dynamically evaluates a simple XPath path : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_dynamic-path.html : @param $parent the root to start from : @param $path the path expression :)          declare function functx:dynamic-path ( $parent as node() , $path as xs:string ) as item()* { let $nextStep := functx:substring-before-if-contains($path,'/') let $restOfSteps := substring-after($path,'/') for $child in ($parent/*[functx:name-test(name(),$nextStep)], $parent/@*[functx:name-test(name(), substring-after($nextStep,'@'))]) return if ($restOfSteps) then functx:dynamic-path($child, $restOfSteps) else $child } ;                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     (:~ : Performs substring-before, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-before-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-before($arg,$delim) else $arg } ;                     let $in-xml := <authors> <author test="abc"> <first>Kate</first> <last>Jones</last> </author> <author> <first>John</first> <a:last xmlns:a="http://a">Doe</a:last> </author> </authors> return (functx:dynamic-path( $in-xml,'author/first'))
declare namespace functx = "http://www.example.com/";                     (:~ : Dynamically evaluates a simple XPath path : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_dynamic-path.html : @param $parent the root to start from : @param $path the path expression :)          declare function functx:dynamic-path ( $parent as node() , $path as xs:string ) as item()* { let $nextStep := functx:substring-before-if-contains($path,'/') let $restOfSteps := substring-after($path,'/') for $child in ($parent/*[functx:name-test(name(),$nextStep)], $parent/@*[functx:name-test(name(), substring-after($nextStep,'@'))]) return if ($restOfSteps) then functx:dynamic-path($child, $restOfSteps) else $child } ;                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     (:~ : Performs substring-before, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-before-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-before($arg,$delim) else $arg } ;                     let $in-xml := <authors> <author test="abc"> <first>Kate</first> <last>Jones</last> </author> <author> <first>John</first> <a:last xmlns:a="http://a">Doe</a:last> </author> </authors> return (name(functx:dynamic-path( $in-xml,'author/@test')))
declare namespace functx = "http://www.example.com/";                     (:~ : Gets XML element(s) that have an attribute with a particular value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_id-untyped.html : @param $node the root node(s) to start from : @param $id the "id" to find :)          declare function functx:id-untyped ( $node as node()* , $id as xs:anyAtomicType ) as element()* { $node//*[@* = $id] } ;                     let $in-xml := <in-xml> <a id="A001">abc</a> <b foo="A001">def</b> <c id="B001">ghi</c> </in-xml> return (functx:id-untyped($in-xml,'A001'))
declare namespace functx = "http://www.example.com/";                     (:~ : Gets XML element(s) that have an attribute with a particular value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_id-untyped.html : @param $node the root node(s) to start from : @param $id the "id" to find :)          declare function functx:id-untyped ( $node as node()* , $id as xs:anyAtomicType ) as element()* { $node//*[@* = $id] } ;                     let $in-xml := <in-xml> <a id="A001">abc</a> <b foo="A001">def</b> <c id="B001">ghi</c> </in-xml> return (functx:id-untyped($in-xml,'B001'))
declare namespace functx = "http://www.example.com/";                     (:~ : Gets XML element(s) that have an attribute with a particular value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_id-untyped.html : @param $node the root node(s) to start from : @param $id the "id" to find :)          declare function functx:id-untyped ( $node as node()* , $id as xs:anyAtomicType ) as element()* { $node//*[@* = $id] } ;                     let $in-xml := <in-xml> <a id="A001">abc</a> <b foo="A001">def</b> <c id="B001">ghi</c> </in-xml> return (functx:id-untyped($in-xml,'B001'), functx:id-untyped($in-xml,'A001'), functx:id-untyped($in-xml,'C001'))
declare namespace functx = "http://www.example.com/";                     (:~ : Gets XML element(s) that have an attribute with a particular value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_id-untyped.html : @param $node the root node(s) to start from : @param $id the "id" to find :)          declare function functx:id-untyped ( $node as node()* , $id as xs:anyAtomicType ) as element()* { $node//*[@* = $id] } ;                     let $in-xml := <in-xml> <a id="A001">abc</a> <b foo="A001">def</b> <c id="B001">ghi</c> </in-xml> return (functx:id-untyped($in-xml,'C001'))
declare namespace functx = "http://www.example.com/";                     (:~ : Inserts a string at a specified position : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_insert-string.html : @param $originalString the original string to insert into : @param $stringToInsert the string to insert : @param $pos the position :)          declare function functx:insert-string ( $originalString as xs:string? , $stringToInsert as xs:string? , $pos as xs:integer ) as xs:string { concat(substring($originalString,1,$pos - 1), $stringToInsert, substring($originalString,$pos)) } ;                     (functx:insert-string('','def',2))
declare namespace functx = "http://www.example.com/";                     (:~ : Inserts a string at a specified position : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_insert-string.html : @param $originalString the original string to insert into : @param $stringToInsert the string to insert : @param $pos the position :)          declare function functx:insert-string ( $originalString as xs:string? , $stringToInsert as xs:string? , $pos as xs:integer ) as xs:string { concat(substring($originalString,1,$pos - 1), $stringToInsert, substring($originalString,$pos)) } ;                     (functx:insert-string('xyz','',2))
declare namespace functx = "http://www.example.com/";                     (:~ : Inserts a string at a specified position : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_insert-string.html : @param $originalString the original string to insert into : @param $stringToInsert the string to insert : @param $pos the position :)          declare function functx:insert-string ( $originalString as xs:string? , $stringToInsert as xs:string? , $pos as xs:integer ) as xs:string { concat(substring($originalString,1,$pos - 1), $stringToInsert, substring($originalString,$pos)) } ;                     (functx:insert-string('xyz','def',2))
declare namespace functx = "http://www.example.com/";                     (:~ : Inserts a string at a specified position : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_insert-string.html : @param $originalString the original string to insert into : @param $stringToInsert the string to insert : @param $pos the position :)          declare function functx:insert-string ( $originalString as xs:string? , $stringToInsert as xs:string? , $pos as xs:integer ) as xs:string { concat(substring($originalString,1,$pos - 1), $stringToInsert, substring($originalString,$pos)) } ;                     (functx:insert-string('xyz','def',2), functx:insert-string('xyz','def',5), functx:insert-string('xyz','',2), functx:insert-string('','def',2))
declare namespace functx = "http://www.example.com/";                     (:~ : Inserts a string at a specified position : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_insert-string.html : @param $originalString the original string to insert into : @param $stringToInsert the string to insert : @param $pos the position :)          declare function functx:insert-string ( $originalString as xs:string? , $stringToInsert as xs:string? , $pos as xs:integer ) as xs:string { concat(substring($originalString,1,$pos - 1), $stringToInsert, substring($originalString,$pos)) } ;                     (functx:insert-string('xyz','def',5))
declare namespace functx = "http://www.example.com/";                     (:~ : Number of days in the month : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_days-in-month.html : @param $date the date :)          declare function functx:days-in-month ( $date as xs:anyAtomicType? ) as xs:integer? { if (month-from-date(xs:date($date)) = 2 and functx:is-leap-year($date)) then 29 else (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31) [month-from-date(xs:date($date))] } ;                     (:~ : Whether a date falls in a leap year : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-leap-year.html : @param $date the date or year :)          declare function functx:is-leap-year ( $date as xs:anyAtomicType? ) as xs:boolean { for $year in xs:integer(substring(string($date),1,4)) return ($year mod 4 = 0 and $year mod 100 != 0) or $year mod 400 = 0 } ;                     (functx:days-in-month('2005-02-15'))
declare namespace functx = "http://www.example.com/";                     (:~ : Number of days in the month : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_days-in-month.html : @param $date the date :)          declare function functx:days-in-month ( $date as xs:anyAtomicType? ) as xs:integer? { if (month-from-date(xs:date($date)) = 2 and functx:is-leap-year($date)) then 29 else (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31) [month-from-date(xs:date($date))] } ;                     (:~ : Whether a date falls in a leap year : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-leap-year.html : @param $date the date or year :)          declare function functx:is-leap-year ( $date as xs:anyAtomicType? ) as xs:boolean { for $year in xs:integer(substring(string($date),1,4)) return ($year mod 4 = 0 and $year mod 100 != 0) or $year mod 400 = 0 } ;                     (functx:days-in-month(xs:date('2004-01-23')))
declare namespace functx = "http://www.example.com/";                     (:~ : Number of days in the month : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_days-in-month.html : @param $date the date :)          declare function functx:days-in-month ( $date as xs:anyAtomicType? ) as xs:integer? { if (month-from-date(xs:date($date)) = 2 and functx:is-leap-year($date)) then 29 else (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31) [month-from-date(xs:date($date))] } ;                     (:~ : Whether a date falls in a leap year : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-leap-year.html : @param $date the date or year :)          declare function functx:is-leap-year ( $date as xs:anyAtomicType? ) as xs:boolean { for $year in xs:integer(substring(string($date),1,4)) return ($year mod 4 = 0 and $year mod 100 != 0) or $year mod 400 = 0 } ;                     (functx:days-in-month(xs:date('2004-01-23')), functx:days-in-month( xs:dateTime('2004-02-15T12:00:13')), functx:days-in-month('2005-02-15'))
declare namespace functx = "http://www.example.com/";                     (:~ : Number of days in the month : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_days-in-month.html : @param $date the date :)          declare function functx:days-in-month ( $date as xs:anyAtomicType? ) as xs:integer? { if (month-from-date(xs:date($date)) = 2 and functx:is-leap-year($date)) then 29 else (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31) [month-from-date(xs:date($date))] } ;                     (:~ : Whether a date falls in a leap year : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-leap-year.html : @param $date the date or year :)          declare function functx:is-leap-year ( $date as xs:anyAtomicType? ) as xs:boolean { for $year in xs:integer(substring(string($date),1,4)) return ($year mod 4 = 0 and $year mod 100 != 0) or $year mod 400 = 0 } ;                     (functx:days-in-month( xs:dateTime('2004-02-15T12:00:13')))
declare namespace functx = "http://www.example.com/";                     (:~ : Pads a string to a desired length : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-string-to-length.html : @param $stringToPad the string to pad : @param $padChar the character(s) to use as padding : @param $length the desired length :)          declare function functx:pad-string-to-length ( $stringToPad as xs:string? , $padChar as xs:string , $length as xs:integer ) as xs:string { substring( string-join ( ($stringToPad, for $i in (1 to $length) return $padChar) ,'') ,1,$length) } ;                     (functx:pad-string-to-length('', '*', 4))
declare namespace functx = "http://www.example.com/";                     (:~ : Pads a string to a desired length : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-string-to-length.html : @param $stringToPad the string to pad : @param $padChar the character(s) to use as padding : @param $length the desired length :)          declare function functx:pad-string-to-length ( $stringToPad as xs:string? , $padChar as xs:string , $length as xs:integer ) as xs:string { substring( string-join ( ($stringToPad, for $i in (1 to $length) return $padChar) ,'') ,1,$length) } ;                     (functx:pad-string-to-length('abc', '*', 6))
declare namespace functx = "http://www.example.com/";                     (:~ : Pads a string to a desired length : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-string-to-length.html : @param $stringToPad the string to pad : @param $padChar the character(s) to use as padding : @param $length the desired length :)          declare function functx:pad-string-to-length ( $stringToPad as xs:string? , $padChar as xs:string , $length as xs:integer ) as xs:string { substring( string-join ( ($stringToPad, for $i in (1 to $length) return $padChar) ,'') ,1,$length) } ;                     (functx:pad-string-to-length('abc', '*', 6), functx:pad-string-to-length('abcdef', '*', 4), functx:pad-string-to-length('', '*', 4))
declare namespace functx = "http://www.example.com/";                     (:~ : Pads a string to a desired length : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_pad-string-to-length.html : @param $stringToPad the string to pad : @param $padChar the character(s) to use as padding : @param $length the desired length :)          declare function functx:pad-string-to-length ( $stringToPad as xs:string? , $padChar as xs:string , $length as xs:integer ) as xs:string { substring( string-join ( ($stringToPad, for $i in (1 to $length) return $padChar) ,'') ,1,$length) } ;                     (functx:pad-string-to-length('abcdef', '*', 4))
declare namespace functx = "http://www.example.com/";                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     (functx:substring-after-if-contains('abcd','b'))
declare namespace functx = "http://www.example.com/";                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     (functx:substring-after-if-contains('abcd','b'), functx:substring-after-if-contains('abcd','x'))
declare namespace functx = "http://www.example.com/";                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     (functx:substring-after-if-contains('abcd','x'))
declare namespace functx = "http://www.example.com/";                     (:~ : Performs substring-before, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-before-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-before($arg,$delim) else $arg } ;                     (functx:substring-before-if-contains('abcd','c'))
declare namespace functx = "http://www.example.com/";                     (:~ : Performs substring-before, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-before-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-before($arg,$delim) else $arg } ;                     (functx:substring-before-if-contains('abcd','c'), functx:substring-before-if-contains('abcd','x'))
declare namespace functx = "http://www.example.com/";                     (:~ : Performs substring-before, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-before-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-before($arg,$delim) else $arg } ;                     (functx:substring-before-if-contains('abcd','x'))
declare namespace functx = "http://www.example.com/";                     (:~ : Reformats a number as an ordinal number, e.g. 1st, 2nd, 3rd. : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_ordinal-number-en.html : @param $num the number :)          declare function functx:ordinal-number-en ( $num as xs:integer? ) as xs:string { concat(xs:string($num), if (matches(xs:string($num),'[04-9]$|1[1-3]$')) then 'th' else if (ends-with(xs:string($num),'1')) then 'st' else if (ends-with(xs:string($num),'2')) then 'nd' else if (ends-with(xs:string($num),'3')) then 'rd' else '') } ;                     (functx:ordinal-number-en(1))
declare namespace functx = "http://www.example.com/";                     (:~ : Reformats a number as an ordinal number, e.g. 1st, 2nd, 3rd. : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_ordinal-number-en.html : @param $num the number :)          declare function functx:ordinal-number-en ( $num as xs:integer? ) as xs:string { concat(xs:string($num), if (matches(xs:string($num),'[04-9]$|1[1-3]$')) then 'th' else if (ends-with(xs:string($num),'1')) then 'st' else if (ends-with(xs:string($num),'2')) then 'nd' else if (ends-with(xs:string($num),'3')) then 'rd' else '') } ;                     (functx:ordinal-number-en(12))
declare namespace functx = "http://www.example.com/";                     (:~ : Reformats a number as an ordinal number, e.g. 1st, 2nd, 3rd. : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_ordinal-number-en.html : @param $num the number :)          declare function functx:ordinal-number-en ( $num as xs:integer? ) as xs:string { concat(xs:string($num), if (matches(xs:string($num),'[04-9]$|1[1-3]$')) then 'th' else if (ends-with(xs:string($num),'1')) then 'st' else if (ends-with(xs:string($num),'2')) then 'nd' else if (ends-with(xs:string($num),'3')) then 'rd' else '') } ;                     (functx:ordinal-number-en(1), functx:ordinal-number-en(12))
declare namespace functx = "http://www.example.com/";                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (functx:repeat-string('*', 6))
declare namespace functx = "http://www.example.com/";                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (functx:repeat-string('*', 6), functx:repeat-string('abc', 3))
declare namespace functx = "http://www.example.com/";                     (:~ : Repeats a string a given number of times : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_repeat-string.html : @param $stringToRepeat the string to repeat : @param $count the desired number of copies :)          declare function functx:repeat-string ( $stringToRepeat as xs:string? , $count as xs:integer ) as xs:string { string-join((for $i in 1 to $count return $stringToRepeat), '') } ;                     (functx:repeat-string('abc', 3))
declare namespace functx = "http://www.example.com/";                     (:~ : Returns the fragment from a URI : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_fragment-from-uri.html : @param $uri the URI :)          declare function functx:fragment-from-uri ( $uri as xs:string? ) as xs:string? { substring-after($uri,'#') } ;                     (functx:fragment-from-uri( 'http://datypic.com/index.htm'))
declare namespace functx = "http://www.example.com/";                     (:~ : Returns the fragment from a URI : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_fragment-from-uri.html : @param $uri the URI :)          declare function functx:fragment-from-uri ( $uri as xs:string? ) as xs:string? { substring-after($uri,'#') } ;                     (functx:fragment-from-uri( 'http://datypic.com/index.htm#abc'))
declare namespace functx = "http://www.example.com/";                     (:~ : Returns the fragment from a URI : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_fragment-from-uri.html : @param $uri the URI :)          declare function functx:fragment-from-uri ( $uri as xs:string? ) as xs:string? { substring-after($uri,'#') } ;                     (functx:fragment-from-uri( 'http://datypic.com/index.htm#abc'), functx:fragment-from-uri( 'http://datypic.com/index.htm'))
declare namespace functx = "http://www.example.com/";                     (:~ : Returns the scheme from a URI : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_scheme-from-uri.html : @param $uri the URI :)          declare function functx:scheme-from-uri ( $uri as xs:string? ) as xs:string? { substring-before($uri,':') } ;                     (functx:scheme-from-uri('ftp.datypic.com'))
declare namespace functx = "http://www.example.com/";                     (:~ : Returns the scheme from a URI : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_scheme-from-uri.html : @param $uri the URI :)          declare function functx:scheme-from-uri ( $uri as xs:string? ) as xs:string? { substring-before($uri,':') } ;                     (functx:scheme-from-uri( 'ftp://ftp.datypic.com'))
declare namespace functx = "http://www.example.com/";                     (:~ : Returns the scheme from a URI : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_scheme-from-uri.html : @param $uri the URI :)          declare function functx:scheme-from-uri ( $uri as xs:string? ) as xs:string? { substring-before($uri,':') } ;                     (functx:scheme-from-uri( 'http://www.datypic.com'))
declare namespace functx = "http://www.example.com/";                     (:~ : Returns the scheme from a URI : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_scheme-from-uri.html : @param $uri the URI :)          declare function functx:scheme-from-uri ( $uri as xs:string? ) as xs:string? { substring-before($uri,':') } ;                     (functx:scheme-from-uri( 'http://www.datypic.com'), functx:scheme-from-uri( 'ftp://ftp.datypic.com'), functx:scheme-from-uri('ftp.datypic.com'), functx:scheme-from-uri('www.datypic.com'), functx:scheme-from-uri('prod.html'))
declare namespace functx = "http://www.example.com/";                     (:~ : Returns the scheme from a URI : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_scheme-from-uri.html : @param $uri the URI :)          declare function functx:scheme-from-uri ( $uri as xs:string? ) as xs:string? { substring-before($uri,':') } ;                     (functx:scheme-from-uri('prod.html'))
declare namespace functx = "http://www.example.com/";                     (:~ : Returns the scheme from a URI : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_scheme-from-uri.html : @param $uri the URI :)          declare function functx:scheme-from-uri ( $uri as xs:string? ) as xs:string? { substring-before($uri,':') } ;                     (functx:scheme-from-uri('www.datypic.com'))
declare namespace functx = "http://www.example.com/";                     (:~ : Reverses the order of characters : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_reverse-string.html : @param $arg the string to reverse :)          declare function functx:reverse-string ( $arg as xs:string? ) as xs:string { codepoints-to-string(reverse(string-to-codepoints($arg))) } ;                     (functx:reverse-string('a'))
declare namespace functx = "http://www.example.com/";                     (:~ : Reverses the order of characters : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_reverse-string.html : @param $arg the string to reverse :)          declare function functx:reverse-string ( $arg as xs:string? ) as xs:string { codepoints-to-string(reverse(string-to-codepoints($arg))) } ;                     (functx:reverse-string('abc'))
declare namespace functx = "http://www.example.com/";                     (:~ : Reverses the order of characters : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_reverse-string.html : @param $arg the string to reverse :)          declare function functx:reverse-string ( $arg as xs:string? ) as xs:string { codepoints-to-string(reverse(string-to-codepoints($arg))) } ;                     (functx:reverse-string('abc'), functx:reverse-string('a'))
declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of nodes in document order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort-document-order.html : @param $seq the sequence to sort :)          declare function functx:sort-document-order ( $seq as node()* ) as node()* { $seq/. } ;                     let $in-xml := <in-xml> <a>123</a> <b>456</b> <c>789</c> </in-xml> return (functx:sort-document-order( ($in-xml/c,$in-xml/a)))
declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of numeric values or nodes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort-as-numeric.html : @param $seq the sequence to sort :)          declare function functx:sort-as-numeric ( $seq as item()* ) as item()* { for $item in $seq order by number($item) return $item } ;                     let $in-xml := <in-xml> <f>1</f> <f>35</f> <e>4</e> </in-xml> return (functx:sort-as-numeric($in-xml/*))
declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of numeric values or nodes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort-as-numeric.html : @param $seq the sequence to sort :)          declare function functx:sort-as-numeric ( $seq as item()* ) as item()* { for $item in $seq order by number($item) return $item } ;                     let $in-xml := <in-xml> <f>1</f> <f>35</f> <e>4</e> </in-xml> return (functx:sort-as-numeric(('1','100','99')))
declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of values or nodes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort.html : @param $seq the sequence to sort :)          declare function functx:sort ( $seq as item()* ) as item()* { for $item in $seq order by $item return $item } ;                     let $in-xml := <in-xml> <f>c</f> <f>a</f> <e>b</e> </in-xml> return (functx:sort($in-xml/*))
declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of values or nodes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort.html : @param $seq the sequence to sort :)          declare function functx:sort ( $seq as item()* ) as item()* { for $item in $seq order by $item return $item } ;                     let $in-xml := <in-xml> <f>c</f> <f>a</f> <e>b</e> </in-xml> return (functx:sort(('c','a','b')))
declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of values or nodes regardless of capitalization : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort-case-insensitive.html : @param $seq the sequence to sort :)          declare function functx:sort-case-insensitive ( $seq as item()* ) as item()* { for $item in $seq order by upper-case(string($item)) return $item } ;                     let $in-xml := <in-xml> <f>a</f> <f>c</f> <e>B</e> </in-xml> return (functx:sort-case-insensitive($in-xml/*))
declare namespace functx = "http://www.example.com/";                     (:~ : Sorts a sequence of values or nodes regardless of capitalization : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sort-case-insensitive.html : @param $seq the sequence to sort :)          declare function functx:sort-case-insensitive ( $seq as item()* ) as item()* { for $item in $seq order by upper-case(string($item)) return $item } ;                     let $in-xml := <in-xml> <f>a</f> <f>c</f> <e>B</e> </in-xml> return (functx:sort-case-insensitive(('a','c','B')))
declare namespace functx = "http://www.example.com/";                     (:~ : Split a string into separate lines : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_lines.html : @param $arg the string to split :)          declare function functx:lines ( $arg as xs:string? ) as xs:string* { tokenize($arg, '(\r\n?|\n\r?)') } ;                     let $in-xml := <in-xml>a value on many lines</in-xml> return (functx:lines($in-xml))
declare namespace functx = "http://www.example.com/";                     (:~ : Split a string into separate lines : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_lines.html : @param $arg the string to split :)          declare function functx:lines ( $arg as xs:string? ) as xs:string* { tokenize($arg, '(\r\n?|\n\r?)') } ;                     let $in-xml := <in-xml>a value on many lines</in-xml> return (functx:lines('a value'))
declare namespace functx = "http://www.example.com/";                     (:~ : Split a string into separate lines : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_lines.html : @param $arg the string to split :)          declare function functx:lines ( $arg as xs:string? ) as xs:string* { tokenize($arg, '(\r\n?|\n\r?)') } ;                     let $in-xml := <in-xml>a value on many lines</in-xml> return (functx:lines('a value'), functx:lines($in-xml))
declare namespace functx = "http://www.example.com/";                     (:~ : Split a string into separate lines : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_lines.html : @param $arg the string to split :)          declare function functx:lines ( $arg as xs:string? ) as xs:string* { tokenize($arg, '(\r\n?|\n\r?)') } ;                     (:~ : The maximum line length : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-line-length.html : @param $arg the string to test :)          declare function functx:max-line-length ( $arg as xs:string? ) as xs:integer? { max( for $line in functx:lines($arg) return string-length($line)) } ;  let $lines := 'a       value       on       several      lines'           return (functx:max-line-length($lines))
declare namespace functx = "http://www.example.com/";                     (:~ : Split a string into separate lines : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_lines.html : @param $arg the string to split :)          declare function functx:lines ( $arg as xs:string? ) as xs:string* { tokenize($arg, '(\r\n?|\n\r?)') } ;                     (:~ : The maximum line length : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-line-length.html : @param $arg the string to test :)          declare function functx:max-line-length ( $arg as xs:string? ) as xs:integer? { max( for $line in functx:lines($arg) return string-length($line)) } ;                     let $lines := 'a value on several lines' return (functx:max-line-length('a value'))
declare namespace functx = "http://www.example.com/";                     (:~ : Split a string into separate lines : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_lines.html : @param $arg the string to split :)          declare function functx:lines ( $arg as xs:string? ) as xs:string* { tokenize($arg, '(\r\n?|\n\r?)') } ;                     (:~ : The maximum line length : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-line-length.html : @param $arg the string to test :)          declare function functx:max-line-length ( $arg as xs:string? ) as xs:integer? { max( for $line in functx:lines($arg) return string-length($line)) } ; let $lines := 'a       value       on       several      lines'           return (functx:max-line-length('a value'), functx:max-line-length($lines))
declare namespace functx = "http://www.example.com/";                     (:~ : The abbreviated day of the week, from a date, in English : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week-abbrev-en.html : @param $date the date :)          declare function functx:day-of-week-abbrev-en ( $date as xs:anyAtomicType? ) as xs:string? { ('Sun', 'Mon', 'Tues', 'Wed', 'Thurs', 'Fri', 'Sat') [functx:day-of-week($date) + 1] } ;                     (:~ : The day of the week, from a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week.html : @param $date the date :)          declare function functx:day-of-week ( $date as xs:anyAtomicType? ) as xs:integer? { if (empty($date)) then () else xs:integer((xs:date($date) - xs:date('1901-01-06')) div xs:dayTimeDuration('P1D')) mod 7 } ;                     (functx:day-of-week-abbrev-en('2004-11-04'))
declare namespace functx = "http://www.example.com/";                     (:~ : The abbreviated day of the week, from a date, in English : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week-abbrev-en.html : @param $date the date :)          declare function functx:day-of-week-abbrev-en ( $date as xs:anyAtomicType? ) as xs:string? { ('Sun', 'Mon', 'Tues', 'Wed', 'Thurs', 'Fri', 'Sat') [functx:day-of-week($date) + 1] } ;                     (:~ : The day of the week, from a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week.html : @param $date the date :)          declare function functx:day-of-week ( $date as xs:anyAtomicType? ) as xs:integer? { if (empty($date)) then () else xs:integer((xs:date($date) - xs:date('1901-01-06')) div xs:dayTimeDuration('P1D')) mod 7 } ;                     (functx:day-of-week-abbrev-en( xs:date('2004-11-04')))
declare namespace functx = "http://www.example.com/";                     (:~ : The abbreviated day of the week, from a date, in English : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week-abbrev-en.html : @param $date the date :)          declare function functx:day-of-week-abbrev-en ( $date as xs:anyAtomicType? ) as xs:string? { ('Sun', 'Mon', 'Tues', 'Wed', 'Thurs', 'Fri', 'Sat') [functx:day-of-week($date) + 1] } ;                     (:~ : The day of the week, from a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week.html : @param $date the date :)          declare function functx:day-of-week ( $date as xs:anyAtomicType? ) as xs:integer? { if (empty($date)) then () else xs:integer((xs:date($date) - xs:date('1901-01-06')) div xs:dayTimeDuration('P1D')) mod 7 } ;                     (functx:day-of-week-abbrev-en( xs:date('2004-11-04')), functx:day-of-week-abbrev-en('2004-11-04'))
declare namespace functx = "http://www.example.com/";                     (:~ : The average, counting "empty" values as zero : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_avg-empty-is-zero.html : @param $values the values to be averaged : @param $allNodes the sequence of all nodes to find the average over :)          declare function functx:avg-empty-is-zero ( $values as xs:anyAtomicType* , $allNodes as node()* ) as xs:double { if (empty($allNodes)) then 0 else sum($values[string(.) != '']) div count($allNodes) } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="69.99"/> <price value="49.99" discount=""/> </prices> return (functx:avg-empty-is-zero( $in-xml//price/@discount, $in-xml//price))
declare namespace functx = "http://www.example.com/";                     (:~ : The built-in type of an atomic value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_atomic-type.html : @param $values the value(s) whose type you want to determine :)          declare function functx:atomic-type ( $values as xs:anyAtomicType* ) as xs:string* { for $val in $values return (if ($val instance of xs:untypedAtomic) then 'xs:untypedAtomic' else if ($val instance of xs:anyURI) then 'xs:anyURI' else if ($val instance of xs:ENTITY) then 'xs:ENTITY' else if ($val instance of xs:ID) then 'xs:ID' else if ($val instance of xs:NMTOKEN) then 'xs:NMTOKEN' else if ($val instance of xs:language) then 'xs:language' else if ($val instance of xs:NCName) then 'xs:NCName' else if ($val instance of xs:Name) then 'xs:Name' else if ($val instance of xs:token) then 'xs:token' else if ($val instance of xs:normalizedString) then 'xs:normalizedString' else if ($val instance of xs:string) then 'xs:string' else if ($val instance of xs:QName) then 'xs:QName' else if ($val instance of xs:boolean) then 'xs:boolean' else if ($val instance of xs:base64Binary) then 'xs:base64Binary' else if ($val instance of xs:hexBinary) then 'xs:hexBinary' else if ($val instance of xs:byte) then 'xs:byte' else if ($val instance of xs:short) then 'xs:short' else if ($val instance of xs:int) then 'xs:int' else if ($val instance of xs:long) then 'xs:long' else if ($val instance of xs:unsignedByte) then 'xs:unsignedByte' else if ($val instance of xs:unsignedShort) then 'xs:unsignedShort' else if ($val instance of xs:unsignedInt) then 'xs:unsignedInt' else if ($val instance of xs:unsignedLong) then 'xs:unsignedLong' else if ($val instance of xs:positiveInteger) then 'xs:positiveInteger' else if ($val instance of xs:nonNegativeInteger) then 'xs:nonNegativeInteger' else if ($val instance of xs:negativeInteger) then 'xs:negativeInteger' else if ($val instance of xs:nonPositiveInteger) then 'xs:nonPositiveInteger' else if ($val instance of xs:integer) then 'xs:integer' else if ($val instance of xs:decimal) then 'xs:decimal' else if ($val instance of xs:float) then 'xs:float' else if ($val instance of xs:double) then 'xs:double' else if ($val instance of xs:date) then 'xs:date' else if ($val instance of xs:time) then 'xs:time' else if ($val instance of xs:dateTime) then 'xs:dateTime' else if ($val instance of xs:dayTimeDuration) then 'xs:dayTimeDuration' else if ($val instance of xs:yearMonthDuration) then 'xs:yearMonthDuration' else if ($val instance of xs:duration) then 'xs:duration' else if ($val instance of xs:gMonth) then 'xs:gMonth' else if ($val instance of xs:gYear) then 'xs:gYear' else if ($val instance of xs:gYearMonth) then 'xs:gYearMonth' else if ($val instance of xs:gDay) then 'xs:gDay' else if ($val instance of xs:gMonthDay) then 'xs:gMonthDay' else 'unknown') } ;                     (functx:atomic-type(2))
declare namespace functx = "http://www.example.com/";                     (:~ : The built-in type of an atomic value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_atomic-type.html : @param $values the value(s) whose type you want to determine :)          declare function functx:atomic-type ( $values as xs:anyAtomicType* ) as xs:string* { for $val in $values return (if ($val instance of xs:untypedAtomic) then 'xs:untypedAtomic' else if ($val instance of xs:anyURI) then 'xs:anyURI' else if ($val instance of xs:ENTITY) then 'xs:ENTITY' else if ($val instance of xs:ID) then 'xs:ID' else if ($val instance of xs:NMTOKEN) then 'xs:NMTOKEN' else if ($val instance of xs:language) then 'xs:language' else if ($val instance of xs:NCName) then 'xs:NCName' else if ($val instance of xs:Name) then 'xs:Name' else if ($val instance of xs:token) then 'xs:token' else if ($val instance of xs:normalizedString) then 'xs:normalizedString' else if ($val instance of xs:string) then 'xs:string' else if ($val instance of xs:QName) then 'xs:QName' else if ($val instance of xs:boolean) then 'xs:boolean' else if ($val instance of xs:base64Binary) then 'xs:base64Binary' else if ($val instance of xs:hexBinary) then 'xs:hexBinary' else if ($val instance of xs:byte) then 'xs:byte' else if ($val instance of xs:short) then 'xs:short' else if ($val instance of xs:int) then 'xs:int' else if ($val instance of xs:long) then 'xs:long' else if ($val instance of xs:unsignedByte) then 'xs:unsignedByte' else if ($val instance of xs:unsignedShort) then 'xs:unsignedShort' else if ($val instance of xs:unsignedInt) then 'xs:unsignedInt' else if ($val instance of xs:unsignedLong) then 'xs:unsignedLong' else if ($val instance of xs:positiveInteger) then 'xs:positiveInteger' else if ($val instance of xs:nonNegativeInteger) then 'xs:nonNegativeInteger' else if ($val instance of xs:negativeInteger) then 'xs:negativeInteger' else if ($val instance of xs:nonPositiveInteger) then 'xs:nonPositiveInteger' else if ($val instance of xs:integer) then 'xs:integer' else if ($val instance of xs:decimal) then 'xs:decimal' else if ($val instance of xs:float) then 'xs:float' else if ($val instance of xs:double) then 'xs:double' else if ($val instance of xs:date) then 'xs:date' else if ($val instance of xs:time) then 'xs:time' else if ($val instance of xs:dateTime) then 'xs:dateTime' else if ($val instance of xs:dayTimeDuration) then 'xs:dayTimeDuration' else if ($val instance of xs:yearMonthDuration) then 'xs:yearMonthDuration' else if ($val instance of xs:duration) then 'xs:duration' else if ($val instance of xs:gMonth) then 'xs:gMonth' else if ($val instance of xs:gYear) then 'xs:gYear' else if ($val instance of xs:gYearMonth) then 'xs:gYearMonth' else if ($val instance of xs:gDay) then 'xs:gDay' else if ($val instance of xs:gMonthDay) then 'xs:gMonthDay' else 'unknown') } ;                     (functx:atomic-type( (2,'abc',xs:date('2005-12-15'))))
declare namespace functx = "http://www.example.com/";                     (:~ : The built-in type of an atomic value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_atomic-type.html : @param $values the value(s) whose type you want to determine :)          declare function functx:atomic-type ( $values as xs:anyAtomicType* ) as xs:string* { for $val in $values return (if ($val instance of xs:untypedAtomic) then 'xs:untypedAtomic' else if ($val instance of xs:anyURI) then 'xs:anyURI' else if ($val instance of xs:ENTITY) then 'xs:ENTITY' else if ($val instance of xs:ID) then 'xs:ID' else if ($val instance of xs:NMTOKEN) then 'xs:NMTOKEN' else if ($val instance of xs:language) then 'xs:language' else if ($val instance of xs:NCName) then 'xs:NCName' else if ($val instance of xs:Name) then 'xs:Name' else if ($val instance of xs:token) then 'xs:token' else if ($val instance of xs:normalizedString) then 'xs:normalizedString' else if ($val instance of xs:string) then 'xs:string' else if ($val instance of xs:QName) then 'xs:QName' else if ($val instance of xs:boolean) then 'xs:boolean' else if ($val instance of xs:base64Binary) then 'xs:base64Binary' else if ($val instance of xs:hexBinary) then 'xs:hexBinary' else if ($val instance of xs:byte) then 'xs:byte' else if ($val instance of xs:short) then 'xs:short' else if ($val instance of xs:int) then 'xs:int' else if ($val instance of xs:long) then 'xs:long' else if ($val instance of xs:unsignedByte) then 'xs:unsignedByte' else if ($val instance of xs:unsignedShort) then 'xs:unsignedShort' else if ($val instance of xs:unsignedInt) then 'xs:unsignedInt' else if ($val instance of xs:unsignedLong) then 'xs:unsignedLong' else if ($val instance of xs:positiveInteger) then 'xs:positiveInteger' else if ($val instance of xs:nonNegativeInteger) then 'xs:nonNegativeInteger' else if ($val instance of xs:negativeInteger) then 'xs:negativeInteger' else if ($val instance of xs:nonPositiveInteger) then 'xs:nonPositiveInteger' else if ($val instance of xs:integer) then 'xs:integer' else if ($val instance of xs:decimal) then 'xs:decimal' else if ($val instance of xs:float) then 'xs:float' else if ($val instance of xs:double) then 'xs:double' else if ($val instance of xs:date) then 'xs:date' else if ($val instance of xs:time) then 'xs:time' else if ($val instance of xs:dateTime) then 'xs:dateTime' else if ($val instance of xs:dayTimeDuration) then 'xs:dayTimeDuration' else if ($val instance of xs:yearMonthDuration) then 'xs:yearMonthDuration' else if ($val instance of xs:duration) then 'xs:duration' else if ($val instance of xs:gMonth) then 'xs:gMonth' else if ($val instance of xs:gYear) then 'xs:gYear' else if ($val instance of xs:gYearMonth) then 'xs:gYearMonth' else if ($val instance of xs:gDay) then 'xs:gDay' else if ($val instance of xs:gMonthDay) then 'xs:gMonthDay' else 'unknown') } ;                     (functx:atomic-type(2), functx:atomic-type('abc'), functx:atomic-type(xs:date('2005-12-15')), functx:atomic-type( (2,'abc',xs:date('2005-12-15'))))
declare namespace functx = "http://www.example.com/";                     (:~ : The built-in type of an atomic value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_atomic-type.html : @param $values the value(s) whose type you want to determine :)          declare function functx:atomic-type ( $values as xs:anyAtomicType* ) as xs:string* { for $val in $values return (if ($val instance of xs:untypedAtomic) then 'xs:untypedAtomic' else if ($val instance of xs:anyURI) then 'xs:anyURI' else if ($val instance of xs:ENTITY) then 'xs:ENTITY' else if ($val instance of xs:ID) then 'xs:ID' else if ($val instance of xs:NMTOKEN) then 'xs:NMTOKEN' else if ($val instance of xs:language) then 'xs:language' else if ($val instance of xs:NCName) then 'xs:NCName' else if ($val instance of xs:Name) then 'xs:Name' else if ($val instance of xs:token) then 'xs:token' else if ($val instance of xs:normalizedString) then 'xs:normalizedString' else if ($val instance of xs:string) then 'xs:string' else if ($val instance of xs:QName) then 'xs:QName' else if ($val instance of xs:boolean) then 'xs:boolean' else if ($val instance of xs:base64Binary) then 'xs:base64Binary' else if ($val instance of xs:hexBinary) then 'xs:hexBinary' else if ($val instance of xs:byte) then 'xs:byte' else if ($val instance of xs:short) then 'xs:short' else if ($val instance of xs:int) then 'xs:int' else if ($val instance of xs:long) then 'xs:long' else if ($val instance of xs:unsignedByte) then 'xs:unsignedByte' else if ($val instance of xs:unsignedShort) then 'xs:unsignedShort' else if ($val instance of xs:unsignedInt) then 'xs:unsignedInt' else if ($val instance of xs:unsignedLong) then 'xs:unsignedLong' else if ($val instance of xs:positiveInteger) then 'xs:positiveInteger' else if ($val instance of xs:nonNegativeInteger) then 'xs:nonNegativeInteger' else if ($val instance of xs:negativeInteger) then 'xs:negativeInteger' else if ($val instance of xs:nonPositiveInteger) then 'xs:nonPositiveInteger' else if ($val instance of xs:integer) then 'xs:integer' else if ($val instance of xs:decimal) then 'xs:decimal' else if ($val instance of xs:float) then 'xs:float' else if ($val instance of xs:double) then 'xs:double' else if ($val instance of xs:date) then 'xs:date' else if ($val instance of xs:time) then 'xs:time' else if ($val instance of xs:dateTime) then 'xs:dateTime' else if ($val instance of xs:dayTimeDuration) then 'xs:dayTimeDuration' else if ($val instance of xs:yearMonthDuration) then 'xs:yearMonthDuration' else if ($val instance of xs:duration) then 'xs:duration' else if ($val instance of xs:gMonth) then 'xs:gMonth' else if ($val instance of xs:gYear) then 'xs:gYear' else if ($val instance of xs:gYearMonth) then 'xs:gYearMonth' else if ($val instance of xs:gDay) then 'xs:gDay' else if ($val instance of xs:gMonthDay) then 'xs:gMonthDay' else 'unknown') } ;                     (functx:atomic-type('abc'))
declare namespace functx = "http://www.example.com/";                     (:~ : The built-in type of an atomic value : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_atomic-type.html : @param $values the value(s) whose type you want to determine :)          declare function functx:atomic-type ( $values as xs:anyAtomicType* ) as xs:string* { for $val in $values return (if ($val instance of xs:untypedAtomic) then 'xs:untypedAtomic' else if ($val instance of xs:anyURI) then 'xs:anyURI' else if ($val instance of xs:ENTITY) then 'xs:ENTITY' else if ($val instance of xs:ID) then 'xs:ID' else if ($val instance of xs:NMTOKEN) then 'xs:NMTOKEN' else if ($val instance of xs:language) then 'xs:language' else if ($val instance of xs:NCName) then 'xs:NCName' else if ($val instance of xs:Name) then 'xs:Name' else if ($val instance of xs:token) then 'xs:token' else if ($val instance of xs:normalizedString) then 'xs:normalizedString' else if ($val instance of xs:string) then 'xs:string' else if ($val instance of xs:QName) then 'xs:QName' else if ($val instance of xs:boolean) then 'xs:boolean' else if ($val instance of xs:base64Binary) then 'xs:base64Binary' else if ($val instance of xs:hexBinary) then 'xs:hexBinary' else if ($val instance of xs:byte) then 'xs:byte' else if ($val instance of xs:short) then 'xs:short' else if ($val instance of xs:int) then 'xs:int' else if ($val instance of xs:long) then 'xs:long' else if ($val instance of xs:unsignedByte) then 'xs:unsignedByte' else if ($val instance of xs:unsignedShort) then 'xs:unsignedShort' else if ($val instance of xs:unsignedInt) then 'xs:unsignedInt' else if ($val instance of xs:unsignedLong) then 'xs:unsignedLong' else if ($val instance of xs:positiveInteger) then 'xs:positiveInteger' else if ($val instance of xs:nonNegativeInteger) then 'xs:nonNegativeInteger' else if ($val instance of xs:negativeInteger) then 'xs:negativeInteger' else if ($val instance of xs:nonPositiveInteger) then 'xs:nonPositiveInteger' else if ($val instance of xs:integer) then 'xs:integer' else if ($val instance of xs:decimal) then 'xs:decimal' else if ($val instance of xs:float) then 'xs:float' else if ($val instance of xs:double) then 'xs:double' else if ($val instance of xs:date) then 'xs:date' else if ($val instance of xs:time) then 'xs:time' else if ($val instance of xs:dateTime) then 'xs:dateTime' else if ($val instance of xs:dayTimeDuration) then 'xs:dayTimeDuration' else if ($val instance of xs:yearMonthDuration) then 'xs:yearMonthDuration' else if ($val instance of xs:duration) then 'xs:duration' else if ($val instance of xs:gMonth) then 'xs:gMonth' else if ($val instance of xs:gYear) then 'xs:gYear' else if ($val instance of xs:gYearMonth) then 'xs:gYearMonth' else if ($val instance of xs:gDay) then 'xs:gDay' else if ($val instance of xs:gMonthDay) then 'xs:gMonthDay' else 'unknown') } ;                     (functx:atomic-type(xs:date('2005-12-15')))
declare namespace functx = "http://www.example.com/";                     (:~ : The day of the week, from a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week.html : @param $date the date :)          declare function functx:day-of-week ( $date as xs:anyAtomicType? ) as xs:integer? { if (empty($date)) then () else xs:integer((xs:date($date) - xs:date('1901-01-06')) div xs:dayTimeDuration('P1D')) mod 7 } ;                     (functx:day-of-week('2004-11-04'))
declare namespace functx = "http://www.example.com/";                     (:~ : The day of the week, from a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week.html : @param $date the date :)          declare function functx:day-of-week ( $date as xs:anyAtomicType? ) as xs:integer? { if (empty($date)) then () else xs:integer((xs:date($date) - xs:date('1901-01-06')) div xs:dayTimeDuration('P1D')) mod 7 } ;                     (functx:day-of-week( xs:date('2004-11-04')))
declare namespace functx = "http://www.example.com/";                     (:~ : The day of the week, from a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week.html : @param $date the date :)          declare function functx:day-of-week ( $date as xs:anyAtomicType? ) as xs:integer? { if (empty($date)) then () else xs:integer((xs:date($date) - xs:date('1901-01-06')) div xs:dayTimeDuration('P1D')) mod 7 } ;                     (functx:day-of-week( xs:date('2004-11-04')), functx:day-of-week( xs:dateTime('2004-11-04T12:00:13')), functx:day-of-week('2004-11-04'))
declare namespace functx = "http://www.example.com/";                     (:~ : The day of the week, from a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week.html : @param $date the date :)          declare function functx:day-of-week ( $date as xs:anyAtomicType? ) as xs:integer? { if (empty($date)) then () else xs:integer((xs:date($date) - xs:date('1901-01-06')) div xs:dayTimeDuration('P1D')) mod 7 } ;                     (functx:day-of-week( xs:dateTime('2004-11-04T12:00:13')))
declare namespace functx = "http://www.example.com/";                     (:~ : The depth (level) of a node in an XML tree : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_depth-of-node.html : @param $node the node to check :)          declare function functx:depth-of-node ( $node as node()? ) as xs:integer { count($node/ancestor-or-self::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:depth-of-node($in-xml))
declare namespace functx = "http://www.example.com/";                     (:~ : The depth (level) of a node in an XML tree : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_depth-of-node.html : @param $node the node to check :)          declare function functx:depth-of-node ( $node as node()? ) as xs:integer { count($node/ancestor-or-self::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:depth-of-node($in-xml/author[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : The depth (level) of a node in an XML tree : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_depth-of-node.html : @param $node the node to check :)          declare function functx:depth-of-node ( $node as node()? ) as xs:integer { count($node/ancestor-or-self::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:depth-of-node( $in-xml/author[1]/fName/text()))
declare namespace functx = "http://www.example.com/";                     (:~ : The depth (level) of a node in an XML tree : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_depth-of-node.html : @param $node the node to check :)          declare function functx:depth-of-node ( $node as node()? ) as xs:integer { count($node/ancestor-or-self::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:depth-of-node($in-xml), functx:depth-of-node($in-xml/author[1]), functx:depth-of-node( $in-xml/author[1]/fName/text()))
declare namespace functx = "http://www.example.com/";                     (:~ : The distinct XML nodes in a sequence (by node identity) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_distinct-nodes.html : @param $nodes the node sequence :)          declare function functx:distinct-nodes ( $nodes as node()* ) as node()* { for $seq in (1 to count($nodes)) return $nodes[$seq][not(functx:is-node-in-sequence( .,$nodes[position() < $seq]))] } ;                     (:~ : Whether an XML node is in a sequence, based on node identity : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies $nodeInSeq is $node } ;                     let $in-xml :=  <test> <child>1</child> <child>2</child> <child>3</child> <child>3</child> </test> return (functx:distinct-nodes( ($in-xml/child, $in-xml/*) ))
declare namespace functx = "http://www.example.com/";                     (:~ : The distinct XML nodes in a sequence (by node identity) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_distinct-nodes.html : @param $nodes the node sequence :)          declare function functx:distinct-nodes ( $nodes as node()* ) as node()* { for $seq in (1 to count($nodes)) return $nodes[$seq][not(functx:is-node-in-sequence( .,$nodes[position() < $seq]))] } ;                     (:~ : Whether an XML node is in a sequence, based on node identity : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies $nodeInSeq is $node } ;                     let $in-xml :=  <test> <child>1</child> <child>2</child> <child>3</child> <child>3</child> </test> return (functx:distinct-nodes( ($in-xml/child, $in-xml/*) ), functx:distinct-nodes( ($in-xml/child[3], $in-xml/*) ))
declare namespace functx = "http://www.example.com/";                     (:~ : The distinct XML nodes in a sequence (by node identity) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_distinct-nodes.html : @param $nodes the node sequence :)          declare function functx:distinct-nodes ( $nodes as node()* ) as node()* { for $seq in (1 to count($nodes)) return $nodes[$seq][not(functx:is-node-in-sequence( .,$nodes[position() < $seq]))] } ;                     (:~ : Whether an XML node is in a sequence, based on node identity : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies $nodeInSeq is $node } ;                     let $in-xml :=  <test> <child>1</child> <child>2</child> <child>3</child> <child>3</child> </test> return (functx:distinct-nodes( ($in-xml/child[3], $in-xml/*) ))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (:~ : Construct a yearMonthDuration from a number of years and months : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_yearmonthduration.html : @param $years the number of years : @param $months the number of months :)          declare function functx:yearMonthDuration ( $years as xs:decimal? , $months as xs:integer? ) as xs:yearMonthDuration { (xs:yearMonthDuration('P1M') * functx:if-empty($months,0)) + (xs:yearMonthDuration('P1Y') * functx:if-empty($years,0)) } ;                     (functx:yearMonthDuration(0,0))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (:~ : Construct a yearMonthDuration from a number of years and months : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_yearmonthduration.html : @param $years the number of years : @param $months the number of months :)          declare function functx:yearMonthDuration ( $years as xs:decimal? , $months as xs:integer? ) as xs:yearMonthDuration { (xs:yearMonthDuration('P1M') * functx:if-empty($months,0)) + (xs:yearMonthDuration('P1Y') * functx:if-empty($years,0)) } ;                     (functx:yearMonthDuration(1,()))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (:~ : Construct a yearMonthDuration from a number of years and months : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_yearmonthduration.html : @param $years the number of years : @param $months the number of months :)          declare function functx:yearMonthDuration ( $years as xs:decimal? , $months as xs:integer? ) as xs:yearMonthDuration { (xs:yearMonthDuration('P1M') * functx:if-empty($months,0)) + (xs:yearMonthDuration('P1Y') * functx:if-empty($years,0)) } ;                     (functx:yearMonthDuration(1,0))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (:~ : Construct a yearMonthDuration from a number of years and months : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_yearmonthduration.html : @param $years the number of years : @param $months the number of months :)          declare function functx:yearMonthDuration ( $years as xs:decimal? , $months as xs:integer? ) as xs:yearMonthDuration { (xs:yearMonthDuration('P1M') * functx:if-empty($months,0)) + (xs:yearMonthDuration('P1Y') * functx:if-empty($years,0)) } ;                     (functx:yearMonthDuration(-1,-3))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (:~ : Construct a yearMonthDuration from a number of years and months : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_yearmonthduration.html : @param $years the number of years : @param $months the number of months :)          declare function functx:yearMonthDuration ( $years as xs:decimal? , $months as xs:integer? ) as xs:yearMonthDuration { (xs:yearMonthDuration('P1M') * functx:if-empty($months,0)) + (xs:yearMonthDuration('P1Y') * functx:if-empty($years,0)) } ;                     (functx:yearMonthDuration(-1,3))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (:~ : Construct a yearMonthDuration from a number of years and months : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_yearmonthduration.html : @param $years the number of years : @param $months the number of months :)          declare function functx:yearMonthDuration ( $years as xs:decimal? , $months as xs:integer? ) as xs:yearMonthDuration { (xs:yearMonthDuration('P1M') * functx:if-empty($months,0)) + (xs:yearMonthDuration('P1Y') * functx:if-empty($years,0)) } ;                     (functx:yearMonthDuration(1.5,0))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (:~ : Construct a yearMonthDuration from a number of years and months : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_yearmonthduration.html : @param $years the number of years : @param $months the number of months :)          declare function functx:yearMonthDuration ( $years as xs:decimal? , $months as xs:integer? ) as xs:yearMonthDuration { (xs:yearMonthDuration('P1M') * functx:if-empty($months,0)) + (xs:yearMonthDuration('P1Y') * functx:if-empty($years,0)) } ;                     (functx:yearMonthDuration(1,6))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     (:~ : Construct a yearMonthDuration from a number of years and months : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_yearmonthduration.html : @param $years the number of years : @param $months the number of months :)          declare function functx:yearMonthDuration ( $years as xs:decimal? , $months as xs:integer? ) as xs:yearMonthDuration { (xs:yearMonthDuration('P1M') * functx:if-empty($months,0)) + (xs:yearMonthDuration('P1Y') * functx:if-empty($years,0)) } ;                     (functx:yearMonthDuration(1,6), functx:yearMonthDuration(1.5,0), functx:yearMonthDuration(1,()), functx:yearMonthDuration(1,0), functx:yearMonthDuration(-1,-3), functx:yearMonthDuration(-1,3), functx:yearMonthDuration(0,0))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     let $in-xml := <prices> <price discount="10.00">29.99</price> <price discount="6.00">39.99</price> <price></price> <price discount="">49.99</price> </prices> return (functx:if-empty($in-xml//price[1], 0))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     let $in-xml := <prices> <price discount="10.00">29.99</price> <price discount="6.00">39.99</price> <price></price> <price discount="">49.99</price> </prices> return (functx:if-empty($in-xml//price[1], 0), functx:if-empty($in-xml//price[3], 0), functx:if-empty($in-xml//price[99], 0), functx:if-empty($in-xml//price[1]/@discount, 0), functx:if-empty($in-xml//price[3]/@discount, 0), functx:if-empty($in-xml//price[4]/@discount, 0))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     let $in-xml := <prices> <price discount="10.00">29.99</price> <price discount="6.00">39.99</price> <price></price> <price discount="">49.99</price> </prices> return (functx:if-empty($in-xml//price[1]/@discount, 0))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     let $in-xml := <prices> <price discount="10.00">29.99</price> <price discount="6.00">39.99</price> <price></price> <price discount="">49.99</price> </prices> return (functx:if-empty($in-xml//price[3], 0))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     let $in-xml := <prices> <price discount="10.00">29.99</price> <price discount="6.00">39.99</price> <price></price> <price discount="">49.99</price> </prices> return (functx:if-empty($in-xml//price[3]/@discount, 0))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     let $in-xml := <prices> <price discount="10.00">29.99</price> <price discount="6.00">39.99</price> <price></price> <price discount="">49.99</price> </prices> return (functx:if-empty($in-xml//price[4]/@discount, 0))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not blank, otherwise the second argument : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-empty.html : @param $arg the node that may be empty : @param $value the item(s) to use if the node is empty :)          declare function functx:if-empty ( $arg as item()? , $value as item()* ) as item()* { if (string($arg) != '') then data($arg) else $value } ;                     let $in-xml := <prices> <price discount="10.00">29.99</price> <price discount="6.00">39.99</price> <price></price> <price discount="">49.99</price> </prices> return (functx:if-empty($in-xml//price[99], 0))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not empty, otherwise the second argument : : @author W3C XML Query WG : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-absent.html : @param $arg the item(s) that may be absent : @param $value the item(s) to use if the item is absent :)          declare function functx:if-absent ( $arg as item()* , $value as item()* ) as item()* { if (exists($arg)) then $arg else $value } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="69.99"/> <price value="49.99" discount=""/> </prices> return (data(functx:if-absent( $in-xml//price[1]/@discount, 0)))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not empty, otherwise the second argument : : @author W3C XML Query WG : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-absent.html : @param $arg the item(s) that may be absent : @param $value the item(s) to use if the item is absent :)          declare function functx:if-absent ( $arg as item()* , $value as item()* ) as item()* { if (exists($arg)) then $arg else $value } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="69.99"/> <price value="49.99" discount=""/> </prices> return (data(functx:if-absent( $in-xml//price[1]/@discount, 0)), data(functx:if-absent( $in-xml//price[3]/@discount, 0)), data(functx:if-absent( $in-xml//price[4]/@discount, 0)))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not empty, otherwise the second argument : : @author W3C XML Query WG : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-absent.html : @param $arg the item(s) that may be absent : @param $value the item(s) to use if the item is absent :)          declare function functx:if-absent ( $arg as item()* , $value as item()* ) as item()* { if (exists($arg)) then $arg else $value } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="69.99"/> <price value="49.99" discount=""/> </prices> return (data(functx:if-absent( $in-xml//price[3]/@discount, 0)))
declare namespace functx = "http://www.example.com/";                     (:~ : The first argument if it is not empty, otherwise the second argument : : @author W3C XML Query WG : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_if-absent.html : @param $arg the item(s) that may be absent : @param $value the item(s) to use if the item is absent :)          declare function functx:if-absent ( $arg as item()* , $value as item()* ) as item()* { if (exists($arg)) then $arg else $value } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="69.99"/> <price value="49.99" discount=""/> </prices> return (data(functx:if-absent( $in-xml//price[4]/@discount, 0)))
declare namespace functx = "http://www.example.com/";                     (:~ : The first position of a matching substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-match-first.html : @param $arg the string : @param $pattern the pattern to match :)          declare function functx:index-of-match-first ( $arg as xs:string? , $pattern as xs:string ) as xs:integer? { if (matches($arg,$pattern)) then string-length(tokenize($arg, $pattern)[1]) + 1 else () } ;                     (functx:index-of-match-first('a1234','\d'))
declare namespace functx = "http://www.example.com/";                     (:~ : The first position of a matching substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-match-first.html : @param $arg the string : @param $pattern the pattern to match :)          declare function functx:index-of-match-first ( $arg as xs:string? , $pattern as xs:string ) as xs:integer? { if (matches($arg,$pattern)) then string-length(tokenize($arg, $pattern)[1]) + 1 else () } ;                     (functx:index-of-match-first('abc abc','\s'))
declare namespace functx = "http://www.example.com/";                     (:~ : The first position of a matching substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-match-first.html : @param $arg the string : @param $pattern the pattern to match :)          declare function functx:index-of-match-first ( $arg as xs:string? , $pattern as xs:string ) as xs:integer? { if (matches($arg,$pattern)) then string-length(tokenize($arg, $pattern)[1]) + 1 else () } ;                     (functx:index-of-match-first('abc abc','z'))
declare namespace functx = "http://www.example.com/";                     (:~ : The first position of a matching substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-match-first.html : @param $arg the string : @param $pattern the pattern to match :)          declare function functx:index-of-match-first ( $arg as xs:string? , $pattern as xs:string ) as xs:integer? { if (matches($arg,$pattern)) then string-length(tokenize($arg, $pattern)[1]) + 1 else () } ;                     (functx:index-of-match-first( 'abcdabcdabcd','abc'))
declare namespace functx = "http://www.example.com/";                     (:~ : The first position of a matching substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-match-first.html : @param $arg the string : @param $pattern the pattern to match :)          declare function functx:index-of-match-first ( $arg as xs:string? , $pattern as xs:string ) as xs:integer? { if (matches($arg,$pattern)) then string-length(tokenize($arg, $pattern)[1]) + 1 else () } ;                     (functx:index-of-match-first( 'abcdabcdabcd','abc'), functx:index-of-match-first( 'abcdabcdabcd','bcd'), functx:index-of-match-first('a1234','\d'), functx:index-of-match-first('abc abc','\s'), functx:index-of-match-first('abc abc','z'))
declare namespace functx = "http://www.example.com/";                     (:~ : The first position of a matching substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-match-first.html : @param $arg the string : @param $pattern the pattern to match :)          declare function functx:index-of-match-first ( $arg as xs:string? , $pattern as xs:string ) as xs:integer? { if (matches($arg,$pattern)) then string-length(tokenize($arg, $pattern)[1]) + 1 else () } ;                     (functx:index-of-match-first( 'abcdabcdabcd','bcd'))
declare namespace functx = "http://www.example.com/";                     (:~ : The first position of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string-first.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string-first ( $arg as xs:string? , $substring as xs:string ) as xs:integer? { if (contains($arg, $substring)) then string-length(substring-before($arg, $substring))+1 else () } ;                     (functx:index-of-string-first( 'abcd','abc'))
declare namespace functx = "http://www.example.com/";                     (:~ : The first position of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string-first.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string-first ( $arg as xs:string? , $substring as xs:string ) as xs:integer? { if (contains($arg, $substring)) then string-length(substring-before($arg, $substring))+1 else () } ;                     (functx:index-of-string-first( 'abcdabcdabcd','abc'))
declare namespace functx = "http://www.example.com/";                     (:~ : The first position of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string-first.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string-first ( $arg as xs:string? , $substring as xs:string ) as xs:integer? { if (contains($arg, $substring)) then string-length(substring-before($arg, $substring))+1 else () } ;                     (functx:index-of-string-first( 'abcdabcdabcd','abc'), functx:index-of-string-first( 'abcd','abc'), functx:index-of-string-first( 'xxx','abc'))
declare namespace functx = "http://www.example.com/";                     (:~ : The first position of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string-first.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string-first ( $arg as xs:string? , $substring as xs:string ) as xs:integer? { if (contains($arg, $substring)) then string-length(substring-before($arg, $substring))+1 else () } ;                     (functx:index-of-string-first( 'xxx','abc'))
declare namespace functx = "http://www.example.com/";                     (:~ : The last position of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string-last.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string-last ( $arg as xs:string? , $substring as xs:string ) as xs:integer? { functx:index-of-string($arg, $substring)[last()] } ;                     (:~ : The position(s) of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string ( $arg as xs:string? , $substring as xs:string ) as xs:integer* { if (contains($arg, $substring)) then (string-length(substring-before($arg, $substring))+1, for $other in functx:index-of-string(substring-after($arg, $substring), $substring) return $other + string-length(substring-before($arg, $substring)) + string-length($substring)) else () } ;                     (functx:index-of-string-last( 'abcd','abc'))
declare namespace functx = "http://www.example.com/";                     (:~ : The last position of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string-last.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string-last ( $arg as xs:string? , $substring as xs:string ) as xs:integer? { functx:index-of-string($arg, $substring)[last()] } ;                     (:~ : The position(s) of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string ( $arg as xs:string? , $substring as xs:string ) as xs:integer* { if (contains($arg, $substring)) then (string-length(substring-before($arg, $substring))+1, for $other in functx:index-of-string(substring-after($arg, $substring), $substring) return $other + string-length(substring-before($arg, $substring)) + string-length($substring)) else () } ;                     (functx:index-of-string-last( 'abcdabcdabcd','abc'))
declare namespace functx = "http://www.example.com/";                     (:~ : The last position of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string-last.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string-last ( $arg as xs:string? , $substring as xs:string ) as xs:integer? { functx:index-of-string($arg, $substring)[last()] } ;                     (:~ : The position(s) of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string ( $arg as xs:string? , $substring as xs:string ) as xs:integer* { if (contains($arg, $substring)) then (string-length(substring-before($arg, $substring))+1, for $other in functx:index-of-string(substring-after($arg, $substring), $substring) return $other + string-length(substring-before($arg, $substring)) + string-length($substring)) else () } ;                     (functx:index-of-string-last( 'abcdabcdabcd','abc'), functx:index-of-string-last( 'abcd','abc'), functx:index-of-string-last( 'xxx','abc'))
declare namespace functx = "http://www.example.com/";                     (:~ : The last position of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string-last.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string-last ( $arg as xs:string? , $substring as xs:string ) as xs:integer? { functx:index-of-string($arg, $substring)[last()] } ;                     (:~ : The position(s) of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string ( $arg as xs:string? , $substring as xs:string ) as xs:integer* { if (contains($arg, $substring)) then (string-length(substring-before($arg, $substring))+1, for $other in functx:index-of-string(substring-after($arg, $substring), $substring) return $other + string-length(substring-before($arg, $substring)) + string-length($substring)) else () } ;                     (functx:index-of-string-last( 'xxx','abc'))
declare namespace functx = "http://www.example.com/";                     (:~ : The maximum depth of elements in an XML tree : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-depth.html : @param $root the root to start from :)          declare function functx:max-depth ( $root as node()? ) as xs:integer? { if ($root/*) then max($root/*/functx:max-depth(.)) + 1 else 1 } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:max-depth($in-xml))
declare namespace functx = "http://www.example.com/";                     (:~ : The maximum depth of elements in an XML tree : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-depth.html : @param $root the root to start from :)          declare function functx:max-depth ( $root as node()? ) as xs:integer? { if ($root/*) then max($root/*/functx:max-depth(.)) + 1 else 1 } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:max-depth($in-xml/author[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : The maximum depth of elements in an XML tree : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-depth.html : @param $root the root to start from :)          declare function functx:max-depth ( $root as node()? ) as xs:integer? { if ($root/*) then max($root/*/functx:max-depth(.)) + 1 else 1 } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:max-depth($in-xml), functx:max-depth($in-xml/author[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : The maximum of a sequence of values, treating them like strings : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-string.html : @param $strings the sequence of values :)          declare function functx:max-string ( $strings as xs:anyAtomicType* ) as xs:string? { max(for $string in $strings return string($string)) } ;                     let $in-xml := <in-xml> <x>a</x> <y>c</y> <z>b</z> </in-xml> return (functx:max-string( $in-xml/* ))
declare namespace functx = "http://www.example.com/";                     (:~ : The maximum of a sequence of values, treating them like strings : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-string.html : @param $strings the sequence of values :)          declare function functx:max-string ( $strings as xs:anyAtomicType* ) as xs:string? { max(for $string in $strings return string($string)) } ;                     let $in-xml := <in-xml> <x>a</x> <y>c</y> <z>b</z> </in-xml> return (functx:max-string( $in-xml/* ), functx:max-string( (100,25,3) ))
declare namespace functx = "http://www.example.com/";                     (:~ : The maximum of a sequence of values, treating them like strings : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-string.html : @param $strings the sequence of values :)          declare function functx:max-string ( $strings as xs:anyAtomicType* ) as xs:string? { max(for $string in $strings return string($string)) } ;                     let $in-xml := <in-xml> <x>a</x> <y>c</y> <z>b</z> </in-xml> return (functx:max-string( (100,25,3) ))
declare namespace functx = "http://www.example.com/";                     (:~ : The maximum value in a sequence, figuring out its type (numeric or string) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-determine-type.html : @param $seq the sequence of values to test :)          declare function functx:max-determine-type ( $seq as xs:anyAtomicType* ) as xs:anyAtomicType? { if (every $value in $seq satisfies ($value castable as xs:double)) then max(for $value in $seq return xs:double($value)) else max(for $value in $seq return xs:string($value)) } ;                     let $in-xml := <values> <nums> <num>12</num> <num>23</num> <num>115</num> <num>12.5</num> </nums> <strings> <string>def</string> <string>abc</string> </strings> </values> return (functx:max-determine-type($in-xml//num))
declare namespace functx = "http://www.example.com/";                     (:~ : The maximum value in a sequence, figuring out its type (numeric or string) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-determine-type.html : @param $seq the sequence of values to test :)          declare function functx:max-determine-type ( $seq as xs:anyAtomicType* ) as xs:anyAtomicType? { if (every $value in $seq satisfies ($value castable as xs:double)) then max(for $value in $seq return xs:double($value)) else max(for $value in $seq return xs:string($value)) } ;                     let $in-xml := <values> <nums> <num>12</num> <num>23</num> <num>115</num> <num>12.5</num> </nums> <strings> <string>def</string> <string>abc</string> </strings> </values> return (functx:max-determine-type($in-xml//num), functx:max-determine-type($in-xml//string), functx:max-determine-type( $in-xml//(num|string)))
declare namespace functx = "http://www.example.com/";                     (:~ : The maximum value in a sequence, figuring out its type (numeric or string) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-determine-type.html : @param $seq the sequence of values to test :)          declare function functx:max-determine-type ( $seq as xs:anyAtomicType* ) as xs:anyAtomicType? { if (every $value in $seq satisfies ($value castable as xs:double)) then max(for $value in $seq return xs:double($value)) else max(for $value in $seq return xs:string($value)) } ;                     let $in-xml := <values> <nums> <num>12</num> <num>23</num> <num>115</num> <num>12.5</num> </nums> <strings> <string>def</string> <string>abc</string> </strings> </values> return (functx:max-determine-type( $in-xml//(num|string)))
declare namespace functx = "http://www.example.com/";                     (:~ : The maximum value in a sequence, figuring out its type (numeric or string) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-determine-type.html : @param $seq the sequence of values to test :)          declare function functx:max-determine-type ( $seq as xs:anyAtomicType* ) as xs:anyAtomicType? { if (every $value in $seq satisfies ($value castable as xs:double)) then max(for $value in $seq return xs:double($value)) else max(for $value in $seq return xs:string($value)) } ;                     let $in-xml := <values> <nums> <num>12</num> <num>23</num> <num>115</num> <num>12.5</num> </nums> <strings> <string>def</string> <string>abc</string> </strings> </values> return (functx:max-determine-type($in-xml//string))
declare namespace functx = "http://www.example.com/";                     (:~ : The minimum of a sequence of strings, ignoring "empty" values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_min-non-empty-string.html : @param $strings the sequence of strings to search :)          declare function functx:min-non-empty-string ( $strings as xs:string* ) as xs:string? { min($strings[. != '']) } ;                     let $in-xml := <authors> <author> <fName/> <lName>Smith</lName> </author> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:min-non-empty-string( $in-xml//fName ))
declare namespace functx = "http://www.example.com/";                     (:~ : The minimum of a sequence of values, treating them like strings : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_min-string.html : @param $strings the sequence of strings :)          declare function functx:min-string ( $strings as xs:anyAtomicType* ) as xs:string? { min(for $string in $strings return string($string)) } ;                     let $in-xml := <in-xml> <x>a</x> <y>c</y> <z>b</z> </in-xml> return (functx:min-string( $in-xml/* ))
declare namespace functx = "http://www.example.com/";                     (:~ : The minimum of a sequence of values, treating them like strings : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_min-string.html : @param $strings the sequence of strings :)          declare function functx:min-string ( $strings as xs:anyAtomicType* ) as xs:string? { min(for $string in $strings return string($string)) } ;                     let $in-xml := <in-xml> <x>a</x> <y>c</y> <z>b</z> </in-xml> return (functx:min-string( $in-xml/* ), functx:min-string( (100,25,3) ))
declare namespace functx = "http://www.example.com/";                     (:~ : The minimum of a sequence of values, treating them like strings : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_min-string.html : @param $strings the sequence of strings :)          declare function functx:min-string ( $strings as xs:anyAtomicType* ) as xs:string? { min(for $string in $strings return string($string)) } ;                     let $in-xml := <in-xml> <x>a</x> <y>c</y> <z>b</z> </in-xml> return (functx:min-string( (100,25,3) ))
declare namespace functx = "http://www.example.com/";                     (:~ : The minimum value in a sequence, figuring out its type (numeric or string) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_min-determine-type.html : @param $seq the sequence of values to test :)          declare function functx:min-determine-type ( $seq as xs:anyAtomicType* ) as xs:anyAtomicType? { if (every $value in $seq satisfies ($value castable as xs:double)) then min(for $value in $seq return xs:double($value)) else min(for $value in $seq return xs:string($value)) } ;                     let $in-xml := <values> <nums> <num>12</num> <num>23</num> <num>115</num> <num>12.5</num> </nums> <strings> <str>def</str> <str>abc</str> </strings> </values> return (functx:min-determine-type($in-xml//num))
declare namespace functx = "http://www.example.com/";                     (:~ : The minimum value in a sequence, figuring out its type (numeric or string) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_min-determine-type.html : @param $seq the sequence of values to test :)          declare function functx:min-determine-type ( $seq as xs:anyAtomicType* ) as xs:anyAtomicType? { if (every $value in $seq satisfies ($value castable as xs:double)) then min(for $value in $seq return xs:double($value)) else min(for $value in $seq return xs:string($value)) } ;                     let $in-xml := <values> <nums> <num>12</num> <num>23</num> <num>115</num> <num>12.5</num> </nums> <strings> <str>def</str> <str>abc</str> </strings> </values> return (functx:min-determine-type($in-xml//num), functx:min-determine-type($in-xml//str), functx:min-determine-type($in-xml//(num|str)))
declare namespace functx = "http://www.example.com/";                     (:~ : The minimum value in a sequence, figuring out its type (numeric or string) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_min-determine-type.html : @param $seq the sequence of values to test :)          declare function functx:min-determine-type ( $seq as xs:anyAtomicType* ) as xs:anyAtomicType? { if (every $value in $seq satisfies ($value castable as xs:double)) then min(for $value in $seq return xs:double($value)) else min(for $value in $seq return xs:string($value)) } ;                     let $in-xml := <values> <nums> <num>12</num> <num>23</num> <num>115</num> <num>12.5</num> </nums> <strings> <str>def</str> <str>abc</str> </strings> </values> return (functx:min-determine-type($in-xml//(num|str)))
declare namespace functx = "http://www.example.com/";                     (:~ : The minimum value in a sequence, figuring out its type (numeric or string) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_min-determine-type.html : @param $seq the sequence of values to test :)          declare function functx:min-determine-type ( $seq as xs:anyAtomicType* ) as xs:anyAtomicType? { if (every $value in $seq satisfies ($value castable as xs:double)) then min(for $value in $seq return xs:double($value)) else min(for $value in $seq return xs:string($value)) } ;                     let $in-xml := <values> <nums> <num>12</num> <num>23</num> <num>115</num> <num>12.5</num> </nums> <strings> <str>def</str> <str>abc</str> </strings> </values> return (functx:min-determine-type($in-xml//str))
declare namespace functx = "http://www.example.com/";                     (:~ : The month of a date as an abbreviated word (Jan, Feb, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_month-abbrev-en.html : @param $date the date :)          declare function functx:month-abbrev-en ( $date as xs:anyAtomicType? ) as xs:string? { ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec') [month-from-date(xs:date($date))] } ;                     (functx:month-abbrev-en('2004-01-23'))
declare namespace functx = "http://www.example.com/";                     (:~ : The month of a date as an abbreviated word (Jan, Feb, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_month-abbrev-en.html : @param $date the date :)          declare function functx:month-abbrev-en ( $date as xs:anyAtomicType? ) as xs:string? { ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec') [month-from-date(xs:date($date))] } ;                     (functx:month-abbrev-en(xs:date('2004-01-23')))
declare namespace functx = "http://www.example.com/";                     (:~ : The month of a date as an abbreviated word (Jan, Feb, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_month-abbrev-en.html : @param $date the date :)          declare function functx:month-abbrev-en ( $date as xs:anyAtomicType? ) as xs:string? { ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec') [month-from-date(xs:date($date))] } ;                     (functx:month-abbrev-en(xs:date('2004-01-23')), functx:month-abbrev-en( xs:dateTime('2004-01-23T12:00:13')), functx:month-abbrev-en('2004-01-23'))
declare namespace functx = "http://www.example.com/";                     (:~ : The month of a date as an abbreviated word (Jan, Feb, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_month-abbrev-en.html : @param $date the date :)          declare function functx:month-abbrev-en ( $date as xs:anyAtomicType? ) as xs:string? { ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec') [month-from-date(xs:date($date))] } ;                     (functx:month-abbrev-en( xs:dateTime('2004-01-23T12:00:13')))
declare namespace functx = "http://www.example.com/";                     (:~ : The month of a date as a word (January, February, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_month-name-en.html : @param $date the date :)          declare function functx:month-name-en ( $date as xs:anyAtomicType? ) as xs:string? { ('January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December') [month-from-date(xs:date($date))] } ;                     (functx:month-name-en('2004-01-23'))
declare namespace functx = "http://www.example.com/";                     (:~ : The month of a date as a word (January, February, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_month-name-en.html : @param $date the date :)          declare function functx:month-name-en ( $date as xs:anyAtomicType? ) as xs:string? { ('January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December') [month-from-date(xs:date($date))] } ;                     (functx:month-name-en(xs:date('2004-01-23')))
declare namespace functx = "http://www.example.com/";                     (:~ : The month of a date as a word (January, February, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_month-name-en.html : @param $date the date :)          declare function functx:month-name-en ( $date as xs:anyAtomicType? ) as xs:string? { ('January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December') [month-from-date(xs:date($date))] } ;                     (functx:month-name-en(xs:date('2004-01-23')), functx:month-name-en( xs:dateTime('2004-01-23T12:00:13')), functx:month-name-en('2004-01-23'))
declare namespace functx = "http://www.example.com/";                     (:~ : The month of a date as a word (January, February, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_month-name-en.html : @param $date the date :)          declare function functx:month-name-en ( $date as xs:anyAtomicType? ) as xs:string? { ('January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December') [month-from-date(xs:date($date))] } ;                     (functx:month-name-en( xs:dateTime('2004-01-23T12:00:13')))
declare namespace functx = "http://www.example.com/";                     (:~ : The name of the day of the week, from a date, in English : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week-name-en.html : @param $date the date :)          declare function functx:day-of-week-name-en ( $date as xs:anyAtomicType? ) as xs:string? { ('Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday') [functx:day-of-week($date) + 1] } ;                     (:~ : The day of the week, from a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week.html : @param $date the date :)          declare function functx:day-of-week ( $date as xs:anyAtomicType? ) as xs:integer? { if (empty($date)) then () else xs:integer((xs:date($date) - xs:date('1901-01-06')) div xs:dayTimeDuration('P1D')) mod 7 } ;                     (functx:day-of-week-name-en('2004-11-04'))
declare namespace functx = "http://www.example.com/";                     (:~ : The name of the day of the week, from a date, in English : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week-name-en.html : @param $date the date :)          declare function functx:day-of-week-name-en ( $date as xs:anyAtomicType? ) as xs:string? { ('Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday') [functx:day-of-week($date) + 1] } ;                     (:~ : The day of the week, from a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week.html : @param $date the date :)          declare function functx:day-of-week ( $date as xs:anyAtomicType? ) as xs:integer? { if (empty($date)) then () else xs:integer((xs:date($date) - xs:date('1901-01-06')) div xs:dayTimeDuration('P1D')) mod 7 } ;                     (functx:day-of-week-name-en( xs:date('2004-11-04')))
declare namespace functx = "http://www.example.com/";                     (:~ : The name of the day of the week, from a date, in English : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week-name-en.html : @param $date the date :)          declare function functx:day-of-week-name-en ( $date as xs:anyAtomicType? ) as xs:string? { ('Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday') [functx:day-of-week($date) + 1] } ;                     (:~ : The day of the week, from a date : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_day-of-week.html : @param $date the date :)          declare function functx:day-of-week ( $date as xs:anyAtomicType? ) as xs:integer? { if (empty($date)) then () else xs:integer((xs:date($date) - xs:date('1901-01-06')) div xs:dayTimeDuration('P1D')) mod 7 } ;                     (functx:day-of-week-name-en( xs:date('2004-11-04')), functx:day-of-week-name-en('2004-11-04'))
declare namespace functx = "http://www.example.com/";                     (:~ : The number of lines : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_line-count.html : @param $arg the string to test :)          declare function functx:line-count ( $arg as xs:string? ) as xs:integer { count(functx:lines($arg)) } ;                     (:~ : Split a string into separate lines : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_lines.html : @param $arg the string to split :)          declare function functx:lines ( $arg as xs:string? ) as xs:string* { tokenize($arg, '(\r\n?|\n\r?)') } ;                     let $lines := 'a value on many lines' return (functx:line-count('a value'))
declare namespace functx = "http://www.example.com/";                     (:~ : The number of regions that match a pattern : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_number-of-matches.html : @param $arg the string to test : @param $pattern the regular expression :)          declare function functx:number-of-matches ( $arg as xs:string? , $pattern as xs:string ) as xs:integer { count(tokenize($arg,$pattern)) - 1 } ;                     (functx:number-of-matches('12345','\d'))
declare namespace functx = "http://www.example.com/";                     (:~ : The number of regions that match a pattern : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_number-of-matches.html : @param $arg the string to test : @param $pattern the regular expression :)          declare function functx:number-of-matches ( $arg as xs:string? , $pattern as xs:string ) as xs:integer { count(tokenize($arg,$pattern)) - 1 } ;                     (functx:number-of-matches('aaaaaa','aaa'))
declare namespace functx = "http://www.example.com/";                     (:~ : The number of regions that match a pattern : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_number-of-matches.html : @param $arg the string to test : @param $pattern the regular expression :)          declare function functx:number-of-matches ( $arg as xs:string? , $pattern as xs:string ) as xs:integer { count(tokenize($arg,$pattern)) - 1 } ;                     (functx:number-of-matches('abcabc','ab'))
declare namespace functx = "http://www.example.com/";                     (:~ : The number of regions that match a pattern : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_number-of-matches.html : @param $arg the string to test : @param $pattern the regular expression :)          declare function functx:number-of-matches ( $arg as xs:string? , $pattern as xs:string ) as xs:integer { count(tokenize($arg,$pattern)) - 1 } ;                     (functx:number-of-matches('abcabc','ab'), functx:number-of-matches('12345','\d'), functx:number-of-matches('aaaaaa','aaa'))
declare namespace functx = "http://www.example.com/";                     (:~ : The number of words : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_word-count.html : @param $arg the string to measure :)          declare function functx:word-count ( $arg as xs:string? ) as xs:integer { count(tokenize($arg, '\W+')[. != '']) } ;                     (functx:word-count('a.b.c'))
declare namespace functx = "http://www.example.com/";                     (:~ : The number of words : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_word-count.html : @param $arg the string to measure :)          declare function functx:word-count ( $arg as xs:string? ) as xs:integer { count(tokenize($arg, '\W+')[. != '']) } ;                     (functx:word-count('hello there world'))
declare namespace functx = "http://www.example.com/";                     (:~ : The number of words : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_word-count.html : @param $arg the string to measure :)          declare function functx:word-count ( $arg as xs:string? ) as xs:integer { count(tokenize($arg, '\W+')[. != '']) } ;                     (functx:word-count('hello there world'), functx:word-count(' hello world '), functx:word-count('a.b.c'))
declare namespace functx = "http://www.example.com/";                     (:~ : The number of words : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_word-count.html : @param $arg the string to measure :)          declare function functx:word-count ( $arg as xs:string? ) as xs:integer { count(tokenize($arg, '\W+')[. != '']) } ;                     (functx:word-count(' hello world '))
declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-deep-equal-node.html : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)          declare function functx:index-of-deep-equal-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* { for $seq in (1 to count($nodes)) return $seq[deep-equal($nodes[$seq],$nodeToFind)] } ;                     let $in-xml := <authors> <author> <fName/> <lName>Smith</lName> </author> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return let $anotherAuthor := <author> <fName>John</fName> <lName>Smith</lName> </author> return (functx:index-of-deep-equal-node( $in-xml/author,$anAuthor))
declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on contents and attributes :                         : @author Priscilla Walmsley, Datypic                         : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-deep-equal-node.html                         : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)                                   declare function functx:index-of-deep-equal-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* {              for $seq in (1 to count($nodes))              return $seq[deep-equal($nodes[$seq],$nodeToFind)]           } ;          let $in-xml := <authors> <author> <fName/> <lName>Smith</lName> </author> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors>           return               let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author>               return                   let $anotherAuthor := <author> <fName>John</fName> <lName>Smith</lName> </author>                   return (functx:index-of-deep-equal-node( $in-xml/author,$anAuthor),                           functx:index-of-deep-equal-node( $in-xml/author,$anotherAuthor),                           functx:index-of-deep-equal-node( $in-xml/author/lName,$anAuthor/lName))
declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-deep-equal-node.html : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)          declare function functx:index-of-deep-equal-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* { for $seq in (1 to count($nodes)) return $seq[deep-equal($nodes[$seq],$nodeToFind)] } ;                     let $in-xml := <authors> <author> <fName/> <lName>Smith</lName> </author> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return let $anotherAuthor := <author> <fName>John</fName> <lName>Smith</lName> </author> return (functx:index-of-deep-equal-node( $in-xml/author,$anotherAuthor))
declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-deep-equal-node.html : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)          declare function functx:index-of-deep-equal-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* { for $seq in (1 to count($nodes)) return $seq[deep-equal($nodes[$seq],$nodeToFind)] } ;                     let $in-xml := <authors> <author> <fName/> <lName>Smith</lName> </author> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return let $anotherAuthor := <author> <fName>John</fName> <lName>Smith</lName> </author> return (functx:index-of-deep-equal-node( $in-xml/author/lName,$anAuthor/lName))
declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on node identity : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-node.html : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)          declare function functx:index-of-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* { for $seq in (1 to count($nodes)) return $seq[$nodes[$seq] is $nodeToFind] } ;                     (:~ : A unique path to an XML node (or sequence of nodes) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_path-to-node-with-pos.html : @param $node the node sequence :)          declare function functx:path-to-node-with-pos ( $node as node()? ) as xs:string { string-join( for $ancestor in $node/ancestor-or-self::* let $sibsOfSameName := $ancestor/../*[name() = name($ancestor)] return concat(name($ancestor), if (count($sibsOfSameName) <= 1) then '' else concat( '[',functx:index-of-node($sibsOfSameName,$ancestor),']')) , '/') } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:path-to-node-with-pos($in-xml/*[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on node identity : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-node.html : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)          declare function functx:index-of-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* { for $seq in (1 to count($nodes)) return $seq[$nodes[$seq] is $nodeToFind] } ;                     (:~ : A unique path to an XML node (or sequence of nodes) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_path-to-node-with-pos.html : @param $node the node sequence :)          declare function functx:path-to-node-with-pos ( $node as node()? ) as xs:string { string-join( for $ancestor in $node/ancestor-or-self::* let $sibsOfSameName := $ancestor/../*[name() = name($ancestor)] return concat(name($ancestor), if (count($sibsOfSameName) <= 1) then '' else concat( '[',functx:index-of-node($sibsOfSameName,$ancestor),']')) , '/') } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:path-to-node-with-pos( $in-xml//lName[. = 'Doe']))
declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on node identity : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-node.html : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)          declare function functx:index-of-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* { for $seq in (1 to count($nodes)) return $seq[$nodes[$seq] is $nodeToFind] } ;                     (:~ : A unique path to an XML node (or sequence of nodes) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_path-to-node-with-pos.html : @param $node the node sequence :)          declare function functx:path-to-node-with-pos ( $node as node()? ) as xs:string { string-join( for $ancestor in $node/ancestor-or-self::* let $sibsOfSameName := $ancestor/../*[name() = name($ancestor)] return concat(name($ancestor), if (count($sibsOfSameName) <= 1) then '' else concat( '[',functx:index-of-node($sibsOfSameName,$ancestor),']')) , '/') } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:path-to-node-with-pos( $in-xml//lName[. = 'Doe']), functx:path-to-node-with-pos($in-xml/*[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on node identity : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-node.html : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)          declare function functx:index-of-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* { for $seq in (1 to count($nodes)) return $seq[$nodes[$seq] is $nodeToFind] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:index-of-node( $in-xml/author,$in-xml/author[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on node identity : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-node.html : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)          declare function functx:index-of-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* { for $seq in (1 to count($nodes)) return $seq[$nodes[$seq] is $nodeToFind] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:index-of-node( $in-xml/author,$in-xml/author[1]), functx:index-of-node( $in-xml/author,$in-xml/author[2]), functx:index-of-node( $in-xml/author, $in-xml/author[lName='Doe']))
declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on node identity : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-node.html : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)          declare function functx:index-of-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* { for $seq in (1 to count($nodes)) return $seq[$nodes[$seq] is $nodeToFind] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:index-of-node( $in-xml/author,$in-xml/author[2]))
declare namespace functx = "http://www.example.com/";                     (:~ : The position of a node in a sequence, based on node identity : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-node.html : @param $nodes the node sequence : @param $nodeToFind the node to find in the sequence :)          declare function functx:index-of-node ( $nodes as node()* , $nodeToFind as node() ) as xs:integer* { for $seq in (1 to count($nodes)) return $seq[$nodes[$seq] is $nodeToFind] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:index-of-node( $in-xml/author, $in-xml/author[lName='Doe']))
declare namespace functx = "http://www.example.com/";                     (:~ : The position(s) of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string ( $arg as xs:string? , $substring as xs:string ) as xs:integer* { if (contains($arg, $substring)) then (string-length(substring-before($arg, $substring))+1, for $other in functx:index-of-string(substring-after($arg, $substring), $substring) return $other + string-length(substring-before($arg, $substring)) + string-length($substring)) else () } ;                     (functx:index-of-string('abcd','abc'))
declare namespace functx = "http://www.example.com/";                     (:~ : The position(s) of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string ( $arg as xs:string? , $substring as xs:string ) as xs:integer* { if (contains($arg, $substring)) then (string-length(substring-before($arg, $substring))+1, for $other in functx:index-of-string(substring-after($arg, $substring), $substring) return $other + string-length(substring-before($arg, $substring)) + string-length($substring)) else () } ;                     (functx:index-of-string('abcdabcdabcd','abc'))
declare namespace functx = "http://www.example.com/";                     (:~ : The position(s) of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string ( $arg as xs:string? , $substring as xs:string ) as xs:integer* { if (contains($arg, $substring)) then (string-length(substring-before($arg, $substring))+1, for $other in functx:index-of-string(substring-after($arg, $substring), $substring) return $other + string-length(substring-before($arg, $substring)) + string-length($substring)) else () } ;                     (functx:index-of-string('abcdabcdabcd','abc'), functx:index-of-string('abcd','abc'), functx:index-of-string('xxx','abc'))
declare namespace functx = "http://www.example.com/";                     (:~ : The position(s) of a substring : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_index-of-string.html : @param $arg the string : @param $substring the substring to find :)          declare function functx:index-of-string ( $arg as xs:string? , $substring as xs:string ) as xs:integer* { if (contains($arg, $substring)) then (string-length(substring-before($arg, $substring))+1, for $other in functx:index-of-string(substring-after($arg, $substring), $substring) return $other + string-length(substring-before($arg, $substring)) + string-length($substring)) else () } ;                     (functx:index-of-string('xxx','abc'))
declare namespace functx = "http://www.example.com/";                     (:~ : The siblings of an XML element that have the same name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_siblings-same-name.html : @param $element the node :)          declare function functx:siblings-same-name ( $element as element()? ) as element()* { $element/../*[node-name(.) = node-name($element)] except $element } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <fName>Jane</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:siblings-same-name( $in-xml/author[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : The siblings of an XML element that have the same name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_siblings-same-name.html : @param $element the node :)          declare function functx:siblings-same-name ( $element as element()? ) as element()* { $element/../*[node-name(.) = node-name($element)] except $element } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <fName>Jane</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:siblings-same-name( $in-xml/author[1]/fName[2]))
declare namespace functx = "http://www.example.com/";                     (:~ : The siblings of an XML element that have the same name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_siblings-same-name.html : @param $element the node :)          declare function functx:siblings-same-name ( $element as element()? ) as element()* { $element/../*[node-name(.) = node-name($element)] except $element } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <fName>Jane</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:siblings-same-name( $in-xml/author[1]), functx:siblings-same-name( $in-xml/author[1]/fName[2]))
declare namespace functx = "http://www.example.com/";                     (:~ : The siblings of an XML node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_siblings.html : @param $node the node :)          declare function functx:siblings ( $node as node()? ) as node()* { $node/../node() except $node } ;                     let $in-xml := <authors a1='xyz'> <author a2='abc'> <fName a3='def'>Kate</fName> <fName a3='def'>Jane</fName> <lName>Jones</lName> </author> <author> <fName a3='def'>John</fName> <lName>Doe</lName> </author> </authors> return (functx:siblings( $in-xml/author[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : The siblings of an XML node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_siblings.html : @param $node the node :)          declare function functx:siblings ( $node as node()? ) as node()* { $node/../node() except $node } ;                     let $in-xml := <authors a1='xyz'> <author a2='abc'> <fName a3='def'>Kate</fName> <fName a3='def'>Jane</fName> <lName>Jones</lName> </author> <author> <fName a3='def'>John</fName> <lName>Doe</lName> </author> </authors> return (functx:siblings( $in-xml/author[1]/fName[2]))
declare namespace functx = "http://www.example.com/";                     (:~ : The siblings of an XML node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_siblings.html : @param $node the node :)          declare function functx:siblings ( $node as node()? ) as node()* { $node/../node() except $node } ;                     let $in-xml := <authors a1='xyz'> <author a2='abc'> <fName a3='def'>Kate</fName> <fName a3='def'>Jane</fName> <lName>Jones</lName> </author> <author> <fName a3='def'>John</fName> <lName>Doe</lName> </author> </authors> return (functx:siblings( $in-xml/author[1]), functx:siblings( $in-xml/author[1]/fName[2]))
declare namespace functx = "http://www.example.com/";                     (:~ : The substring before the first text that matches a regex : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-match.html : @param $arg the string to substring : @param $regex the regular expression :)          declare function functx:substring-before-match ( $arg as xs:string? , $regex as xs:string ) as xs:string? { tokenize($arg,$regex)[1] } ;                     (functx:substring-before-match( 'abcd-abcd', 'bc?'))
declare namespace functx = "http://www.example.com/";                     (:~ : The substring before the first text that matches a regex : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-match.html : @param $arg the string to substring : @param $regex the regular expression :)          declare function functx:substring-before-match ( $arg as xs:string? , $regex as xs:string ) as xs:string? { tokenize($arg,$regex)[1] } ;                     (functx:substring-before-match( 'abcd-abcd', 'x'))
declare namespace functx = "http://www.example.com/";                     (:~ : The substring before the first text that matches a regex : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-match.html : @param $arg the string to substring : @param $regex the regular expression :)          declare function functx:substring-before-match ( $arg as xs:string? , $regex as xs:string ) as xs:string? { tokenize($arg,$regex)[1] } ;                     (functx:substring-before-match( 'abc-def-ghi', '[dg]'))
declare namespace functx = "http://www.example.com/";                     (:~ : The substring before the first text that matches a regex : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-before-match.html : @param $arg the string to substring : @param $regex the regular expression :)          declare function functx:substring-before-match ( $arg as xs:string? , $regex as xs:string ) as xs:string? { tokenize($arg,$regex)[1] } ;                     (functx:substring-before-match( 'abc-def-ghi', '[dg]'), functx:substring-before-match( 'abcd-abcd', 'bc?'), functx:substring-before-match( 'abcd-abcd', 'x'))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of days in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-days-from-duration.html : @param $duration the duration :)          declare function functx:total-days-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('P1D') } ;                     (functx:total-days-from-duration( xs:dayTimeDuration('P1D')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of days in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-days-from-duration.html : @param $duration the duration :)          declare function functx:total-days-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('P1D') } ;                     (functx:total-days-from-duration( xs:dayTimeDuration('PT24H')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of days in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-days-from-duration.html : @param $duration the duration :)          declare function functx:total-days-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('P1D') } ;                     (functx:total-days-from-duration( xs:dayTimeDuration('PT24H')), functx:total-days-from-duration( xs:dayTimeDuration('P1D')), functx:total-days-from-duration( xs:dayTimeDuration('PT36H')), functx:total-days-from-duration( xs:dayTimeDuration('PT48H')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of days in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-days-from-duration.html : @param $duration the duration :)          declare function functx:total-days-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('P1D') } ;                     (functx:total-days-from-duration( xs:dayTimeDuration('PT36H')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of days in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-days-from-duration.html : @param $duration the duration :)          declare function functx:total-days-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('P1D') } ;                     (functx:total-days-from-duration( xs:dayTimeDuration('PT48H')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of hours in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-hours-from-duration.html : @param $duration the duration :)          declare function functx:total-hours-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1H') } ;                     (functx:total-hours-from-duration( xs:dayTimeDuration('P1D')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of hours in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-hours-from-duration.html : @param $duration the duration :)          declare function functx:total-hours-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1H') } ;                     (functx:total-hours-from-duration( xs:dayTimeDuration('P1DT2H')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of hours in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-hours-from-duration.html : @param $duration the duration :)          declare function functx:total-hours-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1H') } ;                     (functx:total-hours-from-duration( xs:dayTimeDuration('PT1H30M')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of hours in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-hours-from-duration.html : @param $duration the duration :)          declare function functx:total-hours-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1H') } ;                     (functx:total-hours-from-duration( xs:dayTimeDuration('PT26H')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of hours in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-hours-from-duration.html : @param $duration the duration :)          declare function functx:total-hours-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1H') } ;                     (functx:total-hours-from-duration( xs:dayTimeDuration('PT26H')), functx:total-hours-from-duration( xs:dayTimeDuration('PT1H30M')), functx:total-hours-from-duration( xs:dayTimeDuration('-PT3H')), functx:total-hours-from-duration( xs:dayTimeDuration('P1D')), functx:total-hours-from-duration( xs:dayTimeDuration('P1DT2H')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of hours in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-hours-from-duration.html : @param $duration the duration :)          declare function functx:total-hours-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1H') } ;                     (functx:total-hours-from-duration( xs:dayTimeDuration('-PT3H')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of minutes in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-minutes-from-duration.html : @param $duration the duration :)          declare function functx:total-minutes-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1M') } ;                     (functx:total-minutes-from-duration( xs:dayTimeDuration('PT1H90M')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of minutes in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-minutes-from-duration.html : @param $duration the duration :)          declare function functx:total-minutes-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1M') } ;                     (functx:total-minutes-from-duration( xs:dayTimeDuration('PT1M30S')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of minutes in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-minutes-from-duration.html : @param $duration the duration :)          declare function functx:total-minutes-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1M') } ;                     (functx:total-minutes-from-duration( xs:dayTimeDuration('PT3H')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of minutes in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-minutes-from-duration.html : @param $duration the duration :)          declare function functx:total-minutes-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1M') } ;                     (functx:total-minutes-from-duration( xs:dayTimeDuration('PT90M')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of minutes in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-minutes-from-duration.html : @param $duration the duration :)          declare function functx:total-minutes-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1M') } ;                     (functx:total-minutes-from-duration( xs:dayTimeDuration('PT90M')), functx:total-minutes-from-duration( xs:dayTimeDuration('PT1H90M')), functx:total-minutes-from-duration( xs:dayTimeDuration('PT3H')), functx:total-minutes-from-duration( xs:dayTimeDuration('PT1M30S')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of months in a yearMonthDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-months-from-duration.html : @param $duration the duration :)          declare function functx:total-months-from-duration ( $duration as xs:yearMonthDuration? ) as xs:decimal? { $duration div xs:yearMonthDuration('P1M') } ;                     (functx:total-months-from-duration( xs:yearMonthDuration('P18M')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of months in a yearMonthDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-months-from-duration.html : @param $duration the duration :)          declare function functx:total-months-from-duration ( $duration as xs:yearMonthDuration? ) as xs:decimal? { $duration div xs:yearMonthDuration('P1M') } ;                     (functx:total-months-from-duration( xs:yearMonthDuration('P18M')), functx:total-months-from-duration( xs:yearMonthDuration('P1Y')), functx:total-months-from-duration( xs:yearMonthDuration('P1Y6M')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of months in a yearMonthDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-months-from-duration.html : @param $duration the duration :)          declare function functx:total-months-from-duration ( $duration as xs:yearMonthDuration? ) as xs:decimal? { $duration div xs:yearMonthDuration('P1M') } ;                     (functx:total-months-from-duration( xs:yearMonthDuration('P1Y')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of months in a yearMonthDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-months-from-duration.html : @param $duration the duration :)          declare function functx:total-months-from-duration ( $duration as xs:yearMonthDuration? ) as xs:decimal? { $duration div xs:yearMonthDuration('P1M') } ;                     (functx:total-months-from-duration( xs:yearMonthDuration('P1Y6M')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of seconds in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-seconds-from-duration.html : @param $duration the duration :)          declare function functx:total-seconds-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1S') } ;                     (functx:total-seconds-from-duration( xs:dayTimeDuration('PT1M30S')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of seconds in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-seconds-from-duration.html : @param $duration the duration :)          declare function functx:total-seconds-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1S') } ;                     (functx:total-seconds-from-duration( xs:dayTimeDuration('PT3M')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of seconds in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-seconds-from-duration.html : @param $duration the duration :)          declare function functx:total-seconds-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1S') } ;                     (functx:total-seconds-from-duration( xs:dayTimeDuration('PT90.5S')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of seconds in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-seconds-from-duration.html : @param $duration the duration :)          declare function functx:total-seconds-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1S') } ;                     (functx:total-seconds-from-duration( xs:dayTimeDuration('PT90S')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of seconds in a dayTimeDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-seconds-from-duration.html : @param $duration the duration :)          declare function functx:total-seconds-from-duration ( $duration as xs:dayTimeDuration? ) as xs:decimal? { $duration div xs:dayTimeDuration('PT1S') } ;                     (functx:total-seconds-from-duration( xs:dayTimeDuration('PT90S')), functx:total-seconds-from-duration( xs:dayTimeDuration('PT90.5S')), functx:total-seconds-from-duration( xs:dayTimeDuration('PT1M30S')), functx:total-seconds-from-duration( xs:dayTimeDuration('PT3M')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of years in a yearMonthDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-years-from-duration.html : @param $duration the duration :)          declare function functx:total-years-from-duration ( $duration as xs:yearMonthDuration? ) as xs:decimal? { $duration div xs:yearMonthDuration('P1Y') } ;                     (functx:total-years-from-duration( xs:yearMonthDuration('P18M')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of years in a yearMonthDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-years-from-duration.html : @param $duration the duration :)          declare function functx:total-years-from-duration ( $duration as xs:yearMonthDuration? ) as xs:decimal? { $duration div xs:yearMonthDuration('P1Y') } ;                     (functx:total-years-from-duration( xs:yearMonthDuration('P18M')), functx:total-years-from-duration( xs:yearMonthDuration('P1Y')), functx:total-years-from-duration( xs:yearMonthDuration('P1Y6M')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of years in a yearMonthDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-years-from-duration.html : @param $duration the duration :)          declare function functx:total-years-from-duration ( $duration as xs:yearMonthDuration? ) as xs:decimal? { $duration div xs:yearMonthDuration('P1Y') } ;                     (functx:total-years-from-duration( xs:yearMonthDuration('P1Y')))
declare namespace functx = "http://www.example.com/";                     (:~ : The total number of years in a yearMonthDuration : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_total-years-from-duration.html : @param $duration the duration :)          declare function functx:total-years-from-duration ( $duration as xs:yearMonthDuration? ) as xs:decimal? { $duration div xs:yearMonthDuration('P1Y') } ;                     (functx:total-years-from-duration( xs:yearMonthDuration('P1Y6M')))
declare namespace functx = "http://www.example.com/";                     (:~ : The XML node in a sequence that appears first in document order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_first-node.html : @param $nodes the sequence of nodes :)          declare function functx:first-node ( $nodes as node()* ) as node()? { ($nodes/.)[1] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:first-node($in-xml//fName))
declare namespace functx = "http://www.example.com/";                     (:~ : The XML node in a sequence that appears first in document order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_first-node.html : @param $nodes the sequence of nodes :)          declare function functx:first-node ( $nodes as node()* ) as node()? { ($nodes/.)[1] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:first-node($in-xml//fName), functx:first-node( ($in-xml//lName, $in-xml//fName) ))
declare namespace functx = "http://www.example.com/";                     (:~ : The XML node in a sequence that appears first in document order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_first-node.html : @param $nodes the sequence of nodes :)          declare function functx:first-node ( $nodes as node()* ) as node()? { ($nodes/.)[1] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:first-node( ($in-xml//lName, $in-xml//fName) ))
declare namespace functx = "http://www.example.com/";                     (:~ : The XML node in a sequence that is last in document order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_last-node.html : @param $nodes the sequence of nodes :)          declare function functx:last-node ( $nodes as node()* ) as node()? { ($nodes/.)[last()] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:last-node($in-xml//fName))
declare namespace functx = "http://www.example.com/";                     (:~ : The XML node in a sequence that is last in document order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_last-node.html : @param $nodes the sequence of nodes :)          declare function functx:last-node ( $nodes as node()* ) as node()? { ($nodes/.)[last()] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:last-node($in-xml//fName), functx:last-node( ($in-xml//lName, $in-xml//fName) ))
declare namespace functx = "http://www.example.com/";                     (:~ : The XML node in a sequence that is last in document order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_last-node.html : @param $nodes the sequence of nodes :)          declare function functx:last-node ( $nodes as node()* ) as node()? { ($nodes/.)[last()] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:last-node( ($in-xml//lName, $in-xml//fName) ))
declare namespace functx = "http://www.example.com/";                     (:~ : The XML node kind (element, attribute, text, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_node-kind.html : @param $nodes the node(s) whose kind you want to determine :)          declare function functx:node-kind ( $nodes as node()* ) as xs:string* { for $node in $nodes return if ($node instance of element()) then 'element' else if ($node instance of attribute()) then 'attribute' else if ($node instance of text()) then 'text' else if ($node instance of document-node()) then 'document-node' else if ($node instance of comment()) then 'comment' else if ($node instance of processing-instruction()) then 'processing-instruction' else 'unknown' } ;          let $in-xml := <in-xml> <!-- this is in-xml --> <?test see?> <a z="2">xyz</a> </in-xml>           return (functx:node-kind(/))
declare namespace functx = "http://www.example.com/";                     (:~ : The XML node kind (element, attribute, text, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_node-kind.html : @param $nodes the node(s) whose kind you want to determine :)          declare function functx:node-kind ( $nodes as node()* ) as xs:string* { for $node in $nodes return if ($node instance of element()) then 'element' else if ($node instance of attribute()) then 'attribute' else if ($node instance of text()) then 'text' else if ($node instance of document-node()) then 'document-node' else if ($node instance of comment()) then 'comment' else if ($node instance of processing-instruction()) then 'processing-instruction' else 'unknown' } ;                     let $in-xml := <in-xml> <!-- this is in-xml --> <?test see?> <a z="2">xyz</a> </in-xml> return (functx:node-kind($in-xml/a))
declare namespace functx = "http://www.example.com/";                                         (:~ : The XML node kind (element, attribute, text, etc.) :                          : @author Priscilla Walmsley, Datypic : @version 1.0                         : @see http://www.xqueryfunctions.com/xq/functx_node-kind.html                         : @param $nodes the node(s) whose kind you want to determine :)          declare function functx:node-kind ( $nodes as node()* ) as xs:string* {            for $node in $nodes return            if ($node instance of element()) then 'element'            else if ($node instance of attribute()) then 'attribute'            else if ($node instance of text()) then 'text'            else if ($node instance of document-node()) then 'document-node'            else if ($node instance of comment()) then 'comment'            else if ($node instance of processing-instruction()) then 'processing-instruction'            else 'unknown' } ;          let $in-xml := <in-xml> <!-- this is in-xml --> <?test see?> <a z="2">xyz</a> </in-xml>           return (functx:node-kind($in-xml/a),                      functx:node-kind($in-xml/a/@z),                      functx:node-kind($in-xml/comment()),                      functx:node-kind( $in-xml/processing-instruction()),                      functx:node-kind($in-xml/a/text()),                      functx:node-kind(/))
declare namespace functx = "http://www.example.com/";                     (:~ : The XML node kind (element, attribute, text, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_node-kind.html : @param $nodes the node(s) whose kind you want to determine :)          declare function functx:node-kind ( $nodes as node()* ) as xs:string* { for $node in $nodes return if ($node instance of element()) then 'element' else if ($node instance of attribute()) then 'attribute' else if ($node instance of text()) then 'text' else if ($node instance of document-node()) then 'document-node' else if ($node instance of comment()) then 'comment' else if ($node instance of processing-instruction()) then 'processing-instruction' else 'unknown' } ;                     let $in-xml := <in-xml> <!-- this is in-xml --> <?test see?> <a z="2">xyz</a> </in-xml> return (functx:node-kind($in-xml/a/text()))
declare namespace functx = "http://www.example.com/";                     (:~ : The XML node kind (element, attribute, text, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_node-kind.html : @param $nodes the node(s) whose kind you want to determine :)          declare function functx:node-kind ( $nodes as node()* ) as xs:string* { for $node in $nodes return if ($node instance of element()) then 'element' else if ($node instance of attribute()) then 'attribute' else if ($node instance of text()) then 'text' else if ($node instance of document-node()) then 'document-node' else if ($node instance of comment()) then 'comment' else if ($node instance of processing-instruction()) then 'processing-instruction' else 'unknown' } ;                     let $in-xml := <in-xml> <!-- this is in-xml --> <?test see?> <a z="2">xyz</a> </in-xml> return (functx:node-kind($in-xml/a/@z))
declare namespace functx = "http://www.example.com/";                     (:~ : The XML node kind (element, attribute, text, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_node-kind.html : @param $nodes the node(s) whose kind you want to determine :)          declare function functx:node-kind ( $nodes as node()* ) as xs:string* { for $node in $nodes return if ($node instance of element()) then 'element' else if ($node instance of attribute()) then 'attribute' else if ($node instance of text()) then 'text' else if ($node instance of document-node()) then 'document-node' else if ($node instance of comment()) then 'comment' else if ($node instance of processing-instruction()) then 'processing-instruction' else 'unknown' } ;                     let $in-xml := <in-xml> <!-- this is in-xml --> <?test see?> <a z="2">xyz</a> </in-xml> return (functx:node-kind($in-xml/comment()))
declare namespace functx = "http://www.example.com/";                     (:~ : The XML node kind (element, attribute, text, etc.) : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_node-kind.html : @param $nodes the node(s) whose kind you want to determine :)          declare function functx:node-kind ( $nodes as node()* ) as xs:string* { for $node in $nodes return if ($node instance of element()) then 'element' else if ($node instance of attribute()) then 'attribute' else if ($node instance of text()) then 'text' else if ($node instance of document-node()) then 'document-node' else if ($node instance of comment()) then 'comment' else if ($node instance of processing-instruction()) then 'processing-instruction' else 'unknown' } ;                     let $in-xml := <in-xml> <!-- this is in-xml --> <?test see?> <a z="2">xyz</a> </in-xml> return (functx:node-kind( $in-xml/processing-instruction()))
declare namespace functx = "http://www.example.com/";                     (:~ : The XML nodes with distinct values, taking into account attributes and descendants : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_distinct-deep.html : @param $nodes the sequence of nodes to test :)          declare function functx:distinct-deep ( $nodes as node()* ) as node()* { for $seq in (1 to count($nodes)) return $nodes[$seq][not(functx:is-node-in-sequence-deep-equal( .,$nodes[position() < $seq]))] } ;                     (:~ : Whether an XML node is in a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>Kate</fName> <lName>Doe</lName> </author> </authors> return (functx:distinct-deep($in-xml//author))
declare namespace functx = "http://www.example.com/";                     (:~ : The XML nodes with distinct values, taking into account attributes and descendants : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_distinct-deep.html : @param $nodes the sequence of nodes to test :)          declare function functx:distinct-deep ( $nodes as node()* ) as node()* { for $seq in (1 to count($nodes)) return $nodes[$seq][not(functx:is-node-in-sequence-deep-equal( .,$nodes[position() < $seq]))] } ;                     (:~ : Whether an XML node is in a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>Kate</fName> <lName>Doe</lName> </author> </authors> return (functx:distinct-deep($in-xml//author), functx:distinct-deep($in-xml//lName), functx:distinct-deep($in-xml//fName))
declare namespace functx = "http://www.example.com/";                     (:~ : The XML nodes with distinct values, taking into account attributes and descendants : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_distinct-deep.html : @param $nodes the sequence of nodes to test :)          declare function functx:distinct-deep ( $nodes as node()* ) as node()* { for $seq in (1 to count($nodes)) return $nodes[$seq][not(functx:is-node-in-sequence-deep-equal( .,$nodes[position() < $seq]))] } ;                     (:~ : Whether an XML node is in a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>Kate</fName> <lName>Doe</lName> </author> </authors> return (functx:distinct-deep($in-xml//fName))
declare namespace functx = "http://www.example.com/";                     (:~ : The XML nodes with distinct values, taking into account attributes and descendants : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_distinct-deep.html : @param $nodes the sequence of nodes to test :)          declare function functx:distinct-deep ( $nodes as node()* ) as node()* { for $seq in (1 to count($nodes)) return $nodes[$seq][not(functx:is-node-in-sequence-deep-equal( .,$nodes[position() < $seq]))] } ;                     (:~ : Whether an XML node is in a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>Kate</fName> <lName>Doe</lName> </author> </authors> return (functx:distinct-deep($in-xml//lName))
declare namespace functx = "http://www.example.com/";                     (:~ : The XML node whose typed value is the maximum : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_max-node.html : @param $nodes the sequence of nodes to test :)          declare function functx:max-node ( $nodes as node()* ) as node()* { $nodes[. = max($nodes)] } ;                     let $in-xml := <values> <int>1</int> <int>23</int> <int>115</int> </values> return (functx:max-node($in-xml//int))
declare namespace functx = "http://www.example.com/";                     (:~ : The XML node whose typed value is the minimum : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_min-node.html : @param $nodes the sequence of nodes to test :)          declare function functx:min-node ( $nodes as node()* ) as node()* { $nodes[. = min($nodes)] } ;                     let $in-xml := <values> <int>1</int> <int>23</int> <int>115</int> </values> return (functx:min-node($in-xml//int))
declare namespace functx = "http://www.example.com/";                     (:~ : Updates the attribute value of an XML element : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_update-attributes.html : @param $elements the element(s) for which you wish to update the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return if ($element/@*[node-name(.) = $attrName]) then attribute {$attrName} {$attrValues[$seq]} else (), $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml xmlns:new='http://new'> <a att1='def'>x</a> <b>x</b> <c new:att1='def'>x</c> </in-xml> return (functx:update-attributes( $in-xml/a, xs:QName('att1'), 123))
declare namespace functx = "http://www.example.com/";                     (:~ : Updates the attribute value of an XML element : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_update-attributes.html : @param $elements the element(s) for which you wish to update the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return if ($element/@*[node-name(.) = $attrName]) then attribute {$attrName} {$attrValues[$seq]} else (), $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml xmlns:new='http://new'> <a att1='def'>x</a> <b>x</b> <c new:att1='def'>x</c> </in-xml> return (functx:update-attributes( $in-xml/a, xs:QName('att1'), 123), functx:update-attributes( $in-xml/a, (xs:QName('att1'),xs:QName('att2')), (1,2)), functx:update-attributes( $in-xml/b, xs:QName('att1'), 123), functx:update-attributes( $in-xml/c, QName('http://new','prefix:att1'), 123))
declare namespace functx = "http://www.example.com/";                     (:~ : Updates the attribute value of an XML element : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_update-attributes.html : @param $elements the element(s) for which you wish to update the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return if ($element/@*[node-name(.) = $attrName]) then attribute {$attrName} {$attrValues[$seq]} else (), $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml xmlns:new='http://new'> <a att1='def'>x</a> <b>x</b> <c new:att1='def'>x</c> </in-xml> return (functx:update-attributes( $in-xml/a, (xs:QName('att1'),xs:QName('att2')), (1,2)))
declare namespace functx = "http://www.example.com/";                     (:~ : Updates the attribute value of an XML element : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_update-attributes.html : @param $elements the element(s) for which you wish to update the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return if ($element/@*[node-name(.) = $attrName]) then attribute {$attrName} {$attrValues[$seq]} else (), $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml xmlns:new='http://new'> <a att1='def'>x</a> <b>x</b> <c new:att1='def'>x</c> </in-xml> return (functx:update-attributes( $in-xml/b, xs:QName('att1'), 123))
declare namespace functx = "http://www.example.com/";                     (:~ : Updates the attribute value of an XML element : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_update-attributes.html : @param $elements the element(s) for which you wish to update the attribute : @param $attrNames the name(s) of the attribute(s) to add : @param $attrValues the value(s) of the attribute(s) to add :)          declare function functx:update-attributes ( $elements as element()* , $attrNames as xs:QName* , $attrValues as xs:anyAtomicType* ) as element()? { for $element in $elements return element { node-name($element)} { for $attrName at $seq in $attrNames return if ($element/@*[node-name(.) = $attrName]) then attribute {$attrName} {$attrValues[$seq]} else (), $element/@*[not(node-name(.) = $attrNames)], $element/node() } } ;                     let $in-xml := <in-xml xmlns:new='http://new'> <a att1='def'>x</a> <b>x</b> <c new:att1='def'>x</c> </in-xml> return (functx:update-attributes( $in-xml/c, QName('http://new','prefix:att1'), 123))
declare namespace functx = "http://www.example.com/";                     (:~ : Updates the content of one or more elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_replace-element-values.html : @param $elements the elements whose content you wish to replace : @param $values the replacement values :)          declare function functx:replace-element-values ( $elements as element()* , $values as xs:anyAtomicType* ) as element()* { for $element at $seq in $elements return element { node-name($element)} { $element/@*, $values[$seq] } } ;                     let $in-xml := <in-xml> <price num="1">12</price> <price num="2">20</price> <price num="3">5</price> </in-xml> return (for $p in $in-xml/price return functx:replace-element-values( $p,concat($p,'.0')))
declare namespace functx = "http://www.example.com/";                     (:~ : Updates the content of one or more elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_replace-element-values.html : @param $elements the elements whose content you wish to replace : @param $values the replacement values :)          declare function functx:replace-element-values ( $elements as element()* , $values as xs:anyAtomicType* ) as element()* { for $element at $seq in $elements return element { node-name($element)} { $element/@*, $values[$seq] } } ;                     let $in-xml := <in-xml> <price num="1">12</price> <price num="2">20</price> <price num="3">5</price> </in-xml> return (functx:replace-element-values( $in-xml/price, for $p in $in-xml/price return $p * 2))
declare namespace functx = "http://www.example.com/";                     (:~ : Updates the content of one or more elements : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_replace-element-values.html : @param $elements the elements whose content you wish to replace : @param $values the replacement values :)          declare function functx:replace-element-values ( $elements as element()* , $values as xs:anyAtomicType* ) as element()* { for $element at $seq in $elements return element { node-name($element)} { $element/@*, $values[$seq] } } ;                     let $in-xml := <in-xml> <price num="1">12</price> <price num="2">20</price> <price num="3">5</price> </in-xml> return (functx:replace-element-values( $in-xml/price, for $p in $in-xml/price return $p * 2), for $p in $in-xml/price return functx:replace-element-values( $p,concat($p,'.0')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a date falls in a leap year : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-leap-year.html : @param $date the date or year :)          declare function functx:is-leap-year ( $date as xs:anyAtomicType? ) as xs:boolean { for $year in xs:integer(substring(string($date),1,4)) return ($year mod 4 = 0 and $year mod 100 != 0) or $year mod 400 = 0 } ;                     (functx:is-leap-year(2004))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a date falls in a leap year : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-leap-year.html : @param $date the date or year :)          declare function functx:is-leap-year ( $date as xs:anyAtomicType? ) as xs:boolean { for $year in xs:integer(substring(string($date),1,4)) return ($year mod 4 = 0 and $year mod 100 != 0) or $year mod 400 = 0 } ;                     (functx:is-leap-year('2005-02-15'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a date falls in a leap year : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-leap-year.html : @param $date the date or year :)          declare function functx:is-leap-year ( $date as xs:anyAtomicType? ) as xs:boolean { for $year in xs:integer(substring(string($date),1,4)) return ($year mod 4 = 0 and $year mod 100 != 0) or $year mod 400 = 0 } ;                     (functx:is-leap-year(xs:date('2004-01-23')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a date falls in a leap year : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-leap-year.html : @param $date the date or year :)          declare function functx:is-leap-year ( $date as xs:anyAtomicType? ) as xs:boolean { for $year in xs:integer(substring(string($date),1,4)) return ($year mod 4 = 0 and $year mod 100 != 0) or $year mod 400 = 0 } ;                     (functx:is-leap-year(xs:date('2004-01-23')), functx:is-leap-year(2004), functx:is-leap-year('2005-02-15'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml := <pre:a xmlns:pre="http://ns.example.com/ns1">abc</pre:a> return (functx:name-test(name($in-xml),('*')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml := <pre:a xmlns:pre="http://ns.example.com/ns1">abc</pre:a> return (functx:name-test(name($in-xml),('*:a')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml := <pre:a xmlns:pre="http://ns.example.com/ns1">abc</pre:a> return (functx:name-test( name($in-xml),('a','b','c')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml := <pre:a xmlns:pre="http://ns/example.com/ns1">abc</pre:a> return (functx:name-test(name($in-xml),('*')), functx:name-test(name($in-xml),('pre:*')), functx:name-test(name($in-xml),('*:a')), functx:name-test( name($in-xml),('pre:a','pre:b')), functx:name-test( name($in-xml),('a','b','c')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml := <pre:a xmlns:pre="http://ns.example.com/ns1">abc</pre:a> return (functx:name-test(name($in-xml),('pre:*')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml := <pre:a xmlns:pre="http://ns.example.com/ns1">abc</pre:a> return (functx:name-test( name($in-xml),('pre:a','pre:b')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML element, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes.html : @param $elements the element(s) from which to remove the attributes : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes ( $elements as element()* , $names as xs:string* ) as element() { for $element in $elements return element {node-name($element)} {$element/@*[not(functx:name-test(name(),$names))], $element/node() } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456">abc</a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456">abc</a> return (functx:remove-attributes($in-xml-1, '*'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML element, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes.html : @param $elements the element(s) from which to remove the attributes : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes ( $elements as element()* , $names as xs:string* ) as element() { for $element in $elements return element {node-name($element)} {$element/@*[not(functx:name-test(name(),$names))], $element/node() } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456">abc</a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456">abc</a> return (functx:remove-attributes( $in-xml-1, ('attr1','attr2')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML element, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes.html : @param $elements the element(s) from which to remove the attributes : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes ( $elements as element()* , $names as xs:string* ) as element() { for $element in $elements return element {node-name($element)} {$element/@*[not(functx:name-test(name(),$names))], $element/node() } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456">abc</a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456">abc</a> return (functx:remove-attributes( $in-xml-1, ('attr1','attr2')), functx:remove-attributes( $in-xml-1, ('attr1','attr3')), functx:remove-attributes($in-xml-1, '*'), functx:remove-attributes( $in-xml-2, ('a:attr1')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML element, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes.html : @param $elements the element(s) from which to remove the attributes : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes ( $elements as element()* , $names as xs:string* ) as element() { for $element in $elements return element {node-name($element)} {$element/@*[not(functx:name-test(name(),$names))], $element/node() } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456">abc</a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456">abc</a> return (functx:remove-attributes( $in-xml-1, ('attr1','attr3')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML element, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes.html : @param $elements the element(s) from which to remove the attributes : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes ( $elements as element()* , $names as xs:string* ) as element() { for $element in $elements return element {node-name($element)} {$element/@*[not(functx:name-test(name(),$names))], $element/node() } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456">abc</a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456">abc</a> return (functx:remove-attributes( $in-xml-2, ('a:attr1')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML fragment, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes-deep.html : @param $nodes the root(s) to start from : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then element { node-name($node)} { $node/@*[not(functx:name-test(name(),$names))], functx:remove-attributes-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-attributes-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456"> <b attr1="xzy">abc</b> </a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456"> <b a:attr1="ghi" attr1="xzy">abc</b> </a> return (functx:remove-attributes-deep( $in-xml-1, ('attr1','attr2')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML fragment, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes-deep.html : @param $nodes the root(s) to start from : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then element { node-name($node)} { $node/@*[not(functx:name-test(name(),$names))], functx:remove-attributes-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-attributes-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456"> <b attr1="xzy">abc</b> </a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456"> <b a:attr1="ghi" attr1="xzy">abc</b> </a> return (functx:remove-attributes-deep( $in-xml-1, ('attr1','attr2')), functx:remove-attributes-deep( $in-xml-1, ('attr1','attr3')), functx:remove-attributes-deep( $in-xml-2, 'a:attr1'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML fragment, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes-deep.html : @param $nodes the root(s) to start from : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then element { node-name($node)} { $node/@*[not(functx:name-test(name(),$names))], functx:remove-attributes-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-attributes-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456"> <b attr1="xzy">abc</b> </a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456"> <b a:attr1="ghi" attr1="xzy">abc</b> </a> return (functx:remove-attributes-deep( $in-xml-1, ('attr1','attr3')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes attributes from an XML fragment, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-attributes-deep.html : @param $nodes the root(s) to start from : @param $names the names of the attributes to remove, or * for all attributes :)          declare function functx:remove-attributes-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then element { node-name($node)} { $node/@*[not(functx:name-test(name(),$names))], functx:remove-attributes-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-attributes-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <a attr1="123" attr2="456"> <b attr1="xzy">abc</b> </a> return let $in-xml-2 := <a xmlns:a="http://a" a:attr1="123" attr1="456"> <b a:attr1="ghi" attr1="xzy">abc</b> </a> return (functx:remove-attributes-deep( $in-xml-2, 'a:attr1'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes child elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements.html : @param $elements the element(s) from which you wish to remove the children : @param $names the names of the child elements to remove :)          declare function functx:remove-elements ( $elements as element()* , $names as xs:string* ) as element()* { for $element in $elements return element {node-name($element)} {$element/@*, $element/node()[not(functx:name-test(name(),$names))] } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a>123</a> <a>456</a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a>123</a> <x:a>456</x:a> <c>Mixed <x:a>content</x:a></c> </in-xml> return (functx:remove-elements( $in-xml-1, ('a','b')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes child elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements.html : @param $elements the element(s) from which you wish to remove the children : @param $names the names of the child elements to remove :)          declare function functx:remove-elements ( $elements as element()* , $names as xs:string* ) as element()* { for $element in $elements return element {node-name($element)} {$element/@*, $element/node()[not(functx:name-test(name(),$names))] } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a>123</a> <a>456</a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a>123</a> <x:a>456</x:a> <c>Mixed <x:a>content</x:a></c> </in-xml> return (functx:remove-elements( $in-xml-1, 'c'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes child elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements.html : @param $elements the element(s) from which you wish to remove the children : @param $names the names of the child elements to remove :)          declare function functx:remove-elements ( $elements as element()* , $names as xs:string* ) as element()* { for $element in $elements return element {node-name($element)} {$element/@*, $element/node()[not(functx:name-test(name(),$names))] } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a>123</a> <a>456</a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a>123</a> <x:a>456</x:a> <c>Mixed <x:a>content</x:a></c> </in-xml> return (functx:remove-elements( $in-xml-1, 'c'), functx:remove-elements( $in-xml-1, ('a','b')), functx:remove-elements( $in-xml-2, 'x:a'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes child elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements.html : @param $elements the element(s) from which you wish to remove the children : @param $names the names of the child elements to remove :)          declare function functx:remove-elements ( $elements as element()* , $names as xs:string* ) as element()* { for $element in $elements return element {node-name($element)} {$element/@*, $element/node()[not(functx:name-test(name(),$names))] } } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a>123</a> <a>456</a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a>123</a> <x:a>456</x:a> <c>Mixed <x:a>content</x:a></c> </in-xml> return (functx:remove-elements( $in-xml-2, 'x:a'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-deep.html : @param $nodes root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then () else element { node-name($node)} { $node/@*, functx:remove-elements-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-elements-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <x:b>b1</x:b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return (functx:remove-elements-deep( $in-xml-1, 'a'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-deep.html : @param $nodes root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then () else element { node-name($node)} { $node/@*, functx:remove-elements-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-elements-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <x:b>b1</x:b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return (functx:remove-elements-deep( $in-xml-1, 'b'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-deep.html : @param $nodes root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then () else element { node-name($node)} { $node/@*, functx:remove-elements-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-elements-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <x:b>b1</x:b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return (functx:remove-elements-deep( $in-xml-1, ('b','c')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-deep.html : @param $nodes root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then () else element { node-name($node)} { $node/@*, functx:remove-elements-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-elements-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <x:b>b1</x:b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return (functx:remove-elements-deep( $in-xml-1, 'b'), functx:remove-elements-deep( $in-xml-1, 'a'), functx:remove-elements-deep( $in-xml-1, ('b','c')), functx:remove-elements-deep( $in-xml-2, 'x:b'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant elements from an XML node, based on name : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-deep.html : @param $nodes root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-deep ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then () else element { node-name($node)} { $node/@*, functx:remove-elements-deep($node/node(), $names)} else if ($node instance of document-node()) then functx:remove-elements-deep($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <x:b>b1</x:b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return (functx:remove-elements-deep( $in-xml-2, 'x:b'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant XML elements but keeps their content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-not-contents.html : @param $nodes the root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-not-contents ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then functx:remove-elements-not-contents($node/node(), $names) else element {node-name($node)} {$node/@*, functx:remove-elements-not-contents($node/node(),$names)} else if ($node instance of document-node()) then functx:remove-elements-not-contents($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <x:b>content</x:b></c> </in-xml> return (functx:remove-elements-not-contents( $in-xml-1, 'a'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant XML elements but keeps their content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-not-contents.html : @param $nodes the root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-not-contents ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then functx:remove-elements-not-contents($node/node(), $names) else element {node-name($node)} {$node/@*, functx:remove-elements-not-contents($node/node(),$names)} else if ($node instance of document-node()) then functx:remove-elements-not-contents($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <x:b>content</x:b></c> </in-xml> return (functx:remove-elements-not-contents( $in-xml-1, 'b'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant XML elements but keeps their content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-not-contents.html : @param $nodes the root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-not-contents ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then functx:remove-elements-not-contents($node/node(), $names) else element {node-name($node)} {$node/@*, functx:remove-elements-not-contents($node/node(),$names)} else if ($node instance of document-node()) then functx:remove-elements-not-contents($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <x:b>content</x:b></c> </in-xml> return (functx:remove-elements-not-contents( $in-xml-1, ('b','c')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant XML elements but keeps their content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-not-contents.html : @param $nodes the root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-not-contents ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then functx:remove-elements-not-contents($node/node(), $names) else element {node-name($node)} {$node/@*, functx:remove-elements-not-contents($node/node(),$names)} else if ($node instance of document-node()) then functx:remove-elements-not-contents($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <x:b>content</x:b></c> </in-xml> return (functx:remove-elements-not-contents( $in-xml-1, 'b'), functx:remove-elements-not-contents( $in-xml-1, ('b','c')), functx:remove-elements-not-contents( $in-xml-1, 'a'), functx:remove-elements-not-contents( $in-xml-2, 'x:b'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a name matches a list of names or name wildcards : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_name-test.html : @param $testname the name to test : @param $names the list of names or name wildcards :)          declare function functx:name-test ( $testname as xs:string? , $names as xs:string* ) as xs:boolean { $testname = $names or $names = '*' or functx:substring-after-if-contains($testname,':') = (for $name in $names return substring-after($name,'*:')) or substring-before($testname,':') = (for $name in $names[contains(.,':*')] return substring-before($name,':*')) } ;                     (:~ : Removes descendant XML elements but keeps their content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_remove-elements-not-contents.html : @param $nodes the root(s) to start from : @param $names the names of the elements to remove :)          declare function functx:remove-elements-not-contents ( $nodes as node()* , $names as xs:string* ) as node()* { for $node in $nodes return if ($node instance of element()) then if (functx:name-test(name($node),$names)) then functx:remove-elements-not-contents($node/node(), $names) else element {node-name($node)} {$node/@*, functx:remove-elements-not-contents($node/node(),$names)} else if ($node instance of document-node()) then functx:remove-elements-not-contents($node/node(), $names) else $node } ;                     (:~ : Performs substring-after, returning the entire string if it does not contain the delimiter : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_substring-after-if-contains.html : @param $arg the string to substring : @param $delim the delimiter :)          declare function functx:substring-after-if-contains ( $arg as xs:string? , $delim as xs:string ) as xs:string? { if (contains($arg,$delim)) then substring-after($arg,$delim) else $arg } ;                     let $in-xml-1 := <in-xml> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <b>content</b></c> </in-xml> return let $in-xml-2 := <in-xml xmlns:x="http://x"> <a> <b>b1</b> <c>c1</c> </a> <c>Mixed <x:b>content</x:b></c> </in-xml> return (functx:remove-elements-not-contents( $in-xml-2, 'x:b'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an atomic value appears in a sequence : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-value-in-sequence.html : @param $value the atomic value to test : @param $seq the sequence of values to search :)          declare function functx:is-value-in-sequence ( $value as xs:anyAtomicType? , $seq as xs:anyAtomicType* ) as xs:boolean { $value = $seq } ;                     (functx:is-value-in-sequence(1.0,(1,2,3)))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an atomic value appears in a sequence : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-value-in-sequence.html : @param $value the atomic value to test : @param $seq the sequence of values to search :)          declare function functx:is-value-in-sequence ( $value as xs:anyAtomicType? , $seq as xs:anyAtomicType* ) as xs:boolean { $value = $seq } ;                     (functx:is-value-in-sequence(1,(1,2,3)))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an atomic value appears in a sequence : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-value-in-sequence.html : @param $value the atomic value to test : @param $seq the sequence of values to search :)          declare function functx:is-value-in-sequence ( $value as xs:anyAtomicType? , $seq as xs:anyAtomicType* ) as xs:boolean { $value = $seq } ;                     (functx:is-value-in-sequence(1,(1,2,3)), functx:is-value-in-sequence(5,(1,2,3)), functx:is-value-in-sequence(1.0,(1,2,3)))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an atomic value appears in a sequence : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-value-in-sequence.html : @param $value the atomic value to test : @param $seq the sequence of values to search :)          declare function functx:is-value-in-sequence ( $value as xs:anyAtomicType? , $seq as xs:anyAtomicType* ) as xs:boolean { $value = $seq } ;                     (functx:is-value-in-sequence(5,(1,2,3)))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has element-only content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-element-only-content.html : @param $element the XML element to test :)          declare function functx:has-element-only-content ( $element as element() ) as xs:boolean { not($element/text()[normalize-space(.) != '']) and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> <h><x>xml</x><y>xml</y></h> <i> <x>xml</x> <y>xml</y> </i> </in-xml> return (functx:has-element-only-content($in-xml/a))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has element-only content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-element-only-content.html : @param $element the XML element to test :)          declare function functx:has-element-only-content ( $element as element() ) as xs:boolean { not($element/text()[normalize-space(.) != '']) and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> <h><x>xml</x><y>xml</y></h> <i> <x>xml</x> <y>xml</y> </i> </in-xml> return (functx:has-element-only-content($in-xml/a), functx:has-element-only-content($in-xml/b), functx:has-element-only-content($in-xml/c), functx:has-element-only-content($in-xml/d), functx:has-element-only-content($in-xml/e), functx:has-element-only-content($in-xml/f), functx:has-element-only-content($in-xml/g), functx:has-element-only-content($in-xml/h), functx:has-element-only-content($in-xml/i))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has element-only content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-element-only-content.html : @param $element the XML element to test :)          declare function functx:has-element-only-content ( $element as element() ) as xs:boolean { not($element/text()[normalize-space(.) != '']) and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> <h><x>xml</x><y>xml</y></h> <i> <x>xml</x> <y>xml</y> </i> </in-xml> return (functx:has-element-only-content($in-xml/b))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has element-only content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-element-only-content.html : @param $element the XML element to test :)          declare function functx:has-element-only-content ( $element as element() ) as xs:boolean { not($element/text()[normalize-space(.) != '']) and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> <h><x>xml</x><y>xml</y></h> <i> <x>xml</x> <y>xml</y> </i> </in-xml> return (functx:has-element-only-content($in-xml/c))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has element-only content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-element-only-content.html : @param $element the XML element to test :)          declare function functx:has-element-only-content ( $element as element() ) as xs:boolean { not($element/text()[normalize-space(.) != '']) and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> <h><x>xml</x><y>xml</y></h> <i> <x>xml</x> <y>xml</y> </i> </in-xml> return (functx:has-element-only-content($in-xml/d))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has element-only content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-element-only-content.html : @param $element the XML element to test :)          declare function functx:has-element-only-content ( $element as element() ) as xs:boolean { not($element/text()[normalize-space(.) != '']) and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> <h><x>xml</x><y>xml</y></h> <i> <x>xml</x> <y>xml</y> </i> </in-xml> return (functx:has-element-only-content($in-xml/e))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has element-only content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-element-only-content.html : @param $element the XML element to test :)          declare function functx:has-element-only-content ( $element as element() ) as xs:boolean { not($element/text()[normalize-space(.) != '']) and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> <h><x>xml</x><y>xml</y></h> <i> <x>xml</x> <y>xml</y> </i> </in-xml> return (functx:has-element-only-content($in-xml/f))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has element-only content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-element-only-content.html : @param $element the XML element to test :)          declare function functx:has-element-only-content ( $element as element() ) as xs:boolean { not($element/text()[normalize-space(.) != '']) and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> <h><x>xml</x><y>xml</y></h> <i> <x>xml</x> <y>xml</y> </i> </in-xml> return (functx:has-element-only-content($in-xml/g))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has element-only content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-element-only-content.html : @param $element the XML element to test :)          declare function functx:has-element-only-content ( $element as element() ) as xs:boolean { not($element/text()[normalize-space(.) != '']) and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> <h><x>xml</x><y>xml</y></h> <i> <x>xml</x> <y>xml</y> </i> </in-xml> return (functx:has-element-only-content($in-xml/h))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has element-only content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-element-only-content.html : @param $element the XML element to test :)          declare function functx:has-element-only-content ( $element as element() ) as xs:boolean { not($element/text()[normalize-space(.) != '']) and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> <h><x>xml</x><y>xml</y></h> <i> <x>xml</x> <y>xml</y> </i> </in-xml> return (functx:has-element-only-content($in-xml/i))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has empty content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-empty-content.html : @param $element the XML element to test :)          declare function functx:has-empty-content ( $element as element() ) as xs:boolean { not($element/node()) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-empty-content($in-xml/a))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has empty content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-empty-content.html : @param $element the XML element to test :)          declare function functx:has-empty-content ( $element as element() ) as xs:boolean { not($element/node()) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-empty-content($in-xml/a), functx:has-empty-content($in-xml/b), functx:has-empty-content($in-xml/c), functx:has-empty-content($in-xml/d), functx:has-empty-content($in-xml/e), functx:has-empty-content($in-xml/f), functx:has-empty-content($in-xml/g))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has empty content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-empty-content.html : @param $element the XML element to test :)          declare function functx:has-empty-content ( $element as element() ) as xs:boolean { not($element/node()) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-empty-content($in-xml/b))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has empty content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-empty-content.html : @param $element the XML element to test :)          declare function functx:has-empty-content ( $element as element() ) as xs:boolean { not($element/node()) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-empty-content($in-xml/c))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has empty content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-empty-content.html : @param $element the XML element to test :)          declare function functx:has-empty-content ( $element as element() ) as xs:boolean { not($element/node()) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-empty-content($in-xml/d))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has empty content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-empty-content.html : @param $element the XML element to test :)          declare function functx:has-empty-content ( $element as element() ) as xs:boolean { not($element/node()) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-empty-content($in-xml/e))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has empty content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-empty-content.html : @param $element the XML element to test :)          declare function functx:has-empty-content ( $element as element() ) as xs:boolean { not($element/node()) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-empty-content($in-xml/f))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has empty content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-empty-content.html : @param $element the XML element to test :)          declare function functx:has-empty-content ( $element as element() ) as xs:boolean { not($element/node()) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-empty-content($in-xml/g))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has mixed content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-mixed-content.html : @param $element the XML element to test :)          declare function functx:has-mixed-content ( $element as element() ) as xs:boolean { $element/text()[normalize-space(.) != ''] and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-mixed-content($in-xml/a))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has mixed content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-mixed-content.html : @param $element the XML element to test :)          declare function functx:has-mixed-content ( $element as element() ) as xs:boolean { $element/text()[normalize-space(.) != ''] and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-mixed-content($in-xml/a), functx:has-mixed-content($in-xml/b), functx:has-mixed-content($in-xml/c), functx:has-mixed-content($in-xml/d), functx:has-mixed-content($in-xml/e), functx:has-mixed-content($in-xml/f), functx:has-mixed-content($in-xml/g))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has mixed content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-mixed-content.html : @param $element the XML element to test :)          declare function functx:has-mixed-content ( $element as element() ) as xs:boolean { $element/text()[normalize-space(.) != ''] and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-mixed-content($in-xml/b))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has mixed content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-mixed-content.html : @param $element the XML element to test :)          declare function functx:has-mixed-content ( $element as element() ) as xs:boolean { $element/text()[normalize-space(.) != ''] and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-mixed-content($in-xml/c))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has mixed content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-mixed-content.html : @param $element the XML element to test :)          declare function functx:has-mixed-content ( $element as element() ) as xs:boolean { $element/text()[normalize-space(.) != ''] and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-mixed-content($in-xml/d))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has mixed content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-mixed-content.html : @param $element the XML element to test :)          declare function functx:has-mixed-content ( $element as element() ) as xs:boolean { $element/text()[normalize-space(.) != ''] and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-mixed-content($in-xml/e))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has mixed content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-mixed-content.html : @param $element the XML element to test :)          declare function functx:has-mixed-content ( $element as element() ) as xs:boolean { $element/text()[normalize-space(.) != ''] and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-mixed-content($in-xml/f))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has mixed content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-mixed-content.html : @param $element the XML element to test :)          declare function functx:has-mixed-content ( $element as element() ) as xs:boolean { $element/text()[normalize-space(.) != ''] and $element/* } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> <g> <x>xml</x> </g> </in-xml> return (functx:has-mixed-content($in-xml/g))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has simple content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-simple-content.html : @param $element the XML element to test :)          declare function functx:has-simple-content ( $element as element() ) as xs:boolean { $element/text() and not($element/*) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> </in-xml> return (functx:has-simple-content($in-xml/a))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has simple content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-simple-content.html : @param $element the XML element to test :)          declare function functx:has-simple-content ( $element as element() ) as xs:boolean { $element/text() and not($element/*) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> </in-xml> return (functx:has-simple-content($in-xml/a), functx:has-simple-content($in-xml/b), functx:has-simple-content($in-xml/c), functx:has-simple-content($in-xml/d), functx:has-simple-content($in-xml/e), functx:has-simple-content($in-xml/f))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has simple content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-simple-content.html : @param $element the XML element to test :)          declare function functx:has-simple-content ( $element as element() ) as xs:boolean { $element/text() and not($element/*) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> </in-xml> return (functx:has-simple-content($in-xml/b))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has simple content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-simple-content.html : @param $element the XML element to test :)          declare function functx:has-simple-content ( $element as element() ) as xs:boolean { $element/text() and not($element/*) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> </in-xml> return (functx:has-simple-content($in-xml/c))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has simple content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-simple-content.html : @param $element the XML element to test :)          declare function functx:has-simple-content ( $element as element() ) as xs:boolean { $element/text() and not($element/*) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> </in-xml> return (functx:has-simple-content($in-xml/d))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has simple content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-simple-content.html : @param $element the XML element to test :)          declare function functx:has-simple-content ( $element as element() ) as xs:boolean { $element/text() and not($element/*) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> </in-xml> return (functx:has-simple-content($in-xml/e))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an element has simple content : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_has-simple-content.html : @param $element the XML element to test :)          declare function functx:has-simple-content ( $element as element() ) as xs:boolean { $element/text() and not($element/*) } ;                     let $in-xml := <in-xml> <a></a> <b/> <c> </c> <d>xml</d> <e><x>xml</x></e> <f>mixed <x>xml</x></f> </in-xml> return (functx:has-simple-content($in-xml/f))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node follows another without being its descendant : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_follows-not-descendant.html : @param $a the first node : @param $b the second node :)          declare function functx:follows-not-descendant ( $a as node()? , $b as node()? ) as xs:boolean { $a >> $b and empty($b intersect $a/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:follows-not-descendant( $in-xml//author[1],$in-xml//author[2]))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node follows another without being its descendant : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_follows-not-descendant.html : @param $a the first node : @param $b the second node :)          declare function functx:follows-not-descendant ( $a as node()? , $b as node()? ) as xs:boolean { $a >> $b and empty($b intersect $a/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:follows-not-descendant( $in-xml//author[1]/fName, $in-xml//author[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node follows another without being its descendant : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_follows-not-descendant.html : @param $a the first node : @param $b the second node :)          declare function functx:follows-not-descendant ( $a as node()? , $b as node()? ) as xs:boolean { $a >> $b and empty($b intersect $a/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:follows-not-descendant( $in-xml//author[2],$in-xml//author[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node follows another without being its descendant : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_follows-not-descendant.html : @param $a the first node : @param $b the second node :)          declare function functx:follows-not-descendant ( $a as node()? , $b as node()? ) as xs:boolean { $a >> $b and empty($b intersect $a/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:follows-not-descendant( $in-xml//author[2],$in-xml//author[1]), functx:follows-not-descendant( $in-xml//author[1]/fName, $in-xml//author[1]), functx:follows-not-descendant( $in-xml//author[1],$in-xml//author[2]))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is a descendant of another node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-descendant.html : @param $node1 the first node : @param $node2 the second node :)          declare function functx:is-descendant ( $node1 as node() , $node2 as node() ) as xs:boolean { boolean($node2 intersect $node1/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:is-descendant( $in-xml//author[1], $in-xml//author[1]/fName))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is a descendant of another node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-descendant.html : @param $node1 the first node : @param $node2 the second node :)          declare function functx:is-descendant ( $node1 as node() , $node2 as node() ) as xs:boolean { boolean($node2 intersect $node1/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:is-descendant( $in-xml//author[1], $in-xml//author[2]))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is a descendant of another node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-descendant.html : @param $node1 the first node : @param $node2 the second node :)          declare function functx:is-descendant ( $node1 as node() , $node2 as node() ) as xs:boolean { boolean($node2 intersect $node1/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:is-descendant( $in-xml//author[1]/fName, $in-xml//author[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is a descendant of another node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-descendant.html : @param $node1 the first node : @param $node2 the second node :)          declare function functx:is-descendant ( $node1 as node() , $node2 as node() ) as xs:boolean { boolean($node2 intersect $node1/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:is-descendant( $in-xml//author[1]/fName, $in-xml//author[1]), functx:is-descendant( $in-xml//author[1], $in-xml//author[1]/fName), functx:is-descendant( $in-xml//author[1]/fName/text(), $in-xml//author[1]/fName), functx:is-descendant( $in-xml//author[1], $in-xml//author[2]))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is a descendant of another node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-descendant.html : @param $node1 the first node : @param $node2 the second node :)          declare function functx:is-descendant ( $node1 as node() , $node2 as node() ) as xs:boolean { boolean($node2 intersect $node1/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:is-descendant( $in-xml//author[1]/fName/text(), $in-xml//author[1]/fName))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is among the descendants of a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-among-descendants-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-among-descendants-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq/descendant-or-self::*/(.|@*) satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>John</fName> <lName>Doe</lName> </author> return let $anotherAuthor := <author> <lName>Doe</lName> <fName>John</fName> </author> return (functx:is-node-among-descendants-deep-equal( $anAuthor,$in-xml))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is among the descendants of a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-among-descendants-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-among-descendants-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq/descendant-or-self::*/(.|@*) satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>John</fName> <lName>Doe</lName> </author> return let $anotherAuthor := <author> <lName>Doe</lName> <fName>John</fName> </author> return (functx:is-node-among-descendants-deep-equal( $anAuthor,$in-xml/author))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is among the descendants of a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-among-descendants-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-among-descendants-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq/descendant-or-self::*/(.|@*) satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>John</fName> <lName>Doe</lName> </author> return let $anotherAuthor := <author> <lName>Doe</lName> <fName>John</fName> </author> return (functx:is-node-among-descendants-deep-equal( $anotherAuthor,$in-xml))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is among the descendants of a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-among-descendants-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-among-descendants-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq/descendant-or-self::*/(.|@*) satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>John</fName> <lName>Doe</lName> </author> return let $anotherAuthor := <author> <lName>Doe</lName> <fName>John</fName> </author> return (functx:is-node-among-descendants-deep-equal( $in-xml/author[1],$in-xml))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is among the descendants of a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-among-descendants-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-among-descendants-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq/descendant-or-self::*/(.|@*) satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>John</fName> <lName>Doe</lName> </author> return let $anotherAuthor := <author> <lName>Doe</lName> <fName>John</fName> </author> return (functx:is-node-among-descendants-deep-equal( $in-xml/author[1],$in-xml), functx:is-node-among-descendants-deep-equal( $anAuthor,$in-xml), functx:is-node-among-descendants-deep-equal( $anotherAuthor,$in-xml), functx:is-node-among-descendants-deep-equal( $anAuthor,$in-xml/author))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is among the descendants of a sequence, based on node identity : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-among-descendants.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-among-descendants ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq/descendant-or-self::*/(.|@*) satisfies $nodeInSeq is $node } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="49.99" discount=""/> </prices> return let $aPrice := <price value="49.99" discount=""/> return (functx:is-node-among-descendants( $aPrice,$in-xml))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is among the descendants of a sequence, based on node identity : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-among-descendants.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-among-descendants ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq/descendant-or-self::*/(.|@*) satisfies $nodeInSeq is $node } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="49.99" discount=""/> </prices> return let $aPrice := <price value="49.99" discount=""/> return (functx:is-node-among-descendants( $in-xml,$in-xml))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is among the descendants of a sequence, based on node identity : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-among-descendants.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-among-descendants ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq/descendant-or-self::*/(.|@*) satisfies $nodeInSeq is $node } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="49.99" discount=""/> </prices> return let $aPrice := <price value="49.99" discount=""/> return (functx:is-node-among-descendants( $in-xml,$in-xml/price[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is among the descendants of a sequence, based on node identity : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-among-descendants.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-among-descendants ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq/descendant-or-self::*/(.|@*) satisfies $nodeInSeq is $node } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="49.99" discount=""/> </prices> return let $aPrice := <price value="49.99" discount=""/> return (functx:is-node-among-descendants( $in-xml/price[1],$in-xml))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is among the descendants of a sequence, based on node identity : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-among-descendants.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-among-descendants ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq/descendant-or-self::*/(.|@*) satisfies $nodeInSeq is $node } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="49.99" discount=""/> </prices> return let $aPrice := <price value="49.99" discount=""/> return (functx:is-node-among-descendants( $in-xml/price[1],$in-xml), functx:is-node-among-descendants( $in-xml,$in-xml/price[1]), functx:is-node-among-descendants( $in-xml,$in-xml), functx:is-node-among-descendants( $aPrice,$in-xml))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is an ancestor of another node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-ancestor.html : @param $node1 the first node : @param $node2 the second node :)          declare function functx:is-ancestor ( $node1 as node() , $node2 as node() ) as xs:boolean { exists($node1 intersect $node2/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:is-ancestor( $in-xml//author[1], $in-xml//author[1]/fName))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is an ancestor of another node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-ancestor.html : @param $node1 the first node : @param $node2 the second node :)          declare function functx:is-ancestor ( $node1 as node() , $node2 as node() ) as xs:boolean { exists($node1 intersect $node2/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:is-ancestor( $in-xml//author[1], $in-xml//author[1]/fName), functx:is-ancestor( $in-xml//author[1]/fName, $in-xml//author[1]), functx:is-ancestor( $in-xml//author[1]/fName, $in-xml//author[1]/fName/text()), functx:is-ancestor( $in-xml//author[1], $in-xml//author[2]))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is an ancestor of another node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-ancestor.html : @param $node1 the first node : @param $node2 the second node :)          declare function functx:is-ancestor ( $node1 as node() , $node2 as node() ) as xs:boolean { exists($node1 intersect $node2/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:is-ancestor( $in-xml//author[1], $in-xml//author[2]))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is an ancestor of another node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-ancestor.html : @param $node1 the first node : @param $node2 the second node :)          declare function functx:is-ancestor ( $node1 as node() , $node2 as node() ) as xs:boolean { exists($node1 intersect $node2/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:is-ancestor( $in-xml//author[1]/fName, $in-xml//author[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is an ancestor of another node : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-ancestor.html : @param $node1 the first node : @param $node2 the second node :)          declare function functx:is-ancestor ( $node1 as node() , $node2 as node() ) as xs:boolean { exists($node1 intersect $node2/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:is-ancestor( $in-xml//author[1]/fName, $in-xml//author[1]/fName/text()))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is in a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>John</fName> <lName>Doe</lName> </author> return (functx:is-node-in-sequence-deep-equal( $anAuthor,$in-xml/author))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is in a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>John</fName> <lName>Doe</lName> </author> return (functx:is-node-in-sequence-deep-equal( $in-xml/author[1],$in-xml))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is in a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>John</fName> <lName>Doe</lName> </author> return (functx:is-node-in-sequence-deep-equal( $in-xml/author[1],$in-xml/author))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is in a sequence, based on contents and attributes : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence-deep-equal.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence-deep-equal ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies deep-equal($nodeInSeq,$node) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>John</fName> <lName>Doe</lName> </author> return (functx:is-node-in-sequence-deep-equal( $in-xml/author[1],$in-xml/author), functx:is-node-in-sequence-deep-equal( $anAuthor,$in-xml/author), functx:is-node-in-sequence-deep-equal( $in-xml/author[1],$in-xml))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is in a sequence, based on node identity : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies $nodeInSeq is $node } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="49.99" discount=""/> </prices> return let $aPrice := <price value="49.99" discount=""/> return (functx:is-node-in-sequence( $aPrice,$in-xml/price))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is in a sequence, based on node identity : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies $nodeInSeq is $node } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="49.99" discount=""/> </prices> return let $aPrice := <price value="49.99" discount=""/> return (functx:is-node-in-sequence( $in-xml/price[1],$in-xml))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is in a sequence, based on node identity : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies $nodeInSeq is $node } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="49.99" discount=""/> </prices> return let $aPrice := <price value="49.99" discount=""/> return (functx:is-node-in-sequence( $in-xml/price[1],$in-xml/price))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node is in a sequence, based on node identity : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-node-in-sequence.html : @param $node the node to test : @param $seq the sequence of nodes to search :)          declare function functx:is-node-in-sequence ( $node as node()? , $seq as node()* ) as xs:boolean { some $nodeInSeq in $seq satisfies $nodeInSeq is $node } ;                     let $in-xml := <prices> <price value="29.99" discount="10.00"/> <price value="39.99" discount="6.00"/> <price value="49.99" discount=""/> </prices> return let $aPrice := <price value="49.99" discount=""/> return (functx:is-node-in-sequence( $in-xml/price[1],$in-xml/price), functx:is-node-in-sequence( $in-xml/price[1],$in-xml), functx:is-node-in-sequence( $aPrice,$in-xml/price))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node precedes another without being its ancestor : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_precedes-not-ancestor.html : @param $a the first node : @param $b the second node :)          declare function functx:precedes-not-ancestor ( $a as node()? , $b as node()? ) as xs:boolean { $a << $b and empty($a intersect $b/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:precedes-not-ancestor( $in-xml//author[1], $in-xml//author[1]/fName))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node precedes another without being its ancestor : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_precedes-not-ancestor.html : @param $a the first node : @param $b the second node :)          declare function functx:precedes-not-ancestor ( $a as node()? , $b as node()? ) as xs:boolean { $a << $b and empty($a intersect $b/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:precedes-not-ancestor( $in-xml//author[1],$in-xml//author[2]))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node precedes another without being its ancestor : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_precedes-not-ancestor.html : @param $a the first node : @param $b the second node :)          declare function functx:precedes-not-ancestor ( $a as node()? , $b as node()? ) as xs:boolean { $a << $b and empty($a intersect $b/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:precedes-not-ancestor( $in-xml//author[1],$in-xml//author[2]), functx:precedes-not-ancestor( $in-xml//author[1], $in-xml//author[1]/fName), functx:precedes-not-ancestor( $in-xml//author[2],$in-xml//author[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether an XML node precedes another without being its ancestor : : @author W3C XML Query Working Group : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_precedes-not-ancestor.html : @param $a the first node : @param $b the second node :)          declare function functx:precedes-not-ancestor ( $a as node()? , $b as node()? ) as xs:boolean { $a << $b and empty($a intersect $b/ancestor::node()) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return (functx:precedes-not-ancestor( $in-xml//author[2],$in-xml//author[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a string contains any of a sequence of strings : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_contains-any-of.html : @param $arg the string to test : @param $searchStrings the strings to look for :)          declare function functx:contains-any-of ( $arg as xs:string? , $searchStrings as xs:string* ) as xs:boolean { some $searchString in $searchStrings satisfies contains($arg,$searchString) } ;                     (functx:contains-any-of('abc',('bc','xy')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a string contains any of a sequence of strings : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_contains-any-of.html : @param $arg the string to test : @param $searchStrings the strings to look for :)          declare function functx:contains-any-of ( $arg as xs:string? , $searchStrings as xs:string* ) as xs:boolean { some $searchString in $searchStrings satisfies contains($arg,$searchString) } ;                     (functx:contains-any-of('abc',('bc','xy')), functx:contains-any-of('abc',('de','xy')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a string contains any of a sequence of strings : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_contains-any-of.html : @param $arg the string to test : @param $searchStrings the strings to look for :)          declare function functx:contains-any-of ( $arg as xs:string? , $searchStrings as xs:string* ) as xs:boolean { some $searchString in $searchStrings satisfies contains($arg,$searchString) } ;                     (functx:contains-any-of('abc',('de','xy')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a URI is absolute : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-absolute-uri.html : @param $uri the URI to test :)          declare function functx:is-absolute-uri ( $uri as xs:string? ) as xs:boolean { matches($uri,'^[a-z]+:') } ;                     (functx:is-absolute-uri('ftp.datypic.com'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a URI is absolute : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-absolute-uri.html : @param $uri the URI to test :)          declare function functx:is-absolute-uri ( $uri as xs:string? ) as xs:boolean { matches($uri,'^[a-z]+:') } ;                     (functx:is-absolute-uri( 'ftp://ftp.datypic.com'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a URI is absolute : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-absolute-uri.html : @param $uri the URI to test :)          declare function functx:is-absolute-uri ( $uri as xs:string? ) as xs:boolean { matches($uri,'^[a-z]+:') } ;                     (functx:is-absolute-uri( 'http://www.datypic.com'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a URI is absolute : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-absolute-uri.html : @param $uri the URI to test :)          declare function functx:is-absolute-uri ( $uri as xs:string? ) as xs:boolean { matches($uri,'^[a-z]+:') } ;                     (functx:is-absolute-uri( 'http://www.datypic.com'), functx:is-absolute-uri( 'ftp://ftp.datypic.com'), functx:is-absolute-uri('ftp.datypic.com'), functx:is-absolute-uri('www.datypic.com'), functx:is-absolute-uri('prod.html'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a URI is absolute : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-absolute-uri.html : @param $uri the URI to test :)          declare function functx:is-absolute-uri ( $uri as xs:string? ) as xs:boolean { matches($uri,'^[a-z]+:') } ;                     (functx:is-absolute-uri('prod.html'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a URI is absolute : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-absolute-uri.html : @param $uri the URI to test :)          declare function functx:is-absolute-uri ( $uri as xs:string? ) as xs:boolean { matches($uri,'^[a-z]+:') } ;                     (functx:is-absolute-uri('www.datypic.com'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is all whitespace or a zero-length string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_all-whitespace.html : @param $arg the string (or node) to test :)          declare function functx:all-whitespace ( $arg as xs:string? ) as xs:boolean { normalize-space($arg) = '' } ;                     let $in-xml := <in-xml> <a> </a> <b>x </b> <c> <x>x</x> </c> </in-xml> return (functx:all-whitespace(' '))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is all whitespace or a zero-length string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_all-whitespace.html : @param $arg the string (or node) to test :)          declare function functx:all-whitespace ( $arg as xs:string? ) as xs:boolean { normalize-space($arg) = '' } ;                     let $in-xml := <in-xml> <a> </a> <b>x </b> <c> <x>x</x> </c> </in-xml> return (functx:all-whitespace($in-xml/a))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is all whitespace or a zero-length string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_all-whitespace.html : @param $arg the string (or node) to test :)          declare function functx:all-whitespace ( $arg as xs:string? ) as xs:boolean { normalize-space($arg) = '' } ;                     let $in-xml := <in-xml> <a> </a> <b>x </b> <c> <x>x</x> </c> </in-xml> return (functx:all-whitespace($in-xml/b))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is all whitespace or a zero-length string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_all-whitespace.html : @param $arg the string (or node) to test :)          declare function functx:all-whitespace ( $arg as xs:string? ) as xs:boolean { normalize-space($arg) = '' } ;                     let $in-xml := <in-xml> <a> </a> <b>x </b> <c> <x>x</x> </c> </in-xml> return (functx:all-whitespace($in-xml/c))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is all whitespace or a zero-length string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_all-whitespace.html : @param $arg the string (or node) to test :)          declare function functx:all-whitespace ( $arg as xs:string? ) as xs:boolean { normalize-space($arg) = '' } ;                     let $in-xml := <in-xml> <a> </a> <b>x </b> <c> <x>x</x> </c> </in-xml> return (functx:all-whitespace($in-xml/c/text()[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is all whitespace or a zero-length string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_all-whitespace.html : @param $arg the string (or node) to test :)          declare function functx:all-whitespace ( $arg as xs:string? ) as xs:boolean { normalize-space($arg) = '' } ;                     let $in-xml := <in-xml> <a> </a> <b>x </b> <c> <x>x</x> </c> </in-xml> return (functx:all-whitespace(' '), functx:all-whitespace(' x '), functx:all-whitespace($in-xml/a), functx:all-whitespace($in-xml/b), functx:all-whitespace($in-xml/c), functx:all-whitespace($in-xml/c/text()[1]))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is all whitespace or a zero-length string : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_all-whitespace.html : @param $arg the string (or node) to test :)          declare function functx:all-whitespace ( $arg as xs:string? ) as xs:boolean { normalize-space($arg) = '' } ;                     let $in-xml := <in-xml> <a> </a> <b>x </b> <c> <x>x</x> </c> </in-xml> return (functx:all-whitespace(' x '))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is between two provided values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_between-exclusive.html : @param $value the value to be tested : @param $minValue the minimum value : @param $maxValue the maximum value :)          declare function functx:between-exclusive ( $value as xs:anyAtomicType? , $minValue as xs:anyAtomicType , $maxValue as xs:anyAtomicType ) as xs:boolean { $value > $minValue and $value < $maxValue } ;                     (functx:between-exclusive(1, 1, 1000))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is between two provided values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_between-exclusive.html : @param $value the value to be tested : @param $minValue the minimum value : @param $maxValue the maximum value :)          declare function functx:between-exclusive ( $value as xs:anyAtomicType? , $minValue as xs:anyAtomicType , $maxValue as xs:anyAtomicType ) as xs:boolean { $value > $minValue and $value < $maxValue } ;                     (functx:between-exclusive(1200, 1, 1000))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is between two provided values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_between-exclusive.html : @param $value the value to be tested : @param $minValue the minimum value : @param $maxValue the maximum value :)          declare function functx:between-exclusive ( $value as xs:anyAtomicType? , $minValue as xs:anyAtomicType , $maxValue as xs:anyAtomicType ) as xs:boolean { $value > $minValue and $value < $maxValue } ;                     (functx:between-exclusive(55, 1, 1000))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is between two provided values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_between-exclusive.html : @param $value the value to be tested : @param $minValue the minimum value : @param $maxValue the maximum value :)          declare function functx:between-exclusive ( $value as xs:anyAtomicType? , $minValue as xs:anyAtomicType , $maxValue as xs:anyAtomicType ) as xs:boolean { $value > $minValue and $value < $maxValue } ;                     (functx:between-exclusive(55, 1, 1000), functx:between-exclusive(1, 1, 1000), functx:between-exclusive(1200, 1, 1000), functx:between-exclusive('b', 'a', 'c'), functx:between-exclusive(xs:date('2004-10-31'), xs:date('2004-10-15'), xs:date('2004-11-01')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is between two provided values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_between-exclusive.html : @param $value the value to be tested : @param $minValue the minimum value : @param $maxValue the maximum value :)          declare function functx:between-exclusive ( $value as xs:anyAtomicType? , $minValue as xs:anyAtomicType , $maxValue as xs:anyAtomicType ) as xs:boolean { $value > $minValue and $value < $maxValue } ;                     (functx:between-exclusive('b', 'a', 'c'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is between two provided values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_between-exclusive.html : @param $value the value to be tested : @param $minValue the minimum value : @param $maxValue the maximum value :)          declare function functx:between-exclusive ( $value as xs:anyAtomicType? , $minValue as xs:anyAtomicType , $maxValue as xs:anyAtomicType ) as xs:boolean { $value > $minValue and $value < $maxValue } ;                     (functx:between-exclusive(xs:date('2004-10-31'), xs:date('2004-10-15'), xs:date('2004-11-01')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is between two provided values, or equal to one of them : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_between-inclusive.html : @param $value the value to be tested : @param $minValue the minimum value : @param $maxValue the maximum value :)          declare function functx:between-inclusive ( $value as xs:anyAtomicType? , $minValue as xs:anyAtomicType , $maxValue as xs:anyAtomicType ) as xs:boolean { $value >= $minValue and $value <= $maxValue } ;                     (functx:between-inclusive(1, 1, 1000))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is between two provided values, or equal to one of them : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_between-inclusive.html : @param $value the value to be tested : @param $minValue the minimum value : @param $maxValue the maximum value :)          declare function functx:between-inclusive ( $value as xs:anyAtomicType? , $minValue as xs:anyAtomicType , $maxValue as xs:anyAtomicType ) as xs:boolean { $value >= $minValue and $value <= $maxValue } ;                     (functx:between-inclusive(1200, 1, 1000))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is between two provided values, or equal to one of them : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_between-inclusive.html : @param $value the value to be tested : @param $minValue the minimum value : @param $maxValue the maximum value :)          declare function functx:between-inclusive ( $value as xs:anyAtomicType? , $minValue as xs:anyAtomicType , $maxValue as xs:anyAtomicType ) as xs:boolean { $value >= $minValue and $value <= $maxValue } ;                     (functx:between-inclusive(55, 1, 1000))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is between two provided values, or equal to one of them : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_between-inclusive.html : @param $value the value to be tested : @param $minValue the minimum value : @param $maxValue the maximum value :)          declare function functx:between-inclusive ( $value as xs:anyAtomicType? , $minValue as xs:anyAtomicType , $maxValue as xs:anyAtomicType ) as xs:boolean { $value >= $minValue and $value <= $maxValue } ;                     (functx:between-inclusive(55, 1, 1000), functx:between-inclusive(1, 1, 1000), functx:between-inclusive(1200, 1, 1000), functx:between-inclusive('b', 'b', 'd'), functx:between-inclusive(xs:date('2004-10-31'), xs:date('2004-10-15'), xs:date('2004-11-01')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is between two provided values, or equal to one of them : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_between-inclusive.html : @param $value the value to be tested : @param $minValue the minimum value : @param $maxValue the maximum value :)          declare function functx:between-inclusive ( $value as xs:anyAtomicType? , $minValue as xs:anyAtomicType , $maxValue as xs:anyAtomicType ) as xs:boolean { $value >= $minValue and $value <= $maxValue } ;                     (functx:between-inclusive('b', 'b', 'd'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is between two provided values, or equal to one of them : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_between-inclusive.html : @param $value the value to be tested : @param $minValue the minimum value : @param $maxValue the maximum value :)          declare function functx:between-inclusive ( $value as xs:anyAtomicType? , $minValue as xs:anyAtomicType , $maxValue as xs:anyAtomicType ) as xs:boolean { $value >= $minValue and $value <= $maxValue } ;                     (functx:between-inclusive(xs:date('2004-10-31'), xs:date('2004-10-15'), xs:date('2004-11-01')))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is numeric : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-a-number.html : @param $value the value to test :)          declare function functx:is-a-number ( $value as xs:anyAtomicType? ) as xs:boolean { string(number($value)) != 'NaN' } ;                     let $in-xml := <in-xml> <a>123</a> <b>abc</b> </in-xml> return (functx:is-a-number(''))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is numeric : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-a-number.html : @param $value the value to test :)          declare function functx:is-a-number ( $value as xs:anyAtomicType? ) as xs:boolean { string(number($value)) != 'NaN' } ;                     let $in-xml := <in-xml> <a>123</a> <b>abc</b> </in-xml> return (functx:is-a-number($in-xml/a))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is numeric : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-a-number.html : @param $value the value to test :)          declare function functx:is-a-number ( $value as xs:anyAtomicType? ) as xs:boolean { string(number($value)) != 'NaN' } ;                     let $in-xml := <in-xml> <a>123</a> <b>abc</b> </in-xml> return (functx:is-a-number($in-xml/b))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is numeric : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-a-number.html : @param $value the value to test :)          declare function functx:is-a-number ( $value as xs:anyAtomicType? ) as xs:boolean { string(number($value)) != 'NaN' } ;                     let $in-xml := <in-xml> <a>123</a> <b>abc</b> </in-xml> return (functx:is-a-number(' 123 '))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is numeric : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-a-number.html : @param $value the value to test :)          declare function functx:is-a-number ( $value as xs:anyAtomicType? ) as xs:boolean { string(number($value)) != 'NaN' } ;                     let $in-xml := <in-xml> <a>123</a> <b>abc</b> </in-xml> return (functx:is-a-number('123'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is numeric : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-a-number.html : @param $value the value to test :)          declare function functx:is-a-number ( $value as xs:anyAtomicType? ) as xs:boolean { string(number($value)) != 'NaN' } ;                     let $in-xml := <in-xml> <a>123</a> <b>abc</b> </in-xml> return (functx:is-a-number(123))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is numeric : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-a-number.html : @param $value the value to test :)          declare function functx:is-a-number ( $value as xs:anyAtomicType? ) as xs:boolean { string(number($value)) != 'NaN' } ;                     let $in-xml := <in-xml> <a>123</a> <b>abc</b> </in-xml> return (functx:is-a-number('123abc'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is numeric : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-a-number.html : @param $value the value to test :)          declare function functx:is-a-number ( $value as xs:anyAtomicType? ) as xs:boolean { string(number($value)) != 'NaN' } ;                     let $in-xml := <in-xml> <a>123</a> <b>abc</b> </in-xml> return (functx:is-a-number('123'), functx:is-a-number(123), functx:is-a-number(' 123 '), functx:is-a-number(''), functx:is-a-number('123abc'), functx:is-a-number('NaN'), functx:is-a-number($in-xml/a), functx:is-a-number($in-xml/b))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether a value is numeric : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_is-a-number.html : @param $value the value to test :)          declare function functx:is-a-number ( $value as xs:anyAtomicType? ) as xs:boolean { string(number($value)) != 'NaN' } ;                     let $in-xml := <in-xml> <a>123</a> <b>abc</b> </in-xml> return (functx:is-a-number('NaN'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether one (and only one) of two boolean values is true : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_exclusive-or.html : @param $arg1 the first boolean value : @param $arg2 the second boolean value :)          declare function functx:exclusive-or ( $arg1 as xs:boolean? , $arg2 as xs:boolean? ) as xs:boolean? { $arg1 != $arg2 } ;                     (functx:exclusive-or(4 >                     3,1 >                     2))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether one (and only one) of two boolean values is true : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_exclusive-or.html : @param $arg1 the first boolean value : @param $arg2 the second boolean value :)          declare function functx:exclusive-or ( $arg1 as xs:boolean? , $arg2 as xs:boolean? ) as xs:boolean? { $arg1 != $arg2 } ;                     (functx:exclusive-or(true(),false()))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether one (and only one) of two boolean values is true : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_exclusive-or.html : @param $arg1 the first boolean value : @param $arg2 the second boolean value :)          declare function functx:exclusive-or ( $arg1 as xs:boolean? , $arg2 as xs:boolean? ) as xs:boolean? { $arg1 != $arg2 } ;                     (functx:exclusive-or(true(),false()), functx:exclusive-or(true(),true()), functx:exclusive-or(4 >                     3,1 >                     2))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether one (and only one) of two boolean values is true : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_exclusive-or.html : @param $arg1 the first boolean value : @param $arg2 the second boolean value :)          declare function functx:exclusive-or ( $arg1 as xs:boolean? , $arg2 as xs:boolean? ) as xs:boolean? { $arg1 != $arg2 } ;                     (functx:exclusive-or(true(),true()))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether one string contains another, without regard to case : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_contains-case-insensitive.html : @param $arg the string to search : @param $substring the substring to find :)          declare function functx:contains-case-insensitive ( $arg as xs:string? , $substring as xs:string ) as xs:boolean? { contains(upper-case($arg), upper-case($substring)) } ;                     (functx:contains-case-insensitive( 'abcdef', 'def'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether one string contains another, without regard to case : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_contains-case-insensitive.html : @param $arg the string to search : @param $substring the substring to find :)          declare function functx:contains-case-insensitive ( $arg as xs:string? , $substring as xs:string ) as xs:boolean? { contains(upper-case($arg), upper-case($substring)) } ;                     (functx:contains-case-insensitive( 'abcdEF', 'def'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether one string contains another, without regard to case : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_contains-case-insensitive.html : @param $arg the string to search : @param $substring the substring to find :)          declare function functx:contains-case-insensitive ( $arg as xs:string? , $substring as xs:string ) as xs:boolean? { contains(upper-case($arg), upper-case($substring)) } ;                     (functx:contains-case-insensitive( 'abcdef', 'def'), functx:contains-case-insensitive( 'abcdEF', 'def'))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether two sequences contain the same XML nodes, in the same order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-node-equal.html : @param $seq1 the first sequence of nodes : @param $seq2 the second sequence of nodes :)          declare function functx:sequence-node-equal ( $seq1 as node()* , $seq2 as node()* ) as xs:boolean { every $i in 1 to max((count($seq1),count($seq2))) satisfies $seq1[$i] is $seq2[$i] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return (functx:sequence-node-equal( $in-xml/author/*, $in-xml/*/*))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether two sequences contain the same XML nodes, in the same order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-node-equal.html : @param $seq1 the first sequence of nodes : @param $seq2 the second sequence of nodes :)          declare function functx:sequence-node-equal ( $seq1 as node()* , $seq2 as node()* ) as xs:boolean { every $i in 1 to max((count($seq1),count($seq2))) satisfies $seq1[$i] is $seq2[$i] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return (functx:sequence-node-equal( $in-xml/author, ($in-xml/author[2],$in-xml/author[1])))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether two sequences contain the same XML nodes, in the same order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-node-equal.html : @param $seq1 the first sequence of nodes : @param $seq2 the second sequence of nodes :)          declare function functx:sequence-node-equal ( $seq1 as node()* , $seq2 as node()* ) as xs:boolean { every $i in 1 to max((count($seq1),count($seq2))) satisfies $seq1[$i] is $seq2[$i] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return (functx:sequence-node-equal( $in-xml/author/*, $in-xml/*/*), functx:sequence-node-equal( $in-xml/author, ($in-xml/author[2],$in-xml/author[1])), functx:sequence-node-equal( $in-xml/author[1],$anAuthor))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether two sequences contain the same XML nodes, in the same order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-node-equal.html : @param $seq1 the first sequence of nodes : @param $seq2 the second sequence of nodes :)          declare function functx:sequence-node-equal ( $seq1 as node()* , $seq2 as node()* ) as xs:boolean { every $i in 1 to max((count($seq1),count($seq2))) satisfies $seq1[$i] is $seq2[$i] } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return (functx:sequence-node-equal( $in-xml/author[1],$anAuthor))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether two sequences contain the same XML nodes, regardless of order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-node-equal-any-order.html : @param $seq1 the first sequence of nodes : @param $seq2 the second sequence of nodes :)          declare function functx:sequence-node-equal-any-order ( $seq1 as node()* , $seq2 as node()* ) as xs:boolean { not( ($seq1 except $seq2, $seq2 except $seq1)) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return (functx:sequence-node-equal-any-order( $in-xml/author, $in-xml/*))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether two sequences contain the same XML nodes, regardless of order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-node-equal-any-order.html : @param $seq1 the first sequence of nodes : @param $seq2 the second sequence of nodes :)          declare function functx:sequence-node-equal-any-order ( $seq1 as node()* , $seq2 as node()* ) as xs:boolean { not( ($seq1 except $seq2, $seq2 except $seq1)) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return (functx:sequence-node-equal-any-order( $in-xml/author, ($in-xml/author[2],$in-xml/author[1])))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether two sequences contain the same XML nodes, regardless of order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-node-equal-any-order.html : @param $seq1 the first sequence of nodes : @param $seq2 the second sequence of nodes :)          declare function functx:sequence-node-equal-any-order ( $seq1 as node()* , $seq2 as node()* ) as xs:boolean { not( ($seq1 except $seq2, $seq2 except $seq1)) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return (functx:sequence-node-equal-any-order( $in-xml/author, $in-xml/*), functx:sequence-node-equal-any-order( $in-xml/author, ($in-xml/author[2],$in-xml/author[1])), functx:sequence-node-equal-any-order( $in-xml/author[1],$anAuthor))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether two sequences contain the same XML nodes, regardless of order : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-node-equal-any-order.html : @param $seq1 the first sequence of nodes : @param $seq2 the second sequence of nodes :)          declare function functx:sequence-node-equal-any-order ( $seq1 as node()* , $seq2 as node()* ) as xs:boolean { not( ($seq1 except $seq2, $seq2 except $seq1)) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return (functx:sequence-node-equal-any-order( $in-xml/author[1],$anAuthor))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether two sequences have the same XML node content and/or values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-deep-equal.html : @param $seq1 the first sequence : @param $seq2 the second sequence :)          declare function functx:sequence-deep-equal ( $seq1 as item()* , $seq2 as item()* ) as xs:boolean { every $i in 1 to max((count($seq1),count($seq2))) satisfies deep-equal($seq1[$i],$seq2[$i]) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return (functx:sequence-deep-equal( $in-xml/author/*, $in-xml/*/*))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether two sequences have the same XML node content and/or values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-deep-equal.html : @param $seq1 the first sequence : @param $seq2 the second sequence :)          declare function functx:sequence-deep-equal ( $seq1 as item()* , $seq2 as item()* ) as xs:boolean { every $i in 1 to max((count($seq1),count($seq2))) satisfies deep-equal($seq1[$i],$seq2[$i]) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return (functx:sequence-deep-equal( $in-xml/author/*, $in-xml/*/*), functx:sequence-deep-equal( $in-xml/author[1], $anAuthor), functx:sequence-deep-equal( (1,2,3), (1.0,2.0,3.0)))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether two sequences have the same XML node content and/or values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-deep-equal.html : @param $seq1 the first sequence : @param $seq2 the second sequence :)          declare function functx:sequence-deep-equal ( $seq1 as item()* , $seq2 as item()* ) as xs:boolean { every $i in 1 to max((count($seq1),count($seq2))) satisfies deep-equal($seq1[$i],$seq2[$i]) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return (functx:sequence-deep-equal( $in-xml/author[1], $anAuthor))
declare namespace functx = "http://www.example.com/";                     (:~ : Whether two sequences have the same XML node content and/or values : : @author Priscilla Walmsley, Datypic : @version 1.0 : @see http://www.xqueryfunctions.com/xq/functx_sequence-deep-equal.html : @param $seq1 the first sequence : @param $seq2 the second sequence :)          declare function functx:sequence-deep-equal ( $seq1 as item()* , $seq2 as item()* ) as xs:boolean { every $i in 1 to max((count($seq1),count($seq2))) satisfies deep-equal($seq1[$i],$seq2[$i]) } ;                     let $in-xml := <authors> <author> <fName>Kate</fName> <lName>Jones</lName> </author> <author> <fName>John</fName> <lName>Doe</lName> </author> </authors> return let $anAuthor := <author> <fName>Kate</fName> <lName>Jones</lName> </author> return (functx:sequence-deep-equal( (1,2,3), (1.0,2.0,3.0)))
declare namespace ht="http://www.example.com/example"; element {fn:QName( "http://www.example.com/another-example", "ht:person" )}{ "test" }
declare namespace ht="http://www.example.com/example"; element {fn:QName( "http://www.example.com/example", "ht2:person" )}{ "test" }
declare namespace local = "http://www.example.com/examples"; let $var := <local:someElement>some context</local:someElement> return $var
declare namespace ma = "http://www.example.com/AuctionWatch";          declare namespace anyzone = "http://www.example.com/auctioneers#anyzone";          <Q6 xmlns:ma="http://www.example.com/AuctionWatch"> { //ma:Auction[@anyzone:ID]/ma:Schedule/ma:Close } </Q6>
declare namespace ma = "http://www.example.com/AuctionWatch";          <Q7 xmlns:xlink="http://www.w3.org/1999/xlink"> {              for $a in //ma:Auction              let $seller_id := $a/ma:Trading_Partners/ma:Seller/*:ID,                  $buyer_id := $a/ma:Trading_Partners/ma:High_Bidder/*:ID              where namespace-uri(exactly-one($seller_id)) = namespace-uri($buyer_id)              return $a/ma:AuctionHomepage } </Q7>
declare namespace ma = "http://www.example.com/AuctionWatch";          <Q8 xmlns:ma="http://www.example.com/AuctionWatch"              xmlns:eachbay="http://www.example.com/auctioneers#eachbay"              xmlns:xlink="http://www.w3.org/1999/xlink"> {                  for $s in //ma:Trading_Partners/(ma:Seller | ma:High_Bidder)                  where $s/*:NegativeComments = 0                  return $s } </Q8>
declare namespace music = "http://www.example.org/music/records";          <Q2> { //music:title } </Q2>
declare namespace music = "http://www.example.org/music/records";          <Q5 xmlns:music="http://www.example.org/music/records"> { //music:record[music:remark/@xml:lang = "de"] } </Q5>
declare namespace my = "http://example.com/ANamespace";         my:function(1)
declare namespace my = "http://example.com/MyNamespace/";         declare variable $my:error-qname := QName("http://example.com/MyErrorNS", "my:qName");         declare function my:error($choice, $msg as xs:string) as empty-sequence() { if($choice) then error($my:error-qname, concat('No luck: ', $msg)) else () };         my:error(false(), "msg"), my:error(true(), "The message")
declare namespace my = "http://example.com/MyNamespace/";         declare variable $my:error-qname := QName("http://example.com/MyErrorNS", "my:qName");         declare function my:error($msg as xs:string) as empty-sequence() { error($my:error-qname, concat('No luck: ', $msg)) };         my:error("The message")
declare namespace my = "http://www.w3.org/2001/XMLSchema";         declare function my:wrongNS() { 1 };         1
declare namespace my = "http://www.w3.org/2001/XMLSchema-instance";         declare function my:wrongNS() { 1 };         1
declare namespace my = "urn:foo";         declare function my:fact($n as xs:integer) as xs:integer { if ($n < 2) then 1 else $n * my:fact($n - 1) };         declare variable $my:ten := my:fact(10);         <table> { for $i in 1 to 10 return <tr> <td>10!/{$i}! = {$my:ten div my:fact($i)}</td> </tr> } </table>
declare namespace namespace = "http://example.com"; declare union <union>for gibberish { for $for in for return <for>***div div</for> }</union>, if(if) then then else else- +-++-**-* instance of element(*)* * * **---++div- div -div
declare namespace NCName := "http://example.com/";
(::)declare(::)namespace(::)ncname(::)=(::)"http://example.com/"(::);(::)1(::)eq(::)1(::)
(::)declare(::)namespace(::)ncname(::)=(::)'http://example.com/';(::)1(::)eq(::)1(::)
declare namespace ns1 = "http://example.org"; let $var := <a attr1 = "abc1"><ns1:b attr2 = "abc2">context2</ns1:b></a> return $var/child::*:b
declare namespace ns1 = "http://example.org"; let $var := <a attr1 = "abc1"><ns1:b attr2 = "abc2">context2</ns1:b></a> return $var/child::ns1:b
declare namespace ns1 = "http://www.example.org/ns1";          declare namespace ns2 = "http://www.example.org/ns2";          let $attribute as attribute(*) := attribute ns1:foo { }          return count($attribute/self::ns2:*)
declare namespace ns1 = "http://www.example.org/ns1";          declare namespace ns2 = "http://www.example.org/ns2";          let $attribute as attribute(ns1:foo) := attribute ns1:foo { }          return count($attribute/self::ns2:*)
declare namespace ns1 = "http://www.example.org/ns1"; declare namespace ns2 = "http://www.example.org/ns2"; let $element as element(ns1:foo) := <ns1:foo/> return count($element/self::ns2:*)
declare namespace ns1 = "http://www.example.org/ns1";          declare namespace ns2 = "http://www.example.org/ns2";          let $element as element(*) := <ns1:foo/>          return count($element/self::ns2:*)
declare namespace ns1 = "http://www.example.org/ns1";          let $comment as comment() := <!--comment-->          return count($comment/self::ns1:*)
declare namespace ns1 = "http://www.example.org/ns1";          let $processing-instruction as processing-instruction() := <?processing instruction?>          return count($processing-instruction/self::ns1:*)
declare namespace p1 = "http://www.example.com";         declare namespace p2 = "http://www.example.com/examples";         declare variable $p1:var as xs:integer := 10;         declare variable $p2:var as xs:integer := 20;         $p2:var
declare namespace p1 = "http://www.example.com";         declare variable $p1:var as xs:integer := 10;         $p1:var
declare namespace p = "http://example.com/"; <a>{<e p:a="1" p:b="2" p:c="3"/>/attribute::*/p:*}</a>
declare namespace p = "http://example.com/QuiteWeirdNamespace"; empty(p:e[1])
declare namespace p = "http://www.example.com/A"; <e xmlns="http://www.example.com/A" xmlns:A="http://www.example.com/C"> <b xmlns:B="http://www.example.com/C"/> </e>/p:b
declare namespace p = "http://www.example.com/"; <p:e/>
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre2 = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (name($in-xml))
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre2 = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (name($in-xml), name($in-xml//pre2:prefixed), name($in-xml//unpre2:unprefixed), name($in-xml//@pre2:prefAttr), name($in-xml//@noNSAttr))
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre2 = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (name($in-xml//@noNSAttr))
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre2 = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (name($in-xml//@pre2:prefAttr))
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre2 = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (name($in-xml//pre2:prefixed))
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre2 = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (name($in-xml//unpre2:unprefixed))
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre2 = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (node-name($in-xml))
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre2 = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (node-name($in-xml), node-name($in-xml/pre2:prefixed), node-name($in-xml//unpre2:unprefixed), node-name($in-xml//@pre2:prefAttr), node-name($in-xml//@noNSAttr))
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre2 = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (node-name($in-xml//@noNSAttr))
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre2 = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (node-name($in-xml//@pre2:prefAttr))
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre2 = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (node-name($in-xml/pre2:prefixed))
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre2 = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (node-name($in-xml//unpre2:unprefixed))
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (prefix-from-QName( node-name($in-xml)))
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (prefix-from-QName( node-name($in-xml//@noNSAttr)))
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (prefix-from-QName( node-name($in-xml//@pre2:prefAttr)))
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (prefix-from-QName( node-name($in-xml//pre2:prefixed)))
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (prefix-from-QName( node-name($in-xml)), prefix-from-QName( node-name($in-xml//pre2:prefixed)), prefix-from-QName( node-name($in-xml//unpre:unprefixed)), prefix-from-QName( node-name($in-xml//@pre2:prefAttr)), prefix-from-QName( node-name($in-xml//@noNSAttr)), prefix-from-QName( node-name(<pre2:new>xyz</pre2:new>)))
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (prefix-from-QName( node-name($in-xml//unpre:unprefixed)))
declare namespace pre2 = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (prefix-from-QName( node-name(<pre2:new>xyz</pre2:new>)))
declare namespace prefix = "http://example.com/";
declare namespace prefix = "http://example.com/" { 1 }
declare namespace prefix = "http://example.com/"; declare variable $a := <e><a/><b/><c/></e>; <a>{$a/@prefix:* eq 1}</a>
declare namespace prefix = "http://example.com/"; declare variable $a := <e><a/><b/><c/></e>; <a>{$a/prefix:* eq 1}</a>
declare namespace prefix = "http://www.w3.org/2000/xmlns/";          <e>{attribute prefix:localName {"content"}}</e>
declare namespace prefix = "http://www.w3.org/2000/xmlns/"; <e>{attribute {"prefix:localName"} {"content"}}</e>
declare namespace prefix = "http://www.w3.org/"; <a> { <b />, attribute prefix:foo { 'bar' } } </a>
declare namespace prefix = "http://www/w3.org/"; let $attr1 := attribute attr { 'foo' } return let $attr2 := attribute attr { 'bar' } return <prefix:a>{$attr1, $attr2 }</prefix:a>
declare namespace prefix = "http://www/w3.org/"; let $attr1 := attribute prefix:attr { 'foo' } return let $attr2 := attribute prefix:attr { 'bar' } return <a>{$attr1, $attr2 }</a>
declare namespace prefix = "http://www/w3.org/"; let $attr1 := attribute prefix:attr { 'foo' } return let $attr2 := attribute prefix:attr { 'bar' } return <prefix:a>{$attr1, $attr2 }</prefix:a>
declare namespace prefix = "http://www.w3.org/"; <prefix:a> { <b />, attribute foo { 'bar' } } </prefix:a>
declare namespace prefix = "http://www.w3.org/"; <prefix:a> { <b />, attribute prefix:foo { 'bar' } } </prefix:a>
declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (local-name($in-xml))
declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (local-name($in-xml), local-name($in-xml//pre:prefixed), local-name($in-xml//unpre:unprefixed), local-name($in-xml//@pre:prefAttr), local-name($in-xml//@noNSAttr))
declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (local-name($in-xml//@noNSAttr))
declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (local-name($in-xml//@pre:prefAttr))
declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (local-name($in-xml//pre:prefixed))
declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (local-name($in-xml//unpre:unprefixed))
declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (namespace-uri($in-xml))
declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (namespace-uri($in-xml), namespace-uri($in-xml//pre:prefixed), namespace-uri($in-xml//unpre:unprefixed), namespace-uri($in-xml//@pre:prefAttr), namespace-uri($in-xml//@noNSAttr))
declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (namespace-uri($in-xml//@noNSAttr))
declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (namespace-uri($in-xml//@pre:prefAttr))
declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (namespace-uri($in-xml//pre:prefixed))
declare namespace pre = "http://datypic.com/pre";          declare namespace unpre = "http://datypic.com/unpre";          let $in-xml := <noNamespace> <pre:prefixed xmlns="http://datypic.com/unpre" xmlns:pre="http://datypic.com/pre"> <unprefixed pre:prefAttr="a" noNSAttr="b">123</unprefixed> </pre:prefixed> </noNamespace> return (namespace-uri($in-xml//unpre:unprefixed))
declare namespace px1 = "http://www.example.com/examples"; declare namespace px2 = "http://www.example.com/examples"; let $var := <px1:someElement>some context</px1:someElement> return $var
declare namespace px = "ftp://ftp.is.co.za/rfc/somefile.txt"; let $var := <px:someElement>some context</px:someElement> return $var
declare namespace px = "http://www.example.com/abc"; let $var := <px:someElement>some context</px:someElement> return namespace-uri-from-QName(node-name($var)) eq xs:anyURI("http://www.example.com/abc")
declare namespace px = "http://www.example.com/examples"; let $var := <px:someElement xmlns:px = "http://www.examples.com/localexamples">some context</px:someElement> return $var
declare namespace test = "http://www.w3.org/2005/xpath-datatypes";         declare function test:myFunction() { 1};         1 eq 1
declare namespace thisPrefixIsNotBoundExampleCom = ""; true()
declare namespace t = "http://example.com/2"; <p:a xmlns:p="http://example.com/"> <p:e xmlns:p="http://example.com/2"/> </p:a>//t:e
declare namespace xdt = "http://www.example.com/examples"; let $var := <xdt:someElement>some context</xdt:someElement> return $var
declare namespace xlink = "http://www.w3.org/1999/xlink";          <Q4 xmlns:xlink="http://www.w3.org/1999/xlink"> { for $hr in //@xlink:href return <ns>{ $hr }</ns> } </Q4>
declare namespace xml = ""; 1
declare namespace xml = "http://example.com/"; 1
declare namespace XML = "http://www.example.com/examples"; let $var := <XML:someElement>some context</XML:someElement> return $var
declare namespace xml = "http://www.example.org/"; 1 + 2
declare namespace xml = "http://www.w3.org/XML/1998/namespace"; "a"
declare namespace xmlns = ""; 1
declare namespace xmlns = "http://example.com/examples"; "a"
declare namespace XMLNS = "http://www.example.com/examples"; let $var := <XMLNS:someElement>some context</XMLNS:someElement> return $var
declare namespace xqt="http://www.w3.org/XQueryTestOrderBy";          for $num as xs:decimal as xs:decimal in data( /xqt:DataValues/xqt:NegativeNumbers/xqt:orderData ) return $num
declare namespace xs = "http://www.example.com/examples"; let $var := <xs:someElement>some context</xs:someElement> return $var
declare namespace xsi = "http://www.example.com/examples"; let $var := <xsi:someElement>some context</xsi:someElement> return $var
declare namespace xsl=``[http://www.w3.org/1999/XSL/Transform]``;         <xsl:output/>
declare namespace xx = "http://example.org"; let $i := <foo:bar xmlns:foo = "http://example.org"> <foo:bing> Lentils </foo:bing> </foo:bar> return $i/xx:bing
declare namespace xx = "http://www.example.com/abc123"; let $var := <xx:someElement>some content</xx:someElement> return namespace-uri-from-QName(node-name($var)) eq xs:anyURI("http://www.example.com/abc123")
declare namespace z = "http://z.com"; map:size(<a><z:b>x</z:b></a>/map{z:b:z:b})
declare namespace zzz="http://example.com/options";         declare option zzz:synonymous = ``[http://www.w3.org/1999/XSL/Transform]``;         <zzz:output/>
declare ne gt
declare option Q{http://www.example.com/ns}option "ignore me"; <a/>
declare variable $a := 1;         declare function local:foo($a as xs:integer) {              if ($a > 100) then $a else let $a := $a + 1 return local:foo($a) };         local:foo($a)
declare variable $a := 1;         declare variable $x external := $a + $b;         declare variable $b external := 2;         $x
declare variable $a := <a/>;          declare function local:testSingleNodeIdentity($node as node()) { $node is $node };          declare function local:testDoubleNodeIdentity($a as node(), $b as node()) { $a is $b };          local:testSingleNodeIdentity(<a/>), local:testDoubleNodeIdentity(<a/>, <b/>), local:testDoubleNodeIdentity($a, $a)
declare variable $A:=(<A>{local:functionA()}</A>);         declare function local:functionA() as element() { <input>testing ...</input> };         declare function local:functionB ( ) as xs:string { $A };         local:functionB()
declare variable $A:=(<A>{local:functionA()}</A>);         declare function local:functionA() as element() { <input>testing ...</input> };         declare function local:functionB ( ) as xs:string { xs:string($A) };         local:functionB()
declare variable $a as attribute()* := (attribute name1 {()}, attribute name2 {()}, attribute name3 {()}); declare variable $b as attribute()* := (attribute name1 {()}, attribute name2 {()}, attribute name3 {()}); $a/(let $p := position() return . is $b[$p])
declare variable $a as attribute()* := (attribute name1 {()}, attribute name2 {()}, attribute name3 {()}); <r> <e> { $a } </e> <e> { $a } </e> </r>
declare variable $a := <e><a/><b/><a/></e>; <a>{$a/a eq 1}</a>
declare variable $a := <e><a/><b/><c/></e>; <a>{$a/*:ncname eq 1}</a>
declare variable $a external := 6 + local:foo();         declare variable $b external := 12;         declare function local:foo() { $b + 10 };         $a
declare variable $array1 := ["abc","def","ghi"]; declare variable $array2 := ["abc", [10,20]];  array:get($array2,3)
declare variable $array1 := ["abc","def","ghi","jkl"];  array:remove($array1,5)
declare variable $array1 := ["abc","def","ghi","jkl"];  array:subarray($array1,2,-1)
declare variable $array1 := ["abc","def","ghi","jkl"];  array:subarray($array1,2,6)
declare variable $array1 := ["abc","def","ghi","jkl"];  array:subarray($array1,6)
declare variable $array1 := ["abc","ghi","jkl"];  array:insert-before($array1,0,"aaa")
declare variable $array1 := ["abc","ghi","jkl"];  array:insert-before($array1,6,"mno")
declare variable $array-of-ints := [10,20,30]; declare variable $array-of-arrays := [ ["a","b","c"], ["d","e","f"] ];  $array-of-arrays instance of item()
declare variable $d1 := <e a="1" b="2"><!-- content -->text</e>; declare variable $d2 := <e b="2" a="1">text</e>; deep-equal($d1, $d2), deep-equal($d2, $d1)
declare variable $d1 := <e a="1" b="2"><?target data?>text</e>; declare variable $d2 := <e b="2" a="1">text</e>; deep-equal($d1, $d2), deep-equal($d2, $d1)
declare variable $d1 := <e a="1" b="2">te<!-- content -->xt</e>; declare variable $d2 := <e b="2" a="1">text</e>; deep-equal($d1, $d2), deep-equal($d2, $d1)
declare variable $d1 := <e a="1" b="2">te<?target data?>xt</e>; declare variable $d2 := <e b="2" a="1">text</e>; deep-equal($d1, $d2), deep-equal($d2, $d1)
declare variable $deptinfo := map {   "ACC": map {             "deptname": "Accessories",             "deptnum": 300 } ,   "WMN": map {             "deptname": "Women's",             "deptnum": 310 } ,   "MEN": map {             "deptname": "Men's",             "deptnum": 320 }  }; $deptinfo instance of item()
declare variable $deptinfo := map {   "ACC": map {             "deptname": "Accessories",             "deptnum": 300 } ,   "WMN": map {             "deptname": "Women's",             "deptnum": 310 } ,   "MEN": map {             "deptname": "Men's",             "deptnum": 320 }  }; deep-equal( $deptinfo?*[?deptname = "Accessories"], map { "deptname": "Accessories",             "deptnum": 300 })
declare variable $deptnames := map {   "ACC" : "Accessories",   "WMN" : "Women's",   "MEN" : "Men's" }; deep-equal(map:put($deptnames,"ACC","Other"), map {   "ACC" : "Other",   "WMN" : "Women's",   "MEN" : "Men's" } )
declare variable $deptnames := map {   "ACC" : "Accessories",   "WMN" : "Women's",   "MEN" : "Men's" }; deep-equal(map:put($deptnames,"SHO","Shoes"), map {   "ACC" : "Accessories",   "WMN" : "Women's",   "MEN" : "Men's",   "SHO" : "Shoes" } )
declare variable $deptnames := map {   "ACC" : "Accessories",   "WMN" : "Women's",   "MEN" : "Men's" }; deep-equal(map:remove($deptnames,"ACC"), map {   "WMN" : "Women's",   "MEN" : "Men's" } )
declare variable $deptnames := map {   "ACC" : "Accessories",   "WMN" : "Women's",   "MEN" : "Men's" };  map:contains($deptnames,"ACC")
declare variable $doc := <root><test><x/><y/></test></root>;         $doc/test[x] union $doc/test[y]
declare variable $e := <a b ="content"><?b asd?><b/></a>; $e/*
declare variable $e := <a b ="content"><?b asd?><b/></a>; $e/processing-instruction(b)
declare variable $e := <a b ="content"><?b asd?><b/></a>; <a>{$e/@*}</a>
declare variable $e := <a b ="content"><?b asd?><b/></a>; <a>{$e/@b}</a>
declare variable $e := <a b ="content"><?b asd?><b/></a>; <a>{$e/processing-instruction()}</a>
declare variable $e := <a b ="content"><?b asd?><b/><c b="content"/></a>; $e/b
declare variable $e := attribute name {()}; $e is $e, <is/> is <is/>
declare variable $e := current-time(); let $i := ($e, 1 to 50000, $e) return $i[1] = $i[last()]
declare variable $e := ()/.; declare variable $b := <b/>/.; $e, <b/>
declare variable $e := <e> <a>3</a> <a>2</a> <a>1</a> </e>; exactly-one(for $i in $e/a order by $i return $i)
declare variable $e := <e> <a>3</a> <a>2</a> <a>1</a> </e>; <result> { avg(for $i in $e/a order by $i return $i) } </result>
declare variable $e := <e> <a/> </e>; declare variable $f := $e; <r> { $e is $e, $f is $e, $e, $f } </r>
declare variable $e := <e>{current-time()}</e>/(string-length(.) > 0); $e, if($e) then "SUCCESS" else "FAILURE"
declare variable $e := <e/>; for $i in (<a/>, $e, <c/>) return $i is $e
declare variable $exampleComThisVarIsNotRecognized as processing-instruction()? external; 1
declare variable $exampleComThisVarIsNotRecognized external; 1
declare variable $ext as xs:integer* external := (0,1,2); <a>{sum($ext)}</a>
declare variable $ext as xs:integer* external := 0,1,2; <a>{sum($ext)}</a>
declare variable $ext as xs:integer external := 0; <a>{$ext}</a>
declare variable $ext as xs:integer* external := ; <a></a>
declare variable $ext external := 0; $ext
declare variable $ext external := 0; <a>{$ext}</a>
declare variable $f := (if (current-date() gt xs:date('1900-01-01')) then local:plus#2 else round#2);         declare function local:plus($x, $y) {           $x + $y + $a         };         declare variable $a := function-arity($f);         $f(3, 4)
declare variable $f := (if (current-date() gt xs:date('1900-01-01')) then local:plus#2 else round#2);         declare function local:plus($x, $y) {           $x + $y         };         $f(5, 7)
declare variable $global := count(*); $global, <wrongFocus> <e1/> <e2/> </wrongFocus>/$global, $global
declare variable $global := count(*); <e/>/$global
declare variable $global := count(*);          <e/>/($global, $global)
declare variable $global := count(*); <wrongFocus> <e1/> <e2/> </wrongFocus>/$global
declare variable $global := node();         declare function local:function() { exists($global) };         local:function()
declare variable $i := 1, 1; 1
declare variable $i := 3; (for $i in 1 return $i) eq 1
declare variable $i := <e> <a>1</a> <b>2</b> </e>; <result> { ($i/b, $i/a)/. } </result>
declare variable $i := <e xmlns="http://example.com/"/>; empty($i/@xmlns)
declare variable $i := false();          declare variable $t := false();          deep-equal( for $i in (true(), true()), $t in (true(), true())                      return ($i, $t), (true(), true(), true(), true(), true(), true(), true(), true()))
declare variable $i := false();          declare variable $t := false();          deep-equal((let $i := true(), $t := true() return ($i, $t)), (true(), true()))
declare variable $i := false();          declare variable $t := false();          some $i in (true(), true()), $t in (true(), true()) satisfies ($i eq $t)
declare variable $i := false();          declare variable $t := false();          some $i in (true(), true()), $t in (true(), true()) satisfies $i eq $t
declare variable $i := false();          every $i in (true(), true()) satisfies $i
declare variable $i := false();          some $i in (true(), true(), true()) satisfies $i
declare variable $in := <in><e on="2017-09-18"/><e on="2016-04-15"/><e on="2012-07-09"/></in>;          for $j in ($in//e/@on, xs:date('1999-12-17'))           order by $j           return $j
declare variable $input-context1 := $string;         declare variable $input-context2 := $company-data;         declare function local:partners($company as xs:string) as element()*         {             let $c := $input-context2//company[name = $company]             return $c//partner         };         let $foobar_partners := local:partners("Foobar Corporation")         for $item in $input-context1//news_item         where           some $t in $item//title satisfies             (contains(exactly-one($t/text()), "Foobar Corporation")             and (some $partner in $foobar_partners satisfies               contains(exactly-one($t/text()), $partner/text())))           or (some $par in $item//par satisfies            (contains(string($par), "Foobar Corporation")              and (some $partner in $foobar_partners satisfies                 contains(string($par), $partner/text()))))         return             <news_item>                 { $item/title }                 { $item/date }             </news_item>
declare variable $input-context := .;         declare function local:one_level($p as element()) as element() {              <part partid="{ $p/@partid }" name="{ $p/@name }" > {                  for $s in ($input-context//part)                 where $s/@partof = $p/@partid                  return local:one_level($s) } </part> };          <parttree> { for $p in //part[empty(@partof)]                       return local:one_level($p) } </parttree>
declare variable $inputDoc := 2; declare namespace x = "http://example.com/"; 1
declare variable $input := <e/>;          empty(for $PI as processing-instruction() in $input//processing-instruction() return $PI)
declare variable $i := <root> <child> <child2> <child3> <leaf/> </child3> <following/> </child2> <following/> </child> <following/> </root>; empty(root($i)//leaf/preceding::node())
declare variable $i := <root> <child/> <child/> <child> <child2> <child3> <leaf/> </child3> </child2> </child> </root>; 1, root($i)//leaf/child::node(), 1
declare variable $i := <root> <child/> <child/> <child> <child2> <child3> <leaf/> </child3> </child2> </child> </root>;          1, root($i)//leaf/following::node(), 1
declare variable $i := <root> <child/> <child/> <child> <child2> <child3> <leaf/> </child3> </child2> </child> </root>;          empty(root($i)/following::node())
declare variable $i := <root> <child/> <child/> <child> <child2> <child3> <leaf/> </child3> </child2> </child> </root>; empty(root($i)/preceding::node())
declare variable $i := <root> <child/> <child/> <child> <child2> <child3> <leaf/> </child3> </child2> </child> </root>;          root($i)//count(following::node())
declare variable $i := <root> <child/> <child/> <child> <child2> <child3> <leaf/> </child3> </child2> </child> </root>;          root($i)//count(following-sibling::node())
declare variable $i := <root> <child/> <child/> <child> <child2> <child3> <leaf/> </child3> </child2> </child> </root>;          root($i)//following-sibling::node()
declare variable $i := <root> <child/> <child/> <child> <child2> <child3> <leaf/> </child3> </child2> </child> </root>;          root($i)//(following-sibling::node(), "BOO")
declare variable $i := <root> <child> <preceding2/> <child2> <preceding1/> <child3> <leaf/> </child3> <following/> </child2> <following/> </child> <following/> </root>; count(root($i)//leaf/preceding::node())
declare variable $i := <root> <child> <preceding2/> <child2> <preceding1/> <child3> <leaf/> </child3> <following/> </child2> <following/> </child> <following/> </root>; count(root($i)/preceding::node())
declare variable $i := <root> <child> <preceding2/> <child2> <preceding1/> <child3> <leaf/> </child3> <following/> </child2> <following/> </child> <following/> </root>; empty(root($i)/preceding::node())
declare variable $i := <root> <child> <preceding2/> <child2> <preceding1/> <child3> <leaf/> </child3> <following/> </child2> <following/> </child> <following/> </root>; empty(root($i)/preceding-sibling::node())
declare variable $i := <root> <child> <preceding2/> <child2> <preceding1/> <child3> <leaf/> </child3> <following/> </child2> <following/> </child> <following/> </root>; root($i)//count(preceding::*)
declare variable $i := <root> <child> <preceding2/> <child2> <preceding1/> <child3> <leaf/> </child3> <following/> </child2> <following/> </child> <following/> </root>; root($i)//count(preceding-sibling::node())
declare variable $i := <root> <child> <preceding2/> <child2> <preceding1/> <child3> <leaf/> </child3> <following/> </child2> <following/> </child> <following/> </root>; root($i)//leaf/(preceding::node())[1]
declare variable $i := <root> <child> <preceding2/> <child2> <preceding1/> <child3> <leaf/> </child3> <following/> </child2> <following/> </child> <following/> </root>; root($i)//leaf/preceding::node()[1]
declare variable $i := <root> <child> <preceding2/> <child2> <preceding1/> <child3> <leaf/> </child3> <following/> </child2> <following/> </child> <following/> </root>; root($i)//leaf/(preceding::node())[last()]
declare variable $i := <root> <child> <preceding2/> <child2> <preceding1/> <child3> <leaf/> </child3> <following/> </child2> <following/> </child> <following/> </root>; root($i)//leaf/preceding::node()[last()]
declare variable $i := ("x", 1);         declare variable $j := $i[position() ne 1];         $i[$j]
declare variable $j external := 1;          for $x at $i in (2, 3)          where $i = $j          return $x
declare variable $local:myName := 1;         declare function local:myName() as xs:integer { 1 };         $local:myName eq local:myName()
declare variable $local:myVar := 1;         declare function local:myFunction($local:myVar) { $local:myVar };         $local:myVar, local:myFunction(2)
declare variable $local:myVar := <a/>; <b> {$local:myVar} {attribute name {"content"}} </b>
declare variable $local:myVar as item() := <a/>; <b> {$local:myVar} {attribute name {"content"}} </b>
declare variable $local:myVar := attribute n2 {"content"}; <b> {$local:myVar} {attribute name {"content"}} </b>
declare variable $local:myVar := local:myFunc(3); declare function local:myFunc($local:myVar) { $local:myVar }; local:myFunc(6)
declare variable $local:myVar := local:myFunction();          declare function local:myFunction() {            if (current-date() lt xs:date('1990-01-01')) then $local:myVar + 1 else 22          };          $local:myVar
declare variable $local:myVar := local:thisFunctionDoesNotExist(); $local:myVar
declare variable $local:myVar := local:thisFunctionDoesNotExist(); 1
declare variable $local:var1 := 1; declare variable $local:var2 := 2; declare variable $local:var3 := 3; declare variable $local:var4 := 4; declare variable $local:var5 := 5; declare variable $local:var6 := 6; declare variable $local:var7 := 7; declare variable $local:var8 := 8; declare variable $local:var9 := 9; declare variable $local:var10 := 10; declare variable $local:var11 := 11; declare variable $local:var12 := 12; declare variable $local:var13 := 13; declare variable $local:var14 := 14; declare variable $local:var15 := 15; declare variable $local:var16 := 16; declare variable $local:var17 := 17; declare variable $local:var18 := 18; declare variable $local:var19 := 19; declare variable $local:var20 := 20; deep-equal((1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20), ($local:var1, $local:var2, $local:var3, $local:var4, $local:var5, $local:var6, $local:var7, $local:var8, $local:var9, $local:var10, $local:var11, $local:var12, $local:var13, $local:var14, $local:var15, $local:var16, $local:var17, $local:var18, $local:var19, $local:var20))
(::)declare(::)variable(::)$local:var(::):=(::)3;(::)1(::)eq(::)1(::)
declare variable $local:var as item() *:=3; true()
declare variable $map1 := map {1:"first", 2:"second", 3:"third",4:()}; declare variable $map2 := map {};  map:contains($map1, "1")
declare variable $map1 := map {1:"first", 2:"second", 3:"third",4:()}; declare variable $map2 := map {};  map:contains($map1, 1)
declare variable $map1 := map {1:"first", 2:"second", 3:"third",4:()}; declare variable $map2 := map {};  map:contains($map1, 4)
declare variable $map1 := map {1:"first", 2:"second", 3:"third",4:()}; declare variable $map2 := map {};  map:contains($map1, 9)
declare variable $map1 := map {1:"first", 2:"second", 3:"third",4:()}; declare variable $map2 := map {};  map:contains($map2, 1)
declare variable $map1 := map {1:"first", 2:"second"}; declare variable $map2 := map {1:"ONE", "abc":"def"}; declare variable $map3 := map {"1":"first", "2":"second"}; deep-equal(  map:merge( ($map1, $map2, $map3) ),  map {1:"ONE", 2:"second", "abc":"def", "1":"first", "2":"second"}  )
declare variable $map1 := map {1:"first", 2:"second"}; declare variable $map2 := map {1:"ONE", "abc":"def"}; declare variable $map3 := map {"1":"first", "2":"second"}; deep-equal(  map:merge( ($map1, $map2) ),  map {1:"first", 2:"second", "abc":"def"}  )
declare variable $map1 := map {1:"first", 2:"second"}; declare variable $map2 := map {1:"ONE", "abc":"def"}; declare variable $map3 := map {"1":"first", "2":"second"}; deep-equal(  map:merge( ($map1, $map3) ),  map {1:"first", 2:"second", "1":"first", "2":"second"}  )
declare variable $map1 := map {1:"first", 2:"second"}; declare variable $map2 := map {1:"ONE", "abc":"def"}; declare variable $map3 := map {"1":"first", "2":"second"}; deep-equal(  map:merge( ($map1) ),  map {1:"first", 2:"second"}  )
declare variable $map1 := map {1:"first", 2:"second"}; declare variable $map2 := map {1:"ONE", "abc":"def"}; declare variable $map3 := map {"1":"first", "2":"second"}; deep-equal(  map:merge( ($map1, map{2:"second-new"}) ),  map {1:"first", 2:"second"}  )
declare variable $map1 := map {1:"first", 2:"second"}; declare variable $map2 := map {1:"ONE", "abc":"def"}; declare variable $map3 := map {"1":"first", "2":"second"}; deep-equal(  map:merge( ($map1, map{3:"third"}) ),  map {1:"first", 2:"second", 3:"third"}  )
declare variable $map1 := map {1:"first", 2:"second"}; declare variable $map2 := map {1:"ONE", "abc":"def"}; declare variable $map3 := map {"1":"first", "2":"second"}; deep-equal(  map:merge( ($map1, map:entry(2,"second-new")) ),  map {1:"first", 2:"second"}  )
declare variable $map1 := map {1:"first", 2:"second"}; declare variable $map2 := map {1:"ONE", "abc":"def"}; declare variable $map3 := map {"1":"first", "2":"second"}; deep-equal(  map:merge( ($map2, $map1) ),  map {1:"ONE", 2:"second", "abc":"def"}  )
declare variable $map1 := map {1:"first", 2:"second"}; declare variable $map2 := map {1:"ONE", "abc":"def"}; declare variable $map3 := map {"1":"first", "2":"second"}; deep-equal(  map:merge( () ),  map {}  )
declare variable $map1 := map {1:"first", 2:"second"}; deep-equal( map:entry(1,"first"), map {1:"first"} )
declare variable $map1 := map {1:"first", 2:"second"}; deep-equal(  map:merge( ($map1, map:entry(3, "third")) ),   map {1:"first", 2:"second", 3:"third"} )
declare variable $map1 := map {1:"first", 2:"second"}; deep-equal(  map:merge( (map:entry(1, "first"), map:entry(2, "second")) ),  map {1:"first", 2:"second"}  )
declare variable $map1 := map {1:"first", 2:"second"};          deep-equal(  map:merge(map:for-each($map1,function($k,$v) {map:entry($k + 1, $v)})),  map {2:"first", 3:"second"}  )
declare variable $map1 := map {1:"first", 2:"second"};          deep-equal(  map:put($map1, 1, "ONE"),  map {1:"ONE", 2:"second"}  )
declare variable $map1 := map {1:"first", 2:"second"};          deep-equal(  map:put($map1, 3, "third"),  map {1:"first", 2:"second", 3:"third"}  )
declare variable $map1 := map {1:"first", 2:"second"};          deep-equal(  map:put($map1, "abc", "def"),  map {1:"first", 2:"second", "abc":"def"}  )
declare variable $map1 := map {1:"first", 2:"second"}; deep-equal(  map:remove($map1,2),  map {1:"first"}  )
declare variable $map1 := map {1:"first", 2:"second"}; deep-equal( map:remove($map1,3), map {1:"first", 2:"second"} )
declare variable $map1 := map {1:"first", 2:"second"}; deep-equal( map:remove($map1,"abc"), map {1:"first", 2:"second"} )
declare variable $m as xs:integer external := 5;          declare variable $n as xs:integer external := 5;          <out>{ for $x allowing empty at $p in 1 to $m, $y at $q in 1 to $n return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>
declare variable $my := 3;         declare function local:myFunction($my, $arg2, $arg4) { 1 };         $my eq 3
declare variable $my := 3; (for $i in 1 return $my) eq 3
declare variable $myVar as xs:gYear := 2006; true()
declare variable $myVar as xs:integer := subsequence((1, 2, "a string"), 3, 1); $myVar eq 3
declare variable $myVar := (attribute name {"content"}, <elem/>); <b> {$myVar[2]} </b>
declare variable $myVar := <e/>; $myVar/(/)/
declare variable $myVar := <e/>; empty($myVar/descendant-or-self::text())
declare variable $myVar := <e/>;          empty($myVar/preceding-sibling::comment()/a/b/c/1/@*)
declare variable $myVar := <e/>; empty(fn:root($myVar/(/)/..))
declare variable $myvar := <elem> <a/> <b/> <c/></elem>; $myvar/*[1]
declare variable $myvar := <elem> <a/> <b/> <c/></elem>; $myvar/*[last()]
declare variable $myvar := <elem> <a/> <b/> <c/></elem>; $myvar/*[last() - 1]
declare variable $myVar := (<elem/>, attribute name {"content"}); <b> {$myVar[2]} </b>
declare variable $myVar := (<elem/>, attribute name {"content"}); <b> {$myVar} </b>
declare variable $myVar := <e>{nametest}</e>; <e/>/$myVar
declare variable $myVar := <e>text</e>; $myVar/text()/(<e/>, (), 1, <e/>)
declare variable $myVariable := <e/>/(1, <e/>); $myVariable
declare variable $myVariable := <e/>/(<e/>, 2); $myVariable
declare variable $myVar := unordered(fn:reverse((<a/>, <b/>))); deep-equal($myVar, (<a/>, <b/>)) or deep-equal($myVar, (<b/>, <a/>))
declare variable $n as xs:integer external := 10;          }`nasty!]``
declare variable $n as xs:integer external := 10;          <out>{ for $x allowing empty at $p in 1 to $n return <a position="{$p}">{$x}</a> }</out>
declare variable $n as xs:integer external := 10;          <out>{ for $x allowing empty in 1 to $n return <a>{$x}</a> }</out>
declare variable $n as xs:integer external := 10;         <out>{ string-join(for $x allowing empty in 1 to $n return concat('[',$x,']'), '|') }</out>
declare variable $n as xs:integer external := 10;          ``[There were `{$n
declare variable $n as xs:integer external := 10;          ``[There were `{$n} green
declare variable $n as xs:integer external := 10;          `[There were `{$n}` green bottles]``
declare variable $n as xs:integer external := 10;          ``[There were `{$n}` green bottles
declare variable $n as xs:integer external := 10;          ``[There were `{$n}` green bottles]
declare variable $n as xs:integer external := 10;          ``[There were `{$n}` green bottles]`
declare variable $n as xs:integer external := 10;          ``{There were `{$n}` green bottles}``
declare variable $n as xs:integer external := 10;          unordered{$n}`
declare variable $n as xs:integer external := 5;          <out>{ for $x as xs:integer? allowing empty at $p in 1 to $n                 for $y as xs:integer? allowing empty at $q in (if (empty($x)) then () else (1 to $x))                 where deep-equal($x,$y)                 return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>
declare variable $n as xs:integer external := 5;          <out>{ for $x as xs:integer? allowing empty at $p in 1 to $n                 for $y as xs:integer at $q in (if (empty($x)) then 0 else (1 to $x))                 return <a p="{$p}" q="{$q}">{$x},{$y}</a> }</out>
declare variable $n external := 0;          for $x in -2 to +2          where ($n - $x)          return $x
declare variable $n external := 10;          for $x allowing empty in 1 to $n          where $x lt 5          return $x
declare variable $p as xs:integer external;          declare function local:negate($x) {-$x};          declare variable $f := let $x := $p return function($a) {local:negate($a + $x + $p)};          $f(12)
declare variable $p as xs:integer external;          declare variable $f := function($a) {$a + $p};          $f(12)
declare variable $p := "base-uri";         declare variable $f := function-lookup(xs:QName("fn:"||$p), 0);         declare context item := $f();         .
declare variable $p external := -101; (1, 8, 13, 14, 98, -22, 0, 17, 34, 87, 99, 54, 22, 33, 44, 55, 66, 77) = $p
declare variable $p external := (105, 22e0); $p = (1, 8, 13, 14, 98, -22, 0, 17, 34, 87, 99, 54, 22, 33, 44, 55, 66, 77)
declare variable $p external := (105, xs:untypedAtomic('22e0')); (1, 8, 13, 14, 98, -22, 0, 17, 34, 87, 99, 54, 22, 33, 44, 55, 66, 77) = $p
declare variable $p external := 17; $p = (1, 8, 13, 14, 98, -22, 0, 17, 34, 87, 99, 54, 22, 33, 44, 55, 66, 77)
declare variable $p external := (1 to 10, xs:untypedAtomic('860302'), 83);          $p = (35 to 65, xs:untypedAtomic('082'), xs:untypedAtomic('0010'))
declare variable $p external := 276; $p = (1 to 1000)
declare variable $p external := -276; (1 to 1000) = $p
declare variable $p external := xs:untypedAtomic('000504e0'); $p = (1 to 1000)
declare variable $p external := xs:untypedAtomic('000504e0'); $p = (1 to xs:integer(xs:double($p)))
declare variable $p external := xs:untypedAtomic('-022e0'); (1, 8, 13, 14, 98, -22, 0, 17, 34, 87, 99, 54, 22, 33, 44, 55, 66, 77) = $p
declare variable $p external := xs:untypedAtomic('4.5'); (1 to 1000) = $p
declare variable $p external := xs:untypedAtomic('-840'); $p = (1, 8, 13, 14, 98, -22, 0, 17, 34, 87, 99, 54, 22, 33, 44, 55, 66, 77)
declare variable $p external := xs:untypedAtomic('860302'); (1 to xs:integer($p)) = $p
declare variable $prefix:var1 := 2; declare namespace prefix = "http://example.com/myNamespace"; true()
declare variable $Q{http://www.example.com/ns/my}var := 12;              <out>{$Q{http://www.example.com/ns/my}var}</out>
declare variable $root := <a> <b e="B"/> <c e="B"/> </a>; declare function local:function($arg) { $root["B" eq $arg/@e] }; $root/local:function(c)
declare variable $root := <a> <b e="B"/> <c e="B"/> </a>; declare function local:function($arg) { $root[exactly-one($arg/@e)] }; $root/local:function(c)
declare variable $root := <a><c e=""/></a>; declare function local:function($arg) { $root[$arg/@e] }; $root/local:function(c)
declare variable $root := ( <b d=""/>, <c> <c d=""/> </c> ); declare function local:function($object) { $root[@d eq $object/@d] }; $root/local:function(c)
declare variable $root := ( <b d=""/>, <c d=""> <c d=""/> </c> );          declare function local:function($object) { $root[@d eq $object/@d] };          $root!local:function(c)
declare variable $root := <root> <b d=""/> <c> <c d=""/> <c/> </c> </root>; declare function local:function($object) { $root[$object/@d] }; $root//local:function(c)
declare variable $root := <root> <b d=""/> <c> <c d=""/> <c/> </c> </root>; declare function local:function($object) { $root/b[$object/@d] }; $root//local:function(c)
declare variable $root := <root> <b d=""/> <c> <c d=""/> <c/> </c> </root>; declare function local:function($object) { $root/b[@d = $object/@d] }; $root/c/c/local:function(.)
declare variable $root := <root> <b d=""/> <c> <c d=""/> <c/> </c> </root>;          declare function local:function($object) { $root/b[@d = $object/@d] };          $root//local:function(c)
declare variable $root := <root> <b d=""/> <c d=""/> </root>; declare function local:function($object) { $root[$object/@d] }; $root//local:function(c)
declare variable $root := <root> <c d=""/> </root>; declare function local:function($object) { $root[$object] }; $root//local:function(c)
declare variable $root := <root> <c d=""/> </root>; declare function local:function($object) { $root[$object/@d] }; $root//local:function(c)
declare variable $root := <root><c/></root>; declare function local:function($arg) { $root[$arg] }; $root//local:function(.)
declare variable $root := <root/>; declare function local:function($arg, $count as xs:integer) { $arg, $root, if($count eq 2) then $root else local:function($arg, $count + 1) }; $root/local:function(., 1)
declare variable $s :=[['A', 'DT'], ['bride', 'NN'], [',', ','], ['you', 'PRP'], ['know', 'VBP'], [',', ','], ['must', 'MD'],  ['appear', 'VB'], ['like', 'IN'], ['a', 'DT'], ['bride', 'NN'], [',', ','], ['but', 'CC'], ['my', 'PRP$'],  ['natural', 'JJ'], ['taste', 'NN'], ['is', 'VBZ'], ['all', 'DT'], ['for', 'IN'], ['simplicity', 'NN'], [';', ':'],  ['a', 'DT'], ['simple', 'JJ'], ['style', 'NN'], ['of', 'IN'], ['dress', 'NN'], ['is', 'VBZ'],  ['so', 'RB'], ['infinitely', 'RB'], ['preferable', 'JJ'], ['to', 'TO'], ['finery', 'VB'], ['.', '.'] ]; declare variable $index := map { "pos" : 2, "lemma" : 1 }; <s>  {   for $w in $s?*   return <w pos="{ $w($index("pos")) }">{ $w($index("lemma")) }</w>  } </s>
declare variable $s :=[['A', 'DT'], ['bride', 'NN'], [',', ','], ['you', 'PRP'], ['know', 'VBP'], [',', ','], ['must', 'MD'],  ['appear', 'VB'], ['like', 'IN'], ['a', 'DT'], ['bride', 'NN'], [',', ','], ['but', 'CC'], ['my', 'PRP$'],  ['natural', 'JJ'], ['taste', 'NN'], ['is', 'VBZ'], ['all', 'DT'], ['for', 'IN'], ['simplicity', 'NN'], [';', ':'],  ['a', 'DT'], ['simple', 'JJ'], ['style', 'NN'], ['of', 'IN'], ['dress', 'NN'], ['is', 'VBZ'],  ['so', 'RB'], ['infinitely', 'RB'], ['preferable', 'JJ'], ['to', 'TO'], ['finery', 'VB'], ['.', '.'] ]; <s>  {   for $w in $s?*   return <w pos="{ $w(2) }">{ $w(1) }</w>  } </s>
declare variable $sep as xs:string := "\s";        declare function local:splitter() as (function(xs:string) as xs:string*)?         { function($x as xs:string) { for $i in tokenize($x, $sep) return upper-case($i)} };        string-join(local:splitter()("A nice cup of tea"), '|')
declare variable $span := <root><span class="ocr_word" title="bbox 1388 430 1461 474">the</span> <span class="ocr_word" title="bbox 1514 433 1635 476">other</span> <span class="ocr_word" title="bbox 133 498 317 554">pcssible</span> <span class="ocr_word" title="bbox 354 498 590 541">derivation</span> <span class="ocr_word" title="bbox 631 497 738 538">from</span> <span class="ocr_word" title="bbox 772 495 799 547" lang="grc" xml:lang="grc">?</span> <span class="ocr_word" title="bbox 835 495 1019 538" lang="grc" xml:lang="grc">???????</span> <span class="ocr_word" title="bbox 134 567 220 607">dies</span> <span class="ocr_word" title="bbox 257 566 462 607">erastinus</span></root>; declare function local:extract-text($spans) {   for $s in $spans//span return string($s) };   local:extract-text($span)
declare variable $strings := ('1','2'); declare variable $untypeds := (<untyped>1</untyped>,<untyped>2</untyped>); for $string in $strings for $untyped in $untypeds where $untyped = $string return $string
declare variable $v : = 1; 1
declare variable $v ::= 1; 1
declare variable $v := <a><b/><b/><b/></a>; $v//45
declare variable $v := <a><b/><b/><b/></a>; deep-equal($v//45, (45, 45, 45, 45))
declare variable $var1 := $var2; declare variable $var2 := 2; $var1
declare variable $var1 := $var2; declare variable $var2 := 2; true()
declare variable $var1 = 1; 1
declare variable $var1 := 1;         declare function local:func1() as xs:integer { $var1 };         declare variable $var2 := 2;         declare function local:func2() as xs:integer { $var2 };         1 eq local:func1() and 2 eq local:func2()
(::)declare(::)variable(::)$var(::):=(::)1(::);(::) 1(::)eq(::)1
declare variable $var := 1 := 2; 3
declare variable $var1 := 2; declare variable $var2 := $var1; $var2 eq 2
declare variable $var1 := let $var1 := 1 return 1;         $var1 eq 1
declare variable $var1 := local:myFunc(); declare function local:myFunc() { 1 }; $var1 eq 1
declare variable $var := <a> <b/> <c/> <d/> </a>; ($var/*, $var/*)
declare variable $var := <a> <b/> <c/> <d/> </a>; ($var/*, $var/*)/.
declare variable $var as xs:anyURI := xs:anyURI("http://example.com"); $var
declare variable $var as xs:boolean := fn:empty((1,2,3)); $var
declare variable $var as xs:boolean := fn:false(); $var
declare variable $var as xs:boolean := fn:not(fn:true()); $var
declare variable $var as xs:boolean := fn:true(); $var
declare variable $var as xs:dateTime := xs:dateTime("1999-11-28T09:00:00Z"); $var
declare variable $var as xs:date := xs:date("1999-11-28Z"); $var
declare variable $var as xs:date := xs:date("1999-11-28Z");         declare variable $var as xs:date := xs:date("1999-11-28Z");         $var
declare variable $var as xs:decimal := 100; $var
declare variable $var as xs:integer := $e +1;        declare variable $e as xs:integer := 10;         $var
declare variable $var as xs:integer := 100; $var
declare variable $var as xs:integer := 17;           declare variable $ext as element(a) external := <a>{$var}</a>;           <out>{$ext}</out>
declare variable $var as xs:integer := 17;          declare variable $ext as xs:integer external := $var;          <out>{$ext}</out>
declare variable $var as xs:integer := 17;          declare variable $ext as xs:integer external := <a>{$var}</a>;          <out>{$ext}</out>
declare variable $var as xs:integer := fn:count((10,2)); $var
declare variable $var as xs:integer := fn:string-length("ABC"); $var
declare variable $var as xs:string := "abc"; $var
declare variable $var as xs:time := xs:time("11:12:00Z"); $var
declare variable $var := document {<a>123</a>}; $var[/*5]
declare variable $var := document {<a>123</a>}; $var[/<5]
declare variable $var := document {<a>123</a>}; $var[/<a]
declare variable $var := document {<a>123</a>}; $var[/<a div 3]
declare variable $var := document {<a>123</a>}; $var[/</b]
declare variable $var := document {<a>123</a>}; $var[/if ($doclevel) then / else /*]
declare variable $var := document {<a>123</a>};          $var[/ instance of document-node(element(x))]
declare variable $var := document {<a>123</a>};          declare variable $a := document {<a>123</a>}; $var[/ is $a]
declare variable $var := document {<a>123</a>};          let $doc := / return $doc/*
declare variable $var := <e><f>f's value</f></e>; $var/(/)/(/)//f
declare variable $var := <elem/>; $var is $var
declare variable $var := <elem/>; <a>{$var}</a>/elem[1] is $var
declare variable $var := <elem/>; not($var is <elem/>)
declare variable $var := <elem>text<a/><!-- a comment --><b/><?target data?><c/><![CDATA[more text]]></elem>; $var/child::*
declare variable $var := <elem xml:space="default"/>; $var/@xml:space eq "default"
declare variable $var := <elem xml:space="preserve"/>; string(($var/@xml:*)[1])
declare variable $var external := 1; 1
declare variable $var := (for $i in 1 to 100 return <e>{$i}</e>); $var[5]
declare variable $var := (for $i in 1 to 100 return <e>{$i}</e>); $var[last()]
declare variable $v as element(notWildcard, xs:untyped*)+ := <e/>; 1
declare variable $v as element(notWildcard, xs:untyped+)+ := <e/>; 1
declare variable $v as element(*, xs:untyped*)+ := <e/>; 1
declare variable $v as element(*, xs:untyped+)+ := <e/>; 1
declare variable $v := function-arity(local:plus#2);         declare function local:plus($x, $y) {           $x + $y         };         $v
declare variable $v := function-name(local:plus#2);         declare function local:plus($x, $y) {           $x + $y         };         $v
declare variable $x := "" ; $x
declare variable $x := '' ; $x
declare variable $x := $y + 3;         declare variable $y := 17;         $x + 5
declare variable $x := 0 ; $x
declare variable $x := 0.0E0 ; $x
declare variable $x := +1 ; $x
declare variable $x := -1 ; $x
declare variable $x := 1 ; $x
declare variable $x := -10000000 ; $x
declare variable $x := ((1+1), (2-2)) ; $x
declare variable $x := ((1,2,2),(1,2,3),(123,""),(),("")) ; $x
declare variable $x := (1,2,3) ; $x
declare variable $x := -1.23 ; $x
declare variable $x := 1.23 ; $x
declare variable $x := 1.2e5 ; $x
declare variable $x := -1.2E5 ; $x
declare variable $x := -1.7976931348623157E308 ; $x
declare variable $x := 1e-5 ; $x
declare variable $x := 1 to 10 ; $x
declare variable $x := 2*2 ; $x
declare variable $x := 2+2 ; $x
declare variable $x := 3-2 ; $x
declare variable $x := -3.4028235E38 ; $x
declare variable $x := 3 div 2 ; $x
declare variable $x := 3 idiv 2 ; $x
declare variable $x := 3 mod 2 ; $x
declare variable $x := -999999999999999999 ; $x
declare variable $x := 999999999999999999 ; $x
declare variable $x := "a "" or a ' delimits a string literal" ; $x
declare variable $x := 'a " or a '' delimits a string literal' ; $x
declare variable $x := "a string" ; $x
declare variable $x := 'a string' ; $x
declare variable $x as xs:boolean external; $x and fn:false()
declare variable $x as xs:boolean external; $x or fn:false()
declare variable $x as xs:boolean external; fn:not($x)
declare variable $x as xs:boolean external; fn:string($x)
declare variable $x as xs:decimal external; $x
declare variable $x as xs:decimal external := xs:integer(10);         $x
declare variable $x as xs:double external; $x
declare variable $x as xs:integer := 10; declare variable $var as xs:integer := $x +1; $var
declare variable $x as xs:integer external; $x
declare variable $x as xs:integer external; $x * $x
declare variable $x as xs:integer external; $x + $x
declare variable $x as xs:integer external; $x div xs:integer(10)
declare variable $x as xs:integer external; $x idiv xs:integer(2)
declare variable $x as xs:integer external; $x mod xs:integer(2)
declare variable $x as xs:integer external; $x - xs:integer(1)
declare variable $x as xs:integer external := xs:int(5);         declare variable $y as xs:decimal external := $x;         $y instance of xs:decimal
declare variable $x as xs:string external; $x
declare variable $x as xs:string external; fn:lower-case($x)
declare variable $x as xs:string external; fn:upper-case($x)
declare variable $x := <b/>;         declare variable $y := <a/>;         ($x union $y) union $x, ($x intersect $y) union $x, ($x except $y) union $x, ($y except $x) union $x, $x union ($x union $y), $x union ($x intersect $y), $x union ($x except $y), $x union ($y except $x)
declare variable $x := /comment() ; $x
declare variable $x external := $a + 10;         $x
declare variable $x external; $x
declare variable $x external; $x * $x
declare variable $x external; $x + $x
declare variable $x external; $x - 1
declare variable $x external; $x and fn:false()
declare variable $x external; $x div 10
declare variable $x external; $x idiv 2
declare variable $x external; $x mod 2
declare variable $x external; $x or fn:false()
declare variable $x external := 10;         declare variable $y external := 18 + $x;         $y
declare variable $x external := 5;         declare variable $a := $x + 2;         declare function local:foo() {$x +$a};         declare variable $y external := 11 + local:foo() + $x;         $y
declare variable $x external; fn:lower-case($x)
declare variable $x external; fn:not($x)
declare variable $x external; fn:string($x)
declare variable $x external; fn:upper-case($x)
declare variable $x external; "result"
declare variable $x external := /works/employee[@name eq "Jane Doe 1"];         fn:count($x)
declare variable $x external; xs:dateTime($x)
declare variable $x external; xs:integer($x)
declare variable $x := false(); $x
declare variable $x := fn:false() ; $x
declare variable $x := fn:true() ; $x
declare variable $x := '&lt;bold&gt;A sample element.&lt;/bold&gt;' ; $x
declare variable $x := //Price/text() ; $x
declare variable $x := /processing-instruction() ; $x
declare variable $x := 'This is a "String"' ; $x
declare variable $x := "This is a string, isn't it?" ; $x
declare variable $x := true() ; $x
declare variable $x := true(); $x
declare variable $x := (xs:boolean("true") , xs:boolean("0"), xs:integer("0")) ; $x
declare variable $x := xs:date("1970-01-01Z") ; $x
declare variable $x := (xs:date("1993-03-31") , xs:boolean("true"), xs:string("abc")) ; $x
declare variable $x := xs:dateTime("2030-12-31T23:59:59Z") ; $x
declare variable $x := xs:decimal("-999999999999999999") ; $x
declare variable $x := xs:decimal("999999999999999999") ; $x
declare variable $x := xs:double("-1.7976931348623157E308") ; $x
declare variable $x := xs:double('-INF'); $x
declare variable $x := xs:double('INF'); $x
declare variable $x := xs:double('NaN'); $x
declare variable $x := xs:float("-3.4028235E38") ; $x
declare variable $x := (xs:float("INF") , xs:double("NaN")) ; $x
declare variable $x := (xs:string("a") , xs:anyURI("www.example.com")) ; $x
declare variable $x := (xs:string("a") , (), "xyz") ; $x
declare variable $x := xs:time("08:03:35Z") ; $x
declare variable $x := (xs:time("12:30:00") , xs:string(" ") , xs:decimal("2.000000000000002")) ; $x
declare variable $y external;         declare variable $z external := 10;         declare function local:aaa() { $z };         declare variable $x external := local:bbb() + local:aaa() + 2;         declare function local:bbb() { $y };         $x
declare variable $y := /works/employee;         declare context item := $y[9];         declare variable $x external := fn:position();         $x
declare variable $y := /works/employee;         declare context item := $y[9];         declare variable $x external := if (./*) then fn:position() else 0;         ($x, $y)
declare variable var1 := 1; 1
deep-equal()
deep-equal((0, 1, 2), (0, 1, 2)[. eq 0 or . eq 1 or . eq 2])
deep-equal((0, 1, 2), (0, 1, 2)[if(. eq 8) then 0 else position()])
deep-equal((0, 1, 2), (0, 1, 2)[if(. eq 8) then "str" else position()])
deep-equal((0, 1, 2), (0, 1, 2)[position() eq position()])
deep-equal((0, 1, 2), (0, 1, 2)[position() = position()])
deep-equal((0, -1, -2, -3, -4, -5), reverse(-5 to 0))
deep-equal((), 0 to -5)
deep-equal(0 to -5, ())
deep-equal((11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1), reverse(((), (), 1, 2, (3, 4), (5), (6, (7, 8), 9), 10, (), 11, ())))
deep-equal(((), 1, 1), ((), 1, 1))
deep-equal((1, (), 1), (1, (), 1))
deep-equal((1, 1, ()), (1, 1, ()))
deep-equal((1, 1, 1), (1, 1, 1))
deep-equal((1, 1, "str"), (1, 1, "str"))
deep-equal((1, 2), (0, 1, 2)[if(. eq 1) then 2 else 3])
deep-equal((1, 2), (1, 2)[remove((true(), "a string"), 2)])
deep-equal((1, 2), (1, 2)[remove((true(), "a string"), 2)]) eq 0
deep-equal((1, 2, 3))
deep-equal((1, 2, 3), (1, 2, 3)[2 or 3])
deep-equal((1, 2, 3), (1, 2, 3)[3 ge position()])
deep-equal((1, 2, 3), (1, 2, 3)[3 >= position()])
deep-equal((1, 2, 3), (1, 2, 3, current-time())[3 ge position()])
deep-equal((1, 2, 3), (1, 2, 3, current-time())[3 >= position()])
deep-equal((1, 2, 3), (1, 2, 3, current-time())[4 gt position()])
deep-equal((1, 2, 3), (1, 2, 3, current-time())[4 > position()])
deep-equal((1, 2, 3), (1, 2, 3, current-time())[position() <= 3])
deep-equal((1, 2, 3), (1, 2, 3, current-time())[position() < 4])
deep-equal((1, 2, 3), (1, 2, 3, current-time())[position() le 3])
deep-equal((1, 2, 3), (1, 2, 3, current-time())[position() lt 4])
deep-equal((1, 2, 3), (1, 2, 3)[. instance of xs:integer])
deep-equal((1, 2, 3), (1, 2, 3)[number(.)])
deep-equal((1, 2, 3), (1, 2, 3)[position() >= 1])
deep-equal((1, 2, 3), (1, 2, 3)[position() ge 1])
deep-equal((1, 2, 3), (1, 2, 3)[true()])
deep-equal((1, 2, 3), (1, 2, 3)[xs:anyURI("example.com/")])
deep-equal((1, 2, 3), (1, 2, 3)[xs:untypedAtomic("content")])
deep-equal(((1, (2, (3, 4, (5, 6)), 7), 8, (9, 10), 11)), (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))
deep-equal((1, 2, 3, 4, 5, 6), index-of((4, 4, 4, 4, 4, 4), 4))
deep-equal((1, 2, 3, 4), for $i at $p in -10 to -7 return $p)
deep-equal((1, 2, 3, 4), for $i at $p in 1 to 4 return $p)
deep-equal((1, 2, 3, 4), for $i at $p in insert-before((1, current-time()), 13, (current-date(), 3)) return $p)
deep-equal((1, 2, 3, 4), for $i at $p in insert-before((1, current-time()), 1, (current-date(), 3)) return $p)
deep-equal((1, 2, 3, 4), for $i at $p in insert-before((1, current-time()), 2, (current-date(), 3)) return $p)
deep-equal((-1, -2, -3, -4), reverse(-4 to -1))
deep-equal((1, 2, 3)[count((last(), last())) eq 2], (1, 2, 3))
deep-equal((1, 2, 3), for $i at $p in (1, 2, 3) return $p)
deep-equal((1, 2, 3), for $i at $p in remove((1, 2, 3, current-time()), 1) return $p)
deep-equal((1, 2, 3), for $i at $p in remove((1, 2, 3, current-time()), 2) return $p)
deep-equal((1, 2, 3), for $i at $p in remove((1, 2, 3, current-time()), 3) return $p)
deep-equal((1, 2, 3), for $i at $p in remove((1, 2, 3, current-time()), 4) return $p)
deep-equal((1, 2, 3), for $i at $p in remove((1, 2, current-time()), 0) return $p)
deep-equal((1, 2, 3), for $i at $p in remove((1, 2, current-time()), 10) return $p)
deep-equal((1, 2, 3), for $i at $p in string-to-codepoints("abc") return $p)
deep-equal((1, 2, 3)[last() eq last()], (1, 2, 3))
deep-equal((1, 2, 3)[number()], (1, 2, 3))
deep-equal( (1, 2, 3, remove((current-time(), 4), 1)) [0 != last()], (1, 2, 3, 4))
deep-equal( (1, 2, 3, remove((current-time(), 4), 1)) [0 ne last()], (1, 2, 3, 4))
deep-equal( (1, 2, 3, remove((current-time(), 4), 1)) [0 ne position()], (1, 2, 3, 4))
deep-equal( (1, 2, 3, remove((current-time(), 4), 1)) [0 != position()], (1, 2, 3, 4))
deep-equal( (1, 2, 3, remove((current-time(), 4), 1)) [last() != 0], (1, 2, 3, 4))
deep-equal( (1, 2, 3, remove((current-time(), 4), 1)) [last() > 0], (1, 2, 3, 4))
deep-equal( (1, 2, 3, remove((current-time(), 4), 1)) [last() >= 1], (1, 2, 3, 4))
deep-equal( (1, 2, 3, remove((current-time(), 4), 1)) [last() ge 1], (1, 2, 3, 4))
deep-equal( (1, 2, 3, remove((current-time(), 4), 1)) [last() gt 0], (1, 2, 3, 4))
deep-equal( (1, 2, 3, remove((current-time(), 4), 1)) [last() ne 0], (1, 2, 3, 4))
deep-equal( (1, 2, 3, remove((current-time(), 4), 1)) [position() != 0], (1, 2, 3, 4))
deep-equal( (1, 2, 3, remove((current-time(), 4), 1)) [position() > 0], (1, 2, 3, 4))
deep-equal( (1, 2, 3, remove((current-time(), 4), 1)) [position() >= 1], (1, 2, 3, 4))
deep-equal( (1, 2, 3, remove((current-time(), 4), 1)) [position() ge 1], (1, 2, 3, 4))
deep-equal( (1, 2, 3, remove((current-time(), 4), 1)) [position() gt 0], (1, 2, 3, 4))
deep-equal( (1, 2, 3, remove((current-time(), 4), 1)) [position() ne 0], (1, 2, 3, 4))
deep-equal((1, 2, 3), unordered((1, 2, 3)))
deep-equal((1, 2, 4), (1, 2, current-time(), 4)[3 ne position()])
deep-equal((1, 2, 4), (1, 2, current-time(), 4)[3 != position()])
deep-equal((1, 2, 4), (1, 2, current-time(), 4)[position() != 3])
deep-equal((1, 2, 4), (1, 2, current-time(), 4)[position() ne 3])
deep-equal((1, 2), for $i at $p in subsequence((1, 2, 3, current-time()), 1, 2) return $p)
deep-equal((1, 2), for $i at $p in subsequence((1, 2, 3, current-time()), 2, 2) return $p)
deep-equal((1, 2), for $i at $p in subsequence((1, 2, 3, current-time()), 3, 2) return $p)
deep-equal((1, 2, xs:base64Binary("FFFF")), (1, 2, xs:base64Binary("FFFF")))
deep-equal((1, <a/>, 2), (1, <b/>, 2))
deep-equal(1, <e>1</e>)
deep-equal((1, <e/>, 2), (1, <e/>, 2))
deep-equal((1, "str", 1), (1, "str", 1))
deep-equal(1, subsequence((1, 2, current-time()), 1, 1))
deep-equal(1 to 5, (for $i in (1,2,3,4,5) return $i))
deep-equal((2, 2), (for $foo in (1, 1) return 1 + $foo))
deep-equal((2, 3, 4, 5, 7, 8, 9), (0, 2, 3, 4, 5, 5, 7, 8, 10 - 1)[.])
deep-equal((3, 2, 1), reverse((1, 2, 3)))
deep-equal((3, 2, 1), reverse((1, 2, 3))[true()])
deep-equal((3, 2, 1), reverse(1 to 3))
deep-equal((4, 5), (1, 2, current-time(), 4, 5)[3 lt position()])
deep-equal((4, 5), (1, 2, current-time(), 4, 5)[3 < position()])
deep-equal((4, 5), (1, 2, current-time(), 4, 5)[4 le position()])
deep-equal((4, 5), (1, 2, current-time(), 4, 5)[4 <= position()])
deep-equal((4, 5), (1, 2, current-time(), 4, 5)[position() > 3])
deep-equal((4, 5), (1, 2, current-time(), 4, 5)[position() >= 4])
deep-equal((4, 5), (1, 2, current-time(), 4, 5)[position() ge 4])
deep-equal((4, 5), (1, 2, current-time(), 4, 5)[position() gt 3])
deep-equal((<a/>, <b/>, 4), (<a/>, <b/>, 2))
deep-equal((<a/>, <b/>), (<a/>, <b/>, <c/>))
deep-equal(("a", "b", "c"), (0, 1, 2, "a", "b", "c")[. instance of xs:string])
deep-equal((<a/>, <b/>, <c/>), (<a/>, <b/>))
deep-equal((<a/>, <b/>, <c/>), (<a/>, <b/>, <a/>))
deep-equal((<a/>, <b/>, <c/>), (<a/>, <b/>, <c/>))
deep-equal('a', 'b', 'http://www.cbcl.co.u,/collation')
deep-equal("a string")
deep-equal("a string", "a string", ())
deep-equal("a string", "a string", "http://www.example.com/COLLATION/NOT/SUPPORTED")
deep-equal("a string", "a string", "http://www.w3.org/2005/xpath-functions/collation/codepoint", "wrong param")
deep-equal((attribute name2 {"content"}, attribute name {"content"}), (attribute name {"content"}, attribute name2 {"content"}))
deep-equal(attribute name {}, attribute name {})
deep-equal(attribute name {}, attribute name2 {})
deep-equal(attribute name {"content"}, attribute name {})
deep-equal(attribute name {"content "}, attribute name2 {"content "})
deep-equal(attribute name {"content"}, attribute name {"content"})
deep-equal((attribute name {"content"}, attribute name {"content"}), (attribute name {"content"}))
deep-equal((attribute name {"content"}, attribute name {"content"}), attribute name {"content"})
deep-equal("a", xs:NCName("a"))
deep-equal((<a />, xs:untypedAtomic("a"), xs:untypedAtomic("P1Y"), 2.0), (<a />, xs:untypedAtomic("a"), xs:yearMonthDuration("P12M"), xs:untypedAtomic(" 2")))
deep-equal((<b/>, <b/>, <b/>, <b/>), (for $v1 in (1, 2, 3, 4) let $v2 := <b/> return ($v2)))
deep-equal((<b/>, <b/>, <b/>, <b/>), (for $v1 in (1, 2, 3, 4) let $v2 := <b/> return ($v2))/.)
deep-equal((current-time(), current-time(), current-time()), (current-time(), current-time()))
deep-equal(current-time(), <e/>)
deep-equal(<e>1</e>, 1)
deep-equal(<e><a>12</a></e>/*, <f><a>12</a></f>/*)
deep-equal(<e/>, current-time())
deep-equal((), ()) eq true()
deep-equal(<e xmlns="http://www.example.com/ns"/>, <p:e xmlns:p="http://www.example.com/ns"/>)
deep-equal(fn:innermost( //*/@* ), //*/@*)
deep-equal(fn:outermost( //*/@* ), //*/@*)
deep-equal((for $a in 1, $b in $a, $c in $a, $d in $c return ($a, $b, $c, $d)), (1, 1, 1, 1))
deep-equal((for $fo in trace((1, 2, 3), "msg") return $fo), (1, 2, 3))
deep-equal(for $i at $p in (1, 2, 3, 4) return ($i, $p), (1, 1, 2, 2, 3, 3, 4, 4))
deep-equal((for $var in (1, 2, 3) return $var), (1, 2, 3))
deep-equal(index-of((10, 20, 30, 30, 20, 10), 20), (2, 5))
deep-equal(index-of(20, 20), (1))
deep-equal(index-of((20, 20), 20), (1, 2))
deep-equal(index-of((20, 40), 20), (1))
deep-equal(index-of((20, 40, 20), 20), (1, 3))
deep-equal(index-of(("a", "sport", "and", "a", "pastime"), "a"), (1, 4))
deep-equal(map{"a":1,"b":2,"c":(3,4,5)}, map{"c":(3,4,5),"a":1,"b":2})
deep-equal(map{"a":1}, map:entry("a", 1))
deep-equal(map{"a":1}, map:merge(()))
deep-equal(map{"a":1}, map:put(map{}, 'a', 1))
deep-equal(map {   "ACC" : "Accessories",   "WMN" : "Women's",   "MEN" : "Men's" },map {   "ACC" : "Accessories",   "WMN" : "Women's",   "MEN" : "Men's" })
deep-equal( map {     "ACC": map {               "name": "Accessories",               "code": 300 } ,     "WMN": map {               "name": "Women's",               "code": 310 } ,     "MEN": map {               "name": "Men's",               "code": 320 }      },map {     "ACC": map {               "name": "Accessories",               "code": 300 } ,     "WMN": map {               "name": "Women's",               "code": 310 } ,     "MEN": map {               "name": "Men's",               "code": 320 }      })
deep-equal(map{}, map:merge(()))
deep-equal(map{}, map:remove(map:put(map:merge(()), 1, 2), 1))
deep-equal(map:merge(for $i in 1 to 1000 return map:entry($i, $i+1)),                          map:merge(for $i in 0 to 1000 return map:entry($i, $i+1)))
deep-equal(map:merge(for $i in 1 to 1000 return map:entry($i, $i+1)),                          map:merge(((for $i in 1 to 1000 return map:entry($i, $i+1)), map:entry(400, 402)),                          map{"duplicates":"use-last"}))
deep-equal(map:merge(for $i in 1 to 1000 return map:entry($i, $i+1)),                          map:merge(for $i in 2 to 1000 return map:entry($i, $i+1)))
deep-equal(map:merge(for $i in 1 to 1000 return map:entry($i, $i+1)),                          map:merge(for $i in 2 to 1001 return map:entry($i, $i+1)))
deep-equal(map:put(map{"a":1,"b":2,"c":(3,4,5)}, "d", 6), map:put(map{"d":6,"c":(3,4,5),"a":1}, "b", 2))
deep-equal(map:put(map:merge(for $i in 1 to 1000 return map:entry($i, $i+1)), 1001, 1002),                          map:merge(for $i in 1 to 1001 return map:entry($i, $i+1)))
deep-equal(map:remove(map{"a":1,"b":(2,3)}, "a"), map:entry("b", (2,3)))
deep-equal(map:remove(map{"a":1,"b":(2,3), "c":1 to 5}, ("a", "c", "d")), map:entry("b", (2,3)))
deep-equal(map:remove(map{"a":1,"b":(2,3), "c":1 to 5}, ("a", "c")), map:entry("b", (2,3)))
deep-equal(map{xs:double('NaN'): 10}, map{xs:float('NaN'):10e0})
deep-equal (  parse-json('{    "number": 557,    "name": "Fleece Pullover",    "colorChoices": ["navy","black"],    "is-current": true,    "other": null  }'), map {    "number": xs:double(557),    "name": "Fleece Pullover",    "colorChoices": ["navy", "black"],    "is-current": true(),    "other": ()  })
deep-equal (  parse-json('{    "number": 557,    "name": "Fleece Pullover",    "colorChoices": ["navy","black"] }'), map {    "number": xs:double(557),    "name": "Fleece Pullover",    "colorChoices": ["navy", "black"] })
deep-equal(remove((1, 2, 3, current-time()), 4)[true()], (1, 2, 3))
deep-equal(remove(for $var in (current-time(), 2, 3, 4) return $var, 1), (2, 3, 4))
deep-equal((), reverse(0 to -5))
deep-equal(reverse(0 to -5), ())
deep-equal(("str", 1, 1), ("str", 1, 1))
deep-equal(string-to-codepoints(' '), (10))
deep-equal(string-to-codepoints(' '), (10, 133))
deep-equal(string-to-codepoints('     '), (10, 32, 10, 32, 10, 10))
deep-equal(string-to-codepoints('  '), (32, 133, 32))
deep-equal(string-to-codepoints('  '), (32, 8232, 32))
deep-equal(string-to-codepoints("ee"), (101, 101))
deep-equal(string-to-codepoints("eee"), (101, 101, 101))
deep-equal(string-to-codepoints("Thrse"), (84, 104, 233, 114, 232, 115, 101))
deep-equal((true(), true()), for $i at $p in (1, 2) return boolean($p))
deep-equal((true(), true(), true()), (false(), true(), true(), false(), true(), false())[.])
deep-equal(xs:double("NaN"), xs:double("NaN"))
deep-equal(xs:double("NaN"), xs:float("NaN"))
deep-equal(xs:float("NaN"), xs:double("NaN"))
deep-equal(xs:float("NaN"), xs:float("NaN"))
deep-equal(xs:gMonth("--12+03:00"), xs:gMonth("--12")) eq (implicit-timezone() eq xs:dayTimeDuration("PT3H"))
deep-equal((xs:untypedAtomic("a"), xs:untypedAtomic("P1Y"), 2.0), (xs:untypedAtomic("a"), xs:yearMonthDuration("P12M"), xs:untypedAtomic(" 2")))
() div 1
//doc/normalize-space(zero-or-one(a[normalize-space() = 'Hello, How are you?']))
document()
document(*)
document{"content"};
document("example.com/file.ext")
document-node(*)
document-node(1)
document-node{"content"}
document-node(local:name)
document-node(name)
document-node(processing-instruction())
document-node(schema-attribute(ncname))
document-node(unknown())
(<e/>, 1)[..]
<e>{1}{1}{1}<e/></e>
<e>1.1</e> < 3
<e>1.1</e> < 3.
<e>1.1</e> < 3e3
<e>1.1</e> < xs:float(3e3)
<e>{[1, 2, 3]}</e>
<e>{1}A{1}</e>
<e>{1}{text{""}}{2}</e>
<e>{1}{text{()}}{2}</e>
<e/>[1]/text{string-join(., " ")}, 1
<e a=""/>/@a instance of attribute(a)
<e a=""/>/attribute::a instance of attribute(a)
<e> <a/> <b/> </e>/((b, a)/., (.), (*, *))
<e> <a/> <b/> </e>/(if(position() = 10) then (<e/>, .) else 4)
<e>a<!--data tar-->b</e>
<e> <a/> </e>/(., .)/.
<e> <a/> </e>/*/(., .)/.
<e a="{<e><b>data</b></e>/b}" xmlns="http://www.example.com/"/>
<e a="{<e b="data"/>/@b}" xmlns="http://www.example.com/"/>
<e>a</e>, <e>b</e>, <e>c</e>
<e a="{p:count(())}" xmlns:p="http://www.w3.org/2005/xpath-functions"/>
<e attr="    "/>
<e attr="<"/>
<e attr="]]>"/>
<e attr="{1}&#86;{1}&#86;"/>
<e attr="   a"/>
<e attr="abc{ 23 (:":) }xyz"/>
<e attr="abc{ 23 (:{:) }xyz"/>
<e attr="abc{ 23 (:}:) }xyz"/>
<e attr="abc{ (# }xyz"/>
<e attr=""/>/(@attr instance of attribute(), @* instance of attribute())
<e attr="c"/>/@attr/..
<e attr="content'/>
<e attr="content}"/>
<e attr='content"/>
<e/>/attribute("any"))
<e> { attribute name {<anElement/>}, attribute name2 {"content"} } </e>
<e> { attribute name {"content"}, attribute name2 {"content"} } </e>
<e> { attribute {QName("http://example.com/", "attr")} {()}, attribute {QName("http://example.com/", "attr")} {()} } </e>
<e> { attribute {QName("http://example.com/", "attr")} {()} } </e>
<e> { attribute {QName("http://www.w3.org/2000/xmlns/", "space")} {"default"} } </e>
<e> { attribute {QName("http://www.w3.org/XML/1998/namespace", "space")} {"default"} } </e>
<e/>/attribute::schema-attribute()
<e attr="x{<e>a</e>, <e>b</e>, <e>c</e>, 1, 2, 3}y"/>
<e> <b a=""/> <b/> </e>/b
<e> { <b attr="fo" a="bo"/>/@* } </e>
<e> <b attr="fo"/> <b/> </e>/descendant-or-self::node()
<e> <b/> <b a=""/> </e>/b
<e><b/></e>/b/..
<e><b/></e>/element(b, xs:anyType)
<e>{<b foo="1"/>/attribute(foo, xs:anyType)}</e>
<e><![CDATA]
<e><![CDATA]]
<e><![CDATA]]>
<e><![CDATA[content]]]></e>
<e><![CDATA[content]]]]]]></e>
<e><![CDATA[]]]></e>
<e><![CDATA[]]]]]]></e>
eclare function
<e> <!-- comment --> <?PA ?>text<b/> <?PB ?> <b/> <?PC ?> </e>/child::node()
<e> content}</e>
<e><!--data --></e>/comment()/..
<e>]]></e>
<e><e/>{1}{1}{1}</e>
<e/>/<e a="{p:asd}" xmlns:p="http://example.com/asd"/>
<e>{<e><b/></e>/element(p:foo)}</e>
<e>{<e foo="asd"/>/attribute(foo, xs:untypedAtomic)}</e>
<e>{<e foo="asd"/>/attribute(notBound:foo, xs:untypedAtomic)}</e>
<e>{<e foo="asd"/>/attribute(*, xs:untypedAtomic)}</e>
<e/>/element("any"))
<e/>/(every $b in 1, $v in self::node() satisfies $v)
<e/>/(every $v in self::node() satisfies $v)
<e/>/(/)//f
<e>{[<f>{[1,<x/>,3]}</f>, <g>{[4, <x/>, 5]}</g>]}</e>
<e><f>foo</f></e> ! map{*:*}         =>         deep-equal(map{"foo":<f>foo</f>})
<e><f>foo</f></e> ! map{*:f:*:f}         =>         deep-equal(map{"foo":<f>foo</f>})
<e>{fn:root(attribute name {"value"})}</e>
<e/>/(for $b in 1, $i in self::node() return $i)
<e/>/(for $i in 1, $b in self::node() return $b)
<e/>/(for $i in self::node() return $i)
<e>{for $PI in <e/>/processing-instruction() return ()}</e>
<e>{for $PI in ()/processing-instruction() return ()}</e>
<e> { for $x in 1 to 10 return <a>{for $y in 1 to 10 where $x > 7 and $y = $x return $y}</a> } </e>
<e> { for $x in 1 to 10 where $x > 7 return <a>{for $y in 1 to 10 where $y = $x return $y}</a> } </e>
<e/>/if(true()) then 1 else 3
<e/> instance of attribute()
<e/> instance of attribute(*)
<e/> instance of attribute(e)
<e/> instance of element()
<e/> instance of element(*)
<e/> instance of element(a, xs:anyType)
<e/> instance of element(e)
<e/> instance of element(name)
<e/> instance of element(*, xs:anyType)
<e/> instance of element(*, xs:untyped)
(<elem/>)
<elem />
<elem/>
<elem>
<elem><
<elem><!-
<elem><![
<elem><[
<elem>{1}{2}{3}{4}{5}</elem>
<elem>{1}{2}{3}{4}</elem>
<elem>{1}{2}{3}</elem>
<elem>{1, '', 2}</elem>
<elem>{1}{2}</elem>
<elem>{1,//a,2,3,//comment(),4,5,//processing-instruction(),6,7,//text(),8}</elem>
<elem>{1,'a',3.5,4e2}</elem>
<elem>{1}{text{""}}{2}</elem>
<elem>{1, //west/@mark}</elem>
<elem>A<a>B<?pi?>C<b/>D<!---->E</a>F<!--content-->G<a/>H<?pi content?>I<c/>J</elem>
<elem><a><b/></a><a/><c/></elem>
<elem> {"a string", attribute name {"content"}} </elem>
<elem att="{<e2 a2="{<e3 a3="{<p:e/>/namespace-uri()}"></e3>/@a3}"></e2>/@a2}"                                       xmlns:p="http://ns.example.com/uri"/>
<elem att="{<p:e/>/namespace-uri()}" xmlns:p="http://ns.example.com/uri"/>
<elem attr=" "/>
<elem attr=""""/>
<elem attr="&"/>
<elem attr="<"/>
<elem attr="{"/>
<elem attr="}"/>
<elem attr='                                                                                                              '/>
<elem attr=''''/>
<elem attr="{1,'',2}"/>
<elem attr="{(1,2)}{3}"/>
<elem attr="{123}456"/>
<elem attr="123{456}"/>
<elem attr="1{2,3}{4,5}6{<a>7</a>}{<a>8</a>}9"/>
<elem attr="{1,<a/>,2}"/>
<elem attr1="""" attr2='''' attr3="''" attr4='""' attr5="'" attr6='"'/>
<elem attr="{(1)}">{(<child/>),(<child/>)}</elem>
<elem attr="{1,'string',3.14,xs:float('1.2345e-2'),xs:dateTime('2002-04-02T12:00:00-01:00')}"/>
<elem attr1="val1" attr2="val2"/>
<elem attr1="val1" attr2="val2" attr3="val3"/>
<elem attr1="val1" attr="val2" attr2="val3" attr="val4" attr3="val5"/>
<elem attr="abxxyz123890!@#$%^*()[]\|?/>:;"/>
<elem attr="&amp;&lt;&gt;"/>
<elem attr="content'/>
<elem attr='content"/>
<elem attr="{<elem>123</elem>, (<elem attr='456'/>)/@attr, (<elem>789</elem>)/text()}"/>
<elem {"attribute-name"} = "attribute value"/>
<elem attributename = {"attribute value"} />
<elem attributename = {"attribute value"}></elem>
<elem attr="val1" attr2="val2" attr="val3"/>
<elem attr="val1" attr="val2" attr2="val3"/>
<elem attr = "value"/>
<elem attr="value" />
<elem attr="value"/>
<elem attr="value'/>
<elem attr='value"/>
<elem attr='value'/>
<elem attr="&#x30;&#x31;&#x32;"/>
<elem attr="&#x9;"/>
<elem attr="&#xa;"/>
<elem attr="&#xd;"/>
<elem attr="z{ (:comment:) }z"/>
<elem attr="z{ }z"/>
<elem attr="z{}z"/>
<elem><a/>{//west/@mark}</elem>
<elem><![CDA
<elem><![CDATA[]]>{attribute name {"content"}}<alem/> </elem>
<elem> <![CDATA[]]> {attribute name {"content"}} </elem>
<elem><![CDATA[cdata&<>'"&lt;&#x20;]]></elem>
<elem><![CDATA[CONTENT]
<elem><![CDATA[CONTENT]]
<elem><![CDATA[CONTENT]]>
<elem> <![CDATA[content]]> {attribute name {"content"}} </elem>
<elem><![cdata[CONTENT]]></elem>
<elem> <!-- comment --> { "a string", 999, ("another string", attribute name {"content"}, 383), xs:hexBinary("FF") } </elem>
<elem> <!-- comment --> { "a string", 999, attribute name {"content"}, xs:hexBinary("FF") } </elem>
<elem>{comment {'one'}}<a>{comment {'two'}}</a>{comment {'three'}}</elem>
<elem> <!-- content --> {attribute name {"content"}} </elem>
<elem>content{(:comment:)}content</elem>
<elem>content{}content</elem>
<elem><!----><!--content--></elem>
<elem>{"", "", <e/>, <b></b>}</elem>
<elem>{<e/>, <b></b>, "", ""}</elem>
<elem>&</elem>
<elem></elem>
<elem><</elem>
<elem>{""}</elem>
<elem>{(/), (/)}</elem>
<elem>{</elem>
<elem>{{</elem>
<elem>}</elem>
<elem>}}</elem>
<elem></elemother>
element()
element { 1 } { }
element(1)
element {123} {'text'}
element {1,2} {'text'}
element {"aPrefix:localName"} {"content"}
element {//a} {'text'}
<element attributeName="}"/>
<element attributeName='}'/>
element e {"content"} instance of element(a, xs:anyType)
element e {"content"} instance of element(*, xs:anyType)
element e {"content"} instance of element(*, xs:untyped)
element e {element b{()}}
element elem {., .}
element elem {}
element elem {1, '', 2}
element elem {1,//a,2,3,//comment(),4,5,//processing-instruction(),6,7,//text(),8}
element elem {1,'a',3.5,4e2}
element elem {1, element a {2, element b {element c {}, element d {3}}, 4}}
element elem {1, //west/@mark}
element elem {attribute {123} {'text'}}
element elem {attribute {1,2} {'text'}}
element elem {attribute {//a} {'text'}}
element elem {attribute attr {., .}}
element elem {attribute attr {1,'',2}}
element elem {attribute attr {1,<a/>,2}}
element elem {attribute attr {1,'string',3.14,xs:float('1.2345e-2'),xs:dateTime('2002-04-02T12:00:00-01:00')}}
element elem {attribute attr {<elem>123</elem>, (<elem attr='456'/>)/@attr, (<elem>789</elem>)/text()}}
element elem {attribute {'attr', ()} {'text'}}
element elem {attribute {'attr'} {'text'}}
element elem {attribute {(), 'attr'} {'text'}}
element elem {attribute attr {'text'}}
element elem {attribute {'el em'} {'text'}}
element elem {attribute {'foo:attr'} {}}
element elem {attribute foo:attr {'text'}}
element elem {attribute {//*:NCName[1]} {'text'}}
element elem {attribute {'one', 'two'} {'text'}}
element elem {attribute {()} {'text'}}
element elem {attribute xml:id {"ncname"}}
element elem {attribute {xs:dateTime("1999-05-31T13:20:00")} {'text'}}
element elem {attribute {xs:QName('aQname')} {'text'}}
element elem {attribute {xs:untypedAtomic('attr')} {'text'}}
element elem {attribute {xs:untypedAtomic('el em')} {'text'}}
element elem {attribute {xs:untypedAtomic('foo:elem')} {'text'}}
element elem {attribute {xs:untypedAtomic('one'), xs:untypedAtomic('two')} {'text'}}
element elem {element a {}, //west/@mark}
element {'el em'} {'text'}
element {'elem', ()} {'text'}
element {'elem'} {'text'}
element {(), 'elem'} {'text'}
element elem {'text'}
element elem {//west/@mark, //center/@mark}
element elem {//west/@mark, //west/@west-attr-1}
element {fn:QName( concat('http://www.example.com/', string((//FolderName)[2])), "people" )}{ "test" }
element {fn:QName("http://www.example.com/example", "ht:person")}{ "test" }
element {fn:QName("http://www.example.com/example", "person")}{ "test" }
element {fn:QName( "http://www.example.com/example", string((//FolderName)[2]) )}{ "test" }
element {fn:QName( "http://www.example.com/example", "" )}{ "test" }
element {fn:QName("", "person")}{ "test" }
element {fn:QName((), "person")}{ "test" }
element foo:anElement {"Element content"}
element {'foo:elem'} {}
element foo:elem {'text'}
element "name" {"content"}
element {//*:NCName[1]} {'text'}
element(notBound:ncname)
element {'one', 'two'} {'text'}
<element> { processing-instruction { 'pi' } { <element>?&gt;</element> } } </element>
element {()} {'text'}
element x { attribute Q{http://example.com/x}y { } }
element {"xmlns:error"} {}
<element xmlns:sgml="http://www.example.com/other"> {         for $a in attribute { fn:QName("http://www.example.com/", "sgml:foo") } { }         return concat(name($a), "=", namespace-uri($a)) }         </element>
element {xs:dateTime("1999-05-31T13:20:00")} {'text'}
element {xs:QName('aQname')} {'text'}
element {xs:untypedAtomic("aPrefix::localName")} {"content"}
element {xs:untypedAtomic('el em')} {'text'}
element {xs:untypedAtomic('elem')} {'text'}
element {xs:untypedAtomic('foo:elem')} {'text'}
element {xs:untypedAtomic('one'), xs:untypedAtomic('two')} {'text'}
<elem foo:attr="value" xmlns:foo="http://www.w3.org/XQueryTest/Construct"/>
<elem mark="w0">{//west/@west-attr-1, //west/@mark}</elem>
<elem mark="w0">{//west/@west-attr-1, //west/@west-attr-2}</elem>
<elem>{(//node() | //node()) except //comment()}</elem>
<elem>{//node() | (//node() except //comment())}</elem>
<elem>{(//(north)/(/)//(@mark)[(1)]/(.)/(..))}</elem>
<elem><?pi?><?pi content?></elem>
<elem>{/root}</elem>
<elem>some text<node/>some text</elem>
<elem> <?target content ?> {attribute name {"content"}} </elem>
<elem>{text {'one'}}<a>{text {'two'}}</a>{text {'three'}}</elem>
<elem><![THISISWRONG[content]]></elem>
<elem>{//west/@mark, //center/@mark}</elem>
<elem>{()}{//west/@mark}</elem>
<elem>{//west/@mark, //west/@west-attr-1}</elem>
<elem>{//west/@mark}x{//west/@west-attr-1}</elem>
<elem>{//west/@west-attr-1}{//west/@west-attr-2}</elem>
<elem>&#x0;</elem>
<elem>&#x30;</elem>
<elem>&#x7b;</elem>
<elem>&#x7d;</elem>
<elem xml:id="ncname"/>
<elem xmlns:cm="http://www.example.com" attr="{count(//cm:b)}"/>
<elem xmlns:cm="http://www.example.com">{count(//cm:b)}</elem>
<elem xmlns:foo="http://www.example.com"/>
<elem xmlns:foo="http://www.example.com/foo">{attribute {xs:untypedAtomic('foo:attr')} {'text'}}</elem>
(<elem xmlns:foo="http://www.example.com"><foo:child/></elem>)/*:child
<elem xmlns:foo="http://www.example.com/foo">{element elem {attribute {'foo:attr'} {}}}</elem>
<elem xmlns:foo="http://www.example.com/foo">{element {'foo:elem'} {'text'}}</elem>
<elem xmlns:foo="http://www.example.com/foo">{element {xs:untypedAtomic('foo:elem')} {'text'}}</elem>
<elem xmlns:foo="http://www.example.com/foo">{processing-instruction {'foo:attr'} {}}</elem>
<elem xmlns:foo="http://www.example.com/foo">{processing-instruction {xs:untypedAtomic('foo:pi')} {'text'}}</elem>
<elem xmlns:foo="http://www.example.com/parent"><foo:child xmlns:foo="http://www.example.com/child"/></elem>
(<elem xmlns:foo="http://www.example.com/parent"><foo:child xmlns:foo="http://www.example.com/child"><foo:grand-child/></foo:child></elem>)//*:grand-child
<elem xmlns:foo="http://www.example.com">{processing-instruction foo:pi {'text'}}</elem>
<elem xmlns:foo="http://www.example.com" xmlns:foo="http://www.example.com"/>
<elem xmlns:foo="http://www.w3.org/XQueryTest/Construct"><child foo:attr="value"/></elem>
<elem xmlns:foo="http://www.w3.org/XQueryTest/Construct" foo:attr="value"/>
<elem xmlns:foo="http://www.w3.org/XQueryTest/Construct" xmlns:bar="http://www.w3.org/XQueryTest/Construct" foo:attr="val1" bar:attr="val2"/>
<elem xmlns="{'http://www.example.com'}"/>
<elem xmlns="http://www.example.com"/>
(<elem xmlns="http://www.example.com"><child/></elem>)/*:child
<elem xmlns="http://www.example.com{'/namespace'}"/>
<elem xmlns="http://www.example.com/parent"><child xmlns=""/></elem>
(<elem xmlns="http://www.example.com/parent"><child xmlns=""><grand-child/></child></elem>)//*:grand-child
<elem xmlns="http://www.example.com/parent"><child xmlns="http://www.example.com/child"/></elem>
(<elem xmlns="http://www.example.com/parent"><child xmlns="http://www.example.com/child"><grand-child/></child></elem>)//*:grand-child
<elem xmlns="http://www.example.com" xmlns="http://www.example.com"/>
<e>{map:for-each(map{"a":1, "b":2}, function($k,$v){attribute{$k}{$v}})}</e>
(//employee[fn:last()])
//(employee[location = "Denver"] intersect //employee[last()])/./location
//empnum
(//empnum | (/))//employee[xs:integer(hours[1]) gt 20]
empty( ((), (), ()) )
empty(((), (), ((), (), ((), (), (())), ()), (), (())))
empty(() * ())
empty(() + ())
empty(() - ())
empty(() << ())
empty(() >> ())
empty(())
empty(()[()])
empty()
empty(+())
empty(-())
empty((0, 1, 2)[false()][1])
empty(0 to -3)
empty(0 to -5)
empty(() * 1)
empty(() << 1)
empty(() >> 1)
empty(()[1])
empty(1 << ())
empty(1 >> ())
empty(() + (1, 2))
empty((1, 2) + ())
empty(1, 2)
empty((1, 2, 3)[()])
empty((1, 2, 3)[0])
empty((1, 2, 3)[0.1])
empty((1, 2, 3)[1.01])
empty((1, 2, 3)[1.1])
empty((1, 2, 3)[3][0])
empty((1, 2, 3)[3][2])
empty((1, 2, 3)[3e8])
empty((1, 2, 3)[4])
empty((1, 2, 3)[4.01])
empty((1, 2, 3)[4.1])
empty((1,2,3,4,5)[3.4])
empty((1, 2, 3, current-time())[0])
empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [0 eq last()])
empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [0 eq position()])
empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [0 = last()])
empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [0 = position()])
empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [last() <= 0])
empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [last() = 0])
empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [last() < 1])
empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [last() eq 0])
empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [last() le 0])
empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [last() lt 1])
empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [position() <= 0])
empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [position() = 0])
empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [position() < 1])
empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [position() eq 0])
empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [position() le 0])
empty((1, 2, 3, current-time(), current-date(), 6, 7, 8) [position() lt 1])
empty((1, 2, 3, current-time())[last() + 1])
empty((1, 2, 3)[false()])
empty((1, 2, 3)[position() eq 2 or position() eq 3][3])
empty((1, 2, 3)[remove((false(), "a string"), 2)])
empty(1 div ())
empty(1 eq ())
empty(1 is ())
empty(1 to ())
empty(1 to 0)
empty(-1 to -3)
empty(30 to 3)
empty(-4 to -5)
empty(<a/>/a)
empty(<a> <b/> <c/> </a>[self::b][last()])
empty(abs(()))
empty(<anElement/>/ancestor::node())
empty(()/@attr)
empty(attribute name {"content"}/ancestor::node())
empty(attribute theName {"some text"}/..)
empty(avg( () ))
empty(avg(((), ())))
empty(avg(()))
empty(() cast as xs:QName?)
empty(ceiling(()))
empty(comment {"some text"}/..)
empty(<!-- content -->/ancestor::node())
empty(()[count(remove((current-time(), 1), 1)) eq 1])
empty(current-time()[2])
empty(data( () ))
empty(dateTime((), ()))
empty(dateTime(xs:date("2004-03-04"), ()))
empty(dateTime((), xs:time("08:05:23")))
empty(day-from-date(()))
empty(day-from-dateTime(()))
empty(days-from-duration(()))
empty(() div ())
empty(() div 1)
empty(() div xs:decimal(1))
empty(<e/>/..)
empty(<e><a/></e>//a[3.4])
empty(<e/>/(a except ancestor))
empty(<e/>/(a except ancestor-or-self))
empty(<e/>/(a except attribute))
empty(<e/>/(a except declare))
empty(<e/>/(a except descendant))
empty(<e/>/(a except descendant-or-self))
empty(<e/>/(a except following))
empty(<e/>/(a except following-sibling))
empty(<e/>/(a except parent))
empty(<e/>/(a except preceding))
empty(<e/>/(a except preceding-sibling))
empty(<e/>/(a except self))
empty(<e/>/(a intersect ancestor))
empty(<e/>/(a intersect ancestor-or-self))
empty(<e/>/(a intersect attribute))
empty(<e/>/(a intersect attribute {"name"} {()}))
empty(<e/>/(a intersect attribute name {()}))
empty(<e/>/(a intersect comment {()}))
empty(<e/>/(a intersect declare))
empty(<e/>/(a intersect descendant))
empty(<e/>/(a intersect descendant-or-self))
empty(<e/>/(a intersect element {"name"} {()}))
empty(<e/>/(a intersect element name {()}))
empty(<e/>/(a intersect following))
empty(<e/>/(a intersect following-sibling))
empty(<e/>/(a intersect parent))
empty(<e/>/(a intersect preceding))
empty(<e/>/(a intersect preceding-sibling))
empty(<e/>/(a intersect processing-instruction {"name"} {()}))
empty(<e/>/(a intersect processing-instruction name {}))
empty(<e/>/(a intersect self))
empty(<e/>/(a intersect text {()}))
empty(<e attr=""/>/descendant::node())
empty(<e attr=""/>/descendant-or-self::node())
empty(<e/>/attribute::attribute())
empty(<e/>/(a union ancestor))
empty(<e/>/(a union ancestor-or-self))
empty(<e/>/(a union attribute))
empty(<e/>/(a union attribute {"name"} {()}))
empty(<e/>/(a union attribute name {()}))
empty(<e/>/(a union comment {()}))
empty(<e/>/(a union declare))
empty(<e/>/(a union descendant))
empty(<e/>/(a union descendant-or-self))
empty(<e/>/(a union element {"name"} {()}))
empty(<e/>/(a union element name {()}))
empty(<e/>/(a union following))
empty(<e/>/(a union following-sibling))
empty(<e/>/(a union parent))
empty(<e/>/(a union preceding))
empty(<e/>/(a union preceding-sibling))
empty(<e/>/(a union processing-instruction {"name"} {()}))
empty(<e/>/(a union processing-instruction name {}))
empty(<e/>/(a union self))
empty(<e/>/(a union text {()}))
empty(<e/>/(author except attribute))
empty(<e/>/(author except comment))
empty(<e/>/(author except div))
empty(<e/>/(author except document))
empty(<e/>/(author except document-node))
empty(<e/>/(author except element))
empty(<e/>/(author except empty-sequence))
empty(<e/>/(author except if))
empty(<e/>/(author except item))
empty(<e/>/(author except mod))
empty(<e/>/(author except node))
empty(<e/>/(author except processing-instruction))
empty(<e/>/(author except schema-attribute))
empty(<e/>/(author except schema-element))
empty(<e/>/(author except text))
empty(<e/>/(author except then))
empty(<e/>/(author intersect attribute))
empty(<e/>/(author intersect comment))
empty(<e/>/(author intersect div))
empty(<e/>/(author intersect document))
empty(<e/>/(author intersect document-node))
empty(<e/>/(author intersect element))
empty(<e/>/(author intersect empty-sequence))
empty(<e/>/(author intersect if))
empty(<e/>/(author intersect item))
empty(<e/>/(author intersect mod))
empty(<e/>/(author intersect node))
empty(<e/>/(author intersect processing-instruction))
empty(<e/>/(author intersect schema-attribute))
empty(<e/>/(author intersect schema-element))
empty(<e/>/(author intersect text))
empty(<e/>/(author intersect then))
empty(<e/>/(author union attribute))
empty(<e/>/(author union comment))
empty(<e/>/(author union div))
empty(<e/>/(author union document))
empty(<e/>/(author union document-node))
empty(<e/>/(author union element))
empty(<e/>/(author union empty-sequence))
empty(<e/>/(author union if))
empty(<e/>/(author union item))
empty(<e/>/(author union mod))
empty(<e/>/(author union node))
empty(<e/>/(author union processing-instruction))
empty(<e/>/(author union schema-attribute))
empty(<e/>/(author union schema-element))
empty(<e/>/(author union text))
empty(<e/>/(author union then))
empty(<e/>/descendant::node())
empty(<e/>/descendant-or-self::node())
empty(<e/>/(div div div))
empty(<e/>/(for $i in e return $i))
empty(<e/>/(gt gt gt))
empty(<elem/>/..)
empty(<element/>/ancestor::node())
empty(<element attr="foo" attr2="foo"/>/*)
empty(element theName {"some text"}/..)
empty(<e/>/(mod mod mod))
empty(<e/>[parent::node()])
empty(() eq ())
empty(() eq 1)
empty(exactly-one(<e/>/*) is exactly-one(<e/>/*))
empty(floor(()))
empty(fn:root(<e/>)/..)
empty(fn:root(<e/>/..))
empty(for $b in <e/> where $b/@id="person0" return ())
<empty> { for $file in (//Folder)[1]/File return () } </empty>
<empty> { for $file in (//Folder)[1]/File where false() return $file/FileName } </empty>
<empty> { for $file in (//Folder)[1]/File where () return $file/FileName } </empty>
<empty> { for $folder in /MyComputer/Drive2//Folder where 1 = 2 return <Folder> { $folder/FolderName/text() } </Folder> } </empty>
empty(for $i at $p in () return $p)
empty(for $i at $p in subsequence((1, 2, 3, current-time()), 5, 8) return $p)
empty(for $i at $p in subsequence((1, 2, 3, current-time()), 5) return $p)
empty(for $i in (1, 2, current-time())[1] where xs:anyURI("") return true())
empty(for $i in 1 where false() return $i)
empty(for $var in () return 1)
empty((for $var in () return 1) eq 1)
empty((for $var in () return current-time()))
empty(for $var in () return current-time())
empty(for $var in subsequence((current-time(), 1), 4) return 1)
empty(for $x in (1 to 10)[. mod 2 = 0] return "blah")
empty(for $x in (1 to 10)[. mod 2 = 0] return floor($x))
empty(for $x in (1 to 10)[. mod 2 = 0] return true())
empty(function-lookup(fn:QName('http://www.w3.org/2005/xquery-local-functions', 'missing'), 1))
empty(hours-from-dateTime(()))
empty(hours-from-duration(()))
empty(hours-from-time(()))
empty(() idiv ())
empty(() idiv xs:decimal(1))
empty(if(<e>{current-time()}</e>) then 1 else 1)
empty(if(<e>{current-time()}</e>) then () else ())
empty(index-of((10, 20, 30, 40), 35))
empty(index-of((), 4))
empty(index-of(xs:double("NaN"), xs:double("NaN")))
empty(index-of(xs:double("NaN"), xs:float("NaN")))
empty(index-of(xs:float("NaN"), xs:double("NaN")))
empty(index-of(xs:float("NaN"), xs:float("NaN")))
empty(insert-before((1, current-time(), 3), 0, (4, 5, 6))[last() - 10])
empty(() is ())
empty(() is 1)
empty((())[last()])
empty(()[last()])
empty(local-name-from-QName( () ))
empty(max(()))
empty(min(()))
empty(minutes-from-dateTime(()))
empty(minutes-from-duration(()))
empty(minutes-from-time(()))
empty(() mod ())
empty(month-from-date(()))
empty(month-from-dateTime(()))
empty(months-from-duration(()))
empty(()/name)
empty(namespace-uri-from-QName( () ))
empty(node-name(()))
empty(node-name( comment { "comments have no name " } ) )
empty(()[position()])
empty(prefix-from-QName( () ))
empty(processing-instruction theName {"some text"}/..)
empty(remove((1, 2, 3, current-time()), 4)[false()])
empty(remove((1, 2, 3, current-time()), 9)[last() - 10])
empty(remove((), 4))
empty(remove(current-time(), 1))
empty(reverse( () ))
empty(reverse(()))
empty(reverse(0 to -5))
empty(reverse(1 to 0))
empty(reverse(4 to 1))
empty(reverse(-4 to -5))
empty(root(()))
empty(round(()))
empty(round-half-to-even(()))
empty(round-half-to-even((), 3))
empty(seconds-from-dateTime(()))
empty(seconds-from-duration(()))
empty(seconds-from-time(()))
empty-sequence()
empty(string-to-codepoints(""))
empty(string-to-codepoints(()))
empty(string-to-codepoints("Thrse")[last() - 7])
empty(subsequence((1, 2, 3), 2, -10))
empty(subsequence((1, 2, 3, current-time(), 5, 6, 7), 1, 1)[2])
empty(subsequence((1, 2, 3, current-time(), 5, 6, 7), 4, 1)[last() - 10])
empty(subsequence((1, 2, 3, "four"), -4, -3))
empty(subsequence((1, 2, 3, "four"), 4, -3))
empty(subsequence((1, 2), 4))
empty(subsequence((), 2, 3))
empty(subsequence((current-time(), 1), 4))
empty(sum((), ()))
empty(<?target data?>/ancestor::node())
empty(text {(1 to 10)[. mod 2 = 0]})
empty(text {"some text"}/..)
empty(timezone-from-date(()))
empty(timezone-from-dateTime(()))
empty(timezone-from-dateTime(xs:dateTime("2004-12-10T23:43:41.965")))
empty(timezone-from-date(xs:date("2004-10-12")))
empty(timezone-from-time(()))
empty(timezone-from-time(xs:time("23:43:12.765")))
empty(() to 1)
empty(unordered(()))
empty(() - xs:double(3))
empty(xs:double(3) div ())
empty(() - xs:float(3))
empty(xs:float(3) mod ())
empty(year-from-date(()))
empty(year-from-dateTime(()))
empty(years-from-duration(()))
empty(zero-or-one(()))
empty(zero-or-one(<e/>/*) is zero-or-one(<e/>/*))
<e><?name data?></e>/processing-instruction()/..
encode-for-uri('')
encode-for-uri('',())
encode-for-uri(())
encode-for-uri()
encode-for-uri("100% organic")
encode-for-uri(12)
encode-for-uri("~bb")
encode-for-uri(()) eq ""
(encode-for-uri( 'http://datypic.com/a%20URI#frag'))
encode-for-uri("http://example.com/", "wrong param")
(encode-for-uri( 'Sales % Numbers.pdf'))
(encode-for-uri( 'Sales % Numbers.pdf'), encode-for-uri( 'http://datypic.com/a%20URI#frag'))
encoding :localName
(:encoding "utf-8xx":)xquery version "1.0"; <bib/>
(:encoding "UTF-8XX":)xquery version "1.0" encoding "UTF-8"; 1 eq 1
ends-with(())
ends-with((), ())
ends-with()
ends-with('a', 'b', 'http://www.cbcl.co.u,/collation')
ends-with("a string", "a string", "http://www.example.com/COLLATION/NOT/SUPPORTED")
ends-with((), (), "http://www.w3.org/2005/xpath-functions/collation/codepoint", "wrong param")
(ends-with('query', ''))
(ends-with('query', 'query'))
(ends-with('query ', 'y'))
(ends-with('query', 'y'))
(ends-with('query', 'y'), ends-with('query', 'query'), ends-with('query', ''), ends-with('query ', 'y'), ends-with('', 'y'))
ends-with("tattoo", "tattoo")
(ends-with('', 'y'))
'en-gb' castable as xs:language
<!-- <<<>><&%(/?=(=)&entity;-]]> -->
<e/>/processing-instruction(1))
<e/>/processing-instruction(prefix:ncname))
"""" eq '"'
'' eq ''
'''' eq "'"
(() ||  ()) eq ""
() eq ()
<!-- - - - - - - - - - - - - - - - - --> eq " - - - - - - - - - - - - - - - - "
[] eq ()
(() != ()) eq false()
'equals' eq 'equals'
<e/>/(some $b in 1, $v in self::node() satisfies $v)
<e/>/(some $v in self::node() satisfies $v)
<e>some text</e>/text()/..
<e/>/(typeswitch (self::node()) case $i as node() return . default return 1)
every $aaa in (3, 3, 3), $bbb in (3, 3, 3) satisfies $aaa + $bbb eq 6
every $a as empty-sequence() in (), $b as xs:integer in $a satisfies $b
every $a as empty-sequence()? in (1, 2) satisfies $a
every $a as item() at $p in (1, 2) satisfies $a
every $a as item()* in (1, 2), $b as item()* in $a satisfies $b
every $a as item()+ in (1, 2), $b as item()+ in $a satisfies $b
every $a as item()? in (1, 2), $b as item()? in $a satisfies $b
every $a as item()* in (1, 2), $b as xs:integer in $a satisfies $b
every $a as xs:integer in (1, 2), $b as xs:integer in $a satisfies $b
every $a as xs:integer+ in (1, 2), $b as xs:integer in $a satisfies $b
every $a at $p in (1, 2) satisfies $a
every $a in 1, $b in $b satisfies 1
every $a in (1, 2), $b in $a satisfies $b
every $a in (1, 2), $b in (1, 2), $c in (1, 2) satisfies 1, $a
every $a in (1, 2), $b in (1, 2), $c in (1, 2) satisfies 1, $b
every $a in (1, 2), $b in (1, 2), $c in (1, 2) satisfies 1, $c
every $a in (1, 2), $b in (1, 2) satisfies 1, $b
every $a in (1, 2, 3), $b in ($a, 4) satisfies $b gt 0
every $a in (1, 2, 3), $b in (1, 2, 3, $b) satisfies ($a eq $b)
every $foo in ($foo, 2, 3) satisfies 1
every $foo in $foo satisfies 1
every $foo in (1, $2) return 1
every $foo in (1, $foo, 3) satisfies 1
every $foo in (1, $foo) satisfies 1
every $foo in (1, 2, $foo) satisfies 1
every $foo in 1 satisfies $bar + (every $bar in 2 satisfies $bar)
every $foo in 1 satisfies $bar + (some $bar in 2 satisfies $bar)
every $foo in 1 satisfies $foo eq "1"
every $foo in 1 satisfies $NOTEXIST
every $foo in 1 satisfies 1
every $foo in 1 satisfies "a string"
every $foo in 1 satisfies QName("example.com/", "ncname")
every $foo in 1 satisfies true()
EVERY $i in (1, 2, 3) satisfies $i
every $i in (1, 2, 3) satisfies ($i, $i)
every $i in (1, 2, 3) satisfies count($i)
every $i in () satisfies $i
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsCJKSymbolsandPunctuation}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCJKSymbolsandPunctuation}+)$')))
(every $s in tokenize('    !"#$%''''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~', '') satisfies matches($s, '^(?:\p{IsBasicLatin}+)$')) and (every $s in tokenize('', '') satisfies not(matches($s, '^(?:\p{IsBasicLatin}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsHalfwidthandFullwidthForms}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsHalfwidthandFullwidthForms}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsSmallFormVariants}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsSmallFormVariants}+)$')))
(every $s in tokenize(',#$', ',') satisfies matches($s, '^(?:[\P{L}*]{0,2})$')) and (every $s in tokenize('!$#,A', ',') satisfies not(matches($s, '^(?:[\P{L}*]{0,2})$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsArmenian}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsArmenian}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsCurrencySymbols}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCurrencySymbols}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{S}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{S}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{Sc}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Sc}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\P{C}*)$')) and (every $s in tokenize(' ', ',') satisfies not(matches($s, '^(?:\P{C}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\P{Sm}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\P{Sm}*)$')))
(every $s in tokenize('0,,,,,,,,,,,,,,,,,,9,,,,,,,,,,,,,,,,,,,', ',') satisfies matches($s, '^(?:\d)$'))          and (every $s in tokenize('),,,,,,,,,,,,,,,,,,,,:,,,,,,,,,,,,,,,,,,,,', ',') satisfies not(matches($s, '^(?:\d)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsSuperscriptsandSubscripts}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsSuperscriptsandSubscripts}+)$')))
(every $s in tokenize('0,1,2,3,4,5,6,7,8,9,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,', ',') satisfies matches($s, '^(?:[\d])$')) and (every $s in tokenize(' , , , ,!,",#,$,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,'|| ',,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,', ',') satisfies not(matches($s, '^(?:[\d])$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsMongolian}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsMongolian}+)$')))
(every $s in tokenize('--03-14', ',') satisfies matches($s, '^(?:--0[123]\-(12|14))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:--0[123]\-(12|14))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{Nd}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Nd}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{N}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{N}*)$')))
(every $s in tokenize('0', ',') satisfies matches($s, '^(?:(1|true|false|0|0))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(1|true|false|0|0))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\P{Me}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\P{Me}*)$')))
(every $s in tokenize('10000101,10000201', ',') satisfies matches($s, '^(?:\p{Nd}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Nd}+)$')))
(every $s in tokenize('1.001,1.001', ',') satisfies matches($s, '^(?:\d*\.\d+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\d*\.\d+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsEnclosedAlphanumerics}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsEnclosedAlphanumerics}+)$')))
(every $s in tokenize('11:00:00,13:20:00-05:00', ',') satisfies matches($s, '^(?:\p{Nd}{2}:\d\d:\d\d(\-\d\d:\d\d)?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Nd}{2}:\d\d:\d\d(\-\d\d:\d\d)?)$')))
(every $s in tokenize('1111,11001010', ',') satisfies matches($s, '^(?:([0-1]{4}|(0|1){8}))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:([0-1]{4}|(0|1){8}))$')))
(every $s in tokenize('-11111,-9', ',') satisfies matches($s, '^(?:\-[0-9]*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\-[0-9]*)$')))
(every $s in tokenize('1111', ',') satisfies matches($s, '^(?:\p{Nd}\d+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Nd}\d+)$')))
(every $s in tokenize('112233123,abcaabbccabc,abab', ',') satisfies matches($s, '^(?:([abc]+)|([123]+))$')) and (every $s in tokenize('1a,1a,x', ',') satisfies not(matches($s, '^(?:([abc]+)|([123]+))$')))
(every $s in tokenize('112233123,abcaabbccabc', ',') satisfies matches($s, '^(?:[123]+|[abc]+)$')) and (every $s in tokenize('1a,a1', ',') satisfies not(matches($s, '^(?:[123]+|[abc]+)$')))
(every $s in tokenize('+1,1,+9', ',') satisfies matches($s, '^(?:\+?\d)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\+?\d)$')))
(every $s in tokenize('123,12', ',') satisfies matches($s, '^(?:\d+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\d+)$')))
(every $s in tokenize('1234567890:;<=>?@Azaz', ',') satisfies matches($s, '^(?:[0-z]*)$')) and (every $s in tokenize('{,/', ',') satisfies not(matches($s, '^(?:[0-z]*)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsDingbats}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsDingbats}+)$')))
(every $s in tokenize('1234', ',') satisfies matches($s, '^(?:\I*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\I*)$')))
(every $s in tokenize('123', ',') satisfies matches($s, '^(?:[1-3]{1,4})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[1-3]{1,4})$')))
(every $s in tokenize('123', ',') satisfies matches($s, '^(?:\d+\d+\d+)$')) and (every $s in tokenize('12', ',') satisfies not(matches($s, '^(?:\d+\d+\d+)$')))
(every $s in tokenize('-128', ',') satisfies matches($s, '^(?:((\-|\+)?[1-127])|(\-?128))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:((\-|\+)?[1-127])|(\-?128))$')))
(every $s in tokenize('--12--', ',') satisfies matches($s, '^(?:--((0[1-9])|(1(1|2)))--)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:--((0[1-9])|(1(1|2)))--)$')))
(every $s in tokenize('1,3', ',') satisfies matches($s, '^(?:[13])$')) and (every $s in tokenize('2', ',') satisfies not(matches($s, '^(?:[13])$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsNumberForms}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsNumberForms}+)$')))
(every $s in tokenize('1999-12-12', ',') satisfies matches($s, '^(?:\p{Nd}{4}-\p{Nd}{2}-\p{Nd}{2})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Nd}{4}-\p{Nd}{2}-\p{Nd}{2})$')))
(every $s in tokenize('1999', ',') satisfies matches($s, '^(?:\p{Nd}{4})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Nd}{4})$')))
(every $s in tokenize('1]', ',') satisfies matches($s, '^(?:[1-\]]+)$')) and (every $s in tokenize('0,^', ',') satisfies not(matches($s, '^(?:[1-\]]+)$')))
(every $s in tokenize('1', ',') satisfies matches($s, '^(?:(1|true))$')) and (every $s in tokenize('0', ',') satisfies not(matches($s, '^(?:(1|true))$')))
(every $s in tokenize('1z', ',') satisfies matches($s, '^(?:[^2-9a-x]{2})$')) and (every $s in tokenize('1x', ',') satisfies not(matches($s, '^(?:[^2-9a-x]{2})$')))
(every $s in tokenize('2001-06-06T12:12:00', ',') satisfies matches($s, '^(?:\p{Nd}{4}-\d\d-\d\dT\d\d:\d\d:\d\d)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Nd}{4}-\d\d-\d\dT\d\d:\d\d:\d\d)$')))
(every $s in tokenize('209.25.0.111', ',') satisfies matches($s, '^(?:([0-9]+(\.[0-9]+){3}))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:([0-9]+(\.[0-9]+){3}))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\P{Nl}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\P{Nl}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{No}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{No}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\P{P}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\P{P}*)$')))
(every $s in tokenize('-300', ',') satisfies matches($s, '^(?:\-?[0-3]{3})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\-?[0-3]{3})$')))
(every $s in tokenize('---30', ',') satisfies matches($s, '^(?:---([123]0)|([12]?[1-9])|(31))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:---([123]0)|([12]?[1-9])|(31))$')))
(every $s in tokenize('9,0', ',') satisfies matches($s, '^(?:[0-9]*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[0-9]*)$')))
(every $s in tokenize('a  123c', ',') satisfies matches($s, '^(?:a\I+\c)$')) and (every $s in tokenize('b123c,a123 123cc', ',') satisfies not(matches($s, '^(?:a\I+\c)$')))
(every $s in tokenize('a1b,ab,ab,name1', ',') satisfies matches($s, '^(?:\c[\c\d]*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\c[\c\d]*)$')))
(every $s in tokenize(',a-1x-7,c-4z-9,a-1z-8a-1z-9,a1z-9,a-1z8,a-1,z-9', ',') satisfies matches($s, '^(?:[a-c-1-4x-z-7-9]*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[a-c-1-4x-z-7-9]*)$')))
(every $s in tokenize(',aa,aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa', ',') satisfies matches($s, '^(?:(a{2})*)$')) and (every $s in tokenize('a,aaa,aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa', ',') satisfies not(matches($s, '^(?:(a{2})*)$')))
(every $s in tokenize('a,aa,aaaaaaaaaaaaaaaaaaaaaaaaaa', ',') satisfies matches($s, '^(?:\c?\c+\c*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\c?\c+\c*)$')))
(every $s in tokenize('aa,aaaa,aaaaaaaaaaaaaaaaaaaa', ',') satisfies matches($s, '^(?:(a{2})+)$')) and (every $s in tokenize(',a,a2,aaa', ',') satisfies not(matches($s, '^(?:(a{2})+)$')))
(every $s in tokenize('a?,a?a?a?,a,a??,aa?', ',') satisfies matches($s, '^(?:[(a\?)?]+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[(a\?)?]+)$')))
(every $s in tokenize('a*a****aaaaa*', ',') satisfies matches($s, '^(?:[\*a]*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[\*a]*)$')))
(every $s in tokenize('aa,a a,a   a', ',') satisfies matches($s, '^(?:a\s{0,3}a)$')) and (every $s in tokenize('a    a,aa a', ',') satisfies not(matches($s, '^(?:a\s{0,3}a)$')))
(every $s in tokenize('a*a**a***,aa*a', ',') satisfies matches($s, '^(?:\c\C?\c\C+\c\C*)$'))          and (every $s in tokenize(',a12b1c1,ab12345,1a2a2,a1b1c1a', ',') satisfies not(matches($s, '^(?:\c\C?\c\C+\c\C*)$')))
(every $s in tokenize('a**,aa*,a', ',') satisfies matches($s, '^(?:[a\*]*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[a\*]*)$')))
(every $s in tokenize('aaabbb,bb,bbb,bbbb', ',') satisfies matches($s, '^(?:a*b{2,4}c{0})$')) and (every $s in tokenize('ab,abbc,bbc,abbbbb,', ',') satisfies not(matches($s, '^(?:a*b{2,4}c{0})$')))
(every $s in tokenize('aaabbbcccdddeeefff', ',') satisfies matches($s, '^(?:(([a-d]*)|(.*)))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(([a-d]*)|(.*)))$')))
(every $s in tokenize('aaabbbcccdddeeefff', ',') satisfies matches($s, '^(?:(([a-d]*)|([a-z]*)))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(([a-d]*)|([a-z]*)))$')))
(every $s in tokenize('aaa', ',') satisfies matches($s, '^(?:(111|aaa))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(111|aaa))$')))
(every $s in tokenize('a--aa---', ',') satisfies matches($s, '^(?:[-a]+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[-a]+)$')))
(every $s in tokenize('a--aa---', ',') satisfies matches($s, '^(?:[a-]*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[a-]*)$')))
(every $s in tokenize(',a,ab, a', ',') satisfies matches($s, '^(?:[^@]{0,2})$')) and (every $s in tokenize('@', ',') satisfies not(matches($s, '^(?:[^@]{0,2})$')))
(every $s in tokenize('a,abcdef', ',') satisfies matches($s, '^(?:\c+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\c+)$')))
(every $s in tokenize('a+*abc', ',') satisfies matches($s, '^(?:([^\?])*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:([^\?])*)$')))
(every $s in tokenize('a*a', ',') satisfies matches($s, '^(?:\c[^\d]\c)$')) and (every $s in tokenize('aa', ',') satisfies not(matches($s, '^(?:\c[^\d]\c)$')))
(every $s in tokenize('abab,ababab,ababababababababababababababababababababababababababababababababab', ',') satisfies matches($s, '^(?:(ab){2,})$')) and (every $s in tokenize('ab,ababa,ababaa,ababababa,abab abab,', ',') satisfies not(matches($s, '^(?:(ab){2,})$')))
(every $s in tokenize(' a    b, a  b, a  b , a    b', ',') satisfies matches($s, '^(?:(\t|\s)a(\r\n|\r|\n|\s)+(\s|\t)b(\s|\r\n|\r|\n)*)$')) and (every $s in tokenize(' a b, a b ', ',') satisfies not(matches($s, '^(?:(\t|\s)a(\r\n|\r|\n|\s)+(\s|\t)b(\s|\r\n|\r|\n)*)$')))
(every $s in tokenize(',a b,a ba b', ',') satisfies matches($s, '^(?:(a\sb){0,2})$')) and (every $s in tokenize('a ba ba b,ab,a b a b,a  b', ',') satisfies not(matches($s, '^(?:(a\sb){0,2})$')))
(every $s in tokenize('ab,abac,abacac', ',') satisfies matches($s, '^(?:((ab)(ac){0,2})?)$')) and (every $s in tokenize('ac,abacacac,abaca,abab,abacabac', ',') satisfies not(matches($s, '^(?:((ab)(ac){0,2})?)$')))
(every $s in tokenize('ab,abc', ',') satisfies matches($s, '^(?:abc?)$')) and (every $s in tokenize('a,bc,abcc,', ',') satisfies not(matches($s, '^(?:abc?)$')))
(every $s in tokenize('abab,', ',') satisfies matches($s, '^(?:((ab){2})?)$')) and (every $s in tokenize('a,ab,ababa,abababab', ',') satisfies not(matches($s, '^(?:((ab){2})?)$')))
(every $s in tokenize('abab', ',') satisfies matches($s, '^(?:[abxyz]+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[abxyz]+)$')))
(every $s in tokenize('a b , a   ', ',') satisfies matches($s, '^(?:\S?\s?\S?\s+)$')) and (every $s in tokenize('a  b, a b,ab', ',') satisfies not(matches($s, '^(?:\S?\s?\S?\s+)$')))
(every $s in tokenize('abbc', ',') satisfies matches($s, '^(?:ab{2}c)$')) and (every $s in tokenize('ac,abc,abbbc,a,', ',') satisfies not(matches($s, '^(?:ab{2}c)$')))
(every $s in tokenize('abc,ab,abccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc', ',') satisfies matches($s, '^(?:abc*)$')) and (every $s in tokenize('a,abcd,abbc,', ',') satisfies not(matches($s, '^(?:abc*)$')))
(every $s in tokenize('abc,abbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbc', ',') satisfies matches($s, '^(?:ab+c)$')) and (every $s in tokenize('ac,bbbc,abbb,', ',') satisfies not(matches($s, '^(?:ab+c)$')))
(every $s in tokenize('abc,abbbbbbbc,ac', ',') satisfies matches($s, '^(?:ab*c)$')) and (every $s in tokenize('a,ab,bc,c,abcb,', ',') satisfies not(matches($s, '^(?:ab*c)$')))
(every $s in tokenize('abc?,abbbc??,abca??,abbbbca?', ',') satisfies matches($s, '^(?:(ab+c)a?\?\??)$')) and (every $s in tokenize('ac??,bc??,abc,abc???', ',') satisfies not(matches($s, '^(?:(ab+c)a?\?\??)$')))
(every $s in tokenize('abc,abccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc', ',') satisfies matches($s, '^(?:abc+)$')) and (every $s in tokenize('a,ab,abcd', ',') satisfies not(matches($s, '^(?:abc+)$')))
(every $s in tokenize('abcc,abccc,abbcc,abbccc,bbcc,bbccc', ',') satisfies matches($s, '^(?:a{0,1}b{1,2}c{2,3})$')) and (every $s in tokenize('aabcc,bbbcc,acc,aabcc,abbc,abbcccc', ',') satisfies not(matches($s, '^(?:a{0,1}b{1,2}c{2,3})$')))
(every $s in tokenize('abcc', ',') satisfies matches($s, '^(?:abc{2})$')) and (every $s in tokenize('abc,abccc,', ',') satisfies not(matches($s, '^(?:abc{2})$')))
(every $s in tokenize('ab.cc', ',') satisfies matches($s, '^(?:a+\.?b*\.+c{2})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:a+\.?b*\.+c{2})$')))
(every $s in tokenize('_:abcdefghijklmnopqrstuvwxyzAZ:_', ',') satisfies matches($s, '^(?:\i*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\i*)$')))
(every $s in tokenize('a,b,c,d', ',') satisfies matches($s, '^(?:a|b|a|c|b|d|a)$')) and (every $s in tokenize('aa,ac,e', ',') satisfies not(matches($s, '^(?:a|b|a|c|b|d|a)$')))
(every $s in tokenize('\.abcd,\sssss,\SSSSSS,\iiiiiii,\,\c,\CCCCCC,\ddd,\D,\wwwwwww,\WWW', ';') satisfies matches($s, '^(?:\\.*,\\s*,\\S*,\\i*,\\I?,\\c+,\\C+,\\d{0,3},\\D{1,1000},\\w*,\\W+)$')) and (every $s in tokenize('', ';') satisfies not(matches($s, '^(?:\\.*,\\s*,\\S*,\\i*,\\I?,\\c+,\\C+,\\d{0,3},\\D{1,1000},\\w*,\\W+)$')))
(every $s in tokenize('abc\nsfc', ',') satisfies matches($s, '^(?:(.*))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(.*))$')))
(every $s in tokenize(' abc       ', ',') satisfies matches($s, '^(?: ([^/]+)       )$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?: ([^/]+)       )$')))
(every $s in tokenize('abc', ',') satisfies matches($s, '^(?:[a-abc]{3})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[a-abc]{3})$')))
(every $s in tokenize('?a?,?b?,?c?', ',') satisfies matches($s, '^(?:[\C\?a-c\?]+)$')) and (every $s in tokenize('?d?', ',') satisfies not(matches($s, '^(?:[\C\?a-c\?]+)$')))
(every $s in tokenize(' a b c ', ',') satisfies matches($s, '^(?:\na\nb\nc\n)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\na\nb\nc\n)$')))
(every $s in tokenize('abc', ',') satisfies matches($s, '^(?:[^\s]{3})$')) and (every $s in tokenize('a c', ',') satisfies not(matches($s, '^(?:[^\s]{3})$')))
(every $s in tokenize(' a b c ', ',') satisfies matches($s, '^(?:\ta\tb\tc\t)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\ta\tb\tc\t)$')))
(every $s in tokenize('abcxyz}', ',') satisfies matches($s, '^(?:[a-\}]+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[a-\}]+)$')))
(every $s in tokenize('a b  c  Z  :_   d y  b     ', ',') satisfies matches($s, '^(?:[\s\i]*)$')) and (every $s in tokenize('1', ',') satisfies not(matches($s, '^(?:[\s\i]*)$')))
(every $s in tokenize('a,b', ',') satisfies matches($s, '^(?:a|b)$')) and (every $s in tokenize('aa,bb,ab,', ',') satisfies not(matches($s, '^(?:a|b)$')))
(every $s in tokenize('ab', ',') satisfies matches($s, '^(?:ab)$')) and (every $s in tokenize('a,b,aa,bb,', ',') satisfies not(matches($s, '^(?:ab)$')))
(every $s in tokenize('ab', ',') satisfies matches($s, '^(?:[\i\c]*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[\i\c]*)$')))
(every $s in tokenize('a:b', ',') satisfies matches($s, '^(?:[\i\c]+:[\i\c]+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[\i\c]+:[\i\c]+)$')))
(every $s in tokenize('   a c  a      ,aa a', ',') satisfies matches($s, '^(?:\s*\c\s?\c\s+\c\s*)$')) and (every $s in tokenize(' a  a a,aaa, a aa ', ',') satisfies not(matches($s, '^(?:\s*\c\s?\c\s+\c\s*)$')))
(every $s in tokenize('ac,abc', ',') satisfies matches($s, '^(?:ab?c)$')) and (every $s in tokenize('a,ab,bc,', ',') satisfies not(matches($s, '^(?:ab?c)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsLetterlikeSymbols}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsLetterlikeSymbols}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCombiningDiacriticalMarks}+)$')) and (every $s in tokenize('a', ',') satisfies not(matches($s, '^(?:\p{IsCombiningDiacriticalMarks}+)$')))
(every $s in tokenize('AF01D1', ',') satisfies matches($s, '^(?:AF01D1)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:AF01D1)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsLatinExtended-A}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsLatinExtended-A}+)$')))
(every $s in tokenize('a, ', ',') satisfies matches($s, '^(?:.)$')) and (every $s in tokenize('aa,', ',') satisfies not(matches($s, '^(?:.)$')))
(every $s in tokenize('a', ',') satisfies matches($s, '^(?:a)$')) and (every $s in tokenize('aa,b,', ',') satisfies not(matches($s, '^(?:a)$')))
(every $s in tokenize('a', ',') satisfies matches($s, '^(?:a|a)$')) and (every $s in tokenize('aa,b,', ',') satisfies not(matches($s, '^(?:a|a)$')))
(every $s in tokenize('a', ',') satisfies matches($s, '^(?:[a-a])$')) and (every $s in tokenize('b', ',') satisfies not(matches($s, '^(?:[a-a])$')))
(every $s in tokenize('       a', ',') satisfies matches($s, '^(?:       a|b      )$')) and (every $s in tokenize('abc', ',') satisfies not(matches($s, '^(?:       a|b      )$')))
(every $s in tokenize('_,:,a', ',') satisfies matches($s, '^(?:\c)$')) and (every $s in tokenize(' , , , ', ',') satisfies not(matches($s, '^(?:\c)$')))
(every $s in tokenize('_,:,a', ',') satisfies matches($s, '^(?:\i)$')) and (every $s in tokenize(' , , , ', ',') satisfies not(matches($s, '^(?:\i)$')))
(every $s in tokenize('a', ',') satisfies matches($s, '^(?:[^\P{IsBasicLatin}])$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[^\P{IsBasicLatin}])$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[^\p{IsBasicLatin}]+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[^\p{IsBasicLatin}]+)$')))
(every $s in tokenize('\a', ',') satisfies matches($s, '^(?:\\\p{L}*)$')) and (every $s in tokenize('a', ',') satisfies not(matches($s, '^(?:\\\p{L}*)$')))
(every $s in tokenize('a', ',') satisfies matches($s, '^(?:\P{Lu}*)$')) and (every $s in tokenize('A', ',') satisfies not(matches($s, '^(?:\P{Lu}*)$')))
(every $s in tokenize('a', ',') satisfies matches($s, '^(?:\S)$')) and (every $s in tokenize(' , , , ,aa', ',') satisfies not(matches($s, '^(?:\S)$')))
(every $s in tokenize('a-x', ',') satisfies matches($s, '^(?:[a-a-x-x]+)$')) and (every $s in tokenize('j,a-b', ',') satisfies not(matches($s, '^(?:[a-a-x-x]+)$')))
(every $s in tokenize('aX', ',') satisfies matches($s, '^(?:[\p{L}*]{0,2})$')) and (every $s in tokenize('aBC', ',') satisfies not(matches($s, '^(?:[\p{L}*]{0,2})$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsLatinExtendedAdditional}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsLatinExtendedAdditional}+)$')))
(every $s in tokenize('a', ',') satisfies matches($s, '^(?:\p{Ll}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Ll}*)$')))
(every $s in tokenize('A', ',') satisfies matches($s, '^(?:\p{Lu}*)$')) and (every $s in tokenize('a', ',') satisfies not(matches($s, '^(?:\p{Lu}*)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsIPAExtensions}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsIPAExtensions}+)$')))
(every $s in tokenize('b,ab,bcccccc,abc,abbbc', ',') satisfies matches($s, '^(?:a?b+c*)$')) and (every $s in tokenize('aabc,a,c,ac,', ',') satisfies not(matches($s, '^(?:a?b+c*)$')))
(every $s in tokenize(',boy0xx,woman1y,girl1xymany,boy0xxwoman1ygirl1xymany,boy0xxwoman1ygirl1xymanyboy0xxwoman1ygirl1xymany', ',') satisfies matches($s, '^(?:(((((boy)|(girl))[0-1][x-z]{2})?)|(man|woman)[0-1]?[y|n])*)$')) and (every $s in tokenize('boy0xxwoman1ygirl1xyman,boyxx', ',') satisfies not(matches($s, '^(?:(((((boy)|(girl))[0-1][x-z]{2})?)|(man|woman)[0-1]?[y|n])*)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsLatinExtended-B}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsLatinExtended-B}+)$')))
(every $s in tokenize('c?1 abc,?0 zzz', ',') satisfies matches($s, '^(?:\c?\?\d\s\c+)$')) and (every $s in tokenize('aa?3 c,a?2 ', ',') satisfies not(matches($s, '^(?:\c?\?\d\s\c+)$')))
(every $s in tokenize('ch-a', ',') satisfies matches($s, '^(?:\c{2,4})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\c{2,4})$')))
(every $s in tokenize('\c', ',') satisfies matches($s, '^(?:\\c)$')) and (every $s in tokenize('\p{_xmlC},\\c,\\', ',') satisfies not(matches($s, '^(?:\\c)$')))
(every $s in tokenize('dddeeeccceee', ',') satisfies matches($s, '^(?:(([c-e]*)|(.*)))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(([c-e]*)|(.*)))$')))
(every $s in tokenize('dddeeeccceee', ',') satisfies matches($s, '^(?:(([c-e]*)|([d-f]*)))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(([c-e]*)|([d-f]*)))$')))
(every $s in tokenize('dddeeeccceee', ',') satisfies matches($s, '^(?:(([d-f]*)|(.*)))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(([d-f]*)|(.*)))$')))
(every $s in tokenize('dddeeeccceee', ',') satisfies matches($s, '^(?:(([d-f]*)|([c-e]*)))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(([d-f]*)|([c-e]*)))$')))
(every $s in tokenize('ello orld', ',') satisfies matches($s, '^(?:(\p{Lt}\w*)\s(\p{Lt}*\w*))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(\p{Lt}\w*)\s(\p{Lt}*\w*))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\P{Ll}*)$')) and (every $s in tokenize('a', ',') satisfies not(matches($s, '^(?:\P{Ll}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\P{M}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\P{M}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{Lt}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Lt}*)$')))
(every $s in tokenize('false', ',') satisfies matches($s, '^(?:false)$')) and (every $s in tokenize('true', ',') satisfies not(matches($s, '^(?:false)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsAlphabeticPresentationForms}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsAlphabeticPresentationForms}+)$')))
(every $s in tokenize('first.last@seznam.cz,first-last@seznam.cz', ',') satisfies matches($s, '^(?:[\w\-\.]+@.*)$')) and (every $s in tokenize('first_last@seznam.cz', ',') satisfies not(matches($s, '^(?:[\w\-\.]+@.*)$')))
(every $s in tokenize('Foo Bar,Foo Bar', ',') satisfies matches($s, '^(?:(Foo) (Bar))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(Foo) (Bar))$')))
(every $s in tokenize('foo bar', ',') satisfies matches($s, '^(?:(\w+)\s+(\w+))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(\w+)\s+(\w+))$')))
(every $s in tokenize('foo', ',') satisfies matches($s, '^(?:([a-z]*)([\w]))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:([a-z]*)([\w]))$')))
(every $s in tokenize('hellofoo barworld', ',') satisfies matches($s, '^(?:(hello)foo\s+bar(world))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(hello)foo\s+bar(world))$')))
(every $s in tokenize('Hello World,Hello World', ',') satisfies matches($s, '^(?:([\P{Ll}][\p{Ll}]*)\s([\P{Ll}][\p{Ll}]*))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:([\P{Ll}][\p{Ll}]*)\s([\P{Ll}][\p{Ll}]*))$')))
(every $s in tokenize('Hello World,Hello World', ',') satisfies matches($s, '^(?:([\p{Lu}]\w*)\s([\p{Lu}]\w*))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:([\p{Lu}]\w*)\s([\p{Lu}]\w*))$')))
(every $s in tokenize('Hello World', ',') satisfies matches($s, '^(?:(\P{Ll}\p{Ll}*)\s(\P{Ll}\p{Ll}*))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(\P{Ll}\p{Ll}*)\s(\P{Ll}\p{Ll}*))$')))
(every $s in tokenize('Hello World', ',') satisfies matches($s, '^(?:\P{Ll}\p{Ll}*\s\P{Ll}\p{Ll}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\P{Ll}\p{Ll}*\s\P{Ll}\p{Ll}*)$')))
(every $s in tokenize('Hello World', ',') satisfies matches($s, '^(?:(\P{Lt}\w*)\s(\P{Lt}*\w*))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(\P{Lt}\w*)\s(\P{Lt}*\w*))$')))
(every $s in tokenize('Hello World', ',') satisfies matches($s, '^(?:(\p{Lu}\p{Ll}*)\s(\p{Lu}\p{Ll}*))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(\p{Lu}\p{Ll}*)\s(\p{Lu}\p{Ll}*))$')))
(every $s in tokenize('hellO worlD', ',') satisfies matches($s, '^(?:(\P{Lu}+\p{Lu})\s(\P{Lu}+\p{Lu}))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(\P{Lu}+\p{Lu})\s(\P{Lu}+\p{Lu}))$')))
(every $s in tokenize('Hello World', ',') satisfies matches($s, '^(?:(\p{Lu}\w*)\s(\p{Lu}\w*))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(\p{Lu}\w*)\s(\p{Lu}\w*))$')))
(every $s in tokenize('Hello World', ',') satisfies matches($s, '^(?:\p{Lu}(\w*)\s\p{Lu}(\w*))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Lu}(\w*)\s\p{Lu}(\w*))$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsSpacingModifierLetters}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsSpacingModifierLetters}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{Lm}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Lm}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\P{Lt}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\P{Lt}*)$')))
(every $s in tokenize('http://www.foo.com', ',') satisfies matches($s, '^(?:http://\c*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:http://\c*)$')))
(every $s in tokenize('\n', ',') satisfies matches($s, '^(?:\\n)$')) and (every $s in tokenize('n,\\n, ', ',') satisfies not(matches($s, '^(?:\\n)$')))
(every $s in tokenize('P1111Y12M', ',') satisfies matches($s, '^(?:P\p{Nd}{4}Y\p{Nd}{2}M)$')) and (every $s in tokenize('P111Y12M,P1111Y1M,P11111Y12M,P1111Y,P12M,P11111Y00M,P11111Y13M', ',') satisfies not(matches($s, '^(?:P\p{Nd}{4}Y\p{Nd}{2}M)$')))
(every $s in tokenize('Price: 5 dollars', ',') satisfies matches($s, '^(?:(\S+):\W(\d+)\s(\D+))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(\S+):\W(\d+)\s(\D+))$')))
(every $s in tokenize('\r', ',') satisfies matches($s, '^(?:\\r)$')) and (every $s in tokenize('r,\\r, ', ',') satisfies not(matches($s, '^(?:\\r)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:            ((.)+)      )$')) and (every $s in tokenize('abc', ',') satisfies not(matches($s, '^(?:            ((.)+)      )$')))
(every $s in tokenize('@', ',') satisfies matches($s, '^(?:[@])$')) and (every $s in tokenize('a', ',') satisfies not(matches($s, '^(?:[@])$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:)$')) and (every $s in tokenize('a,#x20;,#xD;,#x9;,#xA;', ',') satisfies not(matches($s, '^(?:)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[])$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[])$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\\-\{^])$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[\\-\{^])$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[^\?])$')) and (every $s in tokenize('?', ',') satisfies not(matches($s, '^(?:[^\?])$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:|)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:|)$')))
(every $s in tokenize('(', ',') satisfies matches($s, '^(?:\()$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\()$')))
(every $s in tokenize(')', ',') satisfies matches($s, '^(?:\))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\))$')))
(every $s in tokenize('*', ',') satisfies matches($s, '^(?:\*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\*)$')))
(every $s in tokenize('+', ',') satisfies matches($s, '^(?:\+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\+)$')))
(every $s in tokenize('-', ',') satisfies matches($s, '^(?:[-])$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[-])$')))
(every $s in tokenize('-', ',') satisfies matches($s, '^(?:\-)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\-)$')))
(every $s in tokenize('.', ',') satisfies matches($s, '^(?:\.)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\.)$')))
(every $s in tokenize('.\?*+{}[]()|', ',') satisfies matches($s, '^(?:\.\\\?\*\+\{\}\[\]\(\)\|)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\.\\\?\*\+\{\}\[\]\(\)\|)$')))
(every $s in tokenize('.\?*+{}[]()|.\?*+{}[]()|.\?*+{}[]()|', ',') satisfies matches($s, '^(?:(([\.\\\?\*\+\{\}\[\]\(\)\|]?)*)+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(([\.\\\?\*\+\{\}\[\]\(\)\|]?)*)+)$')))
(every $s in tokenize('=,>', ',') satisfies matches($s, '^(?:[=->])$')) and (every $s in tokenize('\?', ',') satisfies not(matches($s, '^(?:[=->])$')))
(every $s in tokenize('?', ',') satisfies matches($s, '^(?:\?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\?)$')))
(every $s in tokenize('[', ',') satisfies matches($s, '^(?:\[)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\[)$')))
(every $s in tokenize('\', ',') satisfies matches($s, '^(?:\\)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\\)$')))
(every $s in tokenize('\|.?*+(){}-[]^', ',') satisfies matches($s, '^(?:[\\\|\.\?\*\+\(\)\{\}\-\[\]\^]*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[\\\|\.\?\*\+\(\)\{\}\-\[\]\^]*)$')))
(every $s in tokenize(']', ',') satisfies matches($s, '^(?:\])$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\])$')))
(every $s in tokenize('^', ',') satisfies matches($s, '^(?:\^)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\^)$')))
(every $s in tokenize('{', ',') satisfies matches($s, '^(?:\{)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\{)$')))
(every $s in tokenize('|', ',') satisfies matches($s, '^(?:\|)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\|)$')))
(every $s in tokenize('}', ',') satisfies matches($s, '^(?:\})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\})$')))
(every $s in tokenize('\,[,],\[,\[],[],[\\,\]\,[][', ',') satisfies matches($s, '^(?:[\\\[\]]{0,3})$')) and (every $s in tokenize('\[][,\]\],[][]', ',') satisfies not(matches($s, '^(?:[\\\[\]]{0,3})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:([0-9-[02468]]|[0-9-[13579]])+)$')) and (every $s in tokenize('az1234567890za', ',') satisfies not(matches($s, '^(?:([0-9-[02468]]|[0-9-[13579]])+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:([0-9]+?)([a-z]+?))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:([0-9]+?)([a-z]+?))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:([^0-9-[a-zAE-Z]]|[\w-[a-zAF-Z]])+)$')) and (every $s in tokenize('azBCDE1234567890BCDEFza', ',') satisfies not(matches($s, '^(?:([^0-9-[a-zAE-Z]]|[\w-[a-zAF-Z]])+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(([0-9])|([a-z])|([A-Z]))*)$')) and (every $s in tokenize('{hello 1234567890 world},{HELLO 1234567890 world},{1234567890 hello  world}', ',') satisfies not(matches($s, '^(?:(([0-9])|([a-z])|([A-Z]))*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(([0-9])|([a-z])|([A-Z]))+)$')) and (every $s in tokenize('{hello 1234567890 world},{HELLO 1234567890 world},{1234567890 hello world}', ',') satisfies not(matches($s, '^(?:(([0-9])|([a-z])|([A-Z]))+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:([0-9]+?)([\w]+?))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:([0-9]+?)([\w]+?))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:98[\d-[9]][\d-[8]][\d-[0]])$')) and (every $s in tokenize('98911 98881 98870 98871', ',') satisfies not(matches($s, '^(?:98[\d-[9]][\d-[8]][\d-[0]])$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[^\^a])$')) and (every $s in tokenize('^,a', ',') satisfies not(matches($s, '^(?:[^\^a])$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[a])$')) and (every $s in tokenize('b,', ',') satisfies not(matches($s, '^(?:[a])$')))
(every $s in tokenize('}-', ',') satisfies matches($s, '^(?:[a-\}-]+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[a-\}-]+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:a{0})$')) and (every $s in tokenize('a', ',') satisfies not(matches($s, '^(?:a{0})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:a.{0,5}?c)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:a.{0,5}?c)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(a)|\1)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(a)|\1)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:((((((((((a))))))))))\10)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:((((((((((a))))))))))\10)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:^aa$)$')) and (every $s in tokenize('aA', ',') satisfies not(matches($s, '^(?:^aa$)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:^Aa$)$')) and (every $s in tokenize('aA', ',') satisfies not(matches($s, '^(?:^Aa$)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:aA)$')) and (every $s in tokenize('Aa,Aa', ',') satisfies not(matches($s, '^(?:aA)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:AA)$')) and (every $s in tokenize('Aa,Aa', ',') satisfies not(matches($s, '^(?:AA)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[a-[a-f]])$')) and (every $s in tokenize('abcdefghijklmnopqrstuvwxyz', ',') satisfies not(matches($s, '^(?:[a-[a-f]])$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(ab){0,0})$')) and (every $s in tokenize('a,ab', ',') satisfies not(matches($s, '^(?:(ab){0,0})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(a+|b){0,1}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(a+|b){0,1}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:ab{0,1}?bc)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:ab{0,1}?bc)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:ab{0,1}?c)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:ab{0,1}?c)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[a-b-[0-9]]+)$')) and (every $s in tokenize('a1', ',') satisfies not(matches($s, '^(?:[a-b-[0-9]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:ab{0,}?bc)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:ab{0,}?bc)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:ab{1,3}?bc)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:ab{1,3}?bc)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:ab{1,}?bc)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:ab{1,}?bc)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:ab{3,4}?bc)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:ab{3,4}?bc)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:ab{4,5}?bc)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:ab{4,5}?bc)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:ab*?bc)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:ab*?bc)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:ab+?bc)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:ab+?bc)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:ab??bc)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:ab??bc)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(a+)(b*)(c?))$')) and (every $s in tokenize('aaabbbccc', ',') satisfies not(matches($s, '^(?:(a+)(b*)(c?))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[a\-\[\-\[\-bc]+)$')) and (every $s in tokenize('```bbbaaa---[[[cccddd', ',') satisfies not(matches($s, '^(?:[a\-\[\-\[\-bc]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:ab??c)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:ab??c)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(abc)\1)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(abc)\1)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[abc\--[b]]+)$')) and (every $s in tokenize('[[[```bbbaaa---cccddd', ',') satisfies not(matches($s, '^(?:[abc\--[b]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[abcd-[d]]+)$')) and (every $s in tokenize('dddaabbccddd', ',') satisfies not(matches($s, '^(?:[abcd-[d]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[abcd\-d-[bc]]+)$')) and (every $s in tokenize('bbbaaa---dddccc,bbbaaa---dddccc', ',') satisfies not(matches($s, '^(?:[abcd\-d-[bc]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[abcd-[def]]+)$')) and (every $s in tokenize('fedddaabbccddd', ',') satisfies not(matches($s, '^(?:[abcd-[def]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[abcdef-[^bce]]+)$')) and (every $s in tokenize('adfbcefda', ',') satisfies not(matches($s, '^(?:[abcdef-[^bce]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[abc-[defg]]+)$')) and (every $s in tokenize('dddaabbccddd', ',') satisfies not(matches($s, '^(?:[abc-[defg]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[abc\-z-[b]]+)$')) and (every $s in tokenize('```aaaccc---zzzbbb', ',') satisfies not(matches($s, '^(?:[abc\-z-[b]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(abra(cad)?)+)$')) and (every $s in tokenize('abracadabra1abracadabra2abracadabra3', ',') satisfies not(matches($s, '^(?:(abra(cad)?)+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:a.*?c)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:a.*?c)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:a.+?c)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:a.+?c)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:([a-c]*)\1)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:([a-c]*)\1)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[a-c-[^a-c]])$')) and (every $s in tokenize('d', ',') satisfies not(matches($s, '^(?:[a-c-[^a-c]])$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(([a-c])b*?\2)*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(([a-c])b*?\2)*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(([a-c])b*?\2){3})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(([a-c])b*?\2){3})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:a(.)c(.)e)$')) and (every $s in tokenize('123abcde456aBCDe789', ',') satisfies not(matches($s, '^(?:a(.)c(.)e)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[a-[c-e]]+)$')) and (every $s in tokenize('bbbaaaccc,```aaaccc', ',') satisfies not(matches($s, '^(?:[a-[c-e]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[^a-d-b-c])$')) and (every $s in tokenize('a-b,c-c,ab,cc', ',') satisfies not(matches($s, '^(?:[^a-d-b-c])$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[a-d-[b-c]])$')) and (every $s in tokenize('b,c', ',') satisfies not(matches($s, '^(?:[a-d-[b-c]])$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[a-d\--[bc]]+)$')) and (every $s in tokenize('cccaaa--dddbbb', ',') satisfies not(matches($s, '^(?:[a-d\--[bc]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[a-e - m-p]+)$')) and (every $s in tokenize('---a b c d e m n o p---', ',') satisfies not(matches($s, '^(?:[a-e - m-p]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:a\sb)$')) and (every $s in tokenize('a  b', ',') satisfies not(matches($s, '^(?:a\sb)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[^a-z^])$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[^a-z^])$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:^([a-z0-9]+)@([a-z]+)\.([a-z]+)$)$')) and (every $s in tokenize('bar@bar.foo.com', ',') satisfies not(matches($s, '^(?:^([a-z0-9]+)@([a-z]+)\.([a-z]+)$)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[a-z-[^a]])$')) and (every $s in tokenize('b', ',') satisfies not(matches($s, '^(?:[a-z-[^a]])$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[a-zA-Z0-9-[\s]]+)$')) and (every $s in tokenize('  azAZ09', ',') satisfies not(matches($s, '^(?:[a-zA-Z0-9-[\s]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[a-zA-Z-[aeiouAEIOU]]+)$')) and (every $s in tokenize('aeiouAEIOUbcdfghjklmnpqrstvwxyz', ',') satisfies not(matches($s, '^(?:[a-zA-Z-[aeiouAEIOU]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:([a-z]*?)([\w]))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:([a-z]*?)([\w]))$')))
(every $s in tokenize(' , , , ', ',') satisfies matches($s, '^(?:\C)$')) and (every $s in tokenize('_,:,a', ',') satisfies not(matches($s, '^(?:\C)$')))
(every $s in tokenize('?', ',') satisfies matches($s, '^(?:[\c\?a-c\?]+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[\c\?a-c\?]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:^(cat|chat))$')) and (every $s in tokenize('cats are bad', ',') satisfies not(matches($s, '^(?:^(cat|chat))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[^cde-[ag]]+)$')) and (every $s in tokenize('agbfxyzga', ',') satisfies not(matches($s, '^(?:[^cde-[ag]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:cH)$')) and (every $s in tokenize('Ch,Ch', ',') satisfies not(matches($s, '^(?:cH)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:CH)$')) and (every $s in tokenize('Ch,Ch', ',') satisfies not(matches($s, '^(?:CH)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\c[^\s]\c)$')) and (every $s in tokenize('a c,a z,a c,a r', ',') satisfies not(matches($s, '^(?:\c[^\s]\c)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\-?\d)$')) and (every $s in tokenize('+1', ',') satisfies not(matches($s, '^(?:\-?\d)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[>-D]+)$')) and (every $s in tokenize('eE=>?@ABCDabcdeE', ',') satisfies not(matches($s, '^(?:[>-D]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[@-D]+)$')) and (every $s in tokenize('eE?@ABCDabcdeE', ',') satisfies not(matches($s, '^(?:[@-D]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\d-[13579]]+)$')) and (every $s in tokenize('1024689', ',') satisfies not(matches($s, '^(?:[\d-[13579]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\d-[13579abcd]]+)$')) and (every $s in tokenize('abcd02468', ',') satisfies not(matches($s, '^(?:[\d-[13579abcd]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\d-[13579a-zA-Z]]+)$')) and (every $s in tokenize('AZ1024689', ',') satisfies not(matches($s, '^(?:[\d-[13579a-zA-Z]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\d-[13579\s]]+)$')) and (every $s in tokenize('  02468', ',') satisfies not(matches($s, '^(?:[\d-[13579\s]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\d-[357]]+)$')) and (every $s in tokenize('33312468955,51246897,3312468977', ',') satisfies not(matches($s, '^(?:[\d-[357]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\d-[357a-z]]+)$')) and (every $s in tokenize('az33312468955', ',') satisfies not(matches($s, '^(?:[\d-[357a-z]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\d-[357\p{Ll}]]+)$')) and (every $s in tokenize('az3312468977', ',') satisfies not(matches($s, '^(?:[\d-[357\p{Ll}]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\d-[abc]]+)$')) and (every $s in tokenize('abc09abc', ',') satisfies not(matches($s, '^(?:[\d-[abc]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\D\?a-c\?]+)$')) and (every $s in tokenize('?1?', ',') satisfies not(matches($s, '^(?:[\D\?a-c\?]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\d-[a-zA-Z]]+)$')) and (every $s in tokenize('az09AZ,azAZ02468', ',') satisfies not(matches($s, '^(?:[\d-[a-zA-Z]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:([\D]*)bar)$')) and (every $s in tokenize('65498foobar58719,65498foobar58719', ',') satisfies not(matches($s, '^(?:([\D]*)bar)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\D*(bar))$')) and (every $s in tokenize('65498foobar58719', ',') satisfies not(matches($s, '^(?:\D*(bar))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\-\d\d)$')) and (every $s in tokenize('11', ',') satisfies not(matches($s, '^(?:\-\d\d)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\d-[\D]]+)$')) and (every $s in tokenize('azAZ1024689', ',') satisfies not(matches($s, '^(?:[\d-[\D]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\d-[de357fgA-Z]]+)$')) and (every $s in tokenize('AZ51246897', ',') satisfies not(matches($s, '^(?:[\d-[de357fgA-Z]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\d+\d+\p{Nd}\d+)$')) and (every $s in tokenize('123', ',') satisfies not(matches($s, '^(?:\d+\d+\p{Nd}\d+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(d+?)(e*?)(f??))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(d+?)(e*?)(f??))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(d)(o)(g)(\s)(c)(a)(t)(\s)(h)(a)(s))$')) and (every $s in tokenize('My dog cat has fleas.,My dog cat has fleas.', ',') satisfies not(matches($s, '^(?:(d)(o)(g)(\s)(c)(a)(t)(\s)(h)(a)(s))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\d-[\p{Ll}]]+)$')) and (every $s in tokenize('az09az', ',') satisfies not(matches($s, '^(?:[\d-[\p{Ll}]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[-e-g]+)$')) and (every $s in tokenize('ddd---eeefffggghhh,ddd---eeefffggghhh', ',') satisfies not(matches($s, '^(?:[-e-g]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(foo)(\176))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(foo)(\176))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(foo)\c)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(foo)\c)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(foo)(\c *)(bar))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(foo)(\c *)(bar))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(foo)(\c*)(bar))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(foo)(\c*)(bar))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(foo)(\c\[*)(bar))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(foo)(\c\[*)(bar))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(foo)(\c\|*)(bar))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(foo)(\c\|*)(bar))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(foo)(\c`*)(bar))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(foo)(\c`*)(bar))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:foo\d+)$')) and (every $s in tokenize('0123456789foo4567890foo         ,0123456789foo4567890foo1foo  0987', ',') satisfies not(matches($s, '^(?:foo\d+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:foo([\d]*)bar)$')) and (every $s in tokenize('hello123foo230927bar1412d,hello123foo230927bar1412d', ',') satisfies not(matches($s, '^(?:foo([\d]*)bar)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(foo)\d*bar)$')) and (every $s in tokenize('hello123foo230927bar1412d', ',') satisfies not(matches($s, '^(?:(foo)\d*bar)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(foo) #foo        \s+ #followed by 1 or more whitespace        (bar)  #followed by bar        )$')) and (every $s in tokenize('foo    bar', ',') satisfies not(matches($s, '^(?:(foo) #foo        \s+ #followed by 1 or more whitespace        (bar)  #followed by bar        )$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(foo) #foo        \s+ #followed by 1 or more whitespace        (bar)  #followed by bar)$')) and (every $s in tokenize('foo    bar', ',') satisfies not(matches($s, '^(?:(foo) #foo        \s+ #followed by 1 or more whitespace        (bar)  #followed by bar)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(foo)([\r]*)(bar))$')) and (every $s in tokenize('foo   bar', ',') satisfies not(matches($s, '^(?:(foo)([\r]*)(bar))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:foo\s+)$')) and (every $s in tokenize('0123456789foo4567890foo         ', ',') satisfies not(matches($s, '^(?:foo\s+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(foo)\S*)$')) and (every $s in tokenize('sfdfoobar    3270', ',') satisfies not(matches($s, '^(?:(foo)\S*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:foo([\S]*))$')) and (every $s in tokenize('sfdfoobar    3270,sfdfoobar    3270', ',') satisfies not(matches($s, '^(?:foo([\S]*))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(foo)\s+(bar))$')) and (every $s in tokenize('before textfoo barafter text,before textfoo barafter text,before textfoo barafter text', ',') satisfies not(matches($s, '^(?:(foo)\s+(bar))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(foo)\s*(bar))$')) and (every $s in tokenize('wiofoo   bar3270', ',') satisfies not(matches($s, '^(?:(foo)\s*(bar))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:foo([\s]*)bar)$')) and (every $s in tokenize('wiofoo   bar3270,wiofoo   bar3270', ',') satisfies not(matches($s, '^(?:foo([\s]*)bar)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(foo)\w*)$')) and (every $s in tokenize('sfdfoobar    3270', ',') satisfies not(matches($s, '^(?:(foo)\w*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:foo([\w]*))$')) and (every $s in tokenize('sfdfoobar    3270,sfdfoobar    3270', ',') satisfies not(matches($s, '^(?:foo([\w]*))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(foo)\W*(bar))$')) and (every $s in tokenize('wiofoo   bar3270', ',') satisfies not(matches($s, '^(?:(foo)\W*(bar))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:foo([\W]*)bar)$')) and (every $s in tokenize('wiofoo   bar3270,wiofoo   bar3270', ',') satisfies not(matches($s, '^(?:foo([\W]*)bar)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(foo\w+)\s+(bar\w+))$')) and (every $s in tokenize('STARTfoo barEND,STARTfoo barEND', ',') satisfies not(matches($s, '^(?:(foo\w+)\s+(bar\w+))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(hello)\s+(world))$')) and (every $s in tokenize('What the hello world goodby,What the hello world goodby,START hello    world END,START hello    world END', ',') satisfies not(matches($s, '^(?:(hello)\s+(world))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:http://([a-zA-Z0-9\-]*\.?)*?/)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:http://([a-zA-Z0-9\-]*\.?)*?/)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:http://([a-zA-z0-9\-]*\.?)*?(:[0-9]*)??/)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:http://([a-zA-z0-9\-]*\.?)*?(:[0-9]*)??/)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:^http://www.([a-zA-Z0-9]+)\.([a-z]+)$)$')) and (every $s in tokenize('http://www.foo.bar.com', ',') satisfies not(matches($s, '^(?:^http://www.([a-zA-Z0-9]+)\.([a-z]+)$)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\i+)$')) and (every $s in tokenize('a b', ',') satisfies not(matches($s, '^(?:\i+)$')))
(every $s in tokenize(' , , , ', ',') satisfies matches($s, '^(?:\I)$')) and (every $s in tokenize('_,:,a', ',') satisfies not(matches($s, '^(?:\I)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:)$')) and (every $s in tokenize('i,i,I,i,I,i', ',') satisfies not(matches($s, '^(?:)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:)$')) and (every $s in tokenize('I,I,I,i,I,i', ',') satisfies not(matches($s, '^(?:)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:m[\w-[^aeiou]][\w-[^aeiou]]t)$')) and (every $s in tokenize('mbbt mect meet', ',') satisfies not(matches($s, '^(?:m[\w-[^aeiou]][\w-[^aeiou]]t)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:([^{}]|\n)+)$')) and (every $s in tokenize('{{{{Hello  World  }END', ',') satisfies not(matches($s, '^(?:([^{}]|\n)+)$')))
(every $s in tokenize(' ', ',') satisfies matches($s, '^(?:[\n])$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[\n])$')))
(every $s in tokenize(' ', ',') satisfies matches($s, '^(?:\n)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\n)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\n\\\r\|\t\.\-\^\?\*\+\{\}\(\)\[\])$')) and (every $s in tokenize(' \ | .-^?*+{}()[,\ | .-^?*+{}()[], \ | -^?*+{}()[]', ',') satisfies not(matches($s, '^(?:\n\\\r\|\t\.\-\^\?\*\+\{\}\(\)\[\])$')))
(every $s in tokenize('\|.-^?*+[]{}()*[[]{}})) *()', ',') satisfies matches($s, '^(?:[\n\r\t\\\|\.\-\^\?\*\+\{\}\[\]\(\)]*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[\n\r\t\\\|\.\-\^\?\*\+\{\}\[\]\(\)]*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{C}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{C}*)$')))
(every $s in tokenize(' ', ',') satisfies matches($s, '^(?:\p{Cc}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Cc}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\P{Cc}*)$')) and (every $s in tokenize(' ', ',') satisfies not(matches($s, '^(?:\P{Cc}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{Cf}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Cf}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\P{Cf}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\P{Cf}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{Cn}*)$')) and (every $s in tokenize(' ', ',') satisfies not(matches($s, '^(?:\p{Cn}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(\p{Co})*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(\p{Co})*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{Co}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Co}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\P{Co}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\P{Co}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsAlphabeticPresentationForms})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsAlphabeticPresentationForms})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsAlphabeticPresentationForms}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsAlphabeticPresentationForms}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsArabic})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsArabic})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsArabic}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsArabic}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsArabicPresentationForms-A}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsArabicPresentationForms-A}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsArabicPresentationForms-A})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsArabicPresentationForms-A})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsArabicPresentationForms-B})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsArabicPresentationForms-B})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsArabicPresentationForms-B}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsArabicPresentationForms-B}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsArmenian}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsArmenian}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsArmenian})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsArmenian})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsArrows})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsArrows})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsArrows}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsArrows}?)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsArrows}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsArrows}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[^\p{IsBasicLatin}]*)$')) and (every $s in tokenize('a', ',') satisfies not(matches($s, '^(?:[^\p{IsBasicLatin}]*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsBasicLatin}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsBasicLatin}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsBasicLatin})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsBasicLatin})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsBengali}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsBengali}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsBengali})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsBengali})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsBlockElements})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsBlockElements})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsBlockElements}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsBlockElements}?)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsBlockElements}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsBlockElements}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsBopomofo}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsBopomofo}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsBopomofo})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsBopomofo})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsBopomofoExtended}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsBopomofoExtended}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsBopomofoExtended})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsBopomofoExtended})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsBoxDrawing})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsBoxDrawing})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsBoxDrawing}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsBoxDrawing}?)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsBoxDrawing}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsBoxDrawing}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsBraillePatterns})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsBraillePatterns})$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsBraillePatterns}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsBraillePatterns}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsBraillePatterns}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsBraillePatterns}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsByzantineMusicalSymbols}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsByzantineMusicalSymbols}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsByzantineMusicalSymbols})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsByzantineMusicalSymbols})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCherokee})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCherokee})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCherokee}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCherokee}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKCompatibility})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCJKCompatibility})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKCompatibility}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCJKCompatibility}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKCompatibilityForms})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCJKCompatibilityForms})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKCompatibilityForms}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCJKCompatibilityForms}?)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsCJKCompatibilityForms}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCJKCompatibilityForms}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKCompatibilityIdeographs}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCJKCompatibilityIdeographs}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKCompatibilityIdeographs})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCJKCompatibilityIdeographs})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKCompatibilityIdeographsSupplement})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCJKCompatibilityIdeographsSupplement})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKCompatibilityIdeographsSupplement}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCJKCompatibilityIdeographsSupplement}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKRadicalsSupplement})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCJKRadicalsSupplement})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKRadicalsSupplement}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCJKRadicalsSupplement}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKSymbolsandPunctuation})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCJKSymbolsandPunctuation})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKSymbolsandPunctuation}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCJKSymbolsandPunctuation}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKUnifiedIdeographs})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCJKUnifiedIdeographs})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKUnifiedIdeographs}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCJKUnifiedIdeographs}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKUnifiedIdeographsExtensionA})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCJKUnifiedIdeographsExtensionA})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKUnifiedIdeographsExtensionA}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCJKUnifiedIdeographsExtensionA}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKUnifiedIdeographsExtensionA}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCJKUnifiedIdeographsExtensionA}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKUnifiedIdeographsExtensionB})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCJKUnifiedIdeographsExtensionB})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCJKUnifiedIdeographsExtensionB}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCJKUnifiedIdeographsExtensionB}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCombiningHalfMarks})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCombiningHalfMarks})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCombiningHalfMarks}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCombiningHalfMarks}?)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsCombiningHalfMarks}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCombiningHalfMarks}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCombiningMarksforSymbols}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCombiningMarksforSymbols}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCombiningMarksforSymbols})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCombiningMarksforSymbols})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCombiningMarksforSymbols}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCombiningMarksforSymbols}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsControlPictures})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsControlPictures})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsControlPictures}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsControlPictures}?)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsControlPictures}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsControlPictures}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCurrencySymbols})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCurrencySymbols})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCurrencySymbols}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCurrencySymbols}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCyrillic}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCyrillic}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCyrillic})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCyrillic})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsDeseret})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsDeseret})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsDeseret}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsDeseret}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsDevanagari})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsDevanagari})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsDevanagari}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsDevanagari}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsDingbats})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsDingbats})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsDingbats}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsDingbats}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsEnclosedAlphanumerics})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsEnclosedAlphanumerics})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsEnclosedAlphanumerics}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsEnclosedAlphanumerics}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsEnclosedCJKLettersandMonths})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsEnclosedCJKLettersandMonths})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsEnclosedCJKLettersandMonths}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsEnclosedCJKLettersandMonths}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsEthiopic}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsEthiopic}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsEthiopic})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsEthiopic})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsGeneralPunctuation}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsGeneralPunctuation}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsGeneralPunctuation})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsGeneralPunctuation})$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsGeneralPunctuation}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsGeneralPunctuation}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsGeometricShapes})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsGeometricShapes})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsGeometricShapes}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsGeometricShapes}?)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsGeometricShapes}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsGeometricShapes}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsGeorgian})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsGeorgian})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsGeorgian}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsGeorgian}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsGothic})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsGothic})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsGothic}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsGothic}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsGreek})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsGreek})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsGreekExtended}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsGreekExtended}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsGreekExtended})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsGreekExtended})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\p{IsGreek}-[\P{Lu}]]+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[\p{IsGreek}-[\P{Lu}]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsGujarati})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsGujarati})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsGujarati}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsGujarati}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsGurmukhi})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsGurmukhi})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsGurmukhi}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsGurmukhi}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsHalfwidthandFullwidthForms})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsHalfwidthandFullwidthForms})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsHalfwidthandFullwidthForms}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsHalfwidthandFullwidthForms}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsHangulCompatibilityJamo})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsHangulCompatibilityJamo})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsHangulCompatibilityJamo}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsHangulCompatibilityJamo}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsHangulJamo})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsHangulJamo})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsHangulJamo}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsHangulJamo}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsHangulSyllables}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsHangulSyllables}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsHangulSyllables})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsHangulSyllables})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsHebrew})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsHebrew})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsHebrew}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsHebrew}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsHighSurrogates})$')) and (every $s in tokenize('''', ',') satisfies not(matches($s, '^(?:\p{IsHighSurrogates})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsHighSurrogates}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsHighSurrogates}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsHiragana})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsHiragana})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsHiragana}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsHiragana}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsIdeographicDescriptionCharacters})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsIdeographicDescriptionCharacters})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsIdeographicDescriptionCharacters}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsIdeographicDescriptionCharacters}?)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsIdeographicDescriptionCharacters}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsIdeographicDescriptionCharacters}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsIPAExtensions}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsIPAExtensions}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsIPAExtensions})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsIPAExtensions})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsKanbun})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsKanbun})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsKanbun}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsKanbun}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsKangxiRadicals})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsKangxiRadicals})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsKangxiRadicals}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsKangxiRadicals}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsKannada})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsKannada})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsKannada}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsKannada}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsKatakana}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsKatakana}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsKatakana})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsKatakana})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsKhmer})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsKhmer})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsKhmer}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsKhmer}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsLao})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsLao})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsLao}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsLao}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsLatin-1Supplement}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsLatin-1Supplement}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsLatin-1Supplement})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsLatin-1Supplement})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsLatinExtended-A}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsLatinExtended-A}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsLatinExtended-A})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsLatinExtended-A})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsLatinExtendedAdditional})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsLatinExtendedAdditional})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsLatinExtendedAdditional}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsLatinExtendedAdditional}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsLatinExtended-B}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsLatinExtended-B}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsLatinExtended-B})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsLatinExtended-B})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsLetterlikeSymbols}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsLetterlikeSymbols}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsLetterlikeSymbols})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsLetterlikeSymbols})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsLowSurrogates}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsLowSurrogates}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsMalayalam})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsMalayalam})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsMalayalam}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsMalayalam}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsMathematicalAlphanumericSymbols})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsMathematicalAlphanumericSymbols})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsMathematicalAlphanumericSymbols}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsMathematicalAlphanumericSymbols}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsMathematicalOperators})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsMathematicalOperators})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsMathematicalOperators}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsMathematicalOperators}?)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsMathematicalOperators}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsMathematicalOperators}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsMiscellaneousSymbols})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsMiscellaneousSymbols})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsMiscellaneousSymbols}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsMiscellaneousSymbols}?)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsMiscellaneousSymbols}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsMiscellaneousSymbols}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsMiscellaneousTechnical})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsMiscellaneousTechnical})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsMiscellaneousTechnical}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsMiscellaneousTechnical}?)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsMiscellaneousTechnical}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsMiscellaneousTechnical}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsMongolian}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsMongolian}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsMongolian})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsMongolian})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsMusicalSymbols}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsMusicalSymbols}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsMusicalSymbols})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsMusicalSymbols})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsMyanmar})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsMyanmar})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsMyanmar}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsMyanmar}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsNumberForms})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsNumberForms})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsNumberForms}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsNumberForms}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsOgham})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsOgham})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsOgham}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsOgham}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsOldItalic}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsOldItalic}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsOldItalic})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsOldItalic})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsOpticalCharacterRecognition}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsOpticalCharacterRecognition}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsOpticalCharacterRecognition})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsOpticalCharacterRecognition})$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsOpticalCharacterRecognition}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsOpticalCharacterRecognition}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsOriya})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsOriya})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsOriya}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsOriya}?)$')))
(every $s in tokenize(',,', ',') satisfies matches($s, '^(?:\p{IsPrivateUse}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsPrivateUse}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsPrivateUse})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsPrivateUse})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsPrivateUse}?)$')) and (every $s in tokenize(',', ',') satisfies not(matches($s, '^(?:\p{IsPrivateUse}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsRunic})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsRunic})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsRunic}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsRunic}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsSinhala}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsSinhala}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsSinhala})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsSinhala})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsSmallFormVariants})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsSmallFormVariants})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsSmallFormVariants}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsSmallFormVariants}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsSpacingModifierLetters}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsSpacingModifierLetters}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsSpacingModifierLetters})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsSpacingModifierLetters})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsSpecials})$')) and (every $s in tokenize(',', ',') satisfies not(matches($s, '^(?:\p{IsSpecials})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsSpecials}?)$')) and (every $s in tokenize(',', ',') satisfies not(matches($s, '^(?:\p{IsSpecials}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsSuperscriptsandSubscripts}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsSuperscriptsandSubscripts}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsSuperscriptsandSubscripts})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsSuperscriptsandSubscripts})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsSyriac})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsSyriac})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsSyriac}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsSyriac}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsTags})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsTags})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsTags}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsTags}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsTamil})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsTamil})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsTamil}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsTamil}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsTelugu})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsTelugu})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsTelugu}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsTelugu}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsThaana}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsThaana}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsThaana})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsThaana})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsThai})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsThai})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsThai}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsThai}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsTibetan})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsTibetan})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsTibetan}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsTibetan}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsUnifiedCanadianAboriginalSyllabics})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsUnifiedCanadianAboriginalSyllabics})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsUnifiedCanadianAboriginalSyllabics}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsUnifiedCanadianAboriginalSyllabics}?)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsYiRadicals})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsYiRadicals})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsYiRadicals}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsYiRadicals}?)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsYiRadicals}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsYiRadicals}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsYiSyllables})$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsYiSyllables})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsYiSyllables}?)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsYiSyllables}?)$')))
(every $s in tokenize('_,', ',') satisfies matches($s, '^(?:\P{L}*)$')) and (every $s in tokenize('aAbB,Aaa', ',') satisfies not(matches($s, '^(?:\P{L}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{L}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{L}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:([\p{Ll}-[aeiou]]|[^\w-[\s]])+)$')) and (every $s in tokenize('aeiobcdxyz!@#aeio', ',') satisfies not(matches($s, '^(?:([\p{Ll}-[aeiou]]|[^\w-[\s]])+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\p{Ll}-[ae-z]]+)$')) and (every $s in tokenize('aaabbbcccdddeee', ',') satisfies not(matches($s, '^(?:[\p{Ll}-[ae-z]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\p{Ll}-[ae-z0-9]]+)$')) and (every $s in tokenize('09aaabbbcccdddeee', ',') satisfies not(matches($s, '^(?:[\p{Ll}-[ae-z0-9]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\p{Ll}-[A-Z]]+)$')) and (every $s in tokenize('AZaz09', ',') satisfies not(matches($s, '^(?:[\p{Ll}-[A-Z]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(\p{Ll}\p{Cc}\p{Nd})*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(\p{Ll}\p{Cc}\p{Nd})*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\P{Lo}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\P{Lo}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\P{Lu}-[ae-z]]+)$')) and (every $s in tokenize('aaabbbcccdddeee', ',') satisfies not(matches($s, '^(?:[\P{Lu}-[ae-z]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\P{Lu}-[ae-zA-Z]]+)$')) and (every $s in tokenize('AZaaabbbcccdddeee', ',') satisfies not(matches($s, '^(?:[\P{Lu}-[ae-zA-Z]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\P{Lu}-[A-Z]]+)$')) and (every $s in tokenize('AZazAZ', ',') satisfies not(matches($s, '^(?:[\P{Lu}-[A-Z]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\P{Lu}-[\p{Lu}]]+)$')) and (every $s in tokenize('AZazAZ', ',') satisfies not(matches($s, '^(?:[\P{Lu}-[\p{Lu}]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{M}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{M}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\P{Mc}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\P{Mc}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{Mc}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Mc}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{Me}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Me}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{Mn}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Mn}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\P{Mn}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\P{Mn}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\P{N}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\P{N}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{Nd}{2})$')) and (every $s in tokenize('1999', ',') satisfies not(matches($s, '^(?:\p{Nd}{2})$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\p{Nd}-[2468]]+)$')) and (every $s in tokenize('20135798', ',') satisfies not(matches($s, '^(?:[\p{Nd}-[2468]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\p{Nd}-[2468az]]+)$')) and (every $s in tokenize('az20135798', ',') satisfies not(matches($s, '^(?:[\p{Nd}-[2468az]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\P{Nd}-[2-8]]+)$')) and (every $s in tokenize('1234567890azAZ1234567890', ',') satisfies not(matches($s, '^(?:[\P{Nd}-[2-8]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\p{Nd}-[a-z]]+)$')) and (every $s in tokenize('az09', ',') satisfies not(matches($s, '^(?:[\p{Nd}-[a-z]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\P{Nd}-[\p{Nd}]]+)$')) and (every $s in tokenize('azAZ09', ',') satisfies not(matches($s, '^(?:[\P{Nd}-[\p{Nd}]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\P{No}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\P{No}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{P}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{P}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{Pc}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Pc}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\P{Pc}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\P{Pc}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{Pd}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Pd}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\P{Pd}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\P{Pd}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{Pe}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Pe}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\P{Pe}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\P{Pe}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{Pf}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Pf}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\P{Pf}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\P{Pf}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{Pi}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Pi}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\P{Pi}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\P{Pi}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{Po}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Po}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\P{Po}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\P{Po}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{Ps}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Ps}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\P{Ps}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\P{Ps}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\P{S}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\P{S}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\P{Sc}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\P{Sc}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{Sk}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Sk}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\P{Sk}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\P{Sk}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{Sm}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Sm}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{So}*)$')) and (every $s in tokenize(' ', ',') satisfies not(matches($s, '^(?:\p{So}*)$')))
(every $s in tokenize(' ', ',') satisfies matches($s, '^(?:\P{So}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\P{So}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{Z}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Z}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\P{Z}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\P{Z}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{Zl}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Zl}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\P{Zl}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\P{Zl}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{Zp}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Zp}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\P{Zp}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\P{Zp}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{Zs}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Zs}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\P{Zs}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\P{Zs}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:qqq(123)*)$')) and (every $s in tokenize('Startqqq123123End', ',') satisfies not(matches($s, '^(?:qqq(123)*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\S+)$')) and (every $s in tokenize('a b', ',') satisfies not(matches($s, '^(?:\S+)$')))
(every $s in tokenize(' , , , ', ',') satisfies matches($s, '^(?:\s)$')) and (every $s in tokenize('a,', ',') satisfies not(matches($s, '^(?:\s)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:(\s)?(-))$')) and (every $s in tokenize('once -upon-a time', ',') satisfies not(matches($s, '^(?:(\s)?(-))$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\S*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\S*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\S\?a-c\?]+)$')) and (every $s in tokenize('? ?,? ?', ',') satisfies not(matches($s, '^(?:[\S\?a-c\?]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\s+\d+)$')) and (every $s in tokenize('sdf 12sad', ',') satisfies not(matches($s, '^(?:\s+\d+)$')))
(every $s in tokenize(' ', ',') satisfies matches($s, '^(?:[\t])$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[\t])$')))
(every $s in tokenize(' ', ',') satisfies matches($s, '^(?:\t)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\t)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\t\ta\t\tb\t\t)$')) and (every $s in tokenize(' a b , a b , a , a b ', ',') satisfies not(matches($s, '^(?:\t\ta\t\tb\t\t)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\W)$')) and (every $s in tokenize('A,,a,a,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,', ',') satisfies not(matches($s, '^(?:\W)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\w)$')) and (every $s in tokenize(',,,,,},,,, ,,', ',') satisfies not(matches($s, '^(?:\w)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:([ ]|[\w-[0-9]])+)$')) and (every $s in tokenize('09az AZ90', ',') satisfies not(matches($s, '^(?:([ ]|[\w-[0-9]])+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\w-[b-y]]+)$')) and (every $s in tokenize('bbbaaaABCD09zzzyyy,bbbaaaABCD09zzzyyy,bbbaaaABCD09zzzyyy,bbbaaaABCD09zzzyyy', ',') satisfies not(matches($s, '^(?:[\w-[b-y]]+)$')))
(every $s in tokenize('', ';') satisfies matches($s, '^(?:[\w-[b-y!.,]]+)$')) and (every $s in tokenize('!.,bbbaaaABCD09zzzyyy', ';') satisfies not(matches($s, '^(?:[\w-[b-y!.,]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\w-[b-y\p{Po}]]+)$')) and (every $s in tokenize('!#bbbaaaABCD09zzzyyy', ',') satisfies not(matches($s, '^(?:[\w-[b-y\p{Po}]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\w-[b-y\s]]+)$')) and (every $s in tokenize('  bbbaaaABCD09zzzyyy', ',') satisfies not(matches($s, '^(?:[\w-[b-y\s]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\w-[\d]]+)$')) and (every $s in tokenize('0AZaz9', ',') satisfies not(matches($s, '^(?:[\w-[\d]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\w-[\d\p{Po}]]+)$')) and (every $s in tokenize('!#0AZaz9', ',') satisfies not(matches($s, '^(?:[\w-[\d\p{Po}]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\w-[\p{Ll}]]+)$')) and (every $s in tokenize('a09AZz', ',') satisfies not(matches($s, '^(?:[\w-[\p{Ll}]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\w-[\p{Ll}\s]]+)$')) and (every $s in tokenize('a09AZz', ',') satisfies not(matches($s, '^(?:[\w-[\p{Ll}\s]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[\w-[\p{Po}]]+)$')) and (every $s in tokenize('#a09AZz!', ',') satisfies not(matches($s, '^(?:[\w-[\p{Po}]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[X-\]]+)$')) and (every $s in tokenize('wWXYZxyz[\]^', ',') satisfies not(matches($s, '^(?:[X-\]]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[X-a]+)$')) and (every $s in tokenize('wWAXYZaxyz', ',') satisfies not(matches($s, '^(?:[X-a]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[X-c]+)$')) and (every $s in tokenize('wWABCXYZabcxyz', ',') satisfies not(matches($s, '^(?:[X-c]+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[^-z]+)$')) and (every $s in tokenize('aaz,a-z', ',') satisfies not(matches($s, '^(?:[^-z]+)$')))
(every $s in tokenize('\.,\s,\S,\i,\I,\c,\C,\d,\D,\w,\W', ';') satisfies matches($s, '^(?:\\.,\\s,\\S,\\i,\\I,\\c,\\C,\\d,\\D,\\w,\\W)$')) and (every $s in tokenize('', ';') satisfies not(matches($s, '^(?:\\.,\\s,\\S,\\i,\\I,\\c,\\C,\\d,\\D,\\w,\\W)$')))
(every $s in tokenize('true,false', ',') satisfies matches($s, '^(?:(true|false))$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:(true|false))$')))
(every $s in tokenize('true', ',') satisfies matches($s, '^(?:true)$')) and (every $s in tokenize('false', ',') satisfies not(matches($s, '^(?:true)$')))
(every $s in tokenize('\t', ',') satisfies matches($s, '^(?:\\t)$')) and (every $s in tokenize('t,\\t, ', ',') satisfies not(matches($s, '^(?:\\t)$')))
(every $s in tokenize('&#xA;&#xD;a&#xA;&#xD;b', ',') satisfies (matches($s, '^(?:\n\ra\n\rb)$'))) and          (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\n\ra\n\rb)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsLatin-1Supplement}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsLatin-1Supplement}+)$')))
(every $s in tokenize('zabcsdea', ',') satisfies matches($s, '^(?:\c\i*a)$')) and (every $s in tokenize('ab', ',') satisfies not(matches($s, '^(?:\c\i*a)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsGreekExtended}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsGreekExtended}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{IsCyrillic}+)$')) and (every $s in tokenize('a', ',') satisfies not(matches($s, '^(?:\p{IsCyrillic}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsGeorgian}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsGeorgian}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\P{Lm}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\P{Lm}*)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsHebrew}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsHebrew}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{Lo}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Lo}*)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsArabicPresentationForms-A}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsArabicPresentationForms-A}+)$')))
(every $s in tokenize('),,,,,,,,,,,,,,,,,,,,:,,,,,,,,,,,,,,,,,,,,', ',') satisfies matches($s, '^(?:\D)$'))          and (every $s in tokenize('0,,,,,,,,,,,,,,,,,,9,,,,,,,,,,,,,,,,,,,', ',') satisfies not(matches($s, '^(?:\D)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsArabic}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsArabic}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsSyriac}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsSyriac}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsThaana}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsThaana}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsEthiopic}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsEthiopic}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsDevanagari}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsDevanagari}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsBengali}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsBengali}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsGurmukhi}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsGurmukhi}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsGujarati}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsGujarati}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsOriya}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsOriya}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsTamil}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsTamil}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsTelugu}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsTelugu}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsKannada}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsKannada}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsMalayalam}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsMalayalam}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsSinhala}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsSinhala}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsThai}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsThai}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsLao}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsLao}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsTibetan}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsTibetan}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsMyanmar}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsMyanmar}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsKhmer}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsKhmer}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsCherokee}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCherokee}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsUnifiedCanadianAboriginalSyllabics}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsUnifiedCanadianAboriginalSyllabics}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsOgham}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsOgham}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsRunic}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsRunic}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsEnclosedCJKLettersandMonths}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsEnclosedCJKLettersandMonths}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsHangulCompatibilityJamo}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsHangulCompatibilityJamo}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsHangulJamo}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsHangulJamo}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsCJKCompatibility}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCJKCompatibility}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsKatakana}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsKatakana}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsHiragana}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsHiragana}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsBopomofoExtended}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsBopomofoExtended}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsBopomofo}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsBopomofo}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsYiSyllables}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsYiSyllables}+)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\p{Nl}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{Nl}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:\P{Nd}*)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\P{Nd}*)$')))
(every $s in tokenize('', ',') satisfies matches($s, '^(?:[])$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:[])$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsKangxiRadicals}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsKangxiRadicals}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsCJKRadicalsSupplement}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCJKRadicalsSupplement}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsKanbun}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsKanbun}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsCJKCompatibilityIdeographs}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCJKCompatibilityIdeographs}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsSpecials}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsSpecials}+)$')))
(every $s in tokenize(',', ',') satisfies matches($s, '^(?:\p{IsCJKUnifiedIdeographs}+)$')) and (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\p{IsCJKUnifiedIdeographs}+)$')))
every $var in (1, 2, 3) satisfies $var eq 1 or $var eq 2 or $var eq 3
every $var in (true(), true(), true()) satisfies $var
every $var in (true(), true(), xs:hexBinary("FF")) satisfies $var
every $var in (true(), xs:hexBinary("FF"), true()) satisfies $var
every $var in (xs:hexBinary("FF"), true(), true()) satisfies $var
every $x as xs:string in ("cat","dog","rat"), $y as xs:integer in (3, 3, 3) satisfies fn:string-length($x) = $y
every $x as xs:string in ("cat","dog","rat") satisfies fn:string-length($x) = 3
every $x in (1, 1) satisfies $x + $x = 2
every $x in (1,2,3), $y in (4,5,6) satisfies $x * $y = 10
every $x in (1,2,3), $y in (4,5,6) satisfies $x + $y = 5
every $x in (1,2,3), $y in (4,5,6) satisfies $x - $y = 5
every $x in (1,2,3), $y in (4,5,6) satisfies $x div $y = 2
every $x in (1,2,3), $y in (4,5,6) satisfies $x idiv $y = 2
every $x in (1,2,3), $y in (4,5,6) satisfies fn:string($x) = fn:string($y)
every $x in (1,2,3), $y in (4,5,6) satisfies xs:decimal($x) = xs:decimal($y)
every $x in (1,2,3), $y in (4,5,6) satisfies xs:double($x) = xs:double($y)
every $x in (1,2,3), $y in (4,5,6) satisfies xs:float($x) = xs:float($y)
every $x in (1,2,3), $y in (4,5,6) satisfies xs:integer($x) = xs:integer($y)
every $x in (1, 2) satisfies $x + $x = 3
every $x in (1, 2) satisfies $x = 1 and ($x +1) = 2
every $x in (1, 2) satisfies $x = 1 or $x = 2
every $x in (1, 2) satisfies $x - 2 = 2
every $x in (1, 2) satisfies $x * 2 = 4
every $x in (1, 2) satisfies $x div 2 = 1
every $x in (1, 2) satisfies $x idiv 2 = 1
every $x in (1, 2) satisfies fn:avg(($x, 1)) = 1
every $x in (1, 2) satisfies fn:count(($x)) = 1
every $x in (1, 2) satisfies fn:not($x)
every $x in (1, 2) satisfies fn:string($x) = "1"
every $x in (1, 2) satisfies fn:string-length(xs:string($x)) = 1
every $x in (1, 2) satisfies fn:true()
every $x in ("1980-05-05T13:13:13Z", "1980-05-05T13:13:13Z"), $y in ("1980-05-05T13:13:13Z","1980-05-05T13:13:13Z") satisfies xs:dateTime($x) = xs:dateTime($y)
every $x in ("1985-07-05Z", "1985-07-05Z"), $y in ("1985-07-05Z","1985-07-05Z") satisfies xs:date($x) = xs:date($y)
every $x in (1 to 10)[. div 2 = 11] satisfies false()
every $x in (1 to 10)[. mod 2 = 0] satisfies true()
every $x in (2, 2) satisfies $x - 2 = 0
every $x in ("A","B","C") satisfies $x = "A"
every $x in ("true", "false"), $y in ("false","true") satisfies xs:boolean($x) = xs:boolean($y)
exactly-one( () )
exactly-one()
exactly-one(1, 2)
exactly-one( (1, 2, 3) )
(exactly-one('a'))
exactly-one("one") eq "one"
exactly-one(/works[1]/employee[12]) >> exactly-one(/works[1]/employee[12]/following::employee)
exactly-one(/works[1]/employee[12]) >> exactly-one(/works[1]/employee[12]/following-sibling::employee)
exactly-one(/works[1]/employee[12]/following::employee) << exactly-one(/works[1]/employee[12]/following::employee)
exactly-one(/works[1]/employee[12]/following::employee) >> exactly-one(/works[1]/employee[12]/following::employee)
exactly-one(/works[1]/employee[12]/following::employee) << exactly-one(/works[1]/employee[12]/overtime[1])
exactly-one(/works[1]/employee[12]/following::employee) is exactly-one(/works[1]/employee[12])
exactly-one(/works[1]/employee[12]/following-sibling::employee) << exactly-one(/works[1]/employee[12]/following-sibling::employee)
exactly-one(/works[1]/employee[12]/following-sibling::employee) >> exactly-one(/works[1]/employee[12]/following-sibling::employee)
exactly-one(/works[1]/employee[12]/following-sibling::employee) << exactly-one(/works[1]/employee[12]/overtime[1])
exactly-one(/works[1]/employee[12]/following-sibling::employee) is exactly-one(/works[1]/employee[12])
exactly-one(/works[1]/employee[12]/overtime/day[1]/following-sibling::day) << exactly-one(/works[1]/employee[13])
exactly-one(/works[1]/employee[13]) >> exactly-one(/works[1]/employee[12]/overtime[1]/day[1]/following::day)
exactly-one(/works[1]/employee[13]) >> exactly-one(/works[1]/employee[12]/overtime[1]/day[1]/following-sibling::day)
exactly-one(/works[1]/employee[13]) >> exactly-one(/works[1]/employee[12]/overtime[1]/day[2]/preceding::day)
exactly-one(/works[1]/employee[13]) >> exactly-one(/works[1]/employee[12]/preceding-sibling::employee[1])
exactly-one(/works[1]/employee[13]) >> exactly-one(/works[1]/employee[2]/preceding::employee)
exactly-one(/works[1]/employee[13]) >> exactly-one(/works[1]/employee[2]/preceding-sibling::employee)
exactly-one(/works[1]/employee[2]/preceding::employee) << exactly-one(/works[1])
exactly-one(/works[1]/employee[2]/preceding::employee) << exactly-one(/works[1]/employee[2])
exactly-one(/works[1]/employee[2]/preceding::employee) << exactly-one(/works[1]/employee[2]/preceding::employee)
exactly-one(/works[1]/employee[2]/preceding::employee) >> exactly-one(/works[1]/employee[2]/preceding::employee)
exactly-one(/works[1]/employee[2]/preceding::employee) is exactly-one(/works[1]/employee[2])
exactly-one(/works[1]/employee[2]/preceding-sibling::employee) << exactly-one(/works[1])
exactly-one(/works[1]/employee[2]/preceding-sibling::employee) << exactly-one(/works[1]/employee[2])
exactly-one(/works[1]/employee[2]/preceding-sibling::employee) << exactly-one(/works[1]/employee[2]/preceding-sibling::employee)
exactly-one(/works[1]/employee[2]/preceding-sibling::employee) >> exactly-one(/works[1]/employee[2]/preceding-sibling::employee)
exactly-one(/works[1]/employee[2]/preceding-sibling::employee) is exactly-one(/works[1]/employee[2])
exactly-one(/works/employee[12]/following::employee) is exactly-one(/works/employee[13])
exactly-one(/works/employee[12]/following-sibling::employee) is exactly-one(/works/employee[13])
exactly-one(/works/employee[1]/ancestor-or-self::works) << exactly-one(/works/employee[1])
exactly-one(/works/employee[1]/ancestor-or-self::works) << exactly-one(/works/employee[1]/ancestor-or-self::works)
exactly-one(/works/employee[1]/ancestor-or-self::works) >> exactly-one(/works/employee[1]/ancestor-or-self::works)
exactly-one(/works/employee[1]/ancestor-or-self::works) >> exactly-one(/works/employee[1]/hours)
exactly-one(/works/employee[1]/ancestor-or-self::works) is exactly-one(/works)
exactly-one(/works/employee[1]/ancestor-or-self::works) is exactly-one(/works/employee[1])
exactly-one(/works/employee[1]/ancestor::works) << exactly-one(/works/employee[1])
exactly-one(/works/employee[1]/ancestor::works) << exactly-one(/works/employee[1]/ancestor::works)
exactly-one(/works/employee[1]/ancestor::works) >> exactly-one(/works/employee[1]/ancestor::works)
exactly-one(/works/employee[1]/ancestor::works) >> exactly-one(/works/employee[1]/hours)
exactly-one(/works/employee[1]/ancestor::works) is exactly-one(/works)
exactly-one(/works/employee[1]/ancestor::works) is exactly-one(/works/employee[1])
exactly-one(/works/employee[1]) >> exactly-one(/works/employee[1]/ancestor-or-self::works)
exactly-one(/works/employee[1]) >> exactly-one(/works/employee[1]/ancestor::works)
exactly-one(/works/employee[2]/preceding::employee) is exactly-one(/works/employee[1])
exactly-one(/works/employee[2]/preceding-sibling::employee) is exactly-one(/works/employee[1])
"example.com/" cast as xs:anyURI eq xs:anyURI('example.com/')
() except ()
(exists( '' ))
(exists( () ))
exists()
exists((1))
exists(1)
exists(1, 2)
exists((1, 2, 3))
(exists( ('a', 'b', 'c') ))
(exists( ('a', 'b', 'c') ), exists( '' ), exists( () ), exists( false() ))
(exists( false() ))
exists(fn:function-name#1)
exists(fn:timezone-from-dateTime(fn:current-dateTime()))
exists(fn:timezone-from-dateTime(xs:dateTimeStamp("2011-07-28T12:34:56-08:00")))
exists(for $x in (1 to 10)[. mod 2 = 0] return "blah")
exists(for $x in (1 to 10)[. mod 2 = 0] return floor($x))
exists(for $x in (1 to 10)[. mod 2 = 0] return true())
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'anyURI'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'base64Binary'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'boolean'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'byte'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'date'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'dateTime'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'dateTimeStamp'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'dayTimeDuration'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'decimal'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'double'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'duration'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'ENTITIES'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'ENTITY'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'float'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'gDay'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'gMonth'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'gMonthDay'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'gYear'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'gYearMonth'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'hexBinary'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'ID'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'IDREF'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'IDREFS'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'int'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'integer'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'language'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'long'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'Name'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'NCName'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'negativeInteger'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'NMTOKEN'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'NMTOKENS'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'nonNegativeInteger'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'nonPositiveInteger'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'normalizedString'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'positiveInteger'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'QName'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'short'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'string'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'time'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'token'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'unsignedByte'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'unsignedInt'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'unsignedLong'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'unsignedShort'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'untypedAtomic'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'yearMonthDuration'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'abs'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'append'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'filter'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'flatten'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'fold-left'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'fold-right'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'for-each'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'for-each-pair'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'get'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'head'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'insert-before'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'join'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'put'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'remove'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'reverse'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'size'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'sort'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'subarray'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'subarray'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'tail'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'avg'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'boolean'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'ceiling'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'codepoint-equal'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'codepoints-to-string'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'compare'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'compare'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'concat'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'contains'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'contains'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'count'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'current-date'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'current-dateTime'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'current-time'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'data'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'data'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'dateTime'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'day-from-date'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'day-from-dateTime'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'days-from-duration'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'deep-equal'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'deep-equal'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'empty'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'encode-for-uri'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'ends-with'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'ends-with'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'exactly-one'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'exists'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'false'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'filter'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'floor'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'fold-left'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'fold-right'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'for-each'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'function-arity'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'function-lookup'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'function-name'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'has-children'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'has-children'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'head'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'hours-from-dateTime'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'hours-from-duration'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'hours-from-time'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'id'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'id'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'idref'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'idref'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'implicit-timezone'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'index-of'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'index-of'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'innermost'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'insert-before'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'iri-to-uri'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'last'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'local-name'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'local-name'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'local-name-from-QName'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'lower-case'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/map', 'contains'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/map', 'entry'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/map', 'for-each'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/map', 'get'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/map', 'keys'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/map', 'merge'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/map', 'merge'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/map', 'put'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/map', 'remove'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/map', 'size'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'matches'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'acos'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'asin'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'atan'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'atan2'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'cos'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'exp'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'exp10'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'log'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'log10'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'pi'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'pow'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'sin'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'sqrt'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'tan'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'max'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'max'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'min'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'min'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'minutes-from-dateTime'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'minutes-from-duration'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'minutes-from-time'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'month-from-date'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'month-from-dateTime'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'months-from-duration'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'name'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'name'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'namespace-uri'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'namespace-uri'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'namespace-uri-from-QName'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'node-name'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'node-name'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'normalize-space'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'normalize-space'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'not'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'number'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'number'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'one-or-more'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'outermost'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'parse-json'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'path'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'path'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'position'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'prefix-from-QName'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'QName'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'random-number-generator'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'remove'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'reverse'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'root'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'root'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'round'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'round'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'round-half-to-even'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'round-half-to-even'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'seconds-from-dateTime'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'seconds-from-duration'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'seconds-from-time'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'starts-with'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'starts-with'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'string'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'string'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'string-join'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'string-join'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'string-length'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'string-length'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'string-to-codepoints'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'subsequence'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'subsequence'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'substring'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'substring'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'substring-after'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'substring-before'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'sum'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'sum'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'tail'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'timezone-from-date'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'timezone-from-dateTime'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'timezone-from-time'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'tokenize'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'tokenize'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'tokenize'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'trace'), 2))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'translate'), 3))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'true'), 0))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'unordered'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'upper-case'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'year-from-date'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'year-from-dateTime'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'years-from-duration'), 1))
exists(function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'zero-or-one'), 1))
exists(one-or-more(("one", 2)))
exists(Q{http://www.w3.org/2001/XMLSchema}anyURI#1)
exists(Q{http://www.w3.org/2001/XMLSchema}base64Binary#1)
exists(Q{http://www.w3.org/2001/XMLSchema}boolean#1)
exists(Q{http://www.w3.org/2001/XMLSchema}byte#1)
exists(Q{http://www.w3.org/2001/XMLSchema}date#1)
exists(Q{http://www.w3.org/2001/XMLSchema}dateTime#1)
exists(Q{http://www.w3.org/2001/XMLSchema}dayTimeDuration#1)
exists(Q{http://www.w3.org/2001/XMLSchema}decimal#1)
exists(Q{http://www.w3.org/2001/XMLSchema}double#1)
exists(Q{http://www.w3.org/2001/XMLSchema}duration#1)
exists(Q{http://www.w3.org/2001/XMLSchema}ENTITIES#1)
exists(Q{http://www.w3.org/2001/XMLSchema}ENTITY#1)
exists(Q{http://www.w3.org/2001/XMLSchema}float#1)
exists(Q{http://www.w3.org/2001/XMLSchema}gDay#1)
exists(Q{http://www.w3.org/2001/XMLSchema}gMonth#1)
exists(Q{http://www.w3.org/2001/XMLSchema}gMonthDay#1)
exists(Q{http://www.w3.org/2001/XMLSchema}gYear#1)
exists(Q{http://www.w3.org/2001/XMLSchema}gYearMonth#1)
exists(Q{http://www.w3.org/2001/XMLSchema}hexBinary#1)
exists(Q{http://www.w3.org/2001/XMLSchema}ID#1)
exists(Q{http://www.w3.org/2001/XMLSchema}IDREF#1)
exists(Q{http://www.w3.org/2001/XMLSchema}IDREFS#1)
exists(Q{http://www.w3.org/2001/XMLSchema}int#1)
exists(Q{http://www.w3.org/2001/XMLSchema}integer#1)
exists(Q{http://www.w3.org/2001/XMLSchema}language#1)
exists(Q{http://www.w3.org/2001/XMLSchema}long#1)
exists(Q{http://www.w3.org/2001/XMLSchema}Name#1)
exists(Q{http://www.w3.org/2001/XMLSchema}NCName#1)
exists(Q{http://www.w3.org/2001/XMLSchema}negativeInteger#1)
exists(Q{http://www.w3.org/2001/XMLSchema}NMTOKEN#1)
exists(Q{http://www.w3.org/2001/XMLSchema}NMTOKENS#1)
exists(Q{http://www.w3.org/2001/XMLSchema}nonNegativeInteger#1)
exists(Q{http://www.w3.org/2001/XMLSchema}nonPositiveInteger#1)
exists(Q{http://www.w3.org/2001/XMLSchema}normalizedString#1)
exists(Q{http://www.w3.org/2001/XMLSchema}positiveInteger#1)
exists(Q{http://www.w3.org/2001/XMLSchema}QName#1)
exists(Q{http://www.w3.org/2001/XMLSchema}short#1)
exists(Q{http://www.w3.org/2001/XMLSchema}string#1)
exists(Q{http://www.w3.org/2001/XMLSchema}time#1)
exists(Q{http://www.w3.org/2001/XMLSchema}token#1)
exists(Q{http://www.w3.org/2001/XMLSchema}unsignedByte#1)
exists(Q{http://www.w3.org/2001/XMLSchema}unsignedInt#1)
exists(Q{http://www.w3.org/2001/XMLSchema}unsignedLong#1)
exists(Q{http://www.w3.org/2001/XMLSchema}unsignedShort#1)
exists(Q{http://www.w3.org/2001/XMLSchema}untypedAtomic#1)
exists(Q{http://www.w3.org/2001/XMLSchema}yearMonthDuration#1)
exists(Q{http://www.w3.org/2005/xpath-functions}abs#1)
exists(Q{http://www.w3.org/2005/xpath-functions}avg#1)
exists(Q{http://www.w3.org/2005/xpath-functions}boolean#1)
exists(Q{http://www.w3.org/2005/xpath-functions}ceiling#1)
exists(Q{http://www.w3.org/2005/xpath-functions}codepoint-equal#2)
exists(Q{http://www.w3.org/2005/xpath-functions}codepoints-to-string#1)
exists(Q{http://www.w3.org/2005/xpath-functions}compare#2)
exists(Q{http://www.w3.org/2005/xpath-functions}compare#3)
exists(Q{http://www.w3.org/2005/xpath-functions}concat#3)
exists(Q{http://www.w3.org/2005/xpath-functions}contains#2)
exists(Q{http://www.w3.org/2005/xpath-functions}contains#3)
exists(Q{http://www.w3.org/2005/xpath-functions}count#1)
exists(Q{http://www.w3.org/2005/xpath-functions}current-date#0)
exists(Q{http://www.w3.org/2005/xpath-functions}current-dateTime#0)
exists(Q{http://www.w3.org/2005/xpath-functions}current-time#0)
exists(Q{http://www.w3.org/2005/xpath-functions}data#0)
exists(Q{http://www.w3.org/2005/xpath-functions}data#1)
exists(Q{http://www.w3.org/2005/xpath-functions}dateTime#2)
exists(Q{http://www.w3.org/2005/xpath-functions}day-from-date#1)
exists(Q{http://www.w3.org/2005/xpath-functions}day-from-dateTime#1)
exists(Q{http://www.w3.org/2005/xpath-functions}days-from-duration#1)
exists(Q{http://www.w3.org/2005/xpath-functions}deep-equal#2)
exists(Q{http://www.w3.org/2005/xpath-functions}deep-equal#3)
exists(Q{http://www.w3.org/2005/xpath-functions}empty#1)
exists(Q{http://www.w3.org/2005/xpath-functions}encode-for-uri#1)
exists(Q{http://www.w3.org/2005/xpath-functions}ends-with#2)
exists(Q{http://www.w3.org/2005/xpath-functions}ends-with#3)
exists(Q{http://www.w3.org/2005/xpath-functions}exactly-one#1)
exists(Q{http://www.w3.org/2005/xpath-functions}exists#1)
exists(Q{http://www.w3.org/2005/xpath-functions}false#0)
exists(Q{http://www.w3.org/2005/xpath-functions}filter#2)
exists(Q{http://www.w3.org/2005/xpath-functions}floor#1)
exists(Q{http://www.w3.org/2005/xpath-functions}fold-left#3)
exists(Q{http://www.w3.org/2005/xpath-functions}fold-right#3)
exists(Q{http://www.w3.org/2005/xpath-functions}for-each#2)
exists(Q{http://www.w3.org/2005/xpath-functions}function-arity#1)
exists(Q{http://www.w3.org/2005/xpath-functions}function-lookup#2)
exists(Q{http://www.w3.org/2005/xpath-functions}function-name#1)
exists(Q{http://www.w3.org/2005/xpath-functions}has-children#0)
exists(Q{http://www.w3.org/2005/xpath-functions}has-children#1)
exists(Q{http://www.w3.org/2005/xpath-functions}head#1)
exists(Q{http://www.w3.org/2005/xpath-functions}hours-from-dateTime#1)
exists(Q{http://www.w3.org/2005/xpath-functions}hours-from-duration#1)
exists(Q{http://www.w3.org/2005/xpath-functions}hours-from-time#1)
exists(Q{http://www.w3.org/2005/xpath-functions}id#1)
exists(Q{http://www.w3.org/2005/xpath-functions}id#2)
exists(Q{http://www.w3.org/2005/xpath-functions}idref#1)
exists(Q{http://www.w3.org/2005/xpath-functions}idref#2)
exists(Q{http://www.w3.org/2005/xpath-functions}implicit-timezone#0)
exists(Q{http://www.w3.org/2005/xpath-functions}index-of#2)
exists(Q{http://www.w3.org/2005/xpath-functions}index-of#3)
exists(Q{http://www.w3.org/2005/xpath-functions}innermost#1)
exists(Q{http://www.w3.org/2005/xpath-functions}insert-before#3)
exists(Q{http://www.w3.org/2005/xpath-functions}iri-to-uri#1)
exists(Q{http://www.w3.org/2005/xpath-functions}last#0)
exists(Q{http://www.w3.org/2005/xpath-functions}local-name#0)
exists(Q{http://www.w3.org/2005/xpath-functions}local-name#1)
exists(Q{http://www.w3.org/2005/xpath-functions}local-name-from-QName#1)
exists(Q{http://www.w3.org/2005/xpath-functions}lower-case#1)
exists(Q{http://www.w3.org/2005/xpath-functions}matches#2)
exists(Q{http://www.w3.org/2005/xpath-functions/math}acos#1)
exists(Q{http://www.w3.org/2005/xpath-functions/math}asin#1)
exists(Q{http://www.w3.org/2005/xpath-functions/math}atan#1)
exists(Q{http://www.w3.org/2005/xpath-functions/math}atan2#2)
exists(Q{http://www.w3.org/2005/xpath-functions/math}cos#1)
exists(Q{http://www.w3.org/2005/xpath-functions/math}exp#1)
exists(Q{http://www.w3.org/2005/xpath-functions/math}exp10#1)
exists(Q{http://www.w3.org/2005/xpath-functions/math}log#1)
exists(Q{http://www.w3.org/2005/xpath-functions/math}log10#1)
exists(Q{http://www.w3.org/2005/xpath-functions/math}pi#0)
exists(Q{http://www.w3.org/2005/xpath-functions/math}pow#2)
exists(Q{http://www.w3.org/2005/xpath-functions/math}sin#1)
exists(Q{http://www.w3.org/2005/xpath-functions/math}sqrt#1)
exists(Q{http://www.w3.org/2005/xpath-functions/math}tan#1)
exists(Q{http://www.w3.org/2005/xpath-functions}max#1)
exists(Q{http://www.w3.org/2005/xpath-functions}max#2)
exists(Q{http://www.w3.org/2005/xpath-functions}min#1)
exists(Q{http://www.w3.org/2005/xpath-functions}min#2)
exists(Q{http://www.w3.org/2005/xpath-functions}minutes-from-dateTime#1)
exists(Q{http://www.w3.org/2005/xpath-functions}minutes-from-duration#1)
exists(Q{http://www.w3.org/2005/xpath-functions}minutes-from-time#1)
exists(Q{http://www.w3.org/2005/xpath-functions}month-from-date#1)
exists(Q{http://www.w3.org/2005/xpath-functions}month-from-dateTime#1)
exists(Q{http://www.w3.org/2005/xpath-functions}months-from-duration#1)
exists(Q{http://www.w3.org/2005/xpath-functions}name#0)
exists(Q{http://www.w3.org/2005/xpath-functions}name#1)
exists(Q{http://www.w3.org/2005/xpath-functions}namespace-uri#0)
exists(Q{http://www.w3.org/2005/xpath-functions}namespace-uri#1)
exists(Q{http://www.w3.org/2005/xpath-functions}namespace-uri-from-QName#1)
exists(Q{http://www.w3.org/2005/xpath-functions}node-name#0)
exists(Q{http://www.w3.org/2005/xpath-functions}node-name#1)
exists(Q{http://www.w3.org/2005/xpath-functions}normalize-space#0)
exists(Q{http://www.w3.org/2005/xpath-functions}normalize-space#1)
exists(Q{http://www.w3.org/2005/xpath-functions}not#1)
exists(Q{http://www.w3.org/2005/xpath-functions}number#0)
exists(Q{http://www.w3.org/2005/xpath-functions}number#1)
exists(Q{http://www.w3.org/2005/xpath-functions}one-or-more#1)
exists(Q{http://www.w3.org/2005/xpath-functions}outermost#1)
exists(Q{http://www.w3.org/2005/xpath-functions}path#0)
exists(Q{http://www.w3.org/2005/xpath-functions}path#1)
exists(Q{http://www.w3.org/2005/xpath-functions}position#0)
exists(Q{http://www.w3.org/2005/xpath-functions}prefix-from-QName#1)
exists(Q{http://www.w3.org/2005/xpath-functions}QName#2)
exists(Q{http://www.w3.org/2005/xpath-functions}remove#2)
exists(Q{http://www.w3.org/2005/xpath-functions}reverse#1)
exists(Q{http://www.w3.org/2005/xpath-functions}root#0)
exists(Q{http://www.w3.org/2005/xpath-functions}root#1)
exists(Q{http://www.w3.org/2005/xpath-functions}round#1)
exists(Q{http://www.w3.org/2005/xpath-functions}round#2)
exists(Q{http://www.w3.org/2005/xpath-functions}round-half-to-even#1)
exists(Q{http://www.w3.org/2005/xpath-functions}round-half-to-even#2)
exists(Q{http://www.w3.org/2005/xpath-functions}seconds-from-dateTime#1)
exists(Q{http://www.w3.org/2005/xpath-functions}seconds-from-duration#1)
exists(Q{http://www.w3.org/2005/xpath-functions}seconds-from-time#1)
exists(Q{http://www.w3.org/2005/xpath-functions}starts-with#2)
exists(Q{http://www.w3.org/2005/xpath-functions}starts-with#3)
exists(Q{http://www.w3.org/2005/xpath-functions}string#0)
exists(Q{http://www.w3.org/2005/xpath-functions}string#1)
exists(Q{http://www.w3.org/2005/xpath-functions}string-join#1)
exists(Q{http://www.w3.org/2005/xpath-functions}string-join#2)
exists(Q{http://www.w3.org/2005/xpath-functions}string-length#0)
exists(Q{http://www.w3.org/2005/xpath-functions}string-length#1)
exists(Q{http://www.w3.org/2005/xpath-functions}string-to-codepoints#1)
exists(Q{http://www.w3.org/2005/xpath-functions}subsequence#2)
exists(Q{http://www.w3.org/2005/xpath-functions}subsequence#3)
exists(Q{http://www.w3.org/2005/xpath-functions}substring#2)
exists(Q{http://www.w3.org/2005/xpath-functions}substring#3)
exists(Q{http://www.w3.org/2005/xpath-functions}substring-after#2)
exists(Q{http://www.w3.org/2005/xpath-functions}substring-before#2)
exists(Q{http://www.w3.org/2005/xpath-functions}sum#1)
exists(Q{http://www.w3.org/2005/xpath-functions}sum#2)
exists(Q{http://www.w3.org/2005/xpath-functions}tail#1)
exists(Q{http://www.w3.org/2005/xpath-functions}timezone-from-date#1)
exists(Q{http://www.w3.org/2005/xpath-functions}timezone-from-dateTime#1)
exists(Q{http://www.w3.org/2005/xpath-functions}timezone-from-time#1)
exists(Q{http://www.w3.org/2005/xpath-functions}tokenize#1)
exists(Q{http://www.w3.org/2005/xpath-functions}tokenize#2)
exists(Q{http://www.w3.org/2005/xpath-functions}tokenize#3)
exists(Q{http://www.w3.org/2005/xpath-functions}trace#1)
exists(Q{http://www.w3.org/2005/xpath-functions}trace#2)
exists(Q{http://www.w3.org/2005/xpath-functions}translate#3)
exists(Q{http://www.w3.org/2005/xpath-functions}true#0)
exists(Q{http://www.w3.org/2005/xpath-functions}unordered#1)
exists(Q{http://www.w3.org/2005/xpath-functions}upper-case#1)
exists(Q{http://www.w3.org/2005/xpath-functions}year-from-date#1)
exists(Q{http://www.w3.org/2005/xpath-functions}year-from-dateTime#1)
exists(Q{http://www.w3.org/2005/xpath-functions}years-from-duration#1)
exists(Q{http://www.w3.org/2005/xpath-functions}zero-or-one#1)
exists(reverse((1)))
exists(reverse((1, 2, 3)))
exists(seconds-from-duration(implicit-timezone()))
exists(text {(1 to 10)[. mod 2 = 0]})
exists(timezone-from-date(current-date()))
exists(timezone-from-dateTime(current-dateTime()))
exists(timezone-from-time(current-time()))
exists(xs:double("+INF"))
exists(xs:float("+INF"))
exists(xs:hexBinary("aa"))
exists(xs:hexBinary("Ab08bcFFAA08b6"))
exists(xs:hexBinary("FF"))
<e xmlns=""/>
<e xmlns="{()}"/>
<e xmlns="{1}"/>/@xmlns
<e xmlns="content{()}"/>
<e xmlns="content{{ {'1'}"/>
<e xmlns:d="http://www.example.com/"/>, d:d
<e xmlns="{"http://example.com/"}"/>
<e xmlns="http://example.com/3">{namespace-uri-from-QName(node-name(<e/>)), namespace-uri-from-QName(node-name(element e2 {()}))}</e>
<e xmlns="http://example.com/"> <b xmlns=""> { attribute {QName("http://example.com/2", "p:attr")} {()} } </b> </e>
<e xmlns="http://example.com/"> {namespace-uri-from-QName(node-name(element anElement{"text"}))} </e>/string()
<e xmlns="http://{exa}mple.com/"/>/@xmlns
<e xmlns="http://www.example.com/A" xmlns:A="http://www.example.com/C"> <b xmlns:B="http://www.example.com/C" xmlns=""/> </e>/b
<e xmlns="http://www.example.com/"> <e xmlns="http://www.example.com/"/> </e>
<e xmlns:p="{"/>
<e xmlns:p="{()}"/>
<e xmlns:p="}"/>
<e xmlns:p="{content"/>
<e xmlns:p="}content"/>
<e xmlns:p="content{"/>
<e xmlns:p="content{()}"/>
<e xmlns:p="content}"/>
<e xmlns:p="content{{ {'1'}"/>
<e xmlns:p="content{content"/>
<e xmlns:p="content}content"/>
<e xmlns:p="{"http://example.com/"}"/>
<e xmlns:p="http://example.com"/>
<e xmlns:p="http://example.com/{{1}}"/>
<e xmlns:p="http://example.com/" p:attr1="value"> { attribute {QName("http://example.com/", "attr2")} {()} } </e>
<e xmlns:p="http://example.com/" p:attr=""> { attribute {QName("http://example.com/", "p:attr")} {()} } </e>
<e xmlns:p="http://www.example.com/"> <e xmlns:p="http://www.example.com/"/> </e>
<e xmlns:p="http://www.w3.org/2001/XMLSchema"> <b xmlns:p="http://www.w3.org/2001/XMLSchema"/> {p:integer(1)} </e>
<e xmlns:p="http://www.w3.org/2005/xpath-functions"> <b xmlns:p="http://www.w3.org/2001/XMLSchema"/> {fn:count(0)} </e>
<e xmlns:prefix="http://example.com/"> { xs:QName("prefix:localName") } </e>
<e xmlns="/www.example.com/{"/>/@xmlns
<e xmlns="/www.example.com/}"/>/@xmlns
<e xmlns:xml="http://www.w3.org/XML/1998/namespace"/>
<e xmlns:xml="http://www.w3.org/XML/1998/namespace" xmlns:xml="http://www.w3.org/XML/1998/namespace"/>
<e xmlns="" xmlns=""/>
<e xmlns="{xs:anyURI("http://www.example.com/")}"/>/@xmlns
<e xmlns="{xs:untypedAtomic("http://www.example.com/")}"/>/@xmlns
:f()
(false())
false(1)
false() = 5
false() and false()
false() and true()
'false' cast as xs:boolean eq false()
false() cast as xs:boolean eq false()
false() cast as xs:string eq "false"
false() cast as xs:untypedAtomic eq xs:untypedAtomic("false")
false() cast as xs:untypedAtomic instance of xs:untypedAtomic
false() eq false()
((((((((((((false() eq false()) eq false()) eq false()) eq false()) eq false()) eq false()) eq false()) eq false()) eq false()) eq false()) eq false()) eq false()) eq false()
false() instance of xs:anyAtomicType
false() instance of xs:boolean
false() le true()
false() lt true()
false() ne true()
false() or count((1, 2, 3, timezone-from-time(current-time()), 4))
false() or false()
false() or true()
false() != xs:anyURI("example.com/")
false() = xs:anyURI("example.com/")
false() != xs:string("false")
false() = xs:string("false")
false() <= xs:untypedAtomic("false")
false() = xs:untypedAtomic("false")
false() >= xs:untypedAtomic("false")
false() != xs:untypedAtomic("falseERR")
false() = xs:untypedAtomic("falseERR")
false() != xs:untypedAtomic("true")
false() < xs:untypedAtomic("true")
<f><c></f></c>
f:f:()
<figlist> { for $f in //figure return <figure> { $f/@* } { $f/title } </figure> } </figlist>
filter((12, 4, 46, 23, -8), function($x){$x gt 10})
filter(("apple", "pear", "apricot", "advocado", "orange", current-date()), ends-with(?, 'e'))
filter(("apple", "pear", "apricot", "advocado", "orange"), function($x){if(starts-with($x,'a')) then true() else ()})
filter( ("apple", "pear", "apricot", "advocado", "orange"), function($x){if(starts-with($x,'a')) then (true(), true()) else false()})
filter(("apple", "pear", "apricot", "advocado", "orange"), normalize-space#1)
filter(("apple", "pear", "apricot", "advocado", "orange"),starts-with(?, "a"))
"first second third"=>concat()
"first second third"=>concat(" fourth")
("first","second","third","fourth")=>head()
(floor( () ))
floor()
floor(0.0)
floor(0.000000001)
floor(0.000000001e0)
floor(0.0e0)
floor(-0.1)
floor(-0.1e0)
floor(10.5) eq 10
floor(-10.5) eq -11
floor(1, 2)
floor(-12345678.567890)
floor(-12345678.567890e0)
floor(-1234567891234567.2)
floor(-1234567891234567.2e0)
floor(12.5)
floor(12.5e0)
floor(12.9)
floor(12.9e0)
(floor#1, ceiling#1, round#1, abs#1)?1
(floor#1, ceiling#1, round#1, abs#1)[.?1 = 1]
(floor#1, ceiling#1, round#1, abs#1)[?1 = 1]
[floor#1, ceiling#1, round#1, abs#1]?2(1.3)
(floor(5))
(floor(-5.1))
(floor(5.1))
(floor(-5.7))
(floor(5.7))
(floor(5), floor(5.1), floor(5.7), floor(-5.1), floor(-5.7), floor( () ))
floor("a string")
floor(unordered((1 to 10)[. div 2 = 0]))
floor(xs:byte(.)) instance of xs:integer
floor(xs:double('-0'))
floor(xs:double('-INF'))
floor(xs:double('INF'))
floor(xs:double('NaN'))
floor(xs:float(0.000000001e0))
floor(xs:float(0.0e0))
floor(xs:float(-0.1e0))
floor(xs:float(-1234567.2e0))
floor(xs:float(-12345678.567890e0))
floor(xs:float(12.5e0))
floor(xs:float(12.9e0))
floor(xs:float(xs:float('-0')))
floor(xs:float(xs:float('-INF')))
floor(xs:float(xs:float('INF')))
floor(xs:float(xs:float('NaN')))
floor(xs:int(.)) instance of xs:integer
floor(xs:long(.)) instance of xs:integer
floor(xs:negativeInteger(.)) instance of xs:integer
floor(xs:nonNegativeInteger(.)) instance of xs:integer
floor(xs:nonPositiveInteger(.)) instance of xs:integer
floor(xs:positiveInteger(.)) instance of xs:integer
floor(xs:short(.)) instance of xs:integer
floor(xs:unsignedByte(.)) instance of xs:integer
floor(xs:unsignedInt(.)) instance of xs:integer
floor(xs:unsignedLong(.)) instance of xs:integer
floor(xs:unsignedShort(.)) instance of xs:integer
fn:abs(-10.5)
fn:abs(10.5)
fn:abs(1.1) instance of xs:decimal
fn:abs(1.1) instance of xs:integer
fn:abs(1e1) instance of xs:double
fn:abs(1e1) instance of xs:integer
fn:abs(fn:minutes-from-time(xs:time("23:20:00Z")))
fn:abs( fn:reverse( (1, xs:decimal(2.2), xs:float(3.3), xs:double(4.4)) )[2] )
fn:abs(xs:anyURI("www.examples.org"))
fn:abs(xs:boolean("0"))
fn:abs(xs:boolean("1"))
fn:abs(xs:boolean(fn:false()))
fn:abs(xs:boolean(fn:true()))
fn:abs(xs:byte(-4))
fn:abs(xs:byte(-4)) instance of xs:integer
fn:abs(xs:date("2002-10-09"))
fn:abs(xs:dateTime("2002-10-10T12:00:00-05:00"))
fn:abs(xs:decimal("-0"))
fn:abs(xs:decimal("0"))
fn:abs(xs:decimal("617375191608514839"))
fn:abs(xs:decimal("-999999999999999999"))
fn:abs(xs:decimal("999999999999999999"))
fn:abs(xs:decimal("-INF"))
fn:abs(xs:decimal("INF"))
fn:abs(xs:decimal("-NaN"))
fn:abs(xs:decimal("NaN"))
fn:abs(xs:double("-0"))
fn:abs(xs:double("0"))
fn:abs(xs:double("-1.7976931348623157E308"))
fn:abs(xs:double("1.7976931348623157E308"))
fn:abs(xs:double("-INF"))
fn:abs(xs:double("INF"))
fn:abs(xs:double("NaN"))
fn:abs(xs:float("-0"))
fn:abs(xs:float("0"))
fn:abs(xs:float(1)) instance of xs:double
fn:abs(xs:float(1)) instance of xs:float
fn:abs(xs:float("-3.4028235E38"))
fn:abs(xs:float("3.4028235E38"))
fn:abs(xs:float("-INF"))
fn:abs(xs:float("INF"))
fn:abs(xs:float("NaN"))
fn:abs(xs:int("-0"))
fn:abs(xs:int("0"))
fn:abs(xs:int("-1873914410"))
fn:abs(xs:int("2147483647"))
fn:abs(xs:int("-2147483648"))
fn:abs(xs:int(-4))
fn:abs(xs:int(-4)) instance of xs:integer
fn:abs(xs:integer("-0"))
fn:abs(xs:integer("0"))
fn:abs(xs:integer(1)) instance of xs:integer
fn:abs(xs:integer(-4))
fn:abs(xs:integer(-4)) instance of xs:integer
fn:abs(xs:integer("-INF"))
fn:abs(xs:integer("INF"))
fn:abs(xs:integer("-NaN"))
fn:abs(xs:integer("NaN"))
fn:abs(xs:int("-INF"))
fn:abs(xs:int("INF"))
fn:abs(xs:int("-NaN"))
fn:abs(xs:int("NaN"))
fn:abs(xs:long("-0"))
fn:abs(xs:long("0"))
fn:abs(xs:long(-4))
fn:abs(xs:long(-4)) instance of xs:integer
fn:abs(xs:long("-INF"))
fn:abs(xs:long("INF"))
fn:abs(xs:long("-NaN"))
fn:abs(xs:long("NaN"))
fn:abs(xs:negativeInteger("-0"))
fn:abs(xs:negativeInteger("0"))
fn:abs(xs:negativeInteger("-1"))
fn:abs(xs:negativeInteger("2"))
fn:abs(xs:negativeInteger(-4))
fn:abs(xs:negativeInteger(-4)) instance of xs:integer
fn:abs(xs:negativeInteger("-INF"))
fn:abs(xs:negativeInteger("INF"))
fn:abs(xs:negativeInteger("-NaN"))
fn:abs(xs:negativeInteger("NaN"))
fn:abs(xs:nonNegativeInteger("-0"))
fn:abs(xs:nonNegativeInteger("0"))
fn:abs(xs:nonNegativeInteger("-2"))
fn:abs(xs:nonNegativeInteger(4))
fn:abs(xs:nonNegativeInteger(4)) instance of xs:integer
fn:abs(xs:nonNegativeInteger("-INF"))
fn:abs(xs:nonNegativeInteger("INF"))
fn:abs(xs:nonNegativeInteger("-NaN"))
fn:abs(xs:nonNegativeInteger("NaN"))
fn:abs(xs:nonPositiveInteger("-0"))
fn:abs(xs:nonPositiveInteger("0"))
fn:abs(xs:nonPositiveInteger("2"))
fn:abs(xs:nonPositiveInteger(-4))
fn:abs(xs:nonPositiveInteger(-4)) instance of xs:integer
fn:abs(xs:nonPositiveInteger("-INF"))
fn:abs(xs:nonPositiveInteger("INF"))
fn:abs(xs:nonPositiveInteger("-NaN"))
fn:abs(xs:nonPositiveInteger("NaN"))
fn:abs(xs:positiveInteger("-0"))
fn:abs(xs:positiveInteger("0"))
fn:abs(xs:positiveInteger("1"))
fn:abs(xs:positiveInteger("-2"))
fn:abs(xs:positiveInteger(4))
fn:abs(xs:positiveInteger(4)) instance of xs:integer
fn:abs(xs:positiveInteger("-INF"))
fn:abs(xs:positiveInteger("INF"))
fn:abs(xs:positiveInteger("-NaN"))
fn:abs(xs:positiveInteger("NaN"))
fn:abs(xs:short("-0"))
fn:abs(xs:short("0"))
fn:abs(xs:short("32767"))
fn:abs(xs:short("-32768"))
fn:abs(xs:short(-4))
fn:abs(xs:short(-4)) instance of xs:integer
fn:abs(xs:short("-5324"))
fn:abs(xs:short("-INF"))
fn:abs(xs:short("INF"))
fn:abs(xs:short("-NaN"))
fn:abs(xs:short("NaN"))
fn:abs(xs:string("1"))
fn:abs(xs:string("hello"))
fn:abs(xs:time("13:20:00-05:00"))
fn:abs(xs:unsignedByte(4))
fn:abs(xs:unsignedByte(4)) instance of xs:integer
fn:abs(xs:unsignedInt(4))
fn:abs(xs:unsignedInt(4)) instance of xs:integer
fn:abs(xs:unsignedLong("-0"))
fn:abs(xs:unsignedLong("0"))
fn:abs(xs:unsignedLong(4))
fn:abs(xs:unsignedLong(4)) instance of xs:integer
fn:abs(xs:unsignedLong("-INF"))
fn:abs(xs:unsignedLong("INF"))
fn:abs(xs:unsignedLong("-NaN"))
fn:abs(xs:unsignedLong("NaN"))
fn:abs(xs:unsignedShort("-0"))
fn:abs(xs:unsignedShort("0"))
fn:abs(xs:unsignedShort(4))
fn:abs(xs:unsignedShort("44633"))
fn:abs(xs:unsignedShort(4)) instance of xs:integer
fn:abs(xs:unsignedShort("65535"))
fn:abs(xs:unsignedShort("-INF"))
fn:abs(xs:unsignedShort("INF"))
fn:abs(xs:unsignedShort("-NaN"))
fn:abs(xs:unsignedShort("NaN"))
fn:avg(())
fn:avg((1 to 5))
fn:avg( (3, 4, 5) )
fn:avg(( (3, 4, 5), xs:float('NaN') ))
fn:avg(("a","b","c"))
fn:avg(( ("a", "b", "c", true()) ))
fn:avg(( concat('hi',' all') ))
fn:avg(( (false(), xs:string("xyz"), (), (), "a" , "b")))
fn:avg(( fn:count("Hello") ))
fn:avg((fn:day-from-dateTime(xs:dateTime("1996-12-10T12:00:00Z")),fn:day-from-dateTime(xs:dateTime("2000-12-20T12:00:00Z"))))
fn:avg((fn:day-from-date(xs:date("1999-12-31Z")),fn:day-from-date(xs:date("1999-12-29Z"))))
fn:avg((fn:days-from-duration(xs:dayTimeDuration("P23DT10H")),fn:days-from-duration(xs:dayTimeDuration("P21DT10H"))))
fn:avg(( fn:empty("Hello") ))
fn:avg(( fn:empty("Hello")) or fn:boolean(fn:count("Hello")))
fn:avg((fn:hours-from-duration(xs:dayTimeDuration("P23DT10H")),fn:hours-from-duration(xs:dayTimeDuration("P21DT08H"))))
fn:avg((fn:minutes-from-duration(xs:dayTimeDuration("P23DT10H20M")),fn:minutes-from-duration(xs:dayTimeDuration("P21DT10H10M"))))
fn:avg((fn:minutes-from-time(xs:time("01:10:00Z")), fn:minutes-from-time(xs:time("01:20:00Z"))))
fn:avg((fn:month-from-dateTime(xs:dateTime("1996-12-31T12:00:00Z")),fn:month-from-dateTime(xs:dateTime("2000-10-31T12:00:00Z"))))
fn:avg((fn:months-from-duration(xs:yearMonthDuration("P23Y10M")),fn:months-from-duration(xs:yearMonthDuration("P21Y10M"))))
fn:avg((fn:seconds-from-dateTime(xs:dateTime("1999-05-31T13:30:10Z")), fn:seconds-from-dateTime(xs:dateTime("1999-05-31T13:30:15Z"))))
fn:avg((fn:seconds-from-duration(xs:dayTimeDuration("P23DT10H20M30S")),fn:seconds-from-duration(xs:dayTimeDuration("P21DT10H10M32S"))))
fn:avg((fn:seconds-from-time(xs:time("01:10:20Z")), fn:seconds-from-time(xs:time("01:20:30Z"))))
fn:avg(( fn:string-length("Hello") ))
fn:avg(fn:string-to-codepoints("A String"))
fn:avg((fn:year-from-dateTime(xs:dateTime("1996-12-31T12:00:00Z")),fn:year-from-dateTime(xs:dateTime("2000-12-31T12:00:00Z"))))
fn:avg((fn:years-from-duration(xs:yearMonthDuration("P23Y10M")),fn:years-from-duration(xs:yearMonthDuration("P21Y10M"))))
fn:avg(( (true(), xs:string("xyz"), (), (), "a" , "b")))
fn:avg(/works/employee[1])
fn:avg(( (xs:anyURI("www.example.com"), "a", (""), "b")))
fn:avg(( (xs:boolean("1"), xs:double("-INF"), "s")))
fn:avg(( (xs:boolean("false"), xs:string("xyz"), (), (), "a" , "b")))
fn:avg(( (xs:boolean("true"), xs:date("1993-03-31"), 4, "a")))
fn:avg(( (xs:date("1993-03-31"), xs:string("xyz"), (), (), "a" , "b")))
fn:avg(( (xs:dateTime("1972-12-31T00:00:00"), xs:boolean("false"), (), (" ")) ))
fn:avg((xs:dayTimeDuration("P1DT2H"), xs:dayTimeDuration("PT22H"), xs:yearMonthDuration("P1M")))
fn:avg((xs:dayTimeDuration("P9223372036854775807D"), xs:dayTimeDuration("P1D")))
fn:avg( ( ( xs:decimal("-1.000000000001"), xs:integer("-100"))))
fn:avg(( (xs:decimal("1.01"), xs:integer("12") )))
fn:avg(( (xs:decimal("1.01"), xs:integer("12"), xs:anyURI("www.example.com"))))
fn:avg((xs:decimal("617375191608514839")))
fn:avg(( (xs:decimal("617375191608514839"), "a", (), "3") ))
fn:avg((xs:decimal("617375191608514839"),xs:decimal("-999999999999999999")))
fn:avg((xs:decimal("79000000000000000000000000000"),                     xs:decimal("79000000000000000000000000000")))             eq 79000000000000000000000000000
fn:avg((xs:decimal("-999999999999999999")))
fn:avg((xs:decimal("999999999999999999")))
fn:avg(( (xs:decimal("-999999999999999999") , "a", (), "3") ))
fn:avg(( (xs:decimal("999999999999999999"), "a", (), "3") ))
fn:avg((xs:decimal("-999999999999999999"),xs:decimal("617375191608514839")))
fn:avg((xs:decimal("-999999999999999999"),xs:decimal("-999999999999999999")))
fn:avg((xs:decimal("-999999999999999999"),xs:decimal("999999999999999999")))
fn:avg((xs:decimal("999999999999999999"),xs:decimal("-999999999999999999")))
fn:avg((xs:double("0")))
fn:avg((xs:double("0"),xs:double("-1.7976931348623157E308"))) eq -8.9884656743115785E307
fn:avg(( (xs:double("1.34"), xs:float("INF"))))
fn:avg(( (xs:double("1.34"), xs:float("INF"), true())))
fn:avg((xs:double("-1.7976931348623157E150"),xs:double("-1.7976931348623157E150"))) eq -1.7976931348623157E150
fn:avg((xs:double("-1.7976931348623157E308")))
fn:avg((xs:double("1.7976931348623157E308")))
fn:avg((xs:double("-1.7976931348623157E308"),xs:double("0"))) eq -8.9884656743115785E307
fn:avg((xs:double("-1.7976931348623157E308"),xs:double("1.7976931348623157E308")))
fn:avg((xs:double("1.7976931348623157E308"),xs:double("-1.7976931348623157E308")))
fn:avg(( (xs:double("INF"), 2, 3)))
fn:avg((xs:float("0")))
fn:avg(( (xs:float("-0"), xs:decimal("-999999999999999999") , "a", (), "3") ))
fn:avg(( (xs:float("0"), xs:decimal("-999999999999999999") , "a", (), "3") ))
fn:avg(( (xs:float("-0"), xs:decimal("-999999999999999999") ))) eq xs:float("-4.9999999999999999E17")
fn:avg(( (xs:float("0"), xs:decimal("-999999999999999999") ))) eq xs:float("-4.9999999999999999E17")
fn:avg(( (xs:float("1.01"))))
fn:avg(( (xs:float("1.01"), xs:string("a"))))
fn:avg((xs:float("-3.4028235E38")))
fn:avg((xs:float("3.4028235E38")))
fn:avg(( (xs:float("-3.4028235E38"), xs:decimal("-999999999999999999") , "a", (), "3") ))
fn:avg(( (xs:float("3.4028235E38"), xs:decimal("-999999999999999999") , "a", (), "3") ))
fn:avg((xs:float("-3.4028235E38"),xs:float("-3.4028235E38")))
fn:avg((xs:float("-3.4028235E38"),xs:float("3.4028235E38")))
fn:avg((xs:float("3.4028235E38"),xs:float("-3.4028235E38")))
fn:avg(( (xs:float("-INF"), xs:decimal("2.34"))))
fn:avg(( (xs:float("-INF"), xs:decimal("2.34"), "abc")))
fn:avg(( (xs:float("INF"), xs:decimal("-999999999999999999") )))
fn:avg(( (xs:float("INF"), xs:decimal("-999999999999999999") , "a", (), "3") ))
fn:avg(( xs:float('INF'), xs:float('-INF')))
fn:avg((xs:float('INF'), xs:float('-INF')))
fn:avg(( (xs:float("NaN"), 100, (), 2)))
fn:avg(( (xs:float("NaN"), xs:decimal("-999999999999999999") )))
fn:avg(( (xs:float("NaN"), xs:decimal("-999999999999999999") , "a", (), "3") ))
fn:avg((xs:int("-1873914410")))
fn:avg((xs:int("-1873914410"),xs:int("-2147483648")))
fn:avg((xs:int("2147483647")))
fn:avg((xs:int("2147483647"),xs:int("-2147483648")))
fn:avg((xs:int("-2147483648")))
fn:avg((xs:int("-2147483648"),xs:int("-1873914410")))
fn:avg((xs:int("-2147483648"),xs:int("2147483647")))
fn:avg((xs:int("-2147483648"),xs:int("-2147483648")))
fn:avg( ( ( xs:integer("100"), xs:integer("-100"))))
fn:avg(( (xs:integer("100"), xs:string("abc"))))
fn:avg((xs:negativeInteger("-1")))
fn:avg((xs:nonNegativeInteger("0")))
fn:avg((xs:nonNegativeInteger("0"),xs:nonNegativeInteger("0")))
fn:avg((xs:nonPositiveInteger("0")))
fn:avg((xs:positiveInteger("1")))
fn:avg((xs:positiveInteger("1"),xs:positiveInteger("1")))
fn:avg((xs:short("32767")))
fn:avg((xs:short("32767"),xs:short("-32768")))
fn:avg((xs:short("-32768")))
fn:avg((xs:short("-32768"),xs:short("32767")))
fn:avg((xs:short("-32768"),xs:short("-32768")))
fn:avg((xs:short("-32768"),xs:short("-5324")))
fn:avg((xs:short("-5324")))
fn:avg((xs:short("-5324"),xs:short("-32768")))
fn:avg(( (xs:string("xyz"), (), (), "a" , "b") ))
fn:avg(( (xs:time("12:30:00"), xs:decimal("2.000003"), 2)))
fn:avg((xs:unsignedLong("0")))
fn:avg((xs:unsignedLong("0"),xs:unsignedLong("0")))
fn:avg((xs:unsignedShort("0")))
fn:avg((xs:unsignedShort("0"),xs:unsignedShort("0")))
fn:avg((xs:unsignedShort("0"),xs:unsignedShort("44633")))
fn:avg((xs:unsignedShort("0"),xs:unsignedShort("65535")))
fn:avg((xs:unsignedShort("44633")))
fn:avg((xs:unsignedShort("44633"),xs:unsignedShort("0")))
fn:avg((xs:unsignedShort("65535")))
fn:avg((xs:unsignedShort("65535"),xs:unsignedShort("0")))
fn:avg( (xs:yearMonthDuration('P1Y0M'), 1) )
fn:avg((xs:yearMonthDuration("P1Y1M"), xs:yearMonthDuration("P11M"), xs:dayTimeDuration("P1D")))
fn:avg((xs:yearMonthDuration("P20Y") , (3, 4, 5)))
fn:avg((xs:yearMonthDuration("P768614336404564650Y"), xs:yearMonthDuration("P1Y")))
fn:boolean("")
fn:boolean(())
fn:boolean([])
fn:boolean(0)
fn:boolean(-1)
fn:boolean(1)
fn:boolean( (1, 2) )
fn:boolean(('a'))
fn:boolean(("ab" || "cde"))
fn:boolean(count((1, 2, 3, timezone-from-time(current-time()), 4)))
fn:boolean(false())
fn:boolean(fn:codepoints-to-string( () ))
fn:boolean(fn:codepoints-to-string( 0 ))
fn:boolean(fn:codepoints-to-string( 65 ))
fn:boolean(fn:codepoints-to-string( 65 to 76 ))
fn:boolean(fn:codepoints-to-string( 999999999 ))
fn:boolean(fn:concat('', ''))
fn:boolean(fn:concat("ab","cde"))
fn:boolean(fn:lower-case("abcde"))
fn:boolean(fn:round-half-to-even(5, 1))
fn:boolean(fn:string(fn:timezone-from-date(xs:date("1970-01-02+10:00"))))
fn:boolean(fn:string(fn:timezone-from-time(xs:time("10:10:20Z"))))
fn:boolean(fn:string-length("abcde"))
fn:boolean(fn:string(xs:date("1962-03-12Z") - xs:date("1962-03-12Z")))
fn:boolean(fn:string(xs:dateTime("1962-03-12T10:09:09Z") - xs:dateTime("1961-02-01T20:10:10Z")))
fn:boolean(fn:string(xs:dayTimeDuration("P05DT09H08M") *2.0))
fn:boolean(fn:string(xs:dayTimeDuration("P05DT09H08M") div 2.0))
fn:boolean(fn:string(xs:dayTimeDuration("P05DT09H08M") + xs:dayTimeDuration("P03DT08H06M")))
fn:boolean(fn:string(xs:dayTimeDuration("P05DT09H08M") - xs:dayTimeDuration("P03DT08H06M")))
fn:boolean(fn:string(xs:time("13:00:00Z") - xs:time("10:00:00Z")))
fn:boolean(fn:string(xs:yearMonthDuration("P05Y08M") * 2.0))
fn:boolean(fn:string(xs:yearMonthDuration("P05Y08M") div 2.0))
fn:boolean(fn:string(xs:yearMonthDuration("P05Y08M") + xs:yearMonthDuration("P03Y06M")))
fn:boolean(fn:string(xs:yearMonthDuration("P05Y08M") - xs:yearMonthDuration("P03Y06M")))
fn:boolean(fn:substring('', 1, 1))
fn:boolean(fn:substring("ABC",1))
fn:boolean(fn:substring('five', 5, 1))
fn:boolean(fn:upper-case("abcde"))
fn:boolean(true())
fn:boolean(xs:anyURI("http://www.example.org/examples"))
fn:boolean( xs:date('2007-01-01') )
fn:boolean(xs:dateTime("1999-12-31T00:00:00"))
fn:boolean(xs:dayTimeDuration("P05DT09H08M") div xs:dayTimeDuration("P03DT08H06M"))
fn:boolean(xs:decimal('0'))
fn:boolean(xs:decimal('-1'))
fn:boolean(xs:decimal('1'))
fn:boolean(xs:decimal('-123456789.123456789123456789'))
fn:boolean(xs:decimal("617375191608514839"))
fn:boolean(xs:decimal("-999999999999999999"))
fn:boolean(xs:decimal("999999999999999999"))
fn:boolean(xs:decimal('9.99999999999999999999999999'))
fn:boolean(xs:double("0"))
fn:boolean(xs:double(0))
fn:boolean(xs:double('1'))
fn:boolean(xs:double(1))
fn:boolean(xs:double("-1.7976931348623157E308"))
fn:boolean(xs:double("1.7976931348623157E308"))
fn:boolean(xs:double('-INF'))
fn:boolean(xs:double('INF'))
fn:boolean(xs:double('NaN'))
fn:boolean(xs:float("0"))
fn:boolean(xs:float(0))
fn:boolean(xs:float(-1))
fn:boolean(xs:float(1))
fn:boolean(xs:float("-3.4028235E38"))
fn:boolean(xs:float("3.4028235E38"))
fn:boolean(xs:float('-INF'))
fn:boolean(xs:float('INF'))
fn:boolean(xs:float('NaN'))
fn:boolean(xs:int('0'))
fn:boolean(xs:int('-1'))
fn:boolean(xs:int('1'))
fn:boolean(xs:int("-1873914410"))
fn:boolean(xs:int("2147483647"))
fn:boolean(xs:int('2147483647'))
fn:boolean(xs:int("-2147483648"))
fn:boolean(xs:int('-2147483648'))
fn:boolean(xs:integer('0'))
fn:boolean(xs:integer('-1'))
fn:boolean(xs:integer('1'))
fn:boolean(xs:long('0'))
fn:boolean(xs:long('-1'))
fn:boolean(xs:long('1'))
fn:boolean(xs:negativeInteger("-1"))
fn:boolean(xs:negativeInteger('-1'))
fn:boolean(xs:nonNegativeInteger("0"))
fn:boolean(xs:nonPositiveInteger("0"))
fn:boolean(xs:nonPositiveInteger('0'))
fn:boolean(xs:nonPositiveInteger('-1'))
fn:boolean(xs:positiveInteger("1"))
fn:boolean(xs:positiveInteger('1'))
fn:boolean(xs:short("32767"))
fn:boolean(xs:short("-32768"))
fn:boolean(xs:short("-5324"))
fn:boolean(xs:string(""))
fn:boolean(xs:string('abc'))
fn:boolean(xs:unsignedLong("0"))
fn:boolean(xs:unsignedShort("0"))
fn:boolean(xs:unsignedShort("44633"))
fn:boolean(xs:unsignedShort("65535"))
fn:boolean(xs:yearMonthDuration("P05Y08M") div xs:yearMonthDuration("P03Y06M"))
fn:ceiling(-10.5)
fn:ceiling(10.5)
fn:ceiling(xs:decimal("617375191608514839"))
fn:ceiling(xs:decimal("-999999999999999999"))
fn:ceiling(xs:decimal("999999999999999999"))
fn:ceiling(xs:double("0"))
fn:ceiling(xs:double("-1.7976931348623157E308"))
fn:ceiling(xs:double("1.7976931348623157E308"))
fn:ceiling(xs:float("0"))
fn:ceiling(xs:float("-3.4028235E38"))
fn:ceiling(xs:float("3.4028235E38"))
fn:ceiling(xs:int("-1873914410"))
fn:ceiling(xs:int("2147483647"))
fn:ceiling(xs:int("-2147483648"))
fn:ceiling(xs:negativeInteger("-1"))
fn:ceiling(xs:nonNegativeInteger("0"))
fn:ceiling(xs:nonPositiveInteger("0"))
fn:ceiling(xs:positiveInteger("1"))
fn:ceiling(xs:short("32767"))
fn:ceiling(xs:short("-32768"))
fn:ceiling(xs:short("-5324"))
fn:ceiling(xs:unsignedLong("0"))
fn:ceiling(xs:unsignedShort("0"))
fn:ceiling(xs:unsignedShort("44633"))
fn:ceiling(xs:unsignedShort("65535"))
fn:codepoint-equal("", "")
fn:codepoint-equal("", ())
fn:codepoint-equal("","")
fn:codepoint-equal((), "")
fn:codepoint-equal((), ())
fn:codepoint-equal((),())
fn:codepoint-equal("a")
fn:codepoint-equal("a","a")
fn:codepoint-equal("aa","AA")
fn:codepoint-equal("aa","aa") and fn:codepoint-equal("aa","aa")
fn:codepoint-equal("aa","aa") and fn:false()
fn:codepoint-equal("aa","aa") and fn:true()
fn:codepoint-equal("aa","aa") or fn:codepoint-equal("aa","aa")
fn:codepoint-equal("aa","aa") or fn:false()
fn:codepoint-equal("aa","aa") or fn:true()
fn:codepoint-equal("aa",fn:lower-case("AA"))
fn:codepoint-equal("aa",fn:upper-case("aa"))
fn:codepoint-equal("aa",xs:integer(1))
fn:codepoint-equal("a","b")
fn:codepoint-equal("abc",())
fn:codepoint-equal("abcd", "abcd ")
fn:codepoint-equal("abcd", "abcd")
fn:codepoint-equal(fn:string(1),fn:string(1))
fn:codepoint-equal(fn:string("aa"),fn:string("aa"))
fn:codepoint-equal(xs:integer(1),xs:integer(1))
fn:codepoints-to-string(())
fn:codepoints-to-string(0)
fn:codepoints-to-string(10000000)
fn:codepoints-to-string((2309, 2358, 2378, 2325))
fn:codepoints-to-string((35, 42, 94, 36))
fn:codepoints-to-string(49)
fn:codepoints-to-string((49,97))
fn:codepoints-to-string( 55295 to 55297 )
fn:codepoints-to-string( 55296 to 57343 )
fn:codepoints-to-string( 65530 to 70000 )
fn:codepoints-to-string( 65535 to 70000 )
fn:codepoints-to-string( 65536 to 1114112 )
fn:codepoints-to-string((66, 65, 67, 72))
fn:codepoints-to-string(97)
fn:codepoints-to-string((99,111,100,101,112,111,105,110,116,115,45,116,111,45,115,116,114,105,110,103))
fn:codepoints-to-string(xs:integer(97))
fn:codepoints-to-string(xs:integer(fn:avg((65,32,83,116,114,105,110,103))))
fn:compare('abc', 'abc')
fn:concat("**","***")
fn:concat("%$","#@!")
fn:concat(01, 02, 03, 04, true())
fn:concat("abc","abc") and fn:concat("abc","abc")
fn:concat("abc","abc", fn:concat#3)
fn:concat("AB","CD")
fn:concat("abc","de")
fn:concat("ABCDE","abcde")
fn:concat('Ciao!',())
fn:concat("concat","concat")
fn:concat(fn:codepoints-to-string((49,97)),"1a")
fn:concat(fn:concat("zzz","zz"),"123")
fn:concat(fn:lower-case("abcde"), fn:lower-case("fghi"))
fn:concat(fn:prefix-from-QName(xs:QName("foo:bar")),":bar")
fn:concat(fn:string-length("abcde"), fn:string-length("fghi"))
fn:concat(fn:substring("ABC",1),"DEF")
fn:concat(fn:upper-case("abcde"), fn:upper-case("fghi"))
fn:concat(fn:upper-case("Abc"),fn:upper-case("DH"))
fn:concat('Ingratitude, ', 'thou ', 'marble-hearted', ' fiend!')
fn:concat('Thy ', (), 'old ', "groans", "", ' ring',                   ' yet', ' in', ' my', ' ancient',' ears.')
fn:concat('Thy ', (), 'old ', "groans", "", ' ring', ' yet', ' in', ' my', ' ancient',' ears.')
fn:concat('un', 'grateful')
fn:concat(xs:double("0"),xs:double("-1.7976931348623157E308"))
fn:concat(xs:double("-1.7976931348623157E308"),xs:double("0"))
fn:concat(xs:double("-1.7976931348623157E308"),xs:double("-1.7976931348623157E308"))
fn:concat(xs:double("-1.7976931348623157E308"),xs:double("1.7976931348623157E308"))
fn:concat(xs:double("1.7976931348623157E308"),xs:double("-1.7976931348623157E308"))
fn:concat(xs:float("0"),xs:float("-3.4028235E38"))
fn:concat(xs:float("-3.4028235E38"),xs:float("0"))
fn:concat(xs:float("-3.4028235E38"),xs:float("-3.4028235E38"))
fn:concat(xs:float("-3.4028235E38"),xs:float("3.4028235E38"))
fn:concat(xs:float("3.4028235E38"),xs:float("-3.4028235E38"))
fn:concat(xs:int("-1873914410"),xs:int("-2147483648"))
fn:concat(xs:int("2147483647"),xs:int("-2147483648"))
fn:concat(xs:int("-2147483648"),xs:int("-1873914410"))
fn:concat(xs:int("-2147483648"),xs:int("2147483647"))
fn:concat(xs:int("-2147483648"),xs:int("-2147483648"))
fn:concat(xs:nonNegativeInteger("0"),xs:nonNegativeInteger("0"))
fn:concat(xs:positiveInteger("1"),xs:positiveInteger("1"))
fn:concat(xs:short("32767"),xs:short("-32768"))
fn:concat(xs:short("-32768"),xs:short("32767"))
fn:concat(xs:short("-32768"),xs:short("-32768"))
fn:concat(xs:short("-32768"),xs:short("-5324"))
fn:concat(xs:short("-5324"),xs:short("-32768"))
fn:concat(xs:string(fn:false()),xs:string(fn:false()))
fn:concat(xs:string(fn:not("true")),xs:string(fn:not("true")))
fn:concat(xs:string(fn:true()),xs:string(fn:true()))
fn:concat(xs:unsignedLong("0"),xs:unsignedLong("0"))
fn:concat(xs:unsignedShort("0"),xs:unsignedShort("0"))
fn:concat(xs:unsignedShort("0"),xs:unsignedShort("44633"))
fn:concat(xs:unsignedShort("0"),xs:unsignedShort("65535"))
fn:concat(xs:unsignedShort("44633"),xs:unsignedShort("0"))
fn:concat(xs:unsignedShort("65535"),xs:unsignedShort("0"))
fn:contains ( "", ())
fn:contains("","")
fn:contains("",())
fn:contains((),"")
fn:contains("a","A")
fn:contains("A","a")
fn:contains(" ","AAAAABBBBB")
fn:contains("AAAAABBBBB"," ")
fn:contains("AAAAABBBBBCCCCC","BBBBB")
fn:contains("","A Character String")
fn:contains("A Character String","")
fn:contains("A Character String",())
fn:contains((),"A Character String")
fn:contains("A",xs:string("A"))
fn:contains(fn:prefix-from-QName(xs:QName("foo:bar")),"f")
fn:contains(fn:substring("ABCDEF",1),"DEF")
fn:contains ( "tattoo", "t")
fn:contains ( "tattoo", "ttt")
fn:contains(xs:string("A"),"A")
fn:contains(xs:string(fn:false()),xs:string(fn:false()))
fn:contains(xs:string(fn:not("true")),xs:string(fn:not("true")))
fn:contains(xs:string(fn:true()),xs:string(fn:true()))
fn:contains(xs:string("This is a characte"),xs:string("This is a characte"))
fn:count( / )
fn:count(("" || ""))
fn:count(/*)
fn:count(//*)
fn:count(//@*)
fn:count([])
fn:count(() << 100)
fn:count(() >> 100)
fn:count([1,2,3])
fn:count(((1,2,3,4,5,6,7,8,9,10,11)[fn:false()]))
fn:count((1, 2 to ()))
fn:count(15 to 10)
fn:count(1 to 10000000)
fn:count((1 to 5))
fn:count(.[(/) * 5])
fn:count(.[(/) < 5])
fn:count(.[/ * 5])
fn:count(.[/ < 5])
fn:count(.[/-5])
fn:count(.[5 * /])
fn:count(.[5</])
fn:count(.[/ < a])
fn:count(.[/<a/>])
fn:count(.[/<a div 3])
fn:count(//attribute::*)
fn:count(//attribute::mark)
fn:count(.[/ < /b])
fn:count(//center/*)
fn:count(//center/..)
fn:count(//center//*)
fn:count(//center//attribute::center-attr-2)
fn:count(//center//@center-attr-2)
fn:count(//center/@center-attr-3/descendant-or-self::node())
fn:count(//center/@center-attr-3/self::node())
fn:count(//center//child::*)
fn:count(//center/child::*)
fn:count(//center//child::node())
fn:count(//center/child::node())
fn:count(//center//child::south)
fn:count(//center/child::south-east)
fn:count(//center/descendant::*)
fn:count(//center/descendant::node())
fn:count(//center/descendant-or-self::*)
fn:count(//center/descendant-or-self::center)
fn:count(//center/descendant-or-self::node())
fn:count(//center/descendant-or-self::south)
fn:count(//center/descendant::south)
fn:count(//center//node())
fn:count(//center/node())
fn:count(//center/parent::*)
fn:count(//center/parent::near-north)
fn:count(//center/parent::node())
fn:count(//center/parent::nowhere)
fn:count(//center/self::*)
fn:count(//center/self::center)
fn:count(//center/self::node())
fn:count(//center//south)
fn:count(//center/south-east)
fn:count(//center/text()/descendant-or-self::node())
fn:count(//center/text()/self::node())
fn:count(//child::*)
fn:count(/child::*)
fn:count(/child::far-north)
fn:count(//child::node())
fn:count(/child::node())
fn:count(//child::south)
fn:count(/descendant::*)
fn:count(/descendant::node())
fn:count(/descendant-or-self::*)
fn:count(/descendant-or-self::node())
fn:count(/descendant-or-self::south)
fn:count(/descendant::south)
fn:count((<elem></elem>)/node())
fn:count((<elem/>)/node())
fn:count((<elem xmlns:foo="http://ns.example.com/uri"/>)/@*)
fn:count((<elem xmlns="http://ns.example.com/uri"/>)/@*)
fn:count(/far-north)
fn:count(/far-north/parent::*)
fn:count(/far-north/parent::node())
fn:count(fn:concat("",""))
fn:count(fn:dateTime((),()))
fn:count(fn:dateTime(xs:date("1999-12-31+10:00"), ()))
fn:count(fn:dateTime((), xs:time("23:00:00+10:00")))
fn:count(fn:day-from-date(()))
fn:count(fn:day-from-dateTime(()))
fn:count(fn:days-from-duration(()))
fn:count(fn:hours-from-dateTime(()))
fn:count(fn:hours-from-duration(()))
fn:count(fn:hours-from-time(()))
fn:count(fn:id("nomatching1 nomatching2", /IDS[1]))
fn:count(fn:id("nomatchingid", /IDS[1]))
fn:count(fn:idref("", /IDS[1]))
fn:count(fn:idref("nomatching1 nomatching2", /IDS[1]))
fn:count(fn:local-name-from-QName(fn:node-name(text {""})))
fn:count(fn:local-name-from-QName(fn:node-name(text {"a text value"})))
fn:count(fn:lower-case(""))
fn:count(fn:lower-case(()))
fn:count(fn:matches("()", "^bra"))
fn:count(fn:minutes-from-dateTime(()))
fn:count(fn:minutes-from-duration(()))
fn:count(fn:minutes-from-time(()))
fn:count(fn:month-from-date(()))
fn:count(fn:month-from-dateTime(()))
fn:count(fn:months-from-duration(()))
fn:count(fn:namespace-uri-from-QName(fn:node-name(attribute attributeName {"an attribute value"})))
fn:count(fn:namespace-uri-from-QName(fn:node-name(element elementName {})))
fn:count(fn:namespace-uri-from-QName(fn:node-name(processing-instruction piName {"Processing Instruction content"})))
fn:count(fn:namespace-uri-from-QName(fn:node-name(text {""})))
fn:count(fn:namespace-uri-from-QName(fn:node-name(text {"a text value"})))
fn:count(((fn:name(/works[1]/employee[1]),fn:name(/works[1]/employee[2]))))
fn:count(fn:node-name(()))
fn:count(fn:node-name(<!-- This a comment node -->))
fn:count(fn:node-name(/works[1]/employee[2]/child::text()[last()]))
fn:count(fn:prefix-from-QName(()))
fn:count(fn:prefix-from-QName(xs:QName("name")))
fn:count(fn:root(()))
fn:count(fn:seconds-from-dateTime(()))
fn:count(fn:seconds-from-duration(()))
fn:count(fn:seconds-from-time(()))
fn:count(fn:string-join("",""))
fn:count(fn:string-join((),""))
fn:count(fn:string-join((" "),"AAAAABBBBB"))
fn:count(fn:string-join("","A Character String"))
fn:count(fn:string-join((),"A Character String"))
fn:count(fn:string-join((), 'separator'))
fn:count(fn:string-to-codepoints("A String"))
fn:count(fn:substring("",0))
fn:count(fn:substring("12345", 0 div 0E0, 3))
fn:count(fn:substring("12345", 1, 0 div 0E0))
fn:count(fn:substring("12345", -1 div 0E0, 1 div 0E0))
fn:count(fn:substring("12345", 5, -3))
fn:count(fn:substring((), 1, 3))
fn:count(fn:timezone-from-date(()))
fn:count(fn:timezone-from-dateTime(()))
fn:count(fn:timezone-from-dateTime(xs:dateTime("2004-08-27T00:00:00")))
fn:count(fn:timezone-from-time(()))
fn:count(fn:timezone-from-time(xs:time("13:20:00")))
fn:count(fn:translate("","",""))
fn:count(fn:upper-case(""))
fn:count(fn:upper-case(()))
fn:count(fn:year-from-date(()))
fn:count(fn:year-from-dateTime(()))
fn:count(fn:years-from-duration(()))
fn:count(.[if (doclevel) then / else /*])
fn:count(.[/ instance of document-node(schema-element(x))])
fn:count((//integer[fn:false()]))
fn:count((//integer[fn:false() and fn:false()]))
fn:count((//integer[fn:false() or fn:false()]))
fn:count((//integer[fn:true()]))
fn:count(() is 100)
fn:count(.[let $doc := / return $doc/*])
fn:count(//@mark)
fn:count(//node())
fn:count(/node())
fn:count(//self::*)
fn:count(//self::node())
fn:count(/self::node())
fn:count(//south)
fn:count(//west//@*)
fn:count(//west/@*)
fn:count(//west//attribute::*)
fn:count(//west/attribute::*)
fn:count(//west//attribute::node())
fn:count(//west/attribute::node())
fn:count(//west/attribute::west-attr-2)
fn:count(//west/@west-attr-2)
fn:count((/works[1]/employee[12]/following::employee) except (/works[1]/employee[12]/following::employee))
fn:count((/works[1]/employee[12]/following-sibling::employee) except (/works[1]/employee[12]/following-sibling::employee))
fn:count((/works[1]/employee[12]/preceding::employee) except (/works[1]/employee[12]/preceding::employee))
fn:count((/works[1]/employee[12]/preceding-sibling::employee) except (/works[1]/employee[12]/preceding-sibling::employee))
fn:count((/works/employee[12]/overtime/day[ancestor-or-self::overtime]) except (/works/employee[12]/overtime/day[ancestor-or-self::overtime]))
fn:count((/works/employee[12]/overtime/day[ancestor::overtime]) except (/works/employee[12]/overtime/day[ancestor::overtime]))
fn:count(/works/employee[1]/ancestor::noSuchNode)
fn:count(/works/employee[1]/ancestor-or-self::noSuchNode)
fn:count(/works/employee[1]/following::noSuchNode)
fn:count(/works/employee[1]/following-sibling::noSuchNode)
fn:count(/works/employee[1]/preceding::noSuchNode)
fn:count(/works/employee[1]/preceding-sibling::noSuchNode)
fn:count(xs:dayTimeDuration("P13DT09H09M") * +0)
fn:count(xs:dayTimeDuration("P13DT09H09M") * -0)
fn:count((xs:decimal("617375191608514839")))
fn:count((xs:decimal("-999999999999999999")))
fn:count((xs:decimal("999999999999999999")))
fn:count((xs:double("0")))
fn:count((xs:double("-1.7976931348623157E308")))
fn:count((xs:double("1.7976931348623157E308")))
fn:count((xs:float("0")))
fn:count((xs:float("-3.4028235E38")))
fn:count((xs:float("3.4028235E38")))
fn:count((xs:int("-1873914410")))
fn:count((xs:int("2147483647")))
fn:count((xs:int("-2147483648")))
fn:count((xs:negativeInteger("-1")))
fn:count((xs:nonNegativeInteger("0")))
fn:count((xs:nonPositiveInteger("0")))
fn:count((xs:positiveInteger("1")))
fn:count((xs:short("32767")))
fn:count((xs:short("-32768")))
fn:count((xs:short("-5324")))
fn:count(((),(),())[xs:string(.)])
fn:count((xs:unsignedLong("0")))
fn:count((xs:unsignedShort("0")))
fn:count((xs:unsignedShort("44633")))
fn:count((xs:unsignedShort("65535")))
fn:count((xs:yearMonthDuration("P13Y09M") *+0))
fn:count((xs:yearMonthDuration("P13Y09M") *-0))
fn:current-date()
fn:current-date("Argument 1")
fn:current-date() - fn:current-date()
fn:current-date() gt xs:date('2010-01-01')
fn:current-dateTime()
fn:current-dateTime("Argument 1")
fn:current-dateTime() - fn:current-dateTime()
fn:current-time()
fn:current-time("Argument 1")
fn:current-time() castable as xs:Name
fn:current-time() castable as xs:NCName
fn:current-time() cast as xs:ENTITY
fn:current-time() cast as xs:ID
fn:current-time() cast as xs:IDREF
fn:current-time() cast as xs:Name
fn:current-time() cast as xs:NCName
fn:current-time() - fn:current-time()
fn:data(<!---->) = ""
fn:data([['A', 'B', 'C'], ['D', 'E'], []]?*?*)
fn:data([['A', 'B', 'C'], ['D', 'E'], []]?2)
fn:data([['A', 'B', 'C'], ['D', 'E'], []]?3)
fn:data(attribute attr {'a', element a {}, 'b'})
fn:data(comment {'a', element a {}, 'b'})
fn:data(<!--comment-->) = "comment"
fn:data(<elem>a<a/>b</elem>)
fn:data(element elem {'a', element a {}, 'b'})
fn:data(<?pi ?>) = ""
fn:data(<?pi content?>) = "content"
fn:data(processing-instruction pi {'a', element a {}, 'b'})
fn:data(text {'a', element a {}, 'b'})
fn:data((xs:decimal("617375191608514839")))
fn:data((xs:decimal("-999999999999999999")))
fn:data((xs:decimal("999999999999999999")))
fn:data((xs:double("0")))
fn:data((xs:double("-1.7976931348623157E308")))
fn:data((xs:double("1.7976931348623157E308")))
fn:data((xs:float("0")))
fn:data((xs:float("-3.4028235E38")))
fn:data((xs:float("3.4028235E38")))
fn:data((xs:int("-1873914410")))
fn:data((xs:int("2147483647")))
fn:data((xs:int("-2147483648")))
fn:data((xs:negativeInteger("-1")))
fn:data((xs:nonNegativeInteger("0")))
fn:data((xs:nonPositiveInteger("0")))
fn:data((xs:positiveInteger("1")))
fn:data((xs:short("32767")))
fn:data((xs:short("-32768")))
fn:data((xs:short("-5324")))
fn:data((xs:unsignedLong("0")))
fn:data((xs:unsignedShort("0")))
fn:data((xs:unsignedShort("44633")))
fn:data((xs:unsignedShort("65535")))
fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00"))
fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00")) eq fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00"))
fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00")) - fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("22:00:00+10:00"))
fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00")) ge fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00"))
fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00")) gt fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00"))
fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00")) le fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00"))
fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00")) lt fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00"))
fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00")) ne fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00"))
fn:dateTime(xs:date("1999-12-31"),                   xs:time("12:00:00"))
fn:dateTime(xs:date("1999-12-31"), xs:time("12:00:00"))
fn:dateTime(xs:date("1999-12-31"), xs:time("23:00:00Z"))
fn:dateTime(xs:date("1999-12-31"),                   xs:time("24:00:00"))
fn:dateTime(xs:date("1999-12-31"), xs:time("24:00:00"))
fn:dateTime(xs:date("1999-12-31Z"), xs:time("12:00:00+10:00"))
fn:dateTime(xs:date("1999-12-31Z"), xs:time("23:00:00"))
fn:dateTime(xs:date("1999-12-31Z"), xs:time("23:00:00Z"))
fn:day-from-date(fn:current-date())
fn:day-from-dateTime(fn:current-dateTime())
fn:day-from-dateTime(fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00")))
fn:day-from-dateTime(xs:dateTime("0001-05-31T23:20:00-05:00"))
fn:day-from-dateTime(xs:dateTime("1000-01-10T02:00:00Z")) div fn:day-from-dateTime(xs:dateTime("0050-01-05T10:00:00Z"))
fn:day-from-dateTime(xs:dateTime("1970-01-01T00:00:00Z"))
fn:day-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")) eq fn:day-from-dateTime(xs:dateTime("1970-01-02T10:00:00Z"))
fn:day-from-dateTime(xs:dateTime("1970-01-02T02:00:00Z")) * fn:day-from-dateTime(xs:dateTime("0002-01-04T10:00:00Z"))
fn:day-from-dateTime(xs:dateTime("1970-01-02T10:00:00Z")) ne fn:day-from-dateTime(xs:dateTime("1970-02-02T10:00:00Z"))
fn:day-from-dateTime(xs:dateTime("1970-01-03T00:00:00Z")) + fn:day-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
-fn:day-from-dateTime(xs:dateTime("1970-01-03T10:00:00Z"))
fn:day-from-dateTime(xs:dateTime("1970-01-10T00:00:00Z")) - fn:day-from-dateTime(xs:dateTime("1969-01-01T10:00:00Z"))
fn:day-from-dateTime(xs:dateTime("1970-01-10T10:00:00Z")) idiv fn:day-from-dateTime(xs:dateTime("1970-01-10T02:00:00Z"))
fn:day-from-dateTime(xs:dateTime("1970-01-10T10:00:00Z")) mod fn:day-from-dateTime(xs:dateTime("1970-01-03T03:00:00Z"))
+fn:day-from-dateTime(xs:dateTime("1971-01-01T10:00:00Z"))
fn:day-from-dateTime(xs:dateTime("1971-01-03T10:00:00Z")) ge fn:day-from-dateTime(xs:dateTime("1970-01-03T10:00:00Z"))
fn:day-from-dateTime(xs:dateTime("1971-01-10T10:00:00Z")) ge fn:day-from-dateTime(xs:dateTime("1970-01-11T10:00:00Z"))
fn:day-from-dateTime(xs:dateTime("1996-04-07T01:40:52Z"))
fn:day-from-dateTime(xs:dateTime("1999-01-01T00:20:00-05:00"))
fn:day-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))
fn:day-from-dateTime(xs:dateTime("1999-12-31T20:00:00-05:00"))
fn:day-from-dateTime(xs:dateTime("2030-12-31T23:59:59Z"))
+fn:day-from-date(xs:date("1970-01-01Z"))
-fn:day-from-date(xs:date("1970-01-01Z"))
fn:day-from-date(xs:date("1970-01-01Z"))
fn:day-from-date(xs:date("1970-01-01Z")) + fn:day-from-date(xs:date("1970-01-01Z"))
fn:day-from-date(xs:date("1970-01-01Z")) - fn:day-from-date(xs:date("1970-01-01Z"))
fn:day-from-date(xs:date("1970-01-01Z")) le fn:day-from-date(xs:date("1970-01-02Z"))
fn:day-from-date(xs:date("1970-01-02Z")) div fn:day-from-date(xs:date("1970-01-01Z"))
fn:day-from-date(xs:date("1970-01-02Z")) eq fn:day-from-date(xs:date("1970-01-01Z"))
fn:day-from-date(xs:date("1970-01-02Z")) idiv fn:day-from-date(xs:date("1970-01-01Z"))
fn:day-from-date(xs:date("1970-01-02Z")) mod fn:day-from-date(xs:date("1970-01-01Z"))
fn:day-from-date(xs:date("1970-01-03Z")) * fn:day-from-date(xs:date("0002-01-01Z"))
fn:day-from-date(xs:date("1970-01-03Z")) ge fn:day-from-date(xs:date("1970-01-01Z"))
fn:day-from-date(xs:date("1983-11-17Z"))
fn:day-from-date(xs:date("1999-05-31-05:00"))
fn:day-from-date(xs:date("1999-05-31Z"))
fn:day-from-date(xs:date("1999-12-31Z")) le fn:day-from-date(xs:date("1999-12-31Z"))
fn:day-from-date(xs:date("1999-12-31Z")) lt fn:day-from-date(xs:date("1999-12-31Z"))
fn:day-from-date(xs:date("2000-01-01+05:00"))
fn:day-from-date(xs:date("2030-12-31Z"))
fn:days-from-duration(xs:dayTimeDuration("P01DT01H"))
fn:days-from-duration(xs:dayTimeDuration("P0DT0H0M0S"))
fn:days-from-duration(xs:dayTimeDuration("P10DT10H")) mod fn:days-from-duration(xs:dayTimeDuration("P03DT03H"))
fn:days-from-duration(xs:dayTimeDuration("P15DT11H59M59S"))
-fn:days-from-duration(xs:dayTimeDuration("P20DT03H"))
fn:days-from-duration(xs:dayTimeDuration("P20DT03H")) le fn:days-from-duration(xs:dayTimeDuration("P21DT15H"))
fn:days-from-duration(xs:dayTimeDuration("P20DT09H")) * fn:days-from-duration(xs:dayTimeDuration("P03DT10H"))
fn:days-from-duration(xs:dayTimeDuration("P20DT10H")) div fn:days-from-duration(xs:dayTimeDuration("P05DT05H"))
fn:days-from-duration(xs:dayTimeDuration("P20DT20H")) lt fn:days-from-duration(xs:dayTimeDuration("P03DT02H"))
fn:days-from-duration(xs:dayTimeDuration("P21DT07H")) ge fn:days-from-duration(xs:dayTimeDuration("P20DT01H"))
+fn:days-from-duration(xs:dayTimeDuration("P21DT10H"))
fn:days-from-duration(xs:dayTimeDuration("P21DT10H")) + fn:days-from-duration(xs:dayTimeDuration("P22DT11H"))
fn:days-from-duration(xs:dayTimeDuration("P21DT10H")) le fn:days-from-duration(xs:dayTimeDuration("P22DT10H"))
fn:days-from-duration(xs:dayTimeDuration("P22DT10H")) eq fn:days-from-duration(xs:dayTimeDuration("P22DT09H"))
fn:days-from-duration(xs:dayTimeDuration("P23DT08H")) ne fn:days-from-duration(xs:dayTimeDuration("P12DT05H"))
fn:days-from-duration(xs:dayTimeDuration("P25DT10H")) idiv fn:days-from-duration(xs:dayTimeDuration("P05DT02H"))
fn:days-from-duration(xs:dayTimeDuration("P30DT10H")) - fn:days-from-duration(xs:dayTimeDuration("P10DT09H"))
fn:days-from-duration(xs:dayTimeDuration("P31DT23H59M59S"))
fn:days-from-duration(xs:dayTimeDuration("P3DT10H"))
fn:days-from-duration(xs:dayTimeDuration("P3DT55H"))
fn:days-from-duration(xs:duration("P1Y2M3DT10H30M"))
fn:days-from-duration(xs:yearMonthDuration('P1Y'))
fn:days-from-duration(xs:yearMonthDuration("P3Y5M"))
fn:deep-equal( ( ) , ())
fn:deep-equal( (()) , ())
fn:deep-equal( () , ())
fn:deep-equal([()], [()])
fn:deep-equal([[]], [[]])
fn:deep-equal([], [()])
fn:deep-equal([], [])
fn:deep-equal([], [1])
fn:deep-equal([1], 1)
fn:deep-equal( (1,2) , (1,2))
fn:deep-equal([1,2], [1,2])
fn:deep-equal( (1,2) , (2,1))
fn:deep-equal((1, 2, 3), [1, 2, 3])
fn:deep-equal([1, 2, 3], [1, 2, 3])
fn:deep-equal([<a>1</a>], [<a>1</a>])
fn:deep-equal(<a b="b" c="c" />, <a b="b" />)
fn:deep-equal([['a', 'b', 'c']], [['a', 'b', 'c']])
fn:deep-equal([['a', 'b', 'c']], [['A', 'B', 'C']])
fn:deep-equal(<a> {/bib/node()} </a>/node(), <b> {/bib/node()} </b>/node() )
fn:deep-equal(<a> {/bib/node(), /bib/node()} </a>/node(), <b> {/bib/node(), <difference/>, /bib/node()} </b>/node() )
fn:deep-equal(<a> {/node(), <diff x='1'/>, /node()} </a>/node(), <b> {/node(), <diff x='2'/>, /node()} </b>/node() )
fn:deep-equal(<a> {/node(), <diff x='1'/>, /node()} </a>/node(), <b> {/node(), <diff xx='1'/>, /node()} </b>/node() )
fn:deep-equal(<a> {/node(), /node()} </a>/node(), <b> {/node(), 'difference', /node()} </b>/node() )
fn:deep-equal(fn:innermost( / ), / )
fn:deep-equal( fn:innermost( ($doc1//node(), $doc2//node()) ),                            let $nodes := ($doc1//node(), $doc2//node())                            return $nodes except $nodes/ancestor::node() )
fn:deep-equal( fn:innermost( //comment() ),                            //comment() )
fn:deep-equal( fn:innermost( //* ),                             let $nodes := //*                            return $nodes except $nodes/ancestor::node() )
fn:deep-equal( fn:innermost( //node() ),                             let $nodes := //node()                            return $nodes except $nodes/ancestor::node() )
fn:deep-equal( fn:innermost( //processing-instruction() ),                            //processing-instruction() )
fn:deep-equal( fn:innermost( /root/descendant::node() ),                             let $nodes := /root/descendant::node()                            return $nodes except $nodes/ancestor::node() )
fn:deep-equal( fn:innermost( /root/level[1]/following-sibling::node() ),                             let $nodes := /root/level[1]/following-sibling::node()                            return $nodes except $nodes/ancestor::node() )
fn:deep-equal( fn:innermost( /root/level[1]/level[1]/ancestor::node() ),                             let $nodes := /root/level[1]/level[1]/ancestor::node()                            return $nodes except $nodes/ancestor::node() )
fn:deep-equal( fn:innermost( /root/level[1]/level[1]/following::node() ),                             let $nodes := /root/level[1]/level[1]/following::node()                            return $nodes except $nodes/ancestor::node() )
fn:deep-equal( fn:innermost( /root/level[1]/level[last()]/preceding::node() ),                             let $nodes := /root/level[1]/level[last()]/preceding::node()                            return $nodes except $nodes/ancestor::node() )
fn:deep-equal( fn:innermost( /root/level[1]/level[last()]/preceding-sibling::node() ),                             let $nodes := /root/level[1]/level[last()]/preceding-sibling::node()                            return $nodes except $nodes/ancestor::node() )
fn:deep-equal( fn:innermost( /root/node() ),                             let $nodes := /root/node()                            return $nodes except $nodes/ancestor::node() )
fn:deep-equal( fn:innermost( /root/node()/.. ),                             let $nodes := /root/node()/..                            return $nodes except $nodes/ancestor::node() )
fn:deep-equal( fn:innermost( //text() ),                            //text() )
fn:deep-equal(fn:outermost( / ), / )
fn:deep-equal( fn:outermost( ($doc1//node(), $doc2//node()) ),                            let $nodes := ($doc1//node(), $doc2//node())                            return $nodes except $nodes/descendant::node() )
fn:deep-equal( fn:outermost( //comment() ),                            //comment() )
fn:deep-equal( fn:outermost( //* ),                             let $nodes := //*                            return $nodes except $nodes/descendant::node() )
fn:deep-equal( fn:outermost( //node() ),                             let $nodes := //node()                            return $nodes except $nodes/descendant::node() )
fn:deep-equal( fn:outermost( //processing-instruction() ),                            //processing-instruction() )
fn:deep-equal( fn:outermost( /root/descendant::node() ),                             let $nodes := /root/descendant::node()                            return $nodes except $nodes/descendant::node() )
fn:deep-equal( fn:outermost( /root/level[1]/following-sibling::node() ),                             let $nodes := /root/level[1]/following-sibling::node()                            return $nodes except $nodes/descendant::node() )
fn:deep-equal( fn:outermost( /root/level[1]/level[1]/ancestor::node() ),                             let $nodes := /root/level[1]/level[1]/ancestor::node()                            return $nodes except $nodes/descendant::node() )
fn:deep-equal( fn:outermost( /root/level[1]/level[1]/following::node() ),                             let $nodes := /root/level[1]/level[1]/following::node()                            return $nodes except $nodes/descendant::node() )
fn:deep-equal( fn:outermost( /root/level[1]/level[last()]/preceding::node() ),                             let $nodes := /root/level[1]/level[last()]/preceding::node()                            return $nodes except $nodes/descendant::node() )
fn:deep-equal( fn:outermost( /root/level[1]/level[last()]/preceding-sibling::node() ),                             let $nodes := /root/level[1]/level[last()]/preceding-sibling::node()                            return $nodes except $nodes/descendant::node() )
fn:deep-equal( fn:outermost( /root/node() ),                             let $nodes := /root/node()                            return $nodes except $nodes/descendant::node() )
fn:deep-equal( fn:outermost( /root/node()/.. ),                             let $nodes := /root/node()/..                            return $nodes except $nodes/descendant::node() )
fn:deep-equal( fn:outermost( //text() ),                            //text() )
fn:deep-equal([map{1:1, 2:2}], [map{2:2, 1:1}])
fn:deep-equal(map{12:[1,2,3]}, map{12.0:[1.0, 2.0, 3.0]})
fn:deep-equal(map{12:[1,2,3]}, map{12:[3,2,1]})
fn:deep-equal(map{12:<a x='2' y='3'>23</a>}, map{12:<a y='3' x='2'>23</a>})
fn:deep-equal(map{12:<a x='2' y='3'>23</a>}, map{12:<a y='3' x='2' z='1'>23</a>})
fn:deep-equal(map{1:2}, map{})
fn:deep-equal(map{1:'a', 2:'b'}, map{2:'b', 1:'a'})
fn:deep-equal(map{1:"A"}, map:remove(map{1:"A", 2:"B"}, 2))
fn:deep-equal(map{1:true(), 2:false()}, map{2:false(), 1:true()})
fn:deep-equal(map{1:true()}, map{1.0e0:true()})
fn:deep-equal(map{1:true()}, map{1.0:true()})
fn:deep-equal([map{}], [map{}])
fn:deep-equal(map{}, map{})
fn:deep-equal(map{}, map{1:()})
fn:deep-equal(map{xs:double('NaN'):true()}, map{xs:double('NaN'):true()})
fn:deep-equal(map{xs:double('NaN'):true()}, map{xs:float('NaN'):true()})
fn:deep-equal(/works[1]/employee[12]/following::employee,/works[1]/employee[12]/following::employee)
fn:deep-equal(/works[1]/employee[12]/following-sibling::employee,/works[1]/employee[12]/following-sibling::employee)
fn:deep-equal(/works[1]/employee[12]/preceding::employee,/works[1]/employee[12]/preceding::employee)
fn:deep-equal(/works[1]/employee[12]/preceding-sibling::employee,/works[1]/employee[12]/preceding-sibling::employee)
fn:deep-equal(/works/employee[12]/overtime/ancestor-or-self::works,/works/employee[12]/overtime/ancestor-or-self::works)
fn:deep-equal(/works/employee[12]/overtime/ancestor::works,/works/employee[12]/overtime/ancestor::works)
fn:deep-equal( xs:anyURI("www.example.com") , "www.example.com")
fn:deep-equal( xs:anyURI("www.example.com") , xs:string("www.example.com"))
fn:deep-equal( xs:boolean("0") , xs:boolean("false"))
fn:deep-equal( xs:boolean("1") , xs:boolean("true"))
fn:deep-equal( xs:boolean("false") , false())
fn:deep-equal( xs:boolean("true") , true())
fn:deep-equal( xs:boolean("true") , xs:boolean("true"))
fn:deep-equal( xs:date("1993-03-31") , "1993-03-31")
fn:deep-equal( xs:date("1993-03-31") , xs:string("1993-03-31"))
fn:deep-equal(xs:dateTime("1972-12-31T00:00:00"), "1972-12-31T00:00:00")
fn:deep-equal( xs:decimal(1.01) , xs:double(1.01))
fn:deep-equal( xs:decimal(1.01) , xs:float(1.01))
fn:deep-equal((xs:decimal("617375191608514839")),(xs:decimal("-999999999999999999")))
fn:deep-equal((xs:decimal("-999999999999999999")),(xs:decimal("617375191608514839")))
fn:deep-equal((xs:decimal("-999999999999999999")),(xs:decimal("-999999999999999999")))
fn:deep-equal((xs:decimal("-999999999999999999")),(xs:decimal("999999999999999999")))
fn:deep-equal((xs:decimal("999999999999999999")),(xs:decimal("-999999999999999999")))
fn:deep-equal((xs:double("0")),(xs:double("-1.7976931348623157E308")))
fn:deep-equal((xs:double("-1.7976931348623157E308")),(xs:double("0")))
fn:deep-equal((xs:double("-1.7976931348623157E308")),(xs:double("-1.7976931348623157E308")))
fn:deep-equal((xs:double("-1.7976931348623157E308")),(xs:double("1.7976931348623157E308")))
fn:deep-equal((xs:double("1.7976931348623157E308")),(xs:double("-1.7976931348623157E308")))
fn:deep-equal((xs:float("0")),(xs:float("-3.4028235E38")))
fn:deep-equal((xs:float("-3.4028235E38")),(xs:float("0")))
fn:deep-equal((xs:float("-3.4028235E38")),(xs:float("-3.4028235E38")))
fn:deep-equal((xs:float("-3.4028235E38")),(xs:float("3.4028235E38")))
fn:deep-equal((xs:float("3.4028235E38")),(xs:float("-3.4028235E38")))
fn:deep-equal( xs:float("-INF") , xs:double("-INF"))
fn:deep-equal( xs:float("INF") , xs:double("INF"))
fn:deep-equal( xs:float("NaN") , xs:double("NaN"))
fn:deep-equal((xs:int("-1873914410")),(xs:int("-2147483648")))
fn:deep-equal((xs:int("2147483647")),(xs:int("-2147483648")))
fn:deep-equal((xs:int("-2147483648")),(xs:int("-1873914410")))
fn:deep-equal((xs:int("-2147483648")),(xs:int("2147483647")))
fn:deep-equal((xs:int("-2147483648")),(xs:int("-2147483648")))
fn:deep-equal( xs:integer(1) , xs:decimal(1.0))
fn:deep-equal( xs:integer(1) , xs:double(1.0))
fn:deep-equal( xs:integer(1) , xs:float(1.0))
fn:deep-equal( xs:integer(1) , xs:integer(-1))
fn:deep-equal((xs:nonNegativeInteger("0")),(xs:nonNegativeInteger("0")))
fn:deep-equal((xs:positiveInteger("1")),(xs:positiveInteger("1")))
fn:deep-equal((xs:short("32767")),(xs:short("-32768")))
fn:deep-equal((xs:short("-32768")),(xs:short("32767")))
fn:deep-equal((xs:short("-32768")),(xs:short("-32768")))
fn:deep-equal((xs:short("-32768")),(xs:short("-5324")))
fn:deep-equal((xs:short("-5324")),(xs:short("-32768")))
fn:deep-equal( xs:string("") , (""))
fn:deep-equal( xs:string("A") , "a")
fn:deep-equal( xs:string("A") , "A")
fn:deep-equal( xs:string("A") , ("A"))
fn:deep-equal(xs:string("abc"), xs:string("cba"))
fn:deep-equal(xs:time("12:30:00"), "12:30:00")
fn:deep-equal((xs:unsignedLong("0")),(xs:unsignedLong("0")))
fn:deep-equal((xs:unsignedShort("0")),(xs:unsignedShort("0")))
fn:deep-equal((xs:unsignedShort("0")),(xs:unsignedShort("44633")))
fn:deep-equal((xs:unsignedShort("0")),(xs:unsignedShort("65535")))
fn:deep-equal((xs:unsignedShort("44633")),(xs:unsignedShort("0")))
fn:deep-equal((xs:unsignedShort("65535")),(xs:unsignedShort("0")))
fn:empty("")
fn:empty([])
fn:empty((1,2,3)[10])
fn:empty(fn:remove(("hello", "world"), 1))
fn:empty(fn:string-to-codepoints(()))
fn:empty(fn:string-to-codepoints("A String"))
fn:empty(map{})
fn:empty((xs:decimal("617375191608514839")))
fn:empty((xs:decimal("-999999999999999999")))
fn:empty((xs:decimal("999999999999999999")))
fn:empty((xs:double("0")))
fn:empty((xs:double("-1.7976931348623157E308")))
fn:empty((xs:double("1.7976931348623157E308")))
fn:empty((xs:float("0")))
fn:empty((xs:float("-3.4028235E38")))
fn:empty((xs:float("3.4028235E38")))
fn:empty((xs:int("-1873914410")))
fn:empty((xs:int("2147483647")))
fn:empty((xs:int("-2147483648")))
fn:empty((xs:negativeInteger("-1")))
fn:empty((xs:nonNegativeInteger("0")))
fn:empty((xs:nonPositiveInteger("0")))
fn:empty((xs:positiveInteger("1")))
fn:empty((xs:short("32767")))
fn:empty((xs:short("-32768")))
fn:empty((xs:short("-5324")))
fn:empty((xs:unsignedLong("0")))
fn:empty((xs:unsignedShort("0")))
fn:empty((xs:unsignedShort("44633")))
fn:empty((xs:unsignedShort("65535")))
(fn:encode-for-uri("example"))
(fn:encode-for-uri("examples0123456789example"))
(fn:encode-for-uri("examples example"))
(fn:encode-for-uri("examples!example"))
(fn:encode-for-uri("examples#example"))
(fn:encode-for-uri("examples'example"))
(fn:encode-for-uri("examples(example"))
(fn:encode-for-uri("examples)example"))
(fn:encode-for-uri("examples*example"))
(fn:encode-for-uri("examples-example"))
(fn:encode-for-uri("examples.example"))
(fn:encode-for-uri("examples/example"))
(fn:encode-for-uri("examples_example"))
(fn:encode-for-uri("examples~example"))
(fn:encode-for-uri("http%20examples"))
(fn:encode-for-uri("http:examples"))
fn:encode-for-uri ("http://www.example.com/00/Weather/CA/Los%20Angeles#ocean")
fn:encode-for-uri("http://www.example.com/00/Weather/CA/Los%20Angeles#ocean")
fn:ends-with ((), ())
fn:ends-with("","")
fn:ends-with("",())
fn:ends-with((),"")
fn:ends-with("a","A")
fn:ends-with("A","a")
fn:ends-with(" ","AAAAABBBBB")
fn:ends-with("AAAAABBBBB"," ")
fn:ends-with("AAAAABBBBBCCCCC","BBBBB")
fn:ends-with("","A Character String")
fn:ends-with("A Character String","")
fn:ends-with("A Character String",())
fn:ends-with((),"A Character String")
fn:ends-with("A",xs:string("A"))
fn:ends-with(fn:prefix-from-QName(xs:QName("foo:bar")),"f")
fn:ends-with("Query","ry") eq xs:boolean("false")
fn:ends-with ( "tattoo", "atto")
fn:ends-with ( "tattoo", "tattoo")
fn:ends-with(xs:string("A"),"A")
fn:ends-with(xs:string("This is a characte"),xs:string("This is a characte"))
fn:error(fn:QName('http://www.example.com/HR', 'myerr:toohighsal'),                   'Does not apply because salary is too high')
fn:escape-uri("http:/example.com/")
fn:exactly-one((1,2))
fn:exactly-one(xs:double("0"))
fn:exactly-one(xs:double("-1.7976931348623157E308"))
fn:exactly-one(xs:double("1.7976931348623157E308"))
fn:exactly-one(xs:float("0"))
fn:exactly-one(xs:float("-3.4028235E38"))
fn:exactly-one(xs:float("3.4028235E38"))
fn:exactly-one(xs:int("-1873914410"))
fn:exactly-one(xs:int("2147483647"))
fn:exactly-one(xs:int("-2147483648"))
fn:exactly-one(xs:negativeInteger("-1"))
fn:exactly-one(xs:nonNegativeInteger("0"))
fn:exactly-one(xs:nonPositiveInteger("0"))
fn:exactly-one(xs:positiveInteger("1"))
fn:exactly-one(xs:short("32767"))
fn:exactly-one(xs:short("-32768"))
fn:exactly-one(xs:short("-5324"))
fn:exactly-one(xs:unsignedLong("0"))
fn:exactly-one(xs:unsignedShort("0"))
fn:exactly-one(xs:unsignedShort("44633"))
fn:exactly-one(xs:unsignedShort("65535"))
fn:exists("")
fn:exists([])
fn:exists( fn:filter#2 )
fn:exists( fn:has-children#0 )
fn:exists( fn:has-children#1 )
fn:exists( fn:innermost#1 )
fn:exists( fn:outermost#1 )
fn:exists(fn:remove(("hello"), 1))
fn:exists(fn:remove(("hello", "world"), 1))
fn:exists(fn:string-to-codepoints(()))
fn:exists(fn:string-to-codepoints("A String"))
fn:exists(map{})
fn:exists((xs:decimal("617375191608514839")))
fn:exists((xs:decimal("-999999999999999999")))
fn:exists((xs:decimal("999999999999999999")))
fn:exists((xs:double("0")))
fn:exists((xs:double("-1.7976931348623157E308")))
fn:exists((xs:double("1.7976931348623157E308")))
fn:exists( xs:error#1 )
fn:exists((xs:float("0")))
fn:exists((xs:float("-3.4028235E38")))
fn:exists((xs:float("3.4028235E38")))
fn:exists((xs:int("-1873914410")))
fn:exists((xs:int("2147483647")))
fn:exists((xs:int("-2147483648")))
fn:exists((xs:negativeInteger("-1")))
fn:exists((xs:nonNegativeInteger("0")))
fn:exists((xs:nonPositiveInteger("0")))
fn:exists((xs:positiveInteger("1")))
fn:exists((xs:short("32767")))
fn:exists((xs:short("-32768")))
fn:exists((xs:short("-5324")))
fn:exists((xs:unsignedLong("0")))
fn:exists((xs:unsignedShort("0")))
fn:exists((xs:unsignedShort("44633")))
fn:exists((xs:unsignedShort("65535")))
fn:false()
fn:false() and fn:false()
fn:false() eq fn:false()
(fn:false(),fn:false())
fn:false() != fn:false()
fn:false() < fn:false()
fn:false() <= fn:false()
fn:false() = fn:false()
fn:false() > fn:false()
fn:false() >= fn:false()
(fn:false(),fn:true(),fn:false())[fn:not(xs:boolean(.))]
fn:false() ge fn:false()
fn:false() gt fn:false()
fn:false() le fn:false()
fn:false() lt fn:false()
fn:false() ne fn:false()
fn:false() or fn:false()
fn:filter()
fn:filter#0
fn:filter#1
fn:filter( ("1", "2", "3"), function($arg as xs:integer) as xs:boolean { $arg eq 100 } )
fn:filter(1 to 10, function($a) {$a mod 2 = 0})
fn:filter( 1 to 10, function($arg) { if ($arg eq 100) then 0 else fn:true()})
fn:filter( 1 to 10, function($arg) { if ($arg eq 100) then () else fn:true()})
fn:filter( 1 to 10, function($arg) { if ($arg eq 100) then (fn:true(), fn:false()) else fn:true()})
fn:filter( 1 to 10, function($arg) { if ($arg eq 10) then 0 else fn:true()})
fn:filter( 1 to 10, function($arg) { if ($arg eq 10) then () else fn:true()})
fn:filter( 1 to 10, function($arg) { if ($arg eq 10) then (fn:true(), fn:false()) else fn:true()})
fn:filter( fn:boolean#1 )
fn:filter( (), fn:string#1 )
fn:filter( (), fn:true() )
fn:filter( (), function($a as item()) as xs:boolean? { () } )
fn:filter( (), function($a as item()) as xs:boolean* { fn:boolean($a), fn:boolean($a) } )
fn:floor(-10.5)
fn:floor(10.5)
fn:floor(xs:double("0"))
fn:floor(xs:double("-1.7976931348623157E308"))
fn:floor(xs:double("1.7976931348623157E308"))
fn:floor(xs:float("0"))
fn:floor(xs:float("-3.4028235E38"))
fn:floor(xs:float("3.4028235E38"))
fn:floor(xs:int("-1873914410"))
fn:floor(xs:int("2147483647"))
fn:floor(xs:int("-2147483648"))
fn:floor(xs:negativeInteger("-1"))
fn:floor(xs:nonNegativeInteger("0"))
fn:floor(xs:nonPositiveInteger("0"))
fn:floor(xs:positiveInteger("1"))
fn:floor(xs:short("32767"))
fn:floor(xs:short("-32768"))
fn:floor(xs:short("-5324"))
fn:floor(xs:unsignedLong("0"))
fn:floor(xs:unsignedShort("0"))
fn:floor(xs:unsignedShort("44633"))
fn:floor(xs:unsignedShort("65535"))
fn:fold-left(1 to 5, "$zero", fn:concat("$f(", ?, ", ", ?, ")"))
fn:fold-left(1 to 5, 0, function($a, $b) { $a + $b                   })
fn:fold-left(1 to 5, "", fn:concat(?, ".", ?))
fn:fold-left(1 to 5, (), function($a, $b) {($b,                   $a)})
fn:fold-left(1 to 5, map{}, function($map, $n) {map:put($map, $n, $n*2)})
fn:fold-left((2,3,5,7), 1, function($a, $b) { $a * $b                   })
fn:fold-left((true(), false(), false()), false(), function($a, $b) {                   $a and $b })
fn:fold-left((true(), false(), false()), false(), function($a, $b) {                   $a or $b })
fn:fold-right(1 to 5, "$zero", concat("$f(", ?, ", ", ?,                   ")"))
fn:fold-right(1 to 5, 0, function($a, $b) { $a + $b                   })
fn:fold-right(1 to 5, "", fn:concat(?, ".", ?))
fn:for-each(1 to 5, function($a) { $a * $a })
fn:for-each(("23", "29"), xs:int#1)
fn:for-each(("john", "jane"),                   fn:string-to-codepoints#1)
fn:for-each(("we", "th"),                 map{"su":"Sunday","mo":"Monday","tu":"Tuesday","we":"Wednesday","th":"Thursday","fr":"Friday","sa":"Saturday"}             )
fn:func-does-not-exist(1, 2, 3)
fn:function-arity(fn:substring#2)
fn:function-arity(function($node){name($node)})
fn:function-lookup()
fn:function-lookup#0
fn:function-lookup#1
fn:function-lookup( (), 1 )
fn:function-lookup#3
( fn:function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'node-name'),                                  if (current-date() eq xs:date('1900-01-01'))                                  then ()                                  else 1 ),               fn:function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'node-name'),                                  if (current-date() eq xs:date('1900-01-01'))                                  then 1                                  else () ) )
fn:function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'node-name'),                                if ( fn:current-dateTime() eq                                     fn:dateTime( fn:current-date(),                                                  fn:current-time() ))                                then ()                                else 1 )
( fn:function-lookup((if (current-date() eq xs:date('1900-01-01'))                                   then fn:QName('http://www.w3.org/2005/xpath-functions', 'node-name')                                   else ()), 1),               fn:function-lookup((if (current-date() eq xs:date('1900-01-01'))                                   then ()                                   else fn:QName('http://www.w3.org/2005/xpath-functions', 'node-name')), 1))
fn:function-lookup(xs:QName('fn:substring'), 2)('abcd',                   2)
fn:function-name( () )
fn:function-name()
fn:function-name#0
fn:function-name( 1 )
fn:function-name#2
fn:function-name( concat#99 )
fn:function-name( dateTime#2 )
fn:function-name( (fn:dateTime#2, fn:dateTime#2) )
fn:function-name( fn:dateTime#2, fn:dateTime#2 )
fn:function-name( fn:substring#2 )
fn:function-name(fn:substring#2)
fn:function-name( function($arg1, $arg2)                                { subsequence($arg1, $arg2, 1) } )
fn:function-name(function($node){count($node/*)})
fn:function-name( function($node){name($node)} )
( fn:function-name( if (current-date() eq xs:date('1900-01-01'))                                 then fn:dateTime#2                                 else 1 ),               fn:function-name( if (current-date() eq xs:date('1900-01-01'))                                 then 1                                 else fn:dateTime#2 ) )
fn:function-name( math:pow#2 )
/fn:has-children()
fn:has-children( (.,.) )
fn:has-children( / )
fn:has-children()
fn:has-children(.)
fn:has-children(1)
fn:has-children#2
fn:has-children(fn:concat#2)
fn:has-children( fn:contains#2, fn:contains#2 )
fn:has-children( /root )
fn:has-children( /root/@attribute )
fn:has-children( /root/comment() )
fn:has-children( /root/empty )
fn:has-children( /root/non-empty )
fn:has-children( /root/processing-instruction() )
fn:has-children( /root/text() )
fn:head(())
fn:head([1,2,3])
fn:head(1 to 5)
fn:head(("a", "b", "c"))
fn:hours-from-dateTime(fn:current-dateTime())
fn:hours-from-dateTime(fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00")))
fn:hours-from-dateTime(xs:dateTime("1970-01-01T00:00:00"))
fn:hours-from-dateTime(xs:dateTime("1970-01-01T00:00:00Z")) + fn:hours-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:hours-from-dateTime(xs:dateTime("1970-01-01T00:00:00Z")) - fn:hours-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:hours-from-dateTime(xs:dateTime("1970-01-01T02:00:00Z")) div fn:hours-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:hours-from-dateTime(xs:dateTime("1970-01-01T02:00:00Z")) * fn:hours-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
+fn:hours-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
-fn:hours-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:hours-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")) eq fn:hours-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:hours-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")) ge fn:hours-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:hours-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")) idiv fn:hours-from-dateTime(xs:dateTime("1970-01-01T02:00:00Z"))
fn:hours-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")) le fn:hours-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:hours-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")) mod fn:hours-from-dateTime(xs:dateTime("1970-01-01T03:00:00Z"))
fn:hours-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")) ne fn:hours-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:hours-from-dateTime(xs:dateTime("1996-04-07T01:40:52"))
fn:hours-from-dateTime(xs:dateTime("1999-05-31T00:20:00-05:00"))
fn:hours-from-dateTime(xs:dateTime("1999-05-31T08:20:00-05:00"))
fn:hours-from-dateTime(xs:dateTime("1999-05-31T23:20:00-05:00"))
fn:hours-from-dateTime(xs:dateTime("1999-12-31T12:00:00"))
fn:hours-from-dateTime(xs:dateTime("1999-12-31T21:20:00-05:00"))
fn:hours-from-dateTime(xs:dateTime("1999-12-31T24:00:00"))
fn:hours-from-dateTime(xs:dateTime("2030-12-31T23:59:59"))
fn:hours-from-duration(xs:dayTimeDuration("P01DT01H"))
fn:hours-from-duration(xs:dayTimeDuration("P0DT0H0M0S"))
fn:hours-from-duration(xs:dayTimeDuration("P10DT10H")) mod fn:hours-from-duration(xs:dayTimeDuration("P03DT02H"))
fn:hours-from-duration(xs:dayTimeDuration("P15DT11H59M59S"))
-fn:hours-from-duration(xs:dayTimeDuration("P20DT02H"))
fn:hours-from-duration(xs:dayTimeDuration("P20DT03H")) le fn:hours-from-duration(xs:dayTimeDuration("P21DT01H"))
fn:hours-from-duration(xs:dayTimeDuration("P20DT05H")) * fn:hours-from-duration(xs:dayTimeDuration("P03DT08H"))
fn:hours-from-duration(xs:dayTimeDuration("P20DT10H")) div fn:hours-from-duration(xs:dayTimeDuration("P05DT05H"))
fn:hours-from-duration(xs:dayTimeDuration("P21DT07H")) ge fn:hours-from-duration(xs:dayTimeDuration("P20DT08H"))
+fn:hours-from-duration(xs:dayTimeDuration("P21DT10H"))
fn:hours-from-duration(xs:dayTimeDuration("P21DT10H")) + fn:hours-from-duration(xs:dayTimeDuration("P22DT20H"))
fn:hours-from-duration(xs:dayTimeDuration("P22DT09H")) eq fn:hours-from-duration(xs:dayTimeDuration("P22DT09H"))
fn:hours-from-duration(xs:dayTimeDuration("P23DT07H")) ne fn:hours-from-duration(xs:dayTimeDuration("P12DT05H"))
fn:hours-from-duration(xs:dayTimeDuration("P25DT10H")) idiv fn:hours-from-duration(xs:dayTimeDuration("P05DT02H"))
fn:hours-from-duration(xs:dayTimeDuration("P30DT10H")) - fn:hours-from-duration(xs:dayTimeDuration("P10DT02H"))
fn:hours-from-duration(xs:dayTimeDuration("P31DT23H59M59S"))
fn:hours-from-duration(xs:dayTimeDuration("-P3DT10H"))
fn:hours-from-duration(xs:dayTimeDuration("P3DT10H"))
fn:hours-from-duration(xs:dayTimeDuration("P3DT12H32M12S"))
fn:hours-from-duration(xs:dayTimeDuration("PT123H"))
fn:hours-from-duration(xs:duration("P1Y2M3DT10H30M"))
fn:hours-from-duration(xs:yearMonthDuration('P1Y'))
fn:hours-from-time(fn:current-time())
fn:hours-from-time(xs:time("00:00:00Z"))
fn:hours-from-time(xs:time("00:20:00Z"))
fn:hours-from-time(xs:time("00:59:00Z"))
fn:hours-from-time(xs:time("01:23:00+05:00"))
fn:hours-from-time(xs:time("02:00:00Z")) * fn:hours-from-time(xs:time("10:00:00Z"))
fn:hours-from-time(xs:time("02:00:00Z")) + fn:hours-from-time(xs:time("10:00:00Z"))
fn:hours-from-time(xs:time("08:03:35Z"))
+fn:hours-from-time(xs:time("10:00:00Z"))
-fn:hours-from-time(xs:time("10:00:00Z"))
fn:hours-from-time(xs:time("10:00:00Z")) eq fn:hours-from-time(xs:time("10:00:00Z"))
fn:hours-from-time(xs:time("10:00:00Z")) - fn:hours-from-time(xs:time("09:00:00Z"))
fn:hours-from-time(xs:time("10:00:00Z")) ge fn:hours-from-time(xs:time("10:00:00Z"))
fn:hours-from-time(xs:time("10:00:00Z")) idiv fn:hours-from-time(xs:time("02:00:00Z"))
fn:hours-from-time(xs:time("10:00:00Z")) le fn:hours-from-time(xs:time("10:00:00Z"))
fn:hours-from-time(xs:time("10:00:00Z")) mod fn:hours-from-time(xs:time("03:00:00Z"))
fn:hours-from-time(xs:time("10:00:00Z")) ne fn:hours-from-time(xs:time("01:00:00Z"))
fn:hours-from-time(xs:time("11:23:00"))
fn:hours-from-time(xs:time("11:23:00Z"))
fn:hours-from-time(xs:time("21:23:00"))
fn:hours-from-time(xs:time("21:23:00Z"))
fn:hours-from-time(xs:time("22:00:00Z")) div fn:hours-from-time(xs:time("02:00:00Z"))
fn:hours-from-time(xs:time("23:20:00Z"))
fn:hours-from-time(xs:time("23:59:59Z"))
fn:hours-from-time(xs:time("24:00:00"))
fn:id("argument1", "A")
fn:id("argument 1", / ,"Argument 3")
fn:id('id', <a />)
fn:id("", /IDS[1])
fn:id("p1:id5", /IDS[1])
fn:idref("argument1",.)
fn:idref("argument1", "A")
fn:idref("argument 1", / ,"Argument 3")
fn:idref("nomatchingid", /IDS[1])
fn:implicit-timezone()
fn:implicit-timezone("Argument 1")
fn:implicit-timezone() * xs:double(2)
fn:index-of((),"")
fn:index-of ((10, 20, 30, 30, 20, 10), 20)
fn:index-of((10, 20, 30, 30, 20, 10), 20)
fn:index-of ((10, 20, 30, 40), 35)
fn:index-of((10, 20, 30, 40), 35)
fn:index-of(((1),(1), (2,1), (0,1)),1)
fn:index-of((1, (1,2,3)),1)
fn:index-of((1,2,3,4))
fn:index-of([1, [5, 6], [6, 7]], 6)
fn:index-of (("a", "sport", "and", "a", "pastime"), "a")
fn:index-of(("a", "sport", "and", "a", "pastime"),                   "a")
fn:index-of((/bib/book/publisher), "Addison-Wesley")
fn:index-of((/bib/book/publisher), /bib/book[1]/publisher[1]/text() cast as xs:string)
fn:index-of((),fn:exactly-one(xs:untypedAtomic('')))
fn:index-of(("sport"), "")
fn:index-of(("sport", "", "and", "", "", "pastime"), "")
fn:index-of((xs:decimal('9.99999999999999999999999999')), fn:exactly-one(xs:decimal('9.99999999999999999999999999')))
fn:index-of((xs:double('-INF')), fn:exactly-one(xs:double('-INF')))
fn:index-of((xs:double('INF')), fn:exactly-one(xs:double('INF')))
fn:index-of((xs:double('NaN')), fn:exactly-one(xs:double('NaN')))
fn:index-of((xs:float('NaN')), fn:exactly-one(xs:float('NaN')))
fn:index-of((xs:negativeInteger('-2'), xs:negativeInteger('-1')), fn:exactly-one(xs:negativeInteger('-1')))
fn:index-of((xs:positiveInteger('1'),xs:positiveInteger('2')), fn:exactly-one(xs:positiveInteger('2')))
fn:innermost( / )
fn:innermost( //* )
fn:innermost( //*/@* )
fn:innermost()
fn:innermost( ($doc1//node(), $doc2//node()) )
fn:innermost#0
fn:innermost( (), 1 )
fn:innermost( 1 )
fn:innermost#2
fn:innermost( //comment() )
fn:innermost( //comment() ) ! string()
fn:innermost( fn:dateTime#2 )
( fn:innermost( if (current-date() eq xs:date('1900-01-01'))                                  then .                                  else 1 ),               fn:innermost( if (current-date() eq xs:date('1900-01-01'))                                  then 1                                  else . ) )
( fn:innermost( if (current-date() eq xs:date('1900-01-01'))                                  then .                                  else fn:dateTime#2 ),               fn:innermost( if (current-date() eq xs:date('1900-01-01'))                                  then fn:dateTime#2                                  else . ) )
fn:innermost( //* ) ! local-name(.)
fn:innermost( //node() )
fn:innermost( //processing-instruction() )
fn:innermost( //processing-instruction() ) ! local-name()
fn:innermost( /root/descendant::node() )
fn:innermost( /root/level[1]/following-sibling::node() )
fn:innermost( /root/level[1]/level[1]/ancestor::node() )
fn:innermost( /root/level[1]/level[1]/following::node() )
fn:innermost( /root/level[1]/level[last()]/preceding::node() )
fn:innermost( /root/level[1]/level[last()]/preceding-sibling::node() )
fn:innermost( /root/node() )
fn:innermost( /root/node()/.. )
fn:innermost( //*/@* ) ! string()
fn:innermost( //text() )
fn:innermost( //text() ) ! string()
fn:insert-before( ("a", "b", "c"),0, ())
fn:insert-before( ("a", "b", "c"),1, "z")
fn:insert-before( ("a", "b", "c"),2, ())
fn:insert-before( ("a", "b", "c"),2, xs:anyURI("www.example.com"))
fn:insert-before( ("a", "b", "c"),2, xs:boolean("0"))
fn:insert-before( ("a", "b", "c"),2, xs:boolean("1"))
fn:insert-before( ("a", "b", "c"),2, xs:boolean("false"))
fn:insert-before( ("a", "b", "c"),2, xs:boolean("true"))
fn:insert-before( ("a", "b", "c"),2, xs:decimal("1.1"))
fn:insert-before( ("a", "b", "c"),2, xs:double("INF"))
fn:insert-before( ("a", "b", "c"),2, xs:double("NaN"))
fn:insert-before( ("a", "b", "c"),2, xs:float("-0"))
fn:insert-before( ("a", "b", "c"),2, xs:float("1.1"))
fn:insert-before( ("a", "b", "c"),2, xs:float("-INF"))
fn:insert-before( ("a", "b", "c"),2, xs:float("NaN"))
fn:insert-before( ("a", "b", "c"),2, xs:integer("100"))
fn:insert-before( ("a", "b", "c"),2, xs:string(" "))
fn:insert-before( ("a", "b", "c"),4, xs:date("1993-03-31"))
fn:insert-before( ("a", "b", "c"),4, xs:dateTime("1972-12-31T00:00:00"))
fn:insert-before( ("a", "b", "c"),4, xs:time("12:30:00"))
fn:iri-to-uri("example")
fn:iri-to-uri("example$example")
fn:iri-to-uri("example0123456789")
fn:iri-to-uri("example&amp;amp;example")
fn:iri-to-uri("example&amp;example")
fn:iri-to-uri("example example")
fn:iri-to-uri("example!example")
fn:iri-to-uri("example#example")
fn:iri-to-uri("example%example")
fn:iri-to-uri("example'example")
fn:iri-to-uri("example(example")
fn:iri-to-uri("example)example")
fn:iri-to-uri("example*example")
fn:iri-to-uri("example+example")
fn:iri-to-uri("example,example")
fn:iri-to-uri("example-example")
fn:iri-to-uri("example.example")
fn:iri-to-uri("example/example")
fn:iri-to-uri("example:example")
fn:iri-to-uri("example;example")
fn:iri-to-uri("example=example")
fn:iri-to-uri("example?example")
fn:iri-to-uri("example@example")
fn:iri-to-uri("example[example")
fn:iri-to-uri("example]example")
fn:iri-to-uri("example_example")
fn:iri-to-uri("example~example")
fn:iri-to-uri                   ("http://www.example.com/00/Weather/CA/Los%20Angeles#ocean")
fn:iri-to-uri ("http://www.example.com/~bb")
fn:local-name-from-QName("")
fn:local-name-from-QName(((),()))
fn:local-name-from-QName(())
fn:local-name-from-QName()
fn:local-name-from-QName(fn:node-name(attribute attributeName {""}))
fn:local-name-from-QName(fn:node-name(attribute attributeName {"an attribute value"}))
fn:local-name-from-QName(fn:node-name(element elementName {}))
fn:local-name-from-QName(fn:node-name(element elementName { element achild {"some text"}}))
fn:local-name-from-QName(fn:node-name(<?format role="output" ?>))
fn:local-name-from-QName(fn:node-name(processing-instruction piName {"Processing Instruction content"}))
fn:local-name-from-QName(fn:node-name(<shoe size = "5"/>))
fn:local-name-from-QName(fn:node-name(/works[1]/employee[2]))
fn:local-name-from-QName(fn:QName("http://www.example.com/example",                   "person"))
fn:local-name-from-QName(fn:QName("http://www.example.com/QNameXSD", exactly-one(xs:string(data((/root/elemQN)[1])))))
fn:local-name-from-QName(fn:QName("http://www.example.com/QNameXSD", exactly-one(xs:string(/root[1]/@attrDerivQN))))
fn:local-name-from-QName(fn:QName("http://www.example.com/QNameXSD", exactly-one(xs:string(/root[1]/@attrDerivQN)))) instance of xs:NCName ?
fn:local-name-from-QName(fn:QName("http://www.example.com/QNameXSD", exactly-one(xs:string(/root[1]/@attrQN))))
fn:local-name-from-QName(fn:QName("http://www.example.com/QNameXSD", exactly-one(xs:string((/root/derivQN)[1]))))
fn:local-name-from-QName(fn:QName("http://www.example.com/QNameXSD", exactly-one(xs:string((/root/elemQN)[1]))))
fn:local-name-from-QName( if( false() ) then fn:QName("http://www.example.com/QNameXSD", exactly-one(xs:string((/root/elemQN)[1]))) else fn:QName("http://www.example.com/QNameXSD", exactly-one(xs:string((/root/@attrQN)[1]))) )
fn:local-name-from-QName( if( true() ) then fn:QName("http://www.example.com/QNameXSD", exactly-one(xs:string((/root/elemQN)[1]))) else fn:QName("http://www.example.com/QNameXSD", exactly-one(xs:string((/root/@attrQN)[1]))) )
fn:local-name-from-QName(node-name(/*))
fn:local-name-from-QName(node-name((//@*)[1]))
fn:local-name-from-QName(/root/elemQN)
fn:local-name-from-qname((/root/elemQN)[1])
fn:local-name-from-Qname((/root/elemQN)[1])
fn:localnamefromQName((/root/elemQN)[1])
fn:local-name-from-QName(xs:integer("100"))
fn:local-name-from-QName(xs:time("12:00:00Z"))
fn:lower-case("*****")
fn:lower-case("%$#@!")
fn:lower-case("12345")
fn:lower-case("12345abcd")
fn:lower-case("abc") and fn:lower-case("abc")
fn:lower-case("ABc!D")
fn:lower-case("ABCD")
fn:lower-case("abcde")
fn:lower-case("ABCDEabcde")
fn:lower-case(fn:codepoints-to-string((97,32,115,116,114,105,110,103)))
fn:lower-case(fn:prefix-from-QName(xs:QName("FOO:bar")))
fn:lower-case("lower-case")
fn:lower-case(lower-case("zzzzz"))
fn:lower-case(upper-case("AbcDH"))
fn:lower-case(xs:string("This is a characte"))
fn:matches('1.0', '\i+')
fn:matches('1.0', '\I+')
fn:matches('a', '[a--]')
fn:matches('aa', '(a\1)')
fn:matches('aA', '(a)\99')
fn:matches("aaababaaabaa", "^(a*b?a*){3,3}$")
fn:matches("a", "a[^b]"), fn:matches("a ", "a[^b]")
fn:matches('-abba-', '[-ab]+')
fn:matches("#abc#1", "^((#)abc\1)$")
fn:matches("#abc#1", "^(#)abc[\1]1$")
fn:matches("#abc#1", "^(#)abc\2$")
fn:matches('abc', '\c+')
fn:matches('abc', '\C+')
fn:matches('abcdefghii', '(a)(b)(c)(d)(e)(f)(g)(h)(i\9)')
fn:matches('abcdefghijj', '(a)(b)(c)(d)(e)(f)(g)(h)(i)(j\10)')
fn:matches('abcdefghijk', '(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k\11)')
fn:matches("abcdefghijklmnopq", "(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)((m)(n)(o)(p)(q)\13)$")
fn:matches('abc', '\S+')
fn:matches("abracadabra", "**%%")
fn:matches("abracadabra", "^a.*a$")
fn:matches("abracadabra", "(?:abra(?:cad)?)*")
fn:matches("abracadabra(abracadabra", "\(")
fn:matches("abracadabra)abracadabra", "\)")
fn:matches("abracadabra*abracadabra", "\*")
fn:matches("abracadabra+abracadabra", "\+")
fn:matches("abracadabra-abracadabra", "\-")
fn:matches("abracadabra-abracadabra.", "\.")
fn:matches("abracadabra.abracadabra", "\.")
fn:matches("abracadabra?abracadabra", "\?")
fn:matches("abracadabra[abracadabra", "\[")
fn:matches("abracadabra\abracadabra", "\\")
fn:matches("abracadabra]abracadabra", "\]")
fn:matches("abracadabra^abracadabra", "\^")
fn:matches("abracadabra{abracadabra", "\{")
fn:matches("abracadabra|abracadabra", "\|")
fn:matches("abracadabra}abracadabra", "\}")
fn:matches("abracadabra-abracadabra-3", "(124|864|377|3)")
fn:matches("abracadabraabracadabra", "aa{1}")
fn:matches("abracadabraabracadabraabracadabra", "aa{1,}")
fn:matches("abracadabraabracadabraabracadabra", "aa{1,2}")
fn:matches("abracadabra abracadabra", "\n")
fn:matches("abracadabra abracadabra", "\t")
fn:matches("abracadabra", "^bra")
fn:matches("abracadabra", "bra")
fn:matches('a_:', '\i+')
fn:matches('a_:', '\I+')
fn:matches('  ', '\c+')
fn:matches(concat('abcd', codepoints-to-string(10), 'defg', codepoints-to-string(10)), "g$")
fn:matches(concat('Mary', codepoints-to-string(10), 'Jones'), 'Mary.Jones')
fn:matches(concat('Mary', codepoints-to-string(10)), 'Mary$')
fn:matches(concat('Mary', codepoints-to-string(13), 'Jones'), 'Mary.Jones')
fn:matches('foo', '[^]')
fn:matches('foo', '[a-\b]')
fn:matches('foo', 'a()b')
fn:matches('foo', '\P{C')
fn:matches('foo', '\P{C}')
fn:matches('foo', '\P{Ca}')
fn:matches('foo', '\P{Cc}')
fn:matches('foo', '\P{L')
fn:matches('foo', '\P{L}')
fn:matches('foo', '\P{La}')
fn:matches('foo', '\P{Lu}')
fn:matches('foo', '\P{M')
fn:matches('foo', '\P{M}')
fn:matches('foo', '\P{Ma}')
fn:matches('foo', '\P{Me}')
fn:matches('foo', '\P{N')
fn:matches('foo', '\P{N}')
fn:matches('foo', '\P{Na}')
fn:matches('foo', '\P{No}')
fn:matches('foo', '\P{P')
fn:matches('foo', '\P{P}')
fn:matches('foo', '\P{Pa}')
fn:matches('foo', '\P{Pf}')
fn:matches('foo', '\P{S')
fn:matches('foo', '\P{S}')
fn:matches('foo', '\P{Sa}')
fn:matches('foo', '\P{Sk}')
fn:matches('foo', '\P{Z')
fn:matches('foo', '\P{Z}')
fn:matches('foo', '\P{Za}')
fn:matches('foo', '\P{Zs}')
fn:matches("h", "(.)\2")
fn:matches("h", "(.)\3")
fn:matches("hello world", "\p{ IsBasicLatin}+")
fn:matches("input", "[0-9-.]*/")
fn:matches('   ', '\S+')
fn:matches(' ', '[\t]')
fn:matches("This is a characte","This is a characte")
fn:matches('&#x10000;', '&#x10000;')
fn:matches('&#x20;&#x9;&#xD;', '\c+')
fn:matches('&#x20;&#x9;&#xD;', '\C+')
fn:matches('&#x9;', '[\t]')
fn:matches('&#xD;&#x20;&#x9;', '\S+')
(fn:max((1,2)) to 5)
fn:max((1 to 5))
fn:max((3,4,5))
fn:max((3,4,"Zero"))
fn:max(("a", "b", "c"))
fn:max((fn:current-date(), xs:date("2100-01-01")))
fn:max(fn:timezone-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")))
fn:max((xs:decimal("617375191608514839")))
fn:max((xs:decimal("617375191608514839"),xs:decimal("-999999999999999999")))
fn:max((xs:decimal("-999999999999999999")))
fn:max((xs:decimal("999999999999999999")))
fn:max((xs:decimal("-999999999999999999"),xs:decimal("617375191608514839")))
fn:max((xs:decimal("-999999999999999999"),xs:decimal("-999999999999999999")))
fn:max((xs:decimal("-999999999999999999"),xs:decimal("999999999999999999")))
fn:max((xs:decimal("999999999999999999"),xs:decimal("-999999999999999999")))
fn:max((xs:double("0")))
fn:max((xs:double("0"),xs:double("-1.7976931348623157E308")))
fn:max((xs:double("-1.7976931348623157E308")))
fn:max((xs:double("1.7976931348623157E308")))
fn:max((xs:double("-1.7976931348623157E308"),xs:double("0")))
fn:max((xs:double("-1.7976931348623157E308"),xs:double("-1.7976931348623157E308")))
fn:max((xs:double("-1.7976931348623157E308"),xs:double("1.7976931348623157E308")))
fn:max((xs:double("1.7976931348623157E308"),xs:double("-1.7976931348623157E308")))
fn:max((xs:float("0")))
fn:max((xs:float("0"),xs:float("-3.4028235E38")))
fn:max((xs:float("-3.4028235E38")))
fn:max((xs:float("3.4028235E38")))
fn:max((xs:float("-3.4028235E38"),xs:float("0")))
fn:max((xs:float("-3.4028235E38"),xs:float("-3.4028235E38")))
fn:max((xs:float("-3.4028235E38"),xs:float("3.4028235E38")))
fn:max((xs:float("3.4028235E38"),xs:float("-3.4028235E38")))
fn:max((xs:int("-1873914410")))
fn:max((xs:int("-1873914410"),xs:int("-2147483648")))
fn:max((xs:int("2147483647")))
fn:max((xs:int("2147483647"),xs:int("-2147483648")))
fn:max((xs:int("-2147483648")))
fn:max((xs:int("-2147483648"),xs:int("-1873914410")))
fn:max((xs:int("-2147483648"),xs:int("2147483647")))
fn:max((xs:int("-2147483648"),xs:int("-2147483648")))
fn:max((xs:integer(5000000000),xs:double(3e0)))
fn:max((xs:integer(5), xs:float(5.0), xs:double(0)))
fn:max((xs:negativeInteger("-1")))
fn:max((xs:nonNegativeInteger("0")))
fn:max((xs:nonNegativeInteger("0"),xs:nonNegativeInteger("0")))
fn:max((xs:nonPositiveInteger("0")))
fn:max((xs:positiveInteger("1")))
fn:max((xs:positiveInteger("1"),xs:positiveInteger("1")))
fn:max((xs:short("32767")))
fn:max((xs:short("32767"),xs:short("-32768")))
fn:max((xs:short("-32768")))
fn:max((xs:short("-32768"),xs:short("32767")))
fn:max((xs:short("-32768"),xs:short("-32768")))
fn:max((xs:short("-32768"),xs:short("-5324")))
fn:max((xs:short("-5324")))
fn:max((xs:short("-5324"),xs:short("-32768")))
fn:max((xs:unsignedLong("0")))
fn:max((xs:unsignedLong("0"),xs:unsignedLong("0")))
fn:max((xs:unsignedShort("0")))
fn:max((xs:unsignedShort("0"),xs:unsignedShort("0")))
fn:max((xs:unsignedShort("0"),xs:unsignedShort("44633")))
fn:max((xs:unsignedShort("0"),xs:unsignedShort("65535")))
fn:max((xs:unsignedShort("44633")))
fn:max((xs:unsignedShort("44633"),xs:unsignedShort("0")))
fn:max((xs:unsignedShort("65535")))
fn:max((xs:unsignedShort("65535"),xs:unsignedShort("0")))
fn:max( (xs:yearMonthDuration('P1Y0M'), 1) )
(fn:min((1,2)) to 5)
(fn:min((1,2)) to fn:max((6,7)))
fn:min((1 to 5))
fn:min((3,4,5))
fn:min((3,4,"Zero"))
fn:min(("a", "b", "c"))
fn:min((fn:current-date(), xs:date("1900-01-01")))
fn:min(fn:timezone-from-dateTime(xs:dateTime("1970-01-01T02:00:00Z")))
fn:minutes-from-dateTime(fn:current-dateTime())
fn:minutes-from-dateTime(fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00")))
fn:minutes-from-dateTime(xs:dateTime("1970-01-01T00:00:00Z"))
fn:minutes-from-dateTime(xs:dateTime("1970-01-01T00:00:00Z")) + fn:minutes-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:minutes-from-dateTime(xs:dateTime("1970-01-01T00:00:00Z")) - fn:minutes-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:minutes-from-dateTime(xs:dateTime("1970-01-01T02:02:00Z")) * fn:minutes-from-dateTime(xs:dateTime("1970-01-01T10:03:00Z"))
fn:minutes-from-dateTime(xs:dateTime("1970-01-01T02:10:00Z")) div fn:minutes-from-dateTime(xs:dateTime("1970-01-01T10:05:00Z"))
+fn:minutes-from-dateTime(xs:dateTime("1970-01-01T10:10:00Z"))
-fn:minutes-from-dateTime(xs:dateTime("1970-01-01T10:10:00Z"))
fn:minutes-from-dateTime(xs:dateTime("1970-01-01T10:10:00Z")) eq fn:minutes-from-dateTime(xs:dateTime("1970-01-01T10:10:00Z"))
fn:minutes-from-dateTime(xs:dateTime("1970-01-01T10:10:00Z")) ge fn:minutes-from-dateTime(xs:dateTime("1970-01-01T10:10:00Z"))
fn:minutes-from-dateTime(xs:dateTime("1970-01-01T10:10:00Z")) idiv fn:minutes-from-dateTime(xs:dateTime("1970-01-01T02:05:00Z"))
fn:minutes-from-dateTime(xs:dateTime("1970-01-01T10:10:00Z")) le fn:minutes-from-dateTime(xs:dateTime("1970-01-01T10:10:00Z"))
fn:minutes-from-dateTime(xs:dateTime("1970-01-01T10:10:00Z")) mod fn:minutes-from-dateTime(xs:dateTime("1970-01-01T03:10:00Z"))
fn:minutes-from-dateTime(xs:dateTime("1970-01-01T10:10:00Z")) ne fn:minutes-from-dateTime(xs:dateTime("1970-01-01T10:10:00Z"))
fn:minutes-from-dateTime(xs:dateTime("1996-04-07T01:40:52Z"))
fn:minutes-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))
fn:minutes-from-dateTime(xs:dateTime("1999-05-31T13:30:00+05:30"))
fn:minutes-from-dateTime(xs:dateTime("1999-05-31T20:00:00-05:00"))
fn:minutes-from-dateTime(xs:dateTime("1999-05-31T23:59:00-05:00"))
fn:minutes-from-dateTime(xs:dateTime("1999-12-31T21:20:00-05:00")) le fn:minutes-from-dateTime(xs:dateTime("1999-12-31T21:20:00-05:00"))
fn:minutes-from-dateTime(xs:dateTime("1999-12-31T21:20:00-05:00")) lt fn:minutes-from-dateTime(xs:dateTime("1999-12-31T21:20:00-05:00"))
fn:minutes-from-dateTime(xs:dateTime("2030-12-31T23:59:59Z"))
fn:minutes-from-duration(xs:dayTimeDuration("P01DT01H01M"))
fn:minutes-from-duration(xs:dayTimeDuration("P0DT0H0M0S"))
fn:minutes-from-duration(xs:dayTimeDuration("P10DT10H20M")) mod fn:minutes-from-duration(xs:dayTimeDuration("P03DT03H03M"))
fn:minutes-from-duration(xs:dayTimeDuration("P15DT11H59M59S"))
fn:minutes-from-duration(xs:dayTimeDuration("P20DT03H09M")) le fn:minutes-from-duration(xs:dayTimeDuration("P21DT15H21M"))
-fn:minutes-from-duration(xs:dayTimeDuration("P20DT03H20M"))
fn:minutes-from-duration(xs:dayTimeDuration("P20DT09H04M")) * fn:minutes-from-duration(xs:dayTimeDuration("P03DT10H10M"))
fn:minutes-from-duration(xs:dayTimeDuration("P20DT10H10M")) div fn:minutes-from-duration(xs:dayTimeDuration("P05DT05H02M"))
fn:minutes-from-duration(xs:dayTimeDuration("P20DT20H20M")) lt fn:minutes-from-duration(xs:dayTimeDuration("P03DT02H10M"))
fn:minutes-from-duration(xs:dayTimeDuration("P21DT07H12M")) ge fn:minutes-from-duration(xs:dayTimeDuration("P20DT01H13M"))
+fn:minutes-from-duration(xs:dayTimeDuration("P21DT10H10M"))
fn:minutes-from-duration(xs:dayTimeDuration("P21DT10H10M")) + fn:minutes-from-duration(xs:dayTimeDuration("P22DT11H30M"))
fn:minutes-from-duration(xs:dayTimeDuration("P21DT10H10M")) le fn:minutes-from-duration(xs:dayTimeDuration("P22DT10H09M"))
fn:minutes-from-duration(xs:dayTimeDuration("P21DT10H65M"))
fn:minutes-from-duration(xs:dayTimeDuration("P22DT10H10M")) eq fn:minutes-from-duration(xs:dayTimeDuration("P22DT09H10M"))
fn:minutes-from-duration(xs:dayTimeDuration("P23DT08H20M")) ne fn:minutes-from-duration(xs:dayTimeDuration("P12DT05H22M"))
fn:minutes-from-duration(xs:dayTimeDuration("P25DT10H20M")) idiv fn:minutes-from-duration(xs:dayTimeDuration("P05DT02H04M"))
fn:minutes-from-duration(xs:dayTimeDuration("P30DT10H20M")) - fn:minutes-from-duration(xs:dayTimeDuration("P10DT09H10M"))
fn:minutes-from-duration(xs:dayTimeDuration("P31DT23H59M59S"))
fn:minutes-from-duration(xs:dayTimeDuration("P3DT10H"))
fn:minutes-from-duration(xs:dayTimeDuration("-P5DT12H30M"))
fn:minutes-from-duration(xs:duration("P1Y2M3DT10H30M"))
fn:minutes-from-duration(xs:yearMonthDuration('P1Y'))
fn:minutes-from-time(fn:current-time())
fn:minutes-from-time(xs:time("00:00:00Z"))
fn:minutes-from-time(xs:time("01:23:00Z")) gt fn:minutes-from-time(xs:time("01:23:00Z"))
fn:minutes-from-time(xs:time("02:00:00Z")) + fn:minutes-from-time(xs:time("10:00:00Z"))
fn:minutes-from-time(xs:time("02:02:00Z")) * fn:minutes-from-time(xs:time("10:08:00Z"))
fn:minutes-from-time(xs:time("08:03:35Z"))
+fn:minutes-from-time(xs:time("10:00:00Z"))
fn:minutes-from-time(xs:time("10:00:00Z")) le fn:minutes-from-time(xs:time("10:00:00Z"))
fn:minutes-from-time(xs:time("10:00:00Z")) ne fn:minutes-from-time(xs:time("01:01:00Z"))
fn:minutes-from-time(xs:time("10:02:00Z")) eq fn:minutes-from-time(xs:time("10:02:00Z"))
fn:minutes-from-time(xs:time("10:03:00Z")) ge fn:minutes-from-time(xs:time("10:04:00Z"))
-fn:minutes-from-time(xs:time("10:10:00Z"))
fn:minutes-from-time(xs:time("10:10:00Z")) - fn:minutes-from-time(xs:time("09:02:00Z"))
fn:minutes-from-time(xs:time("10:10:00Z")) mod fn:minutes-from-time(xs:time("03:03:00Z"))
fn:minutes-from-time(xs:time("10:12:00Z")) idiv fn:minutes-from-time(xs:time("02:02:00Z"))
fn:minutes-from-time(xs:time("13:00:00Z"))
fn:minutes-from-time(xs:time("21:23:00Z")) lt fn:minutes-from-time(xs:time("21:24:00Z"))
fn:minutes-from-time(xs:time("22:33:00Z")) div fn:minutes-from-time(xs:time("02:11:00Z"))
fn:minutes-from-time(xs:time("23:59:59Z"))
fn:min((xs:decimal("617375191608514839")))
fn:min((xs:decimal("617375191608514839"),xs:decimal("-999999999999999999")))
fn:min((xs:decimal("-999999999999999999")))
fn:min((xs:decimal("999999999999999999")))
fn:min((xs:decimal("-999999999999999999"),xs:decimal("617375191608514839")))
fn:min((xs:decimal("-999999999999999999"),xs:decimal("-999999999999999999")))
fn:min((xs:decimal("-999999999999999999"),xs:decimal("999999999999999999")))
fn:min((xs:decimal("999999999999999999"),xs:decimal("-999999999999999999")))
fn:min((xs:double("0")))
fn:min((xs:double("0"),xs:double("-1.7976931348623157E308")))
fn:min((xs:double("-1.7976931348623157E308")))
fn:min((xs:double("1.7976931348623157E308")))
fn:min((xs:double("-1.7976931348623157E308"),xs:double("0")))
fn:min((xs:double("-1.7976931348623157E308"),xs:double("-1.7976931348623157E308")))
fn:min((xs:double("-1.7976931348623157E308"),xs:double("1.7976931348623157E308")))
fn:min((xs:double("1.7976931348623157E308"),xs:double("-1.7976931348623157E308")))
fn:min((xs:float("0")))
fn:min((xs:float("0"),xs:float("-3.4028235E38")))
fn:min((xs:float("-3.4028235E38")))
fn:min((xs:float("3.4028235E38")))
fn:min((xs:float("-3.4028235E38"),xs:float("0")))
fn:min((xs:float("-3.4028235E38"),xs:float("-3.4028235E38")))
fn:min((xs:float("-3.4028235E38"),xs:float("3.4028235E38")))
fn:min((xs:float("3.4028235E38"),xs:float("-3.4028235E38")))
fn:min((xs:int("-1873914410")))
fn:min((xs:int("-1873914410"),xs:int("-2147483648")))
fn:min((xs:int("2147483647")))
fn:min((xs:int("2147483647"),xs:int("-2147483648")))
fn:min((xs:int("-2147483648")))
fn:min((xs:int("-2147483648"),xs:int("-1873914410")))
fn:min((xs:int("-2147483648"),xs:int("2147483647")))
fn:min((xs:int("-2147483648"),xs:int("-2147483648")))
fn:min((xs:integer(5000000),xs:double(3e8)))
fn:min((xs:integer(5), xs:float(5), xs:double(10)))
fn:min((xs:negativeInteger("-1")))
fn:min((xs:nonNegativeInteger("0")))
fn:min((xs:nonNegativeInteger("0"),xs:nonNegativeInteger("0")))
fn:min((xs:nonPositiveInteger("0")))
fn:min((xs:positiveInteger("1")))
fn:min((xs:positiveInteger("1"),xs:positiveInteger("1")))
fn:min((xs:short("32767")))
fn:min((xs:short("32767"),xs:short("-32768")))
fn:min((xs:short("-32768")))
fn:min((xs:short("-32768"),xs:short("32767")))
fn:min((xs:short("-32768"),xs:short("-32768")))
fn:min((xs:short("-32768"),xs:short("-5324")))
fn:min((xs:short("-5324")))
fn:min((xs:short("-5324"),xs:short("-32768")))
fn:min((xs:unsignedLong("0")))
fn:min((xs:unsignedLong("0"),xs:unsignedLong("0")))
fn:min((xs:unsignedShort("0")))
fn:min((xs:unsignedShort("0"),xs:unsignedShort("0")))
fn:min((xs:unsignedShort("0"),xs:unsignedShort("44633")))
fn:min((xs:unsignedShort("0"),xs:unsignedShort("65535")))
fn:min((xs:unsignedShort("44633")))
fn:min((xs:unsignedShort("44633"),xs:unsignedShort("0")))
fn:min((xs:unsignedShort("65535")))
fn:min((xs:unsignedShort("65535"),xs:unsignedShort("0")))
fn:min( (xs:yearMonthDuration('P1Y0M'), 1) )
fn:month-from-date(fn:current-date())
fn:month-from-dateTime(fn:current-dateTime())
fn:month-from-dateTime(fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00")))
fn:month-from-dateTime(xs:dateTime("0001-12-31T23:20:00Z"))
fn:month-from-dateTime(xs:dateTime("1000-10-01T02:00:00Z")) div fn:month-from-dateTime(xs:dateTime("0050-05-01T10:00:00Z"))
fn:month-from-dateTime(xs:dateTime("1970-01-01T00:00:00Z"))
fn:month-from-dateTime(xs:dateTime("1970-01-01T00:00:00Z")) + fn:month-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:month-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")) eq fn:month-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:month-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")) ne fn:month-from-dateTime(xs:dateTime("1970-02-01T10:00:00Z"))
fn:month-from-dateTime(xs:dateTime("1970-01-12T10:00:00Z")) idiv fn:month-from-dateTime(xs:dateTime("1970-02-01T02:00:00Z"))
fn:month-from-dateTime(xs:dateTime("1970-02-01T00:00:00Z")) - fn:month-from-dateTime(xs:dateTime("1969-01-01T10:00:00Z"))
-fn:month-from-dateTime(xs:dateTime("1970-02-01T10:00:00Z"))
fn:month-from-dateTime(xs:dateTime("1970-02-01T10:00:00Z")) le fn:month-from-dateTime(xs:dateTime("1971-01-01T10:00:00Z"))
fn:month-from-dateTime(xs:dateTime("1970-03-01T02:00:00Z")) * fn:month-from-dateTime(xs:dateTime("0002-02-01T10:00:00Z"))
fn:month-from-dateTime(xs:dateTime("1970-10-01T10:00:00Z")) mod fn:month-from-dateTime(xs:dateTime("1970-03-01T03:00:00Z"))
+fn:month-from-dateTime(xs:dateTime("1971-01-01T10:00:00Z"))
fn:month-from-dateTime(xs:dateTime("1971-01-01T10:00:00Z")) ge fn:month-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:month-from-dateTime(xs:dateTime("1996-04-07T01:40:52Z"))
fn:month-from-dateTime(xs:dateTime("-1999-01-31T00:20:00-05:00"))
fn:month-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))
fn:month-from-dateTime(xs:dateTime("1999-12-31T19:20:00-05:00"))
fn:month-from-dateTime(xs:dateTime("2030-12-31T23:59:59Z"))
fn:month-from-date(xs:date("1970-01-01+05:00")) ne fn:month-from-date(xs:date("1970-01-03+03:00"))
+fn:month-from-date(xs:date("1970-01-01Z"))
-fn:month-from-date(xs:date("1970-01-01Z"))
fn:month-from-date(xs:date("1970-01-01Z"))
fn:month-from-date(xs:date("1970-01-01Z")) div fn:month-from-date(xs:date("1970-01-01Z"))
fn:month-from-date(xs:date("1970-01-01Z")) eq fn:month-from-date(xs:date("1970-01-01Z"))
fn:month-from-date(xs:date("1970-01-01Z")) * fn:month-from-date(xs:date("0002-01-01Z"))
fn:month-from-date(xs:date("1970-01-01Z")) + fn:month-from-date(xs:date("1970-01-01Z"))
fn:month-from-date(xs:date("1970-01-01Z")) - fn:month-from-date(xs:date("1970-01-01Z"))
fn:month-from-date(xs:date("1970-01-01Z")) ge fn:month-from-date(xs:date("1970-01-01Z"))
fn:month-from-date(xs:date("1970-01-01Z")) idiv fn:month-from-date(xs:date("1970-01-01Z"))
fn:month-from-date(xs:date("1970-01-01Z")) le fn:month-from-date(xs:date("1970-01-01Z"))
fn:month-from-date(xs:date("1970-01-01Z")) mod fn:month-from-date(xs:date("1970-01-01Z"))
fn:month-from-date(xs:date("1970-01-01Z")) ne fn:month-from-date(xs:date("1970-01-01Z"))
fn:month-from-date(xs:date("1970-01-01Z")) ne fn:month-from-date(xs:date("1970-01-03Z"))
fn:month-from-date(xs:date("1970-01-31Z"))
fn:month-from-date(xs:date("1983-11-17Z"))
fn:month-from-date(xs:date("1999-05-31-05:00"))
fn:month-from-date(xs:date("1999-12-31Z"))
fn:month-from-date(xs:date("1999-12-31Z")) le fn:month-from-date(xs:date("1999-12-31Z"))
fn:month-from-date(xs:date("1999-12-31Z")) lt fn:month-from-date(xs:date("1999-12-31Z"))
fn:month-from-date(xs:date("2000-01-01+05:00"))
fn:month-from-date(xs:date("2030-12-31Z"))
fn:months-from-duration(xs:dayTimeDuration('P1D'))
fn:months-from-duration(xs:dayTimeDuration("-P2DT15H0M0S"))
fn:months-from-duration(xs:duration("P1Y2M3DT10H30M"))
fn:months-from-duration(xs:yearMonthDuration("P01Y01M"))
fn:months-from-duration(xs:yearMonthDuration("P0Y0M"))
fn:months-from-duration(xs:yearMonthDuration("P1000Y6M"))
fn:months-from-duration(xs:yearMonthDuration("P10Y10M")) mod fn:months-from-duration(xs:yearMonthDuration("P03Y03M"))
fn:months-from-duration(xs:yearMonthDuration("P2030Y12M"))
fn:months-from-duration(xs:yearMonthDuration("P20Y09M")) * fn:months-from-duration(xs:yearMonthDuration("P02Y10M"))
fn:months-from-duration(xs:yearMonthDuration("P20Y09M")) ge fn:months-from-duration(xs:yearMonthDuration("P20Y01M"))
fn:months-from-duration(xs:yearMonthDuration("P20Y10M")) div fn:months-from-duration(xs:yearMonthDuration("P05Y05M"))
fn:months-from-duration(xs:yearMonthDuration("P20Y15M"))
fn:months-from-duration(xs:yearMonthDuration("-P20Y18M"))
fn:months-from-duration(xs:yearMonthDuration("P20Y3M")) lt fn:months-from-duration(xs:yearMonthDuration("P21Y2M"))
fn:months-from-duration(xs:yearMonthDuration("P21Y01M")) le fn:months-from-duration(xs:yearMonthDuration("P21Y15M"))
+fn:months-from-duration(xs:yearMonthDuration("P21Y10M"))
fn:months-from-duration(xs:yearMonthDuration("P21Y10M")) + fn:months-from-duration(xs:yearMonthDuration("P22Y11M"))
fn:months-from-duration(xs:yearMonthDuration("P21Y10M")) le fn:months-from-duration(xs:yearMonthDuration("P22Y10M"))
fn:months-from-duration(xs:yearMonthDuration("P22Y10M")) eq fn:months-from-duration(xs:yearMonthDuration("P22Y09M"))
fn:months-from-duration(xs:yearMonthDuration("P22Y10M")) ne fn:months-from-duration(xs:yearMonthDuration("P23Y10M"))
-fn:months-from-duration(xs:yearMonthDuration("P25Y03M"))
fn:months-from-duration(xs:yearMonthDuration("P25Y10M")) idiv fn:months-from-duration(xs:yearMonthDuration("P05Y02M"))
fn:months-from-duration(xs:yearMonthDuration("P30Y10M")) - fn:months-from-duration(xs:yearMonthDuration("P10Y09M"))
fn:name()
fn:name(.)
fn:name(<anElement>Content</anElement>)
fn:name(<anElement name="attribute1">Content</anElement>)
fn:namespace-uri-from-QName("")
fn:namespace-uri-from-QName(((),()))
fn:namespace-uri-from-QName(())
fn:namespace-uri-from-QName()
fn:namespace-uri-from-QName(fn:node-name(<anelement xmlns = "http://example.com/examples"></anelement>))
fn:namespace-uri-from-QName(fn:QName("http://www.example.com/example",                   "person"))
fn:namespace-uri-from-QName(fn:QName("http://www.example.com/urn", exactly-one(xs:string(data((/root/elemQN))[1]))))
fn:namespace-uri-from-QName(fn:QName("http://www.example.com/urn", exactly-one(xs:string(/root[1]/@attrDerivQN)))) instance of xs:anyURI ?
fn:namespace-uri-from-QName(fn:QName("http://www.example.com/urn", exactly-one(xs:string((/root/@attrDerivQN)[1]))))
fn:namespace-uri-from-QName(fn:QName("http://www.example.com/urn", exactly-one(xs:string((/root/@attrQN)[1]))))
fn:namespace-uri-from-QName(fn:QName("http://www.example.com/urn", exactly-one(xs:string((/root/derivQN)[1]))))
fn:namespace-uri-from-QName(fn:QName("http://www.example.com/urn", exactly-one(xs:string((/root/elemQN)[1]))))
fn:namespace-uri-from-QName( if( false() ) then fn:QName("http://www.example.com/urn", exactly-one(xs:string((/root/elemQN)[1]))) else fn:QName("http://www.example.com/urn", exactly-one(xs:string((/root/@attrQN)[1]))) )
fn:namespace-uri-from-QName( if( true() ) then fn:QName("http://www.example.com/urn", exactly-one(xs:string((/root/elemQN[1])))) else fn:QName("http://www.example.com/urn", exactly-one(xs:string((/root/@attrQN))[1])) )
fn:namespace-uri-from-QName(/root/elemQN)
fn:namespace-uri-from-qname((/root/elemQN)[1])
fn:namespace-uri-from-Qname((/root/elemQN)[1])
fn:namespaceURIfromQName((/root/elemQN)[1])
fn:namespace-uri-from-QName(xs:integer("100"))
fn:namespace-uri-from-QName(xs:time("12:00:00Z"))
(fn:name(./works[1]/employee[1]))
(fn:name(./works[1]/employee[1]),fn:name(./works[1]/employee[2]))
(fn:name(./works[1]/employee[1]/@name))
fn:node-name(processing-instruction piName {"Processing Instruction content"},"A Second Argument")
fn:normalize-space("      ")
fn:normalize-space("    ")
fn:normalize-space(" ")
fn:normalize-space("")
fn:normalize-space(())
fn:normalize-space()
fn:normalize-space(" 12345")
fn:normalize-space(fn:normalize-space(" ABC"))
fn:normalize-space(fn:string(" ABC "))
fn:normalize-space(" The    wealthy curled darlings                                         of    our    nation. ")
fn:normalize-space(" The wealthy curled darlings of our nation. ")
fn:normalize-space("This is a ch")
fn:normalize-space("This is a charac")
fn:normalize-space("This text should contains no newline characters.")
fn:normalize-space("This text should contains no tab characters.")
fn:normalize-space("This text should contains no tabs")
fn:normalize-space("This  text  should  contains  no tabs or newline characters.")
fn:normalize-space("This text should contains no tabs or newline characters.")
fn:not(())
fn:not(7 lt 7) and xs:boolean("false")
fn:not(7 lt 7) eq xs:boolean("true")
fn:not(("ab" || "cde"))
fn:not(current-date() > xs:date("1997-01-01Z"))
fn:not("false")
fn:not(fn:codepoint-equal("a","a"))
fn:not(fn:codepoint-equal("a","b"))
fn:not(fn:concat("ab","cde"))
fn:not(fn:contains("A","A"))
fn:not(fn:contains("A","B"))
fn:not(fn:ends-with("A","A"))
fn:not(fn:ends-with("A","B"))
fn:not(fn:false())
fn:not(fn:lower-case("abcde"))
fn:not("fn:not()")
fn:not(fn:QName("http://www.example.com/example", "px1:person1") eq fn:QName("http://www.example.com/example","px2:person2"))
fn:not(fn:QName("http://www.example.com/example", "px1:person1") ne fn:QName("http://www.example.com/example","px2:person2"))
fn:not(fn:starts-with("A","A"))
fn:not(fn:starts-with("A","B"))
fn:not(fn:string(fn:current-date()))
fn:not(fn:string(fn:current-dateTime()))
fn:not(fn:string(fn:current-time()))
fn:not(fn:string(fn:timezone-from-date(xs:date("1970-01-03+02:00"))))
fn:not(fn:string(fn:timezone-from-time(xs:time("02:02:03Z"))))
fn:not(fn:string-join((),"A"))
fn:not(fn:string-join(("A"),"B"))
fn:not(fn:string-length("abcde"))
fn:not(fn:string(xs:date("1998-09-12Z") - xs:date("1998-09-21Z")))
fn:not(fn:string(xs:dateTime("1998-09-12T11:12:12Z") - xs:dateTime("1996-02-02T01:01:01Z")))
fn:not(fn:string(xs:dayTimeDuration("P11DT12H04M") * 2.0))
fn:not(fn:string(xs:dayTimeDuration("P11DT12H04M") div 2.0))
fn:not(fn:string(xs:dayTimeDuration("P11DT12H04M") + xs:dayTimeDuration("P02DT07H01M")))
fn:not(fn:string(xs:dayTimeDuration("P11DT12H04M") - xs:dayTimeDuration("P02DT07H01M")))
fn:not(fn:string(xs:time("13:00:00Z") - xs:time("14:00:00Z")))
fn:not(fn:string(xs:yearMonthDuration("P11Y04M") * 2.0))
fn:not(fn:string(xs:yearMonthDuration("P11Y04M") div 2.0))
fn:not(fn:string(xs:yearMonthDuration("P11Y04M") + xs:yearMonthDuration("P02Y11M")))
fn:not(fn:string(xs:yearMonthDuration("P11Y04M") - xs:yearMonthDuration("P02Y11M")))
fn:not(fn:substring("ABC",1))
fn:not(fn:substring-after("A","A"))
fn:not(fn:substring-after("A","B"))
fn:not(fn:substring-before("A","A"))
fn:not(fn:substring-before("A","B"))
fn:not(fn:true())
fn:not(fn:upper-case("abcde"))
fn:not(for $x in 1 to 10 return <e>{$x}</e>)
fn:not((/staff[1]/employee[1]/empnum[1]) is (/staff[1]/employee[1]/empnum[1]))
fn:not((/staff[1]/employee[1]/empnum[1]) << (/staff[1]/employee[1]/empnum[1]))
fn:not((/staff[1]/employee[1]/empnum[1]) >> (/staff[1]/employee[1]/empnum[1]))
fn:not("true")
fn:not("true") and fn:not("true")
fn:not("true") eq fn:not("true")
(fn:not("true"),fn:not("false"))
fn:not("true") != fn:not("true")
fn:not("true") < fn:not("true")
fn:not("true") <= fn:not("true")
fn:not("true") = fn:not("true")
fn:not("true") > fn:not("true")
fn:not("true") >= fn:not("true")
fn:not("true") ge fn:not("true")
fn:not("true") gt fn:not("true")
fn:not("true") le fn:not("true")
fn:not("true") lt fn:not("true")
fn:not("true") ne fn:not("true")
fn:not("true") or fn:not("true")
fn:not(xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") eq xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp"))
fn:not(xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") ne xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp"))
fn:not(xs:boolean("false") and xs:boolean("false")) eq xs:boolean("false")
fn:not(xs:boolean("false") and xs:boolean("true")) eq fn:not(xs:boolean("false") and xs:boolean("true"))
fn:not(xs:boolean("false")) eq fn:not(xs:boolean("false"))
fn:not(xs:boolean("false")) eq xs:boolean("false")
fn:not(xs:boolean("false")) ge xs:boolean("false")
fn:not(xs:boolean("false")) ge xs:boolean("true")
fn:not(xs:boolean("false")) gt xs:boolean("false")
fn:not(xs:boolean("false")) gt xs:boolean("true")
fn:not(xs:boolean("false")) le xs:boolean("false")
fn:not(xs:boolean("false")) le xs:boolean("true")
fn:not(xs:boolean("false")) lt xs:boolean("false")
fn:not(xs:boolean("false")) lt xs:boolean("true")
fn:not(xs:boolean("true") and xs:boolean("true")) eq xs:boolean("true")
fn:not(xs:boolean("true")) eq xs:boolean("false")
fn:not(xs:boolean("true")) eq xs:boolean("true")
fn:not(xs:boolean("true")) ge xs:boolean("false")
fn:not(xs:boolean("true")) ge xs:boolean("true")
fn:not(xs:boolean("true")) gt xs:boolean("false")
fn:not(xs:boolean("true")) gt xs:boolean("true")
fn:not(xs:boolean("true")) le xs:boolean("false")
fn:not(xs:boolean("true")) le xs:boolean("true")
fn:not(xs:boolean("true")) lt xs:boolean("false")
fn:not(xs:boolean("true")) lt xs:boolean("true")
fn:not(xs:date("2000-11-09Z") gt xs:date("2000-11-10Z"))
fn:not(xs:date("2000-12-25Z") lt xs:date("2000-11-25Z"))
fn:not(xs:date("2005-04-02Z") ge xs:date("2005-04-02Z"))
fn:not(xs:date("2005-04-02Z") le xs:date("2005-04-02Z"))
fn:not(xs:date("2005-10-23Z") ge xs:date("2005-10-25Z"))
fn:not(xs:date("2005-10-25Z") le xs:date("2005-10-23Z"))
fn:not((xs:date("2005-12-25Z") lt xs:date("2005-12-26Z")))
fn:not((xs:date("2005-12-26Z") gt xs:date("2005-12-25Z")))
fn:not(xs:dateTime("2002-04-02T12:00:00Z") ge xs:dateTime("2002-04-02T12:00:00Z"))
fn:not(xs:dateTime("2002-04-02T12:00:00Z") ge xs:dateTime("2008-04-02T12:00:00Z"))
fn:not(xs:dateTime("2002-04-02T12:00:00Z") gt xs:dateTime("2002-05-02T12:00:00Z"))
fn:not(xs:dateTime("2002-04-02T12:00:00Z") le xs:dateTime("2002-04-02T12:00:00Z"))
fn:not((xs:dateTime("2002-04-02T12:00:00Z") lt xs:dateTime("2003-04-02T12:00:00Z")))
fn:not(xs:dateTime("2002-05-02T12:00:00Z") lt xs:dateTime("2002-04-02T12:00:00Z"))
fn:not((xs:dateTime("2004-04-02T12:00:00Z") gt xs:dateTime("2003-04-02T12:00:00Z")))
fn:not(xs:dateTime("2004-04-02T12:00:00Z") le xs:dateTime("2002-04-02T12:00:00Z"))
fn:not(xs:dayTimeDuration("P07DT09H") ge xs:dayTimeDuration("P09DT09H"))
fn:not(xs:dayTimeDuration("P08DT10H") gt xs:dayTimeDuration("P9DT09H"))
fn:not(xs:dayTimeDuration("P10DT09H") le xs:dayTimeDuration("P09DT09H"))
fn:not(xs:dayTimeDuration("P10DT10H") lt xs:dayTimeDuration("P9DT09H"))
fn:not(xs:dayTimeDuration("P10DT110H") le xs:dayTimeDuration("P10DT11H"))
fn:not(xs:dayTimeDuration("P10DT11H") ge xs:dayTimeDuration("P10DT10H"))
fn:not(xs:dayTimeDuration("P11DT12H04M") div xs:dayTimeDuration("P02DT07H01M"))
fn:not((xs:dayTimeDuration("P13DT12H") lt xs:dayTimeDuration("P14DT11H")))
fn:not((xs:dayTimeDuration("P15DT12H") gt xs:dayTimeDuration("P14DT11H")))
fn:not(xs:decimal("617375191608514839"))
fn:not(xs:decimal("-999999999999999999"))
fn:not(xs:decimal("999999999999999999"))
fn:not(xs:double("0"))
fn:not(xs:double("-1.7976931348623157E308"))
fn:not(xs:double("1.7976931348623157E308"))
fn:not(xs:duration("P36D") eq xs:duration("P36D"))
fn:not(xs:duration("P36D") ne xs:duration("P36D"))
fn:not(xs:float("0"))
fn:not(xs:float("-3.4028235E38"))
fn:not(xs:float("3.4028235E38"))
fn:not(xs:gDay("---05Z") ne xs:gDay("---05Z"))
fn:not(xs:gDay("---05Z") ne xs:gDay("---06Z"))
fn:not(xs:gDay("---11Z") eq xs:gDay("---10Z"))
fn:not((xs:gDay("---12Z") eq xs:gDay("---12Z")))
fn:not(xs:gMonth("--05Z") ne xs:gMonth("--05Z"))
fn:not(xs:gMonth("--05Z") ne xs:gMonth("--06Z"))
fn:not(xs:gMonth("--11Z") eq xs:gMonth("--10Z"))
fn:not((xs:gMonth("--12Z") eq xs:gMonth("--12Z")))
fn:not(xs:gMonthDay("--05-01Z") ne xs:gMonthDay("--06-12Z"))
fn:not(xs:gMonthDay("--05-10Z") ne xs:gMonthDay("--05-10Z"))
fn:not(xs:gMonthDay("--11-10Z") eq xs:gMonthDay("--10-02Z"))
fn:not((xs:gMonthDay("--12-10Z") eq xs:gMonthDay("--12-10Z")))
fn:not((xs:gYear("1995Z") eq xs:gYear("1995Z")))
fn:not(xs:gYear("2000Z") eq xs:gYear("2001Z"))
fn:not(xs:gYear("2005Z") ne xs:gYear("2005Z"))
fn:not(xs:gYear("2005Z") ne xs:gYear("2006Z"))
fn:not((xs:gYearMonth("1995-02Z") eq xs:gYearMonth("1995-02Z")))
fn:not(xs:gYearMonth("2000-01Z") eq xs:gYearMonth("2001-04Z"))
fn:not(xs:gYearMonth("2005-01Z") ne xs:gYearMonth("2005-01Z"))
fn:not(xs:gYearMonth("2005-02Z") ne xs:gYearMonth("2006-03Z"))
fn:not((xs:hexBinary("786174616d61616772") eq xs:hexBinary("786174616d61616772")))
fn:not((xs:hexBinary("786174616d61616772") ne xs:hexBinary("786174616d61616772")))
fn:not(xs:int("-1873914410"))
fn:not(xs:int("2147483647"))
fn:not(xs:int("-2147483648"))
fn:not(xs:negativeInteger("-1"))
fn:not(xs:nonNegativeInteger("0"))
fn:not(xs:nonPositiveInteger("0"))
fn:not(xs:positiveInteger("1"))
fn:not(xs:short("32767"))
fn:not(xs:short("-32768"))
fn:not(xs:short("-5324"))
fn:not(xs:unsignedLong("0"))
fn:not(xs:unsignedShort("0"))
fn:not(xs:unsignedShort("44633"))
fn:not(xs:unsignedShort("65535"))
fn:not(xs:yearMonthDuration("P10Y07M") ge xs:yearMonthDuration("P10Y09M"))
fn:not(xs:yearMonthDuration("P10Y09M") le xs:yearMonthDuration("P10Y07M"))
fn:not(xs:yearMonthDuration("P11Y04M") div xs:yearMonthDuration("P02Y11M"))
fn:not(xs:yearMonthDuration("P20Y09M") gt xs:yearMonthDuration("P20Y10M"))
fn:not(xs:yearMonthDuration("P20Y10M") ge xs:yearMonthDuration("P20Y10M"))
fn:not(xs:yearMonthDuration("P20Y10M") le xs:yearMonthDuration("P20Y10M"))
fn:not(xs:yearMonthDuration("P20Y10M") lt xs:yearMonthDuration("P20Y09M"))
fn:not((xs:yearMonthDuration("P20Y10M") lt xs:yearMonthDuration("P20Y11M")))
fn:not((xs:yearMonthDuration("P20Y123M") gt xs:yearMonthDuration("P20Y11M")))
fn:number(())
fn:number()
fn:number(.)
fn:number(1.1) instance of xs:double
fn:number(1) eq 1
fn:number(1) instance of xs:double
fn:number("A String")
fn:number(fn:timezone-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")))
fn:number(fn:timezone-from-date(xs:date("1970-01-02+10:00")))
fn:number(fn:timezone-from-time(xs:time("10:12:15Z")))
fn:number(()) instance of xs:double
fn:number("NaN") instance of xs:double
fn:number("results in NaN") instance of xs:double
fn:number(xs:date("1988-01-28Z") - xs:date("2001-03-02"))
fn:number(xs:dateTime("1988-01-28T10:09:08Z") - xs:dateTime("1987-01-01T01:01:02Z"))
fn:number(xs:dayTimeDuration("P02DT06H09M") *2.0)
fn:number(xs:dayTimeDuration("P02DT06H09M") div 2.0)
fn:number(xs:dayTimeDuration("P02DT06H09M") div xs:dayTimeDuration("P02DT06H09M"))
fn:number(xs:dayTimeDuration("P02DT06H09M") + xs:dayTimeDuration("P10DT08H01M"))
fn:number(xs:dayTimeDuration("P02DT06H09M") - xs:dayTimeDuration("P10DT08H01M"))
fn:number(xs:decimal("617375191608514839")) eq 617375191608514839
fn:number(xs:double("0"))
fn:number(xs:double("-1.7976931348623157E308"))
fn:number(xs:double("1.7976931348623157E308"))
fn:number(xs:double(3)) instance of xs:double
fn:number(xs:float("0"))
fn:number(xs:float(3)) instance of xs:double
fn:number(xs:negativeInteger("-1"))
fn:number(xs:nonNegativeInteger("0"))
fn:number(xs:nonPositiveInteger("0"))
fn:number(xs:positiveInteger("1"))
fn:number(xs:short("32767"))
fn:number(xs:short("-32768"))
fn:number(xs:short("-5324"))
fn:number(xs:time("13:00:00Z") - xs:time("12:00:00Z"))
fn:number(xs:unsignedLong("0"))
fn:number(xs:unsignedShort("0"))
fn:number(xs:unsignedShort("44633"))
fn:number(xs:unsignedShort("65535"))
fn:number(xs:yearMonthDuration("P02Y09M") * 2.0)
fn:number(xs:yearMonthDuration("P02Y09M") div 2.0)
fn:number(xs:yearMonthDuration("P02Y09M") div xs:yearMonthDuration("P02Y09M"))
fn:number(xs:yearMonthDuration("P02Y09M") + xs:yearMonthDuration("P10Y01M"))
fn:number(xs:yearMonthDuration("P02Y09M") - xs:yearMonthDuration("P10Y01M"))
fn:one-or-more(())
fn:one-or-more(xs:double("0"))
fn:one-or-more(xs:double("-1.7976931348623157E308"))
fn:one-or-more(xs:double("1.7976931348623157E308"))
fn:one-or-more(xs:float("0"))
fn:one-or-more(xs:float("-3.4028235E38"))
fn:one-or-more(xs:float("3.4028235E38"))
fn:one-or-more(xs:int("-1873914410"))
fn:one-or-more(xs:int("2147483647"))
fn:one-or-more(xs:int("-2147483648"))
fn:one-or-more(xs:negativeInteger("-1"))
fn:one-or-more(xs:nonNegativeInteger("0"))
fn:one-or-more(xs:nonPositiveInteger("0"))
fn:one-or-more(xs:positiveInteger("1"))
fn:one-or-more(xs:short("32767"))
fn:one-or-more(xs:short("-32768"))
fn:one-or-more(xs:short("-5324"))
fn:one-or-more(xs:unsignedLong("0"))
fn:one-or-more(xs:unsignedShort("0"))
fn:one-or-more(xs:unsignedShort("44633"))
fn:one-or-more(xs:unsignedShort("65535"))
fn:outermost( / )
fn:outermost( //* )
fn:outermost( //*/@* )
fn:outermost()
fn:outermost( ($doc1//node(), $doc2//node()) )
fn:outermost#0
fn:outermost( (), 1 )
fn:outermost( 1 )
fn:outermost#2
fn:outermost( //comment() )
fn:outermost( //comment() ) ! string()
fn:outermost( fn:dateTime#2 )
( fn:outermost( if (current-date() eq xs:date('1900-01-01'))                                  then .                                  else 1 ),               fn:outermost( if (current-date() eq xs:date('1900-01-01'))                                  then 1                                  else . ) )
( fn:outermost( if (current-date() eq xs:date('1900-01-01'))                                  then .                                  else fn:dateTime#2 ),               fn:outermost( if (current-date() eq xs:date('1900-01-01'))                                  then fn:dateTime#2                                  else . ) )
fn:outermost( //* ) ! local-name(.)
fn:outermost( //node() )
fn:outermost( //processing-instruction() )
fn:outermost( //processing-instruction() ) ! local-name()
fn:outermost( /root/descendant::node() )
fn:outermost( /root/level[1]/following-sibling::node() )
fn:outermost( /root/level[1]/level[1]/ancestor::node() )
fn:outermost( /root/level[1]/level[1]/following::node() )
fn:outermost( /root/level[1]/level[last()]/preceding::node() )
fn:outermost( /root/level[1]/level[last()]/preceding-sibling::node() )
fn:outermost( /root/node() )
fn:outermost( /root/node()/.. )
fn:outermost( //*/@* ) ! string()
fn:outermost( //text() )
fn:outermost( //text() ) ! string()
fn:path(())
fn:path(/)
fn:path(/*)
fn:path(<a><b/><b/></a>/(b[2]))
fn:path(<a b="c"/>/@b)
fn:path((//*:all-of)[1])
fn:path(attribute name {"fred"})
fn:path((//comment())[2])
fn:path((//@idref)[1])
fn:path(//*[@name="fn-absintg1args-1"])
fn:path(//p)
fn:path(//processing-instruction()[1])
fn:path((//*:source)[3]/@xml:id)
fn:path(//text()[.='2147483647'][1])
fn:path(text{"fred"})
fn:prefix-from-QName("arg1","arg2")
fn:prefix-from-QName(node-name(/*))
fn:prefix-from-QName(node-name((//@*)[1]))
fn:prefix-from-QName(xs:integer(1))
fn:prefix-from-QName(xs:QName("foo:bar"))
fn:QName('', ' ')
fn:QName((), ())
fn:QName("", "ht:person")
fn:QName((), "ht:person")
fn:QName("http://www.example.com/example")
fn:QName("http://www.example.com/example", "1person")
fn:QName("http://www.example.com/example1", "person") eq fn:QName("http://www.example.com/example2", "person")
fn:QName("http://www.example.com/example1", "person") ne fn:QName("http://www.example.com/example2", "person")
fn:QName("http://www.example.com/example1", "px1:person1") eq fn:QName("http://www.example.com/example2","px2:person2")
fn:QName("http://www.example.com/example1", "px1:person1") ne fn:QName("http://www.example.com/example2","px2:person2")
fn:QName("http://www.example.com/example", "-person")
fn:QName("http://www.example.com/example", ":person")
fn:QName("http://www.example.com/example", "<person>")
fn:QName("http://www.example.com/example", "@person")
fn:QName("http://www.example.com/example", "person:")
fn:QName("http://www.example.com/example", "person1") eq fn:QName("http://www.example.com/example","person2")
fn:QName("http://www.example.com/example", "person1") ne fn:QName("http://www.example.com/example","person2")
fn:QName("http://www.example.com/example", "person") eq fn:QName("http://www.example.com/example", "person")
fn:QName("http://www.example.com/example", "person") eq fn:QName("","person")
fn:QName("http://www.example.com/example", "person") ne fn:QName("http://www.example.com/example", "person")
fn:QName("http://www.example.com/example", "person") ne fn:QName("","person")
fn:QName("http://www.example.com/example", "px1:person1") eq fn:QName("http://www.example.com/example","px2:person2")
fn:QName("http://www.example.com/example", "px1:person1") ne fn:QName("http://www.example.com/example","px2:person2")
fn:QName("http://www.example.com/example", "px1:person") eq fn:QName("http://www.example.com/example","px1:person")
fn:QName("http://www.example.com/example", "px1:person") eq fn:QName("http://www.example.com/example","px2:person")
fn:QName("http://www.example.com/example", "px1:person") ne fn:QName("http://www.example.com/example","px1:person")
fn:QName("http://www.example.com/example", "px1:person") ne fn:QName("http://www.example.com/example","px2:person")
(fn:QName("http://www.example.com/example", "px:person") eq fn:QName("http://www.example.com/example","px:person")) and fn:true()
(fn:QName("http://www.example.com/example", "px:person") ne fn:QName("http://www.example.com/example","px:person")) and fn:true()
fn:QName("http://www.example.com/example", xs:integer("100"))
fn:QName("person")
fn:QName("", "person") eq fn:QName("http://www.example.com/example","person")
fn:QName("", "person") eq fn:QName("","person")
fn:QName("", "person") ne fn:QName("http://www.example.com/example","person")
fn:QName("", "person") ne fn:QName("","person")
fn:QName( xs:integer("100"), "person" )
fn:remove ( ("a", "b", "c"), 0)
fn:remove ( ("a", "b", "c"), 1)
fn:remove ( ("a", "b", "c", true()), 3)
fn:remove( (xs:anyURI("www.example.com"), "a", (""), "b"), 10)
fn:remove( (xs:anyURI("www.example.com"), "a", (""), "b"), 2)
fn:remove( (xs:anyURI("www.example.com"), "a", (""), "b"), -20)
fn:remove( (xs:boolean("0")), 2 )
fn:remove( (xs:boolean("1"), xs:double("-INF"), "s"), 3)
fn:remove( (xs:boolean("true"), xs:date("1993-03-31"), 4, "a"),3)
fn:remove( (xs:dateTime("1972-12-31T00:00:00"), xs:boolean("false"), (), (" ")) ,3)
fn:remove( (xs:decimal("1.01"), xs:integer("12"), xs:anyURI("www.example.com")),3)
fn:remove( (xs:double("1.34"), xs:float("INF"), true()), 1)
fn:remove( (xs:double("INF"), 2, 3), 2)
fn:remove( (xs:double("NaN"), "a", "b"), 3)
fn:remove( (xs:float("1.01"), xs:string("a")), 2)
fn:remove( (xs:float("-INF"), xs:decimal("2.34"), "abc"), 2)
fn:remove( (xs:float("NaN"), 100, (), 2), 2)
fn:remove( (xs:integer("100"), xs:string("abc")), 1)
fn:remove ( (xs:string("xyz"), (), (), "a" , "b"), 2)
fn:remove( (xs:time("12:30:00"), xs:decimal("2.000003"), 2), 2)
fn:reverse(())
fn:reverse()
fn:reverse(10 to 15)
fn:reverse(1, 2)
fn:reverse([1,2,3])
fn:reverse(([1,2,3],[4,5,6]))
fn:reverse(1 to 10)
fn:reverse(("hello"))
fn:reverse((xs:decimal("617375191608514839")))
fn:reverse((xs:decimal("-999999999999999999")))
fn:reverse((xs:decimal("999999999999999999")))
fn:reverse((xs:double("0")))
fn:reverse((xs:double("-1.7976931348623157E308")))
fn:reverse((xs:double("1.7976931348623157E308")))
fn:reverse((xs:float("0")))
fn:reverse((xs:float("-3.4028235E38")))
fn:reverse((xs:float("3.4028235E38")))
fn:reverse((xs:int("-1873914410")))
fn:reverse((xs:int("2147483647")))
fn:reverse((xs:int("-2147483648")))
fn:reverse((xs:negativeInteger("-1")))
fn:reverse((xs:nonNegativeInteger("0")))
fn:reverse((xs:nonPositiveInteger("0")))
fn:reverse((xs:positiveInteger("1")))
fn:reverse((xs:short("32767")))
fn:reverse((xs:short("-32768")))
fn:reverse((xs:short("-5324")))
fn:reverse((xs:unsignedLong("0")))
fn:reverse((xs:unsignedShort("0")))
fn:reverse((xs:unsignedShort("44633")))
fn:reverse((xs:unsignedShort("65535")))
fn:root()
fn:root(.)
fn:root(<!-- A Comment Node -->)
fn:root(<anElement>An Element Content</anElement>)
fn:root(<!-- comment -->)
fn:root(<e/>)
fn:root(element anElement {attribute anAttribute {"Attribute Value"}})
fn:root(<?format role="output" ?>)
fn:root(<?target data?>)
fn:root(text {"A text Node"})
fn:root(text{"text node"})
fn:round(-0.43e0, 1)
fn:round(1.125, 2)
fn:round(-1234.567, -2)
fn:round(-12.567, 0)
fn:round(-12.567, 2)
fn:round(-12.567, 4)
fn:round(1.567, -3)
fn:round(2.4999)
fn:round(-2.5)
fn:round(2.5)
fn:round(3.1415e0, 2)
fn:round(8452, -2)
fn:round-half-to-even(0.5)
fn:round-half-to-even(12345, -2)
fn:round-half-to-even(12345, 2)
fn:round-half-to-even(12345.6, -2)
fn:round-half-to-even(12345.6, 2)
fn:round-half-to-even(123456e-2, -2)
fn:round-half-to-even(123456e-2, 2)
fn:round-half-to-even(123456e-2, "two")
fn:round-half-to-even(1.5)
fn:round-half-to-even(2.5)
fn:round-half-to-even(35612.25, -2)
fn:round-half-to-even(3.567812, 4294967296)
fn:round-half-to-even(3.567812e+3, 2)
fn:round-half-to-even(3.567812E+3, 4294967296)
fn:round-half-to-even(4.7564e-3, 2)
fn:round-half-to-even( (xs:dayTimeDuration("P42DT10H10M") div xs:dayTimeDuration("P10DT10H10M")) div (xs:dayTimeDuration("P20DT10H10M") div xs:dayTimeDuration("P18DT10H10M")) ,15)
fn:round-half-to-even(xs:decimal("617375191608514839"))
fn:round-half-to-even((xs:decimal("617375191608514839") div xs:decimal("-999999999999999999")),18)
fn:round-half-to-even(xs:decimal("-999999999999999999"))
fn:round-half-to-even(xs:decimal("999999999999999999"))
fn:round-half-to-even((xs:decimal("-999999999999999999") div xs:decimal("617375191608514839")),18)
fn:round-half-to-even(xs:double("0"))
fn:round-half-to-even(xs:double("-1.7976931348623157E308"))
fn:round-half-to-even(xs:double("1.7976931348623157E308"))
fn:round-half-to-even(xs:float("0"))
fn:round-half-to-even(xs:float(12345.6), -2)
fn:round-half-to-even(xs:float(12345.6), 2)
fn:round-half-to-even(xs:float("-3.4028235E38"))
fn:round-half-to-even(xs:float("3.4028235E38"))
fn:round-half-to-even(xs:int("-1873914410"))
fn:round-half-to-even((xs:int("-1873914410") div xs:int("-2147483648")),10)
fn:round-half-to-even(xs:int("2147483647"))
fn:round-half-to-even((xs:int("2147483647") div xs:int("-2147483648")),10)
fn:round-half-to-even(xs:int("-2147483648"))
fn:round-half-to-even((xs:int("-2147483648") div xs:int("-1873914410")),10)
fn:round-half-to-even((xs:int("-2147483648") div xs:int("2147483647")),10)
fn:round-half-to-even(xs:negativeInteger("-1"))
fn:round-half-to-even(xs:nonNegativeInteger("0"))
fn:round-half-to-even(xs:nonPositiveInteger("0"))
fn:round-half-to-even(xs:positiveInteger("1"))
fn:round-half-to-even(xs:short(12345), -2)
fn:round-half-to-even(xs:short(12345), 2)
fn:round-half-to-even(xs:short("32767"))
fn:round-half-to-even(xs:short("-32768"))
fn:round-half-to-even((xs:short("-32768") div xs:short("-5324")),5)
fn:round-half-to-even(xs:short("-5324"))
fn:round-half-to-even((xs:short("-5324") div xs:short("-32768")),5)
fn:round-half-to-even(xs:unsignedLong("0"))
fn:round-half-to-even(xs:unsignedShort("0"))
fn:round-half-to-even(xs:unsignedShort("44633"))
fn:round-half-to-even(xs:unsignedShort("65535"))
fn:round(xs:decimal("-12.1"))
fn:round(xs:decimal("12.1"))
fn:round(xs:decimal("-12.5"))
fn:round(xs:decimal("12.5"))
fn:round(xs:decimal("-12.7"))
fn:round(xs:decimal("12.7"))
fn:round(xs:decimal("617375191608514839"))
fn:round(xs:decimal("-999999999999999999"))
fn:round(xs:decimal("999999999999999999"))
fn:round(xs:double("0"))
fn:round(xs:double("-0.00"))
fn:round(xs:double("0.00"))
fn:round(xs:double("-0.01"))
fn:round(xs:double("0.01"))
fn:round(xs:double("-0.04"))
fn:round(xs:double("0.04"))
fn:round(xs:double("-0.05"))
fn:round(xs:double("0.05"))
fn:round(xs:double("-0.06"))
fn:round(xs:double("0.06"))
fn:round(xs:double("-0.09"))
fn:round(xs:double("0.09"))
fn:round(xs:double("-0.10"))
fn:round(xs:double("0.10"))
fn:round(xs:double("-0.100"))
fn:round(xs:double("0.100"))
fn:round(xs:double("-0.101"))
fn:round(xs:double("0.101"))
fn:round(xs:double("-0.104"))
fn:round(xs:double("0.104"))
fn:round(xs:double("-0.105"))
fn:round(xs:double("0.105"))
fn:round(xs:double("-0.106"))
fn:round(xs:double("0.106"))
fn:round(xs:double("-0.109"))
fn:round(xs:double("0.109"))
fn:round(xs:double("-0.11"))
fn:round(xs:double("0.11"))
fn:round(xs:double("-0.14"))
fn:round(xs:double("0.14"))
fn:round(xs:double("-0.15"))
fn:round(xs:double("0.15"))
fn:round(xs:double("-0.16"))
fn:round(xs:double("0.16"))
fn:round(xs:double("-0.19"))
fn:round(xs:double("0.19"))
fn:round(xs:double("-0.40"))
fn:round(xs:double("0.40"))
fn:round(xs:double("-0.41"))
fn:round(xs:double("0.41"))
fn:round(xs:double("-0.44"))
fn:round(xs:double("0.44"))
fn:round(xs:double("-0.45"))
fn:round(xs:double("0.45"))
fn:round(xs:double("-0.46"))
fn:round(xs:double("0.46"))
fn:round(xs:double("-0.49"))
fn:round(xs:double("0.49"))
fn:round(xs:double("-0.50"))
fn:round(xs:double("0.50"))
fn:round(xs:double("-0.51"))
fn:round(xs:double("0.51"))
fn:round(xs:double("-0.54"))
fn:round(xs:double("0.54"))
fn:round(xs:double("-0.55"))
fn:round(xs:double("0.55"))
fn:round(xs:double("-0.56"))
fn:round(xs:double("0.56"))
fn:round(xs:double("-0.59"))
fn:round(xs:double("0.59"))
fn:round(xs:double("-0.60"))
fn:round(xs:double("0.60"))
fn:round(xs:double("-0.61"))
fn:round(xs:double("0.61"))
fn:round(xs:double("-0.64"))
fn:round(xs:double("0.64"))
fn:round(xs:double("-0.65"))
fn:round(xs:double("0.65"))
fn:round(xs:double("-0.66"))
fn:round(xs:double("0.66"))
fn:round(xs:double("-0.69"))
fn:round(xs:double("0.69"))
fn:round(xs:double("-0.90"))
fn:round(xs:double("0.90"))
fn:round(xs:double("-0.91"))
fn:round(xs:double("0.91"))
fn:round(xs:double("-0.94"))
fn:round(xs:double("0.94"))
fn:round(xs:double("-0.95"))
fn:round(xs:double("0.95"))
fn:round(xs:double("-0.96"))
fn:round(xs:double("0.96"))
fn:round(xs:double("-0.99"))
fn:round(xs:double("0.99"))
fn:round(xs:double("-1.7976931348623157E308"))
fn:round(xs:double("1.7976931348623157E308"))
fn:round(xs:double("NaN"))
fn:round(xs:float("0"))
fn:round(xs:float("-0.00"))
fn:round(xs:float("0.00"))
fn:round(xs:float("-0.01"))
fn:round(xs:float("0.01"))
fn:round(xs:float("-0.04"))
fn:round(xs:float("0.04"))
fn:round(xs:float("-0.05"))
fn:round(xs:float("0.05"))
fn:round(xs:float("-0.06"))
fn:round(xs:float("0.06"))
fn:round(xs:float("-0.09"))
fn:round(xs:float("0.09"))
fn:round(xs:float("-0.10"))
fn:round(xs:float("0.10"))
fn:round(xs:float("-0.100"))
fn:round(xs:float("0.100"))
fn:round(xs:float("-0.101"))
fn:round(xs:float("0.101"))
fn:round(xs:float("-0.104"))
fn:round(xs:float("0.104"))
fn:round(xs:float("-0.105"))
fn:round(xs:float("0.105"))
fn:round(xs:float("-0.106"))
fn:round(xs:float("0.106"))
fn:round(xs:float("-0.109"))
fn:round(xs:float("0.109"))
fn:round(xs:float("-0.11"))
fn:round(xs:float("0.11"))
fn:round(xs:float(0.125), 2)
fn:round(xs:float("-0.14"))
fn:round(xs:float("0.14"))
fn:round(xs:float("-0.15"))
fn:round(xs:float("0.15"))
fn:round(xs:float("-0.16"))
fn:round(xs:float("0.16"))
fn:round(xs:float("-0.19"))
fn:round(xs:float("0.19"))
fn:round(xs:float("-0.40"))
fn:round(xs:float("0.40"))
fn:round(xs:float("-0.41"))
fn:round(xs:float("0.41"))
fn:round(xs:float(-0.43e0), 1)
fn:round(xs:float("-0.44"))
fn:round(xs:float("0.44"))
fn:round(xs:float("-0.45"))
fn:round(xs:float("0.45"))
fn:round(xs:float("-0.46"))
fn:round(xs:float("0.46"))
fn:round(xs:float("-0.49"))
fn:round(xs:float("0.49"))
fn:round(xs:float("-0.50"))
fn:round(xs:float("0.50"))
fn:round(xs:float("-0.51"))
fn:round(xs:float("0.51"))
fn:round(xs:float("-0.54"))
fn:round(xs:float("0.54"))
fn:round(xs:float("-0.55"))
fn:round(xs:float("0.55"))
fn:round(xs:float("-0.56"))
fn:round(xs:float("0.56"))
fn:round(xs:float("-0.59"))
fn:round(xs:float("0.59"))
fn:round(xs:float("-0.60"))
fn:round(xs:float("0.60"))
fn:round(xs:float("-0.61"))
fn:round(xs:float("0.61"))
fn:round(xs:float("-0.64"))
fn:round(xs:float("0.64"))
fn:round(xs:float("-0.65"))
fn:round(xs:float("0.65"))
fn:round(xs:float("-0.66"))
fn:round(xs:float("0.66"))
fn:round(xs:float("-0.69"))
fn:round(xs:float("0.69"))
fn:round(xs:float("-0.90"))
fn:round(xs:float("0.90"))
fn:round(xs:float("-0.91"))
fn:round(xs:float("0.91"))
fn:round(xs:float("-0.94"))
fn:round(xs:float("0.94"))
fn:round(xs:float("-0.95"))
fn:round(xs:float("0.95"))
fn:round(xs:float("-0.96"))
fn:round(xs:float("0.96"))
fn:round(xs:float("-0.99"))
fn:round(xs:float("0.99"))
fn:round(xs:float(1.125), 2)
fn:round(xs:float(3.1415e0), 2)
fn:round(xs:float("-3.4028235E38"))
fn:round(xs:float("3.4028235E38"))
fn:round(xs:float(8452), -2)
fn:round(xs:float("NaN"))
fn:round(xs:int("-1873914410"))
fn:round(xs:int("2147483647"))
fn:round(xs:int("-2147483648"))
fn:round(xs:negativeInteger("-1"))
fn:round(xs:nonNegativeInteger("0"))
fn:round(xs:nonPositiveInteger("0"))
fn:round(xs:positiveInteger("1"))
fn:round(xs:short("32767"))
fn:round(xs:short("-32768"))
fn:round(xs:short("-5324"))
fn:round(xs:unsignedLong("0"))
fn:round(xs:unsignedShort("0"))
fn:round(xs:unsignedShort("44633"))
fn:round(xs:unsignedShort("65535"))
fn:seconds-from-dateTime(fn:current-dateTime())
fn:seconds-from-dateTime(fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00")))
fn:seconds-from-dateTime(xs:dateTime("1970-01-01T00:00:00Z"))
fn:seconds-from-dateTime(xs:dateTime("1970-01-01T00:00:10Z")) - fn:seconds-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:seconds-from-dateTime(xs:dateTime("1970-01-01T00:00:10Z")) + fn:seconds-from-dateTime(xs:dateTime("1970-01-01T10:00:11Z"))
fn:seconds-from-dateTime(xs:dateTime("1970-01-01T02:02:02Z")) * fn:seconds-from-dateTime(xs:dateTime("1970-01-01T10:03:03Z"))
fn:seconds-from-dateTime(xs:dateTime("1970-01-01T02:10:10Z")) div fn:seconds-from-dateTime(xs:dateTime("1970-01-01T10:05:05Z"))
+fn:seconds-from-dateTime(xs:dateTime("1970-01-01T10:10:10Z"))
-fn:seconds-from-dateTime(xs:dateTime("1970-01-01T10:10:10Z"))
fn:seconds-from-dateTime(xs:dateTime("1970-01-01T10:10:10Z")) eq fn:seconds-from-dateTime(xs:dateTime("1970-01-01T10:10:10Z"))
fn:seconds-from-dateTime(xs:dateTime("1970-01-01T10:10:10Z")) ge fn:seconds-from-dateTime(xs:dateTime("1970-01-01T10:10:10Z"))
fn:seconds-from-dateTime(xs:dateTime("1970-01-01T10:10:10Z")) idiv fn:seconds-from-dateTime(xs:dateTime("1970-01-01T02:05:05Z"))
fn:seconds-from-dateTime(xs:dateTime("1970-01-01T10:10:10Z")) le fn:seconds-from-dateTime(xs:dateTime("1970-01-01T10:10:10Z"))
fn:seconds-from-dateTime(xs:dateTime("1970-01-01T10:10:10Z")) mod fn:seconds-from-dateTime(xs:dateTime("1970-01-01T03:10:10Z"))
fn:seconds-from-dateTime(xs:dateTime("1970-01-01T10:10:10Z")) ne fn:seconds-from-dateTime(xs:dateTime("1970-01-01T10:10:10Z"))
fn:seconds-from-dateTime(xs:dateTime("1996-04-07T01:40:52Z"))
fn:seconds-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))
fn:seconds-from-dateTime(xs:dateTime("1999-05-31T20:00:00-05:00"))
fn:seconds-from-dateTime(xs:dateTime("1999-05-31T23:59:59-05:00"))
fn:seconds-from-dateTime(xs:dateTime("1999-12-31T21:20:20-05:00")) le fn:seconds-from-dateTime(xs:dateTime("1999-12-31T21:20:20-05:00"))
fn:seconds-from-dateTime(xs:dateTime("1999-12-31T21:20:20-05:00")) lt fn:seconds-from-dateTime(xs:dateTime("1999-12-31T21:20:20-05:00"))
fn:seconds-from-dateTime(xs:dateTime("2030-12-31T23:59:59Z"))
fn:seconds-from-duration(xs:dayTimeDuration("P01DT01H01M01S"))
fn:seconds-from-duration(xs:dayTimeDuration("P0DT0H0M0S"))
fn:seconds-from-duration(xs:dayTimeDuration("P10DT10H20M10S")) mod fn:seconds-from-duration(xs:dayTimeDuration("P03DT03H03M03S"))
fn:seconds-from-duration(xs:dayTimeDuration("P15DT11H59M59S"))
fn:seconds-from-duration(xs:dayTimeDuration("P20DT03H09M20S")) le fn:seconds-from-duration(xs:dayTimeDuration("P21DT15H21M31S"))
-fn:seconds-from-duration(xs:dayTimeDuration("P20DT03H20M30S"))
fn:seconds-from-duration(xs:dayTimeDuration("P20DT09H04M20S")) * fn:seconds-from-duration(xs:dayTimeDuration("P03DT10H10M03S"))
fn:seconds-from-duration(xs:dayTimeDuration("P20DT10H10M30S")) div fn:seconds-from-duration(xs:dayTimeDuration("P05DT05H02M02S"))
fn:seconds-from-duration(xs:dayTimeDuration("P20DT20H20M10S")) lt fn:seconds-from-duration(xs:dayTimeDuration("P03DT02H10M20S"))
fn:seconds-from-duration(xs:dayTimeDuration("P21DT07H12M59S")) ge fn:seconds-from-duration(xs:dayTimeDuration("P20DT01H13M01S"))
fn:seconds-from-duration(xs:dayTimeDuration("P21DT10H10M09S")) + fn:seconds-from-duration(xs:dayTimeDuration("P22DT11H30M21S"))
fn:seconds-from-duration(xs:dayTimeDuration("P21DT10H10M09S")) le fn:seconds-from-duration(xs:dayTimeDuration("P22DT10H09M31S"))
+fn:seconds-from-duration(xs:dayTimeDuration("P21DT10H10M20S"))
fn:seconds-from-duration(xs:dayTimeDuration("P21DT10H10M90S"))
fn:seconds-from-duration(xs:dayTimeDuration("P22DT10H10M01S")) eq fn:seconds-from-duration(xs:dayTimeDuration("P22DT09H10M01S"))
fn:seconds-from-duration(xs:dayTimeDuration("P23DT08H20M02S")) ne fn:seconds-from-duration(xs:dayTimeDuration("P12DT05H22M03S"))
fn:seconds-from-duration(xs:dayTimeDuration("P25DT10H20M40S")) idiv fn:seconds-from-duration(xs:dayTimeDuration("P05DT02H04M20S"))
fn:seconds-from-duration(xs:dayTimeDuration("P30DT10H20M10S")) - fn:seconds-from-duration(xs:dayTimeDuration("P10DT09H10M02S"))
fn:seconds-from-duration(xs:dayTimeDuration("P31DT23H59M59S"))
fn:seconds-from-duration(xs:dayTimeDuration("P3DT10H12.5S"))
fn:seconds-from-duration(xs:dayTimeDuration("-PT256S"))
fn:seconds-from-duration(xs:duration("P1Y2M3DT10H30M911S"))
fn:seconds-from-duration(xs:yearMonthDuration('P1Y'))
fn:seconds-from-time(fn:current-time())
fn:seconds-from-time(xs:time("00:00:00Z"))
fn:seconds-from-time(xs:time("01:23:02Z")) gt fn:seconds-from-time(xs:time("01:23:03Z"))
fn:seconds-from-time(xs:time("02:00:00Z")) + fn:seconds-from-time(xs:time("10:00:10Z"))
fn:seconds-from-time(xs:time("02:02:03Z")) * fn:seconds-from-time(xs:time("10:08:09Z"))
fn:seconds-from-time(xs:time("08:03:35Z"))
fn:seconds-from-time(xs:time("10:00:00Z")) le fn:seconds-from-time(xs:time("10:00:00Z"))
+fn:seconds-from-time(xs:time("10:00:01Z"))
fn:seconds-from-time(xs:time("10:00:01Z")) ne fn:seconds-from-time(xs:time("01:01:00Z"))
fn:seconds-from-time(xs:time("10:02:01Z")) eq fn:seconds-from-time(xs:time("10:02:00Z"))
fn:seconds-from-time(xs:time("10:03:01Z")) ge fn:seconds-from-time(xs:time("10:04:02Z"))
-fn:seconds-from-time(xs:time("10:10:01Z"))
fn:seconds-from-time(xs:time("10:10:10Z")) - fn:seconds-from-time(xs:time("09:02:07Z"))
fn:seconds-from-time(xs:time("10:10:20Z")) mod fn:seconds-from-time(xs:time("03:03:02Z"))
fn:seconds-from-time(xs:time("10:12:15Z")) idiv fn:seconds-from-time(xs:time("02:02:03Z"))
fn:seconds-from-time(xs:time("13:20:10.5"))
fn:seconds-from-time(xs:time("21:23:04Z")) lt fn:seconds-from-time(xs:time("21:24:00Z"))
fn:seconds-from-time(xs:time("22:33:10Z")) div fn:seconds-from-time(xs:time("02:11:02Z"))
fn:seconds-from-time(xs:time("23:20:59Z"))
fn:seconds-from-time(xs:time("23:59:59Z"))
fn:starts-with ((), ())
fn:starts-with("","")
fn:starts-with("",())
fn:starts-with((),"")
fn:starts-with("a","A")
fn:starts-with("A","a")
fn:starts-with(" ","AAAAABBBBB")
fn:starts-with("AAAAABBBBB"," ")
fn:starts-with("AAAAABBBBBCCCCC","BBBBB")
fn:starts-with("","A Character String")
fn:starts-with("A Character String","")
fn:starts-with("A Character String",())
fn:starts-with((),"A Character String")
fn:starts-with("A",xs:string("A"))
fn:starts-with(fn:prefix-from-QName(xs:QName("foo:bar")),"f")
fn:starts-with("Query","Que") eq xs:boolean("false")
fn:starts-with ( "tattoo", "att")
fn:starts-with("tattoo", "tat")
fn:starts-with(xs:string("A"),"A")
fn:starts-with(xs:string("This is a characte"),xs:string("This is a characte"))
fn:string(())
fn:string()
fn:string(.)
fn:string(("abc" || "de"))
fn:string(attribute attr {'a', element a {}, 'b'})
fn:string(comment {'a', element a {}, 'b'})
fn:string(<elem>a<a/>b</elem>)
fn:string(element elem {'a', element a {}, 'b'})
fn:string(fn:concat("abc","de"))
fn:string(fn:current-date()) and fn:false()
fn:string(fn:current-date()) and fn:true()
fn:string(fn:current-date()) eq fn:string(fn:current-date())
fn:string(fn:current-date()) ge fn:string(fn:current-date())
fn:string(fn:current-date()) le fn:string(fn:current-date())
fn:string(fn:current-date()) ne fn:string(fn:current-date())
fn:string(fn:current-date()) or fn:false()
fn:string(fn:current-date()) or fn:true()
fn:string(fn:current-dateTime()) and fn:false()
fn:string(fn:current-dateTime()) and fn:true()
fn:string(fn:current-dateTime()) eq fn:string(fn:current-dateTime())
fn:string(fn:current-dateTime()) ge fn:string(fn:current-dateTime())
fn:string(fn:current-dateTime()) le fn:string(fn:current-dateTime())
fn:string(fn:current-dateTime()) ne fn:string(fn:current-dateTime())
fn:string(fn:current-dateTime()) or fn:false()
fn:string(fn:current-dateTime()) or fn:true()
fn:string(fn:current-time()) and fn:false()
fn:string(fn:current-time()) and fn:true()
fn:string(fn:current-time()) eq fn:string(fn:current-time())
fn:string(fn:current-time()) ge fn:string(fn:current-time())
fn:string(fn:current-time()) le fn:string(fn:current-time())
fn:string(fn:current-time()) ne fn:string(fn:current-time())
fn:string(fn:current-time()) or fn:false()
fn:string(fn:current-time()) or fn:true()
fn:string(fn:false())
fn:string(fn:implicit-timezone() * -0)
fn:string(fn:implicit-timezone() * 0)
fn:string(fn:implicit-timezone() * (0 div 0E0))
fn:string(fn:implicit-timezone() div -0 )
fn:string(fn:implicit-timezone() div 0 )
fn:string(fn:implicit-timezone() div ( 0 div 0E0))
fn:string(fn:implicit-timezone() div xs:dayTimeDuration("P0DT60M00S"))
fn:string(fn:implicit-timezone() div xs:double(2))
fn:string(fn:implicit-timezone() + fn:implicit-timezone())
fn:string(fn:implicit-timezone() - fn:implicit-timezone())
fn:string(fn:not("true"))
fn:string(fn:prefix-from-QName(xs:QName("foo:name")))
fn:string(fn:timezone-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")))
fn:string(fn:timezone-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))) and fn:string(fn:timezone-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")))
fn:string(fn:timezone-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))) or fn:string(fn:timezone-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")))
fn:string(fn:timezone-from-date(xs:date("1970-01-01Z")))
fn:string(fn:timezone-from-date(xs:date("1970-01-01Z"))) and fn:string(fn:timezone-from-date(xs:date("1970-01-01Z")))
fn:string(fn:timezone-from-date(xs:date("1970-01-01Z"))) or fn:string(fn:timezone-from-date(xs:date("1970-01-01Z")))
fn:string(fn:timezone-from-time(xs:time("10:00:01Z")))
fn:string(fn:timezone-from-time(xs:time("10:03:01Z"))) or fn:string(fn:timezone-from-time(xs:time("10:04:02Z")))
fn:string(fn:timezone-from-time(xs:time("10:10:01Z"))) and fn:string(fn:timezone-from-time(xs:time("10:10:01Z")))
fn:string(fn:translate("ABC", "ABC", "ABC"))
fn:string(fn:true())
fn:string-join("****","***")
fn:string-join(("1", "2", "3"))
fn:string-join("12345","1234")
fn:string-join(1 to 5, "")
fn:string-join(1 to 5, ', ')
fn:string-join(1 to 9)
fn:string-join((1 to 9)!string())
fn:string-join(("a"),"A")
fn:string-join(("A"),"a")
fn:string-join(("AAAAABBBBB")," ")
fn:string-join(("AAAAABBBBBCCCCC"),"BBBBB")
fn:string-join(("A"),xs:string("A"))
fn:string-join(('Blow, ', 'blow, ', 'thou ', 'winter ', 'wind!'),                   '')
fn:string-join(('Blow, ', 'blow, ', 'thou ', 'winter ', 'wind!'), '')
fn:string-join((current-date(), current-time(), current-dateTime()), '#')
fn:string-join((fn:codepoints-to-string((49,97)),'ab'),'')
fn:string-join((fn:prefix-from-QName(xs:QName("foo:bar")),":bar"),"")
fn:string-join(('Now', 'is', 'the', 'time', '...'),                   ' ')
fn:string-join(('Now', 'is', 'the', 'time', '...'), ' ')
fn:string-join((), 'separator')
fn:string-join("string-join","nioj-gnirts")
fn:string-join("string-join","string-join")
fn:string-join(("string-joinstring-join"),"string-join")
fn:string-join(string-to-codepoints('abc'), '-')
fn:string-join((xs:string#1, xs:gYear#1, xs:float#1, xs:double#1, xs:integer#1)!'1900', ',')
fn:string-join((xs:string("A")),"A")
fn:string-join(xs:string("This is a characte"),xs:string("This is a characte"))
fn:string-length("")
fn:string-length("*****")
fn:string-length(())
fn:string-length()
fn:string-length("%$#@!")
fn:string-length("12345")
fn:string-length("12345abcd")
fn:string-length("abc") and fn:string-length("abc")
fn:string-length("ABCD")
fn:string-length("abcde")
fn:string-length("ABCDEabcde")
fn:string-length(.//employee/@name )
fn:string-length(fn:codepoints-to-string((49,97)))
fn:string-length(fn:name(()))
fn:string-length(fn:name(.))
fn:string-length(fn:name(./works[1]/employee[2]/@name))
fn:string-length(fn:name(./works[1]/nonexistent[1]))
fn:string-length(fn:prefix-from-QName(xs:QName("foo:bar")))
fn:string-length(fn:string("AbcDH"))
fn:string-length(fn:translate("ABC","ABC","ABC"))
fn:string-length("Harp not on that string, madam; that is past.")
fn:string-length(if (2 != 3) then 'foo' else 'expanded-foo')
fn:string-length(string((<elem attr="&amp;&lt;&gt;"/>)/@attr))
fn:string-length("string-length")
fn:string-length(xs:date('2007-11-29'))
fn:string-length(xs:string(fn:false()))
fn:string-length(xs:string(fn:not("true")))
fn:string-length(xs:string(fn:prefix-from-QName(xs:QName("name"))))
fn:string-length(xs:string(fn:true()))
fn:string-length(xs:string("This is a characte"))
fn:string-length("zzzzz") + fn:string-length("zzzzz")
fn:string(processing-instruction pi {'a', element a {}, 'b'})
fn:string(text {'a', element a {}, 'b'})
fn:string-to-codepoints("")
fn:string-to-codepoints('#*^$')
fn:string-to-codepoints('1')
fn:string-to-codepoints('1a')
fn:string-to-codepoints('a')
fn:string-to-codepoints(fn:codepoints-to-string((49,97)))
fn:string-to-codepoints(fn:lower-case("A String"))
fn:string-to-codepoints(fn:lower-case(fn:codepoints-to-string(160 to 256)))
fn:string-to-codepoints(fn:lower-case(fn:codepoints-to-string(459)))
fn:string-to-codepoints(fn:upper-case("A String"))
fn:string-to-codepoints(fn:upper-case(fn:codepoints-to-string(160 to 256)))
fn:string-to-codepoints(fn:upper-case(fn:codepoints-to-string(223)))
fn:string-to-codepoints(fn:upper-case(fn:codepoints-to-string(459)))
fn:string-to-codepoints(fn:upper-case(fn:codepoints-to-string(64279)))
fn:string-to-codepoints('string-to-codepoints')
fn:string-to-codepoints("Thrse")
fn:string-to-codepoints(xs:string("A String"))
fn:string-to-codepoints(xs:string("This is a characte"))
fn:string((xs:date("1977-12-12Z") - xs:date("1976-12-12Z"))) ge xs:string(xs:dayTimeDuration("P17DT10H02M"))
fn:string((xs:date("1978-12-12Z") - xs:date("1977-03-12Z"))) le xs:string(xs:dayTimeDuration("P17DT10H02M"))
fn:string((xs:date("1979-12-12Z") - xs:date("1979-11-11Z"))) ne xs:string(xs:dayTimeDuration("P17DT10H02M"))
fn:string((xs:date("1980-03-02Z") - xs:date("2001-09-11Z"))) and (fn:true())
fn:string((xs:date("1980-05-05Z") - xs:date("1981-12-03Z"))) eq xs:string(xs:dayTimeDuration("P17DT10H02M"))
fn:string((xs:date("1985-07-05Z") - xs:date("1977-12-02Z"))) or fn:string((xs:date("1985-07-05Z") - xs:date("1960-11-07Z")))
fn:string(xs:date("1989-07-05Z") - xs:date("1962-09-04Z"))
fn:string((xs:date("1993-12-09Z") - xs:date("1992-10-02Z"))) and fn:string((xs:date("1993-12-09Z") - xs:date("1980-10-20Z")))
fn:string((xs:date("1999-10-23Z") - xs:date("1998-09-09Z"))) or fn:false()
fn:string(xs:date("2000-12-12Z") - xs:date("2000-11-11Z")) and fn:false()
fn:string((xs:dateTime("1977-12-12T01:02:02Z") - xs:dateTime("1976-12-12T02:03:04Z"))) ge xs:string(xs:dayTimeDuration("P18DT02H02M"))
fn:string((xs:dateTime("1978-12-12T10:09:08Z") - xs:dateTime("1977-12-12T09:08:07Z"))) le xs:string(xs:dayTimeDuration("P17DT10H02M"))
fn:string((xs:dateTime("1979-12-12T16:16:16Z") - xs:dateTime("1978-12-12T17:17:17Z"))) ne xs:string(xs:dayTimeDuration("P17DT10H02M"))
fn:string((xs:dateTime("1980-03-02T11:11:11Z") - xs:dateTime("1981-12-12T12:12:12Z"))) and (fn:true())
fn:string((xs:dateTime("1980-05-05T13:13:13Z") - xs:dateTime("1979-10-05T14:14:14Z"))) eq xs:string(xs:dayTimeDuration("P17DT10H02M"))
fn:string((xs:dateTime("1985-07-05T07:07:07Z") - xs:dateTime("1984-07-05T08:08:08Z"))) or fn:string((xs:dateTime("1985-07-05T09:09:09Z") - xs:dateTime("1984-07-05T10:10:10Z")))
fn:string(xs:dateTime("1989-07-05T02:02:02Z") - xs:dateTime("1988-01-28T03:03:03Z"))
fn:string((xs:dateTime("1993-12-09T04:04:04Z") - xs:dateTime("1992-12-09T05:05:05Z"))) and fn:string((xs:dateTime("1993-12-09T01:01:01Z") - xs:dateTime("1992-12-09T06:06:06Z")))
fn:string((xs:dateTime("1999-10-23T03:02:01Z") - xs:dateTime("1998-09-09T04:04:05Z"))) or fn:false()
fn:string(xs:dateTime("2000-12-12T12:07:08Z") - xs:dateTime("1999-12-12T13:08:09Z")) and fn:false()
fn:string((xs:dayTimeDuration("P01DT02H01M") * 2.0)) and fn:string((xs:dayTimeDuration("P02DT03H03M") * 2.0 ))
fn:string((xs:dayTimeDuration("P01DT02H01M") div 2.0)) and fn:string((xs:dayTimeDuration("P02DT03H03M") div 2.0 ))
fn:string((xs:dayTimeDuration("P01DT02H01M") + xs:dayTimeDuration("P02DT09H02M"))) and fn:string((xs:dayTimeDuration("P02DT03H03M") + xs:dayTimeDuration("P04DT04H04M")))
fn:string((xs:dayTimeDuration("P01DT02H01M") - xs:dayTimeDuration("P02DT09H02M"))) and fn:string((xs:dayTimeDuration("P02DT03H03M") - xs:dayTimeDuration("P04DT04H04M")))
fn:string(xs:dayTimeDuration("P03DT04H08M") * 2.0)
fn:string(xs:dayTimeDuration("P03DT04H08M") div 2.0)
fn:string(xs:dayTimeDuration("P03DT04H08M") + xs:dayTimeDuration("P01DT09H02M"))
fn:string(xs:dayTimeDuration("P03DT04H08M") - xs:dayTimeDuration("P01DT09H02M"))
fn:string((xs:dayTimeDuration("P05DT09H02M") * 2.0)) or fn:string((xs:dayTimeDuration("P05DT05H03M") * 2.0))
fn:string((xs:dayTimeDuration("P05DT09H02M") div 2.0)) or fn:string((xs:dayTimeDuration("P05DT05H03M") div 2.0))
fn:string((xs:dayTimeDuration("P05DT09H02M") + xs:dayTimeDuration("P03DT01H04M"))) or fn:string((xs:dayTimeDuration("P05DT05H03M") + xs:dayTimeDuration("P01DT01H03M")))
fn:string((xs:dayTimeDuration("P05DT09H02M") - xs:dayTimeDuration("P03DT01H04M"))) or fn:string((xs:dayTimeDuration("P05DT05H03M") - xs:dayTimeDuration("P01DT01H03M")))
fn:string(xs:dayTimeDuration("P08DT06H08M") div xs:dayTimeDuration("P08DT06H08M"))
fn:string((xs:dayTimeDuration("P10DT08H11M") * 2.0)) and (fn:true())
fn:string((xs:dayTimeDuration("P10DT08H11M") div 2.0)) and (fn:true())
fn:string((xs:dayTimeDuration("P10DT08H11M") + xs:dayTimeDuration("P05DT08H11M"))) and (fn:true())
fn:string((xs:dayTimeDuration("P10DT08H11M") - xs:dayTimeDuration("P05DT08H11M"))) and (fn:true())
fn:string((xs:dayTimeDuration("P10DT10H11M")) * 2.0) and fn:false()
fn:string((xs:dayTimeDuration("P10DT10H11M")) div 2.0) and fn:false()
fn:string(xs:dayTimeDuration("P10DT10H11M") + xs:dayTimeDuration("P12DT10H07M")) and fn:false()
fn:string(xs:dayTimeDuration("P10DT10H11M") - xs:dayTimeDuration("P12DT10H07M")) and fn:false()
fn:string((xs:dayTimeDuration("P20DT20H10M") * 2.0)) or fn:false()
fn:string((xs:dayTimeDuration("P20DT20H10M") div 2.0)) or fn:false()
fn:string(xs:dayTimeDuration("P20DT20H10M") + xs:dayTimeDuration("P19DT13H10M")) or fn:false()
fn:string(xs:dayTimeDuration("P20DT20H10M") - xs:dayTimeDuration("P19DT13H10M")) or fn:false()
fn:string(xs:double("-0"))
fn:string(xs:double("0"))
fn:string(xs:double("-1.7976931348623157E308"))
fn:string(xs:double("1.7976931348623157E308"))
fn:string(xs:float("-0"))
fn:string(xs:float("0"))
fn:string(xs:float("-3.4028235E38"))
fn:string(xs:float("3.4028235E38"))
fn:string(xs:int("-1873914410"))
fn:string(xs:int("2147483647"))
fn:string(xs:int("-2147483648"))
fn:string(xs:negativeInteger("-1"))
fn:string(xs:nonNegativeInteger("0"))
fn:string(xs:nonPositiveInteger("0"))
fn:string(xs:positiveInteger("1"))
fn:string(xs:short("32767"))
fn:string(xs:short("-32768"))
fn:string(xs:short("-5324"))
fn:string((xs:time("13:00:00Z") - xs:time("12:00:00Z"))) and fn:string((xs:time("13:00:00Z") - xs:time("10:00:00Z")))
fn:string(xs:time("13:00:00Z") - xs:time("17:00:00Z"))
fn:string((xs:time("13:00:00Z") - xs:time("17:00:00Z"))) or fn:string((xs:time("13:00:00Z") - xs:time("17:00:00Z")))
fn:string((xs:time("17:00:00Z") - xs:time("13:00:00Z"))) and (fn:true())
fn:string(xs:unsignedLong("0"))
fn:string(xs:unsignedShort("0"))
fn:string(xs:unsignedShort("44633"))
fn:string(xs:unsignedShort("65535"))
fn:string((xs:yearMonthDuration("P01Y01M") * 2.0)) and fn:string((xs:yearMonthDuration("P02Y03M") * 2.0))
fn:string((xs:yearMonthDuration("P01Y01M") div 2.0)) and fn:string((xs:yearMonthDuration("P02Y03M") div 2.0))
fn:string((xs:yearMonthDuration("P01Y01M") + xs:yearMonthDuration("P02Y02M"))) and fn:string((xs:yearMonthDuration("P02Y03M") + xs:yearMonthDuration("P04Y04M")))
fn:string((xs:yearMonthDuration("P01Y01M") - xs:yearMonthDuration("P02Y02M"))) and fn:string((xs:yearMonthDuration("P02Y03M") - xs:yearMonthDuration("P04Y04M")))
fn:string(xs:yearMonthDuration("P03Y08M") * 2.0)
fn:string(xs:yearMonthDuration("P03Y08M") div 2.0)
fn:string(xs:yearMonthDuration("P03Y08M") div xs:yearMonthDuration("P03Y08M"))
fn:string(xs:yearMonthDuration("P03Y08M") + xs:yearMonthDuration("P01Y02M"))
fn:string(xs:yearMonthDuration("P03Y08M") - xs:yearMonthDuration("P01Y02M"))
fn:string((xs:yearMonthDuration("P05Y02M") * 2.0)) or fn:string((xs:yearMonthDuration("P05Y03M") * 2.0))
fn:string((xs:yearMonthDuration("P05Y02M") div 2.0)) or fn:string((xs:yearMonthDuration("P05Y03M") div 2.0))
fn:string((xs:yearMonthDuration("P05Y02M") + xs:yearMonthDuration("P03Y04M"))) or fn:string((xs:yearMonthDuration("P05Y03M") + xs:yearMonthDuration("P01Y03M")))
fn:string((xs:yearMonthDuration("P05Y02M") - xs:yearMonthDuration("P03Y04M"))) or fn:string((xs:yearMonthDuration("P05Y03M") - xs:yearMonthDuration("P01Y03M")))
fn:string((xs:yearMonthDuration("P10Y11M")) * 2.0) and fn:false()
fn:string((xs:yearMonthDuration("P10Y11M") * 2.0)) and (fn:true())
fn:string((xs:yearMonthDuration("P10Y11M") div 2.0)) and fn:false()
fn:string((xs:yearMonthDuration("P10Y11M") div 2.0)) and (fn:true())
fn:string((xs:yearMonthDuration("P10Y11M") + xs:yearMonthDuration("P05Y07M"))) and (fn:true())
fn:string((xs:yearMonthDuration("P10Y11M") - xs:yearMonthDuration("P05Y07M"))) and (fn:true())
fn:string(xs:yearMonthDuration("P10Y11M") + xs:yearMonthDuration("P12Y07M")) and fn:false()
fn:string(xs:yearMonthDuration("P10Y11M") - xs:yearMonthDuration("P12Y07M")) and fn:false()
fn:string((xs:yearMonthDuration("P20Y10M") * 2.0)) or fn:false()
fn:string((xs:yearMonthDuration("P20Y10M") div 2.0)) or fn:false()
fn:string(xs:yearMonthDuration("P20Y10M") + xs:yearMonthDuration("P19Y10M")) or fn:false()
fn:string(xs:yearMonthDuration("P20Y10M") - xs:yearMonthDuration("P19Y10M")) or fn:false()
fn:subsequence((1,2,3), 1.1, 1)
fn:subsequence((1,2,3), 1.4, 1.4)
fn:subsequence((1,2,3), 1.5, 1.5)
fn:subsequence((1,2,3), 1.8, 1)
fn:subsequence (1 to 10, xs:double('-INF'), xs:double('INF'))
fn:subsequence( ("a", "b", "c"), 1, 1)
fn:subsequence( ("a", (), (), "b", "c"), 1, 3)
fn:subsequence( ("a", "b", "c"), 3, 12)
fn:subsequence( ("a", xs:anyURI("www.example.com"),"b", "c"), 1, 3)
fn:subsequence ( ("a", xs:boolean("0"), "b", "c"), 2,1)
fn:subsequence ( ("a", xs:boolean("1"), "b", "c"), 1,2)
fn:subsequence ( ("a", xs:boolean("false"), "b", "c"), 1, 3)
fn:subsequence ( ("a", xs:boolean("true"), "b", "c"), 1,2)
fn:subsequence ( ("a", xs:date("1993-03-31"), "b", "c"), 1,2)
fn:subsequence ( ("a", xs:dateTime("1972-12-31T00:00:00"), "b", "c"), 0,2)
fn:subsequence( ("a", xs:decimal("-1.000000000001"), xs:integer("-100"), "b", "c"), 2,3)
fn:subsequence ( ("a", xs:double("1.01"), "b", "c"), 2,3)
fn:subsequence ( ("a", xs:double("INF"), "b", "c"), 2, 1)
fn:subsequence ( ("a", xs:double("-INF"), "b", "c"), 2,2)
fn:subsequence ( ("a", xs:double("NaN"), "b", "c"), 2, 20)
fn:subsequence ( ("a", xs:float("1.01"), "b", "c"), 2,4)
fn:subsequence ( ("a", xs:float("-INF"), "b", "c"), 1,2)
fn:subsequence( ("a", xs:float("INF"), "b", "c"),-2,3)
fn:subsequence ( ("a", xs:float("NaN"), "b", "c"), 0, 2)
fn:subsequence( ("a", xs:integer("100"), xs:integer("-100"), "b", "c"),2,4)
fn:subsequence( ("a", xs:string(""),"b", "c"), 1, 3)
fn:subsequence( ("a", xs:string("hello"),"b", "c"), 1, 3)
fn:subsequence ( ("a", xs:time("12:30:00"), "b", "c"), 1, 2)
fn:sub-sequence("http:/example.com/", 1, 1)
fn:substring("!@#$%^*()",1)
fn:substring("12345", 0, 3)
fn:substring("12345", 0 div 0E0, 3)
fn:substring("12345", 1, 0 div 0E0)
fn:substring("12345", 1.5, 2.6)
fn:substring("12345", -1 div 0E0, 1 div 0E0)
fn:substring("12345", -3, 5)
fn:substring("12345", -42, 1 div 0E0)
fn:substring("12345", 5, -3)
fn:substring((), 1, 3)
fn:substring("ABCDE",1+1)
fn:substring("ABCD",xs:double(1))
fn:substring-after("","")
fn:substring-after("",())
fn:substring-after("****","***")
fn:substring-after((), ())
fn:substring-after((),"")
fn:substring-after("12345","1234")
fn:substring-after("a","A")
fn:substring-after("A","a")
fn:substring-after(" ","AAAAABBBBB")
fn:substring-after("AAAAABBBBB"," ")
fn:substring-after("AAAAABBBBBCCCCC","BBBBB")
fn:substring-after("","A Character String")
fn:substring-after("A Character String","")
fn:substring-after("A Character String",())
fn:substring-after((),"A Character String")
fn:substring-after("A",xs:string("A"))
fn:substring-after(fn:prefix-from-QName(xs:QName("foo:bar")),"f")
fn:substring-after("substring-after","refta-gnirtsbus")
fn:substring-after("substring-after","substring-after")
fn:substring-after("substring-aftersubstring-after","substring-after")
fn:substring-after("tattoo", "tat")
fn:substring-after("tattoo", "tattoo")
fn:substring-after(xs:string("A"),"A")
fn:substring-before ((), ())
fn:substring-before("","")
fn:substring-before("",())
fn:substring-before("****","***")
fn:substring-before((),"")
fn:substring-before("12345","2345")
fn:substring-before("a","A")
fn:substring-before("A","a")
fn:substring-before(" ","AAAAABBBBB")
fn:substring-before("AAAAABBBBB"," ")
fn:substring-before("AAAAABBBBBCCCCC","BBBBB")
fn:substring-before("","A Character String")
fn:substring-before("A Character String","")
fn:substring-before("A Character String",())
fn:substring-before((),"A Character String")
fn:substring-before("A",xs:string("A"))
fn:substring-before(fn:prefix-from-QName(xs:QName("foo:bar")),"oo")
fn:substring-before("substring-before","erofeb-gnirtsbus")
fn:substring-before("substring-before","substring-before")
fn:substring-before("substring-beforesubstring-before","substring-before")
fn:substring-before ( "tattoo", "attoo")
fn:substring-before ( "tattoo", "tatto")
fn:substring-before(xs:string("A"),"A")
fn:substring(fn:prefix-from-QName(xs:QName("foo:bar")),2)
fn:substring(fn:substring("ABCDE",1),1)
fn:substring("metadata", 4, 3)
fn:substring("motor car", 6)
fn:substring("substring",1)
fn:sum(())
fn:sum((),())
fn:sum((1 to 100)[. lt 0], 0)
fn:sum((xs:decimal("0"),xs:decimal("0"),xs:decimal("617375191608514839")))
fn:sum((xs:decimal("617375191608514839")))
fn:sum((xs:decimal("617375191608514839"),xs:decimal("-999999999999999999")))
fn:sum((xs:decimal("-999999999999999999")))
fn:sum((xs:decimal("999999999999999999")))
fn:sum((xs:decimal("-999999999999999999"),xs:decimal("617375191608514839")))
fn:sum((xs:decimal("-999999999999999999"),xs:decimal("999999999999999999")))
fn:sum((xs:decimal("999999999999999999"),xs:decimal("-999999999999999999")))
fn:sum((xs:decimal("-999999999999999999"),xs:decimal("-999999999999999999"),xs:decimal("999999999999999999")))
fn:sum((xs:decimal("-999999999999999999"),xs:decimal("999999999999999999"),xs:decimal("-999999999999999999")))
fn:sum((xs:decimal("999999999999999999"),xs:decimal("-999999999999999999"),xs:decimal("-999999999999999999")))
fn:sum((xs:double("0")))
fn:sum((xs:double("0"),xs:double("0"),xs:double("0")))
fn:sum((xs:double("0"),xs:double("-1.7976931348623157E308")))
fn:sum((xs:double("0"),xs:double("-1.7976931348623157E308"),xs:double("-1.7976931348623157E308")))
fn:sum((xs:double("-1.7976931348623157E308")))
fn:sum((xs:double("1.7976931348623157E308")))
fn:sum((xs:double("-1.7976931348623157E308"),xs:double("0")))
fn:sum((xs:double("-1.7976931348623157E308"),xs:double("0"),xs:double("0")))
fn:sum((xs:double("-1.7976931348623157E308"),xs:double("1.7976931348623157E308")))
fn:sum((xs:double("1.7976931348623157E308"),xs:double("-1.7976931348623157E308")))
fn:sum((xs:double("-1.7976931348623157E308"),xs:double("-1.7976931348623157E308"),xs:double("1.7976931348623157E308")))
fn:sum((xs:double("-1.7976931348623157E308"),xs:double("1.7976931348623157E308"),xs:double("-1.7976931348623157E308")))
fn:sum((xs:double("1.7976931348623157E308"),xs:double("-1.7976931348623157E308"),xs:double("-1.7976931348623157E308")))
fn:sum((xs:float("0")))
fn:sum((xs:float("0"),xs:float("0"),xs:float("0")))
fn:sum((xs:float("0"),xs:float("-3.4028235E38")))
fn:sum((xs:float("-3.4028235E38")))
fn:sum((xs:float("3.4028235E38")))
fn:sum((xs:float("-3.4028235E38"),xs:float("0")))
fn:sum((xs:float("-3.4028235E38"),xs:float("0"),xs:float("0")))
fn:sum((xs:float("-3.4028235E38"),xs:float("3.4028235E38")))
fn:sum((xs:float("3.4028235E38"),xs:float("-3.4028235E38")))
fn:sum((xs:float("-3.4028235E38"),xs:float("-3.4028235E38"),xs:float("3.4028235E38")))
fn:sum((xs:float("-3.4028235E38"),xs:float("3.4028235E38"),xs:float("-3.4028235E38")))
fn:sum((xs:float("3.4028235E38"),xs:float("-3.4028235E38"),xs:float("-3.4028235E38")))
fn:sum((xs:int("0"),xs:int("0"),xs:int("-1873914410")))
fn:sum((xs:int("0"),xs:int("0"),xs:int("2147483647")))
fn:sum((xs:int("-1873914410")))
fn:sum((xs:int("-1873914410"),xs:int("-273569238")))
fn:sum((xs:int("-1873914410"),xs:int("-273569238"),xs:int("-273569238")))
fn:sum((xs:int("2147483647")))
fn:sum((xs:int("2147483647"),xs:int("-2147483648")))
fn:sum((xs:int("-2147483648")))
fn:sum((xs:int("-2147483648"),xs:int("2147483647")))
fn:sum((xs:int("-273569238"),xs:int("-1873914410")))
fn:sum((xs:int("-273569238"),xs:int("-1873914410"),xs:int("0")))
fn:sum((xs:negativeInteger("-1")))
fn:sum((xs:nonNegativeInteger("0")))
fn:sum((xs:nonNegativeInteger("0"),xs:nonNegativeInteger("0")))
fn:sum((xs:nonNegativeInteger("0"),xs:nonNegativeInteger("0"),xs:nonNegativeInteger("0")))
fn:sum((xs:nonPositiveInteger("0")))
fn:sum((xs:nonPositiveInteger("0"),xs:nonPositiveInteger("0"),xs:nonPositiveInteger("0")))
fn:sum((xs:positiveInteger("1")))
fn:sum((xs:positiveInteger("1"),xs:positiveInteger("1")))
fn:sum((xs:positiveInteger("1"),xs:positiveInteger("1"),xs:positiveInteger("1")))
fn:sum((xs:short("0"),xs:short("0"),xs:short("32767")))
fn:sum((xs:short("0"),xs:short("0"),xs:short("-5324")))
fn:sum((xs:short("-27444"),xs:short("-5324")))
fn:sum((xs:short("-27444"),xs:short("-5324"),xs:short("0")))
fn:sum((xs:short("32767")))
fn:sum((xs:short("32767"),xs:short("-32768")))
fn:sum((xs:short("-32768")))
fn:sum((xs:short("-32768"),xs:short("32767")))
fn:sum((xs:short("-5324")))
fn:sum((xs:short("-5324"),xs:short("-27444")))
fn:sum((xs:short("-5324"),xs:short("-27444"),xs:short("-27444")))
fn:sum((xs:unsignedLong("0")))
fn:sum((xs:unsignedLong("0"),xs:unsignedLong("0")))
fn:sum((xs:unsignedLong("0"),xs:unsignedLong("0"),xs:unsignedLong("0")))
fn:sum((xs:unsignedShort("0")))
fn:sum((xs:unsignedShort("0"),xs:unsignedShort("0")))
fn:sum((xs:unsignedShort("0"),xs:unsignedShort("0"),xs:unsignedShort("0")))
fn:sum((xs:unsignedShort("0"),xs:unsignedShort("0"),xs:unsignedShort("44633")))
fn:sum((xs:unsignedShort("0"),xs:unsignedShort("0"),xs:unsignedShort("65535")))
fn:sum((xs:unsignedShort("0"),xs:unsignedShort("44633")))
fn:sum((xs:unsignedShort("0"),xs:unsignedShort("44633"),xs:unsignedShort("0")))
fn:sum((xs:unsignedShort("0"),xs:unsignedShort("65535")))
fn:sum((xs:unsignedShort("0"),xs:unsignedShort("65535"),xs:unsignedShort("0")))
fn:sum((xs:unsignedShort("44633")))
fn:sum((xs:unsignedShort("44633"),xs:unsignedShort("0")))
fn:sum((xs:unsignedShort("44633"),xs:unsignedShort("0"),xs:unsignedShort("0")))
fn:sum((xs:unsignedShort("65535")))
fn:sum((xs:unsignedShort("65535"),xs:unsignedShort("0")))
fn:sum((xs:unsignedShort("65535"),xs:unsignedShort("0"),xs:unsignedShort("0")))
fn:sum( (xs:yearMonthDuration('P1Y0M'), 1) )
fn:tail(())
fn:tail([1,2,3])
fn:tail(1 to 5)
fn:tail("a")
fn:tail(("a", "b", "c"))
fn:timezone-from-date(current-date())
fn:timezone-from-dateTime(current-dateTime())
fn:timezone-from-dateTime(fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00")))
fn:timezone-from-dateTime(xs:dateTime("1970-01-01T00:00:00+04:00")) - fn:timezone-from-dateTime(xs:dateTime("1970-01-01T10:00:00+02:00"))
fn:timezone-from-dateTime(xs:dateTime("1970-01-01T00:02:00Z")) + fn:timezone-from-dateTime(xs:dateTime("1970-01-01T10:03:00Z"))
fn:timezone-from-dateTime(xs:dateTime("1970-01-01T02:00:00+10:00")) div fn:timezone-from-dateTime(xs:dateTime("1970-01-01T10:00:00+05:00"))
fn:timezone-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")) eq fn:timezone-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:timezone-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")) ge fn:timezone-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:timezone-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")) le fn:timezone-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:timezone-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")) ne fn:timezone-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:timezone-from-dateTime(xs:dateTime("1999-05-31T00:20:00+00:00"))
fn:timezone-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))
fn:timezone-from-dateTime(xs:dateTime("1999-05-31T23:20:00-00:00"))
fn:timezone-from-dateTime(xs:dateTime("1999-12-31T12:00:00+02:00")) le fn:timezone-from-dateTime(xs:dateTime("1999-12-30T12:00:00+03:00"))
fn:timezone-from-dateTime(xs:dateTime("2000-06-12T13:20:00Z"))
fn:timezone-from-dateTime(xs:dateTime("2004-08-27T00:00:00"))
fn:timezone-from-date(xs:date("1970-01-01+04:00")) le fn:timezone-from-date(xs:date("1970-01-02+02:00"))
fn:timezone-from-date(xs:date("1970-01-01+08:00")) + fn:timezone-from-date(xs:date("1970-01-01+03:00"))
fn:timezone-from-date(xs:date("1970-01-01+09:00")) - fn:timezone-from-date(xs:date("1970-01-01+10:00"))
fn:timezone-from-date(xs:date("1970-01-02+10:00")) div fn:timezone-from-date(xs:date("1970-01-01+05:00"))
fn:timezone-from-date(xs:date("1970-01-02+10:00")) eq fn:timezone-from-date(xs:date("1970-01-01+10:00"))
fn:timezone-from-date(xs:date("1970-01-03+02:00")) ge fn:timezone-from-date(xs:date("1970-01-01+01:00"))
fn:timezone-from-date(xs:date("1999-05-31+00:00"))
fn:timezone-from-date(xs:date("1999-05-31-05:00"))
fn:timezone-from-date(xs:date("1999-12-31-00:00"))
fn:timezone-from-date(xs:date("1999-12-31+01:00")) le fn:timezone-from-date(xs:date("1999-12-31+01:00"))
fn:timezone-from-date(xs:date("1999-12-31+05:00")) lt fn:timezone-from-date(xs:date("1999-12-31+06:00"))
fn:timezone-from-date(xs:date("2000-06-12Z"))
fn:timezone-from-time(current-time())
fn:timezone-from-time(xs:time("00:59:00+00:00"))
fn:timezone-from-time(xs:time("01:10:20Z")) le fn:timezone-from-time(xs:time("01:20:30Z"))
fn:timezone-from-time(xs:time("01:23:02Z")) gt fn:timezone-from-time(xs:time("01:23:03Z"))
fn:timezone-from-time(xs:time("02:00:00Z")) + fn:timezone-from-time(xs:time("10:00:10Z"))
fn:timezone-from-time(xs:time("10:00:00Z")) le fn:timezone-from-time(xs:time("10:00:00Z"))
fn:timezone-from-time(xs:time("10:00:01Z")) ne fn:timezone-from-time(xs:time("01:01:00Z"))
fn:timezone-from-time(xs:time("10:02:01Z")) eq fn:timezone-from-time(xs:time("10:02:00Z"))
fn:timezone-from-time(xs:time("10:03:01Z")) ge fn:timezone-from-time(xs:time("10:04:02Z"))
fn:timezone-from-time(xs:time("10:10:10Z")) - fn:timezone-from-time(xs:time("09:02:07Z"))
fn:timezone-from-time(xs:time("13:20:00"))
fn:timezone-from-time(xs:time("13:20:00-05:00"))
fn:timezone-from-time(xs:time("22:33:10+10:00")) div fn:timezone-from-time(xs:time("02:11:02+05:00"))
fn:timezone-from-time(xs:time("23:20:59-00:00"))
fn:tokenize("1,15,,24,50,", ",")
fn:tokenize("1, 15, 24, 50", ",\s*")
fn:tokenize('foo', () )
fn:tokenize(" red green blue ")
fn:tokenize(" red green blue ", "\s+")
fn:tokenize("The cat sat on the mat", "\s+")
fn:translate("123", "123", "123")
fn:translate("123ABC", "123ABC", "123ABC")
fn:translate("--aaa--","abc-","ABC")
fn:translate("ABC", "ABC", "ABC")
fn:translate("abcdabc", "abc", "AB")
fn:translate("ABCDEFGHIJKLMNOPQRSTUVWXYZ","ABCDEFGHIJKLMNOPQRSTUVWXYZ","abcdefghijklmnopqrstuvwxyz")
fn:translate("acdefghijklmnopqrstuvwxyz", "abcdefghijklmnopqrstuvwxyz", "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
fn:translate("arg", "mapString", ())
fn:translate("arg", (), "transString")
fn:translate("bar","abc","ABC")
fn:translate(fn:string("ABC"), fn:string("ABC"), fn:string("ABC"))
fn:true()
fn:true() and fn:true()
(fn:true() and fn:true(), fn:true())
fn:true() cast as xs:boolean
fn:true() cast as xs:decimal
fn:true() cast as xs:double
fn:true() cast as xs:float
fn:true() cast as xs:integer
fn:true() cast as xs:string
fn:true() eq fn:true()
(fn:true(),fn:false(),fn:true())[xs:boolean(.)]
(fn:true(),fn:false(),fn:true())[xs:boolean(.) and xs:boolean(.)]
(fn:true(),fn:false(),fn:true())[xs:boolean(.) or xs:boolean(.)]
(fn:true(),fn:false()) instance of xs:boolean*
(fn:true(),fn:false()) instance of xs:boolean+
(fn:true(),fn:false()) instance of xs:boolean?
(fn:true(),fn:true())
fn:true() != fn:true()
fn:true() < fn:true()
fn:true() <= fn:true()
fn:true() = fn:true()
fn:true() > fn:true()
fn:true() >= fn:true()
fn:true() ge fn:true()
fn:true() gt fn:true()
fn:true() le fn:true()
fn:true() lt fn:true()
fn:true() ne fn:true()
fn:true() or fn:true()
(fn:true() or fn:true()) and fn:false()
fn:true() or (fn:true() and fn:false())
(fn:true() or fn:true(), fn:true())
fn:upper-case("*****")
fn:upper-case("%$#@!")
fn:upper-case(1)
fn:upper-case("12345")
fn:upper-case("12345abcd")
fn:upper-case("abc") and fn:upper-case("abc")
fn:upper-case("ABc!D")
fn:upper-case("ABCD")
fn:upper-case("abCd0")
fn:upper-case("abcde")
fn:upper-case("ABCDEabcde")
(fn:upper-case("Abc") || fn:upper-case("DH"))
fn:upper-case(fn:codepoints-to-string((65,32,83,84,82,73,78,71)))
fn:upper-case(fn:prefix-from-QName(xs:QName("foo:bar")))
fn:upper-case(lower-case("AbcDH"))
fn:upper-case("upper-case")
fn:upper-case(upper-case("zzzzz"))
fn:upper-case(xs:string("This is a characte"))
fn:year-from-date(fn:current-date())
fn:year-from-dateTime(fn:current-dateTime())
fn:year-from-dateTime(fn:dateTime(xs:date("1999-12-31+10:00"), xs:time("23:00:00+10:00")))
fn:year-from-dateTime(xs:dateTime("0001-05-31T23:20:00-05:00"))
fn:year-from-dateTime(xs:dateTime("-0002-06-06T00:00:00"))
fn:year-from-dateTime(xs:dateTime("1000-01-01T02:00:00Z")) div fn:year-from-dateTime(xs:dateTime("0050-01-01T10:00:00Z"))
fn:year-from-dateTime(xs:dateTime("1970-01-01T00:00:00Z"))
fn:year-from-dateTime(xs:dateTime("1970-01-01T00:00:00Z")) - fn:year-from-dateTime(xs:dateTime("1969-01-01T10:00:00Z"))
fn:year-from-dateTime(xs:dateTime("1970-01-01T00:00:00Z")) + fn:year-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:year-from-dateTime(xs:dateTime("1970-01-01T02:00:00Z")) * fn:year-from-dateTime(xs:dateTime("0002-01-01T10:00:00Z"))
-fn:year-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:year-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")) eq fn:year-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:year-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")) idiv fn:year-from-dateTime(xs:dateTime("1970-01-01T02:00:00Z"))
fn:year-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")) le fn:year-from-dateTime(xs:dateTime("1971-01-01T10:00:00Z"))
fn:year-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")) mod fn:year-from-dateTime(xs:dateTime("1970-01-01T03:00:00Z"))
fn:year-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z")) ne fn:year-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
+fn:year-from-dateTime(xs:dateTime("1971-01-01T10:00:00Z"))
fn:year-from-dateTime(xs:dateTime("1971-01-01T10:00:00Z")) ge fn:year-from-dateTime(xs:dateTime("1970-01-01T10:00:00Z"))
fn:year-from-dateTime(xs:dateTime("1996-04-07T01:40:52Z"))
fn:year-from-dateTime(xs:dateTime("-1999-05-31T00:20:00-05:00"))
fn:year-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))
fn:year-from-dateTime(xs:dateTime("1999-05-31T21:30:00-05:00"))
fn:year-from-dateTime(xs:dateTime("1999-12-31T19:20:00"))
fn:year-from-dateTime(xs:dateTime("2030-12-31T23:59:59Z"))
fn:year-from-date(xs:date("0001-05-31Z"))
fn:year-from-date(xs:date("-0002-06-01"))
+fn:year-from-date(xs:date("1970-01-01Z"))
-fn:year-from-date(xs:date("1970-01-01Z"))
fn:year-from-date(xs:date("1970-01-01Z"))
fn:year-from-date(xs:date("1970-01-01Z")) div fn:year-from-date(xs:date("1970-01-01Z"))
fn:year-from-date(xs:date("1970-01-01Z")) eq fn:year-from-date(xs:date("1970-01-01Z"))
fn:year-from-date(xs:date("1970-01-01Z")) * fn:year-from-date(xs:date("0002-01-01Z"))
fn:year-from-date(xs:date("1970-01-01Z")) + fn:year-from-date(xs:date("1970-01-01Z"))
fn:year-from-date(xs:date("1970-01-01Z")) - fn:year-from-date(xs:date("1970-01-01Z"))
fn:year-from-date(xs:date("1970-01-01Z")) ge fn:year-from-date(xs:date("1970-01-01Z"))
fn:year-from-date(xs:date("1970-01-01Z")) idiv fn:year-from-date(xs:date("1970-01-01Z"))
fn:year-from-date(xs:date("1970-01-01Z")) le fn:year-from-date(xs:date("1970-01-01Z"))
fn:year-from-date(xs:date("1970-01-01Z")) mod fn:year-from-date(xs:date("1970-01-01Z"))
fn:year-from-date(xs:date("1970-01-01Z")) ne fn:year-from-date(xs:date("1970-01-01Z"))
fn:year-from-date(xs:date("1983-11-17Z"))
fn:year-from-date(xs:date("1999-05-31"))
fn:year-from-date(xs:date("-1999-05-31Z"))
fn:year-from-date(xs:date("1999-05-31Z"))
fn:year-from-date(xs:date("1999-12-31Z")) le fn:year-from-date(xs:date("1999-12-31Z"))
fn:year-from-date(xs:date("1999-12-31Z")) lt fn:year-from-date(xs:date("1999-12-31Z"))
fn:year-from-date(xs:date("2000-01-01+05:00"))
fn:year-from-date(xs:date("2000-01-01Z"))
fn:year-from-date(xs:date("2030-12-31Z"))
fn:years-from-duration(xs:dayTimeDuration('P1D'))
fn:years-from-duration(xs:dayTimeDuration("-P2DT15H"))
fn:years-from-duration(xs:duration("P1Y2M3DT10H30M"))
fn:years-from-duration(xs:yearMonthDuration("P01Y10M"))
fn:years-from-duration(xs:yearMonthDuration("P0Y0M"))
fn:years-from-duration(xs:yearMonthDuration("P1000Y6M"))
fn:years-from-duration(xs:yearMonthDuration("P10Y10M")) mod fn:years-from-duration(xs:yearMonthDuration("P03Y10M"))
fn:years-from-duration(xs:yearMonthDuration("-P15M"))
fn:years-from-duration(xs:yearMonthDuration("P2030Y12M"))
fn:years-from-duration(xs:yearMonthDuration("P20Y10M")) div fn:years-from-duration(xs:yearMonthDuration("P05Y10M"))
fn:years-from-duration(xs:yearMonthDuration("P20Y10M")) * fn:years-from-duration(xs:yearMonthDuration("P02Y10M"))
fn:years-from-duration(xs:yearMonthDuration("P20Y10M")) ge fn:years-from-duration(xs:yearMonthDuration("P20Y10M"))
fn:years-from-duration(xs:yearMonthDuration("P20Y15M"))
fn:years-from-duration(xs:yearMonthDuration("P20Y3M")) lt fn:years-from-duration(xs:yearMonthDuration("P21Y2M"))
fn:years-from-duration(xs:yearMonthDuration("P21Y01M")) le fn:years-from-duration(xs:yearMonthDuration("P21Y15M"))
+fn:years-from-duration(xs:yearMonthDuration("P21Y10M"))
fn:years-from-duration(xs:yearMonthDuration("P21Y10M")) + fn:years-from-duration(xs:yearMonthDuration("P22Y10M"))
fn:years-from-duration(xs:yearMonthDuration("P21Y10M")) le fn:years-from-duration(xs:yearMonthDuration("P22Y10M"))
fn:years-from-duration(xs:yearMonthDuration("P22Y10M")) eq fn:years-from-duration(xs:yearMonthDuration("P22Y10M"))
fn:years-from-duration(xs:yearMonthDuration("P22Y10M")) ne fn:years-from-duration(xs:yearMonthDuration("P23Y10M"))
-fn:years-from-duration(xs:yearMonthDuration("P25Y10M"))
fn:years-from-duration(xs:yearMonthDuration("P25Y10M")) idiv fn:years-from-duration(xs:yearMonthDuration("P05Y10M"))
fn:years-from-duration(xs:yearMonthDuration("P30Y10M")) - fn:years-from-duration(xs:yearMonthDuration("P10Y10M"))
fn:zero-or-one((1,2))
fn:zero-or-one(xs:double("0"))
fn:zero-or-one(xs:double("-1.7976931348623157E308"))
fn:zero-or-one(xs:double("1.7976931348623157E308"))
fn:zero-or-one(xs:float("0"))
fn:zero-or-one(xs:float("-3.4028235E38"))
fn:zero-or-one(xs:float("3.4028235E38"))
fn:zero-or-one(xs:int("-1873914410"))
fn:zero-or-one(xs:int("2147483647"))
fn:zero-or-one(xs:int("-2147483648"))
fn:zero-or-one(xs:negativeInteger("-1"))
fn:zero-or-one(xs:nonNegativeInteger("0"))
fn:zero-or-one(xs:nonPositiveInteger("0"))
fn:zero-or-one(xs:positiveInteger("1"))
fn:zero-or-one(xs:short("32767"))
fn:zero-or-one(xs:short("-32768"))
fn:zero-or-one(xs:short("-5324"))
fn:zero-or-one(xs:unsignedLong("0"))
fn:zero-or-one(xs:unsignedShort("0"))
fn:zero-or-one(xs:unsignedShort("44633"))
fn:zero-or-one(xs:unsignedShort("65535"))
(//Folder)[1]/File[ if ( ./@name='File00000000000' ) then 2 else true() ]/FileName
fold-left((13, 14, 9, 6), (), function($a, $b){ if(empty($a)) then $b else ($a + $b) div 2 })
fold-left(1 to 13, 0, concat("(", ?, "+", ?, ")"))
fold-left(1 to 2, 1, function($a, $b){ ($a, $b) })
fold-left(1 to 5, "$zero", fn:concat("$f(", ?, ", ", ?, ")"))
fold-left(1 to 5, 0, function($a, $b) { $a + $b })
fold-left(1 to 5, 1, function($a, $b, $c){ $a + $b + $c })
fold-left(1 to 5, 1, function($a, $b as element(foo)) { $a + $b })
fold-left(1 to 5, 1, function($a as element(bar), $b) { $a + $b })
fold-left(1 to 5, [], array:append#2)
fold-left(1 to 5, "", fn:concat(?, ".", ?))
fold-left(1 to 5, "", function($a, $b) { $a + $b })
fold-left(1 to 5, (), function($a, $b) {($b, $a)})
fold-left((2,3,5,7), 1, function($a, $b) { $a * $b })
fold-left((true(), false(), false()), false(), function($a, $b) { $a and $b })
fold-left((true(), false(), false()), false(), function($a, $b) { $a or $b })
fold-right((1, 2, 2, 3, 3, 3, 4, 5, 5), (), function($a, $b){ if(exists($b[. eq $a])) then $b else ($a, $b) })
fold-right(1 to 10, (), function($a, $b){ if(empty($b)) then $a else if($a gt $b) then $b else $a })
fold-right( 1 to 10, (), function($a, $b){ if(empty($b)) then $a else if($a lt $b) then $b else $a })
fold-right((1 to 13), 0, concat("(", ?, "+", ?, ")"))
fold-right(1 to 5, "$zero", fn:concat("$f(", ?, ", ", ?, ")"))
fold-right(1 to 5, 0,function($a, $b) { $a + $b })
fold-right(1 to 5, 0, function($a, $b, $c){ $a + $b + $c })
fold-right(1 to 5, 0, function($a, $b as xs:string){ $a + $b })
fold-right(1 to 5, 0, function($a as xs:string, $b){ $a + $b })
fold-right(1 to 5, "", fn:concat(?, ".", ?))
fold-right((1 to 5), (), function($a, $b){ ($a, $a, $b) })
fold-right(1 to 5, "", function($a, $b){ $a + $b })
fold-right((1 to 5), (), function($a , $b){ ($b, $a) })
fold-right((2,3,5,7), 1,function($a, $b) { $a * $b })
fold-right(("Hello", "World"), 0, function($a, $b){ string-length($a) + $b })
fold-right((true(), false(), false()), false(),function($a, $b) { $a and $b })
fold-right((true(), false(), false()), false(),function($a, $b) { $a or $b })
"f"oo"
'f'oo'
(/)/(//)/foo
< foo/>
<foo
<foo /
<foo/ >
<foo><!
<foo><!-
<foo><!--
"foo" + 1
<foo a='1' b='2' c='3'> <bar>4</bar> <bar>5</bar> <bar>6</bar> </foo>/@a/following-sibling::node()
<foo a='1' b='2' c='3'> <bar>4</bar> <bar>5</bar> <bar>6</bar> </foo>/@c/preceding-sibling::node()
<foo> a <![CDATA[cdata section]]> in mixed content. a <!-- comment --> in mixed content. a <?processing instruction?> in mixed content. </foo>
<foo attr=
<foo attr="
<foo attr="""/>
<foo attr="{
<foo attr="{"
<foo attr="{{{"
<foo attr='''/>
<foo attr="<!-- a comment-->"/>
<foo attr="{'a string'}><<<"/>
<foo attr="<![CDATA[content]]>"/>
<foo attr="{<!-- comment -->}"/>
<foo attr(:comment:)="value" />
<foo attr=(:comment:)"value" />
<foo attr="content{1"/>
<foo attr="content<content"/>
<foo attr="content}content"/>
<foo attr="<foo/>"/>
<foo attr="{<foo attr="foo"/>}"/>
<foo > {attribute name {"content"}} <doo/> </foo>
<foo attr="<?target content?>"/>
<foo attr="{<?target dat a ?>}"/>
<foo attr="value" (:comment:) attr2="value" />
"  foobar  " castable as xs:NMTOKEN
<foo (:comment :)/>
<foo > <doo/> {attribute name {"content"}} </foo>
<foo > <doo/> </foo>
<foo><doo/> </foo>
<foo><doo/></foo>
<foo:elem/>
<foo:elem xmlns:foo="http://www.example.com/parent"><child xmlns:foo=""/></foo:elem>
(<foo:elem xmlns:foo="http://www.example.com/parent"><child xmlns:foo=""><grand-child/></child></foo:elem>)//grand-child
<foo:elem xmlns:foo="http://www.w3.org/XQueryTest/Construct" xmlns:bar="http://www.w3.org/XQueryTest/Construct"></bar:elem>
"fo""o" eq concat("fo", """", "o")
"f oo eq "f oo"
"f oo" eq "f oo
"f oo" eq f oo"
'fo''o' eq 'fo''o'
'foo' eq "foo"
f oo" eq "f oo"
< foo></foo>
<foo></foo>
<foo>< /foo>
foo- foo
for $AaBbCc.-_Dd in /MyComputer/Drive1/Folder return $AaBbCc.-_Dd/FolderName
for $AaBbCc.-_Dd in /MyComputer/Drive1/Folder where $AaBbCc.-_Dd/@creator = "Mani" return $AaBbCc.-_Dd/FolderName
for $a at $p1 in (1, 2), $b at $p2 in (1, 2), $c at $p3 in (1, 2) return 1, $p1
for $a at $p1 in (1, 2), $b at $p2 in (1, 2), $c at $p3 in (1, 2) return 1, $p2
for $a at $p1 in (1, 2), $b at $p2 in (1, 2), $c at $p3 in (1, 2) return 1, $p3
for $a at $p in (1, 2) return 1, $p
for $a at $pos1 in (1, 2, 3) return for $b at $pos2 in (4, 5, 6) return for $c at $pos3 in (7, 8, 9) return ($a, $pos1, $b, $pos2, $c, $pos2)
for $a at p1 in 1 return 1
for $a in $a/* return $a
for $a in (1, 2), $b in (1, 2), $c in (1, 2) return 1, $a
for $a in (1, 2), $b in (1, 2), $c in (1, 2) return 1, $b
for $a in (1, 2), $b in (1, 2), $c in (1, 2) return 1, $c
for $a in (1, 2, 3), $b in (1, 2, 3, $b) return $a, $b
for $a in (1, 2) return 1, $a
for $a in (1, 4, 2) let $i := (1, $a, 2) order by $i return $i
for $a in (1, 4, 2) let $i := (1, 3, 2) order by $a return $i
for $a in (1, 4, 2) let $i := (1, 3, 2) order by $i return 1
for $a in 1 satisfies 4
for $a in 1 where true(), true() return $a
for $a in 1 where true() where true() return $a
for $a in (2, 1) let $b := 1 where true() order by $a return $a
for $a in (3, 2, 1), $b in (6, 5, 4) order by $a return $a
for $a in (3, 2, 1), $b in (6, 5, 4) stable order by $b return $a
for $a in (3, 2, 1), $b in (6) stable order by $b return $a
for $a in (3, 2, 1, 1) stable order by $a return 5
for $a in (3, 2, 1, 1) stable order by 1 return $a
for $a in (3, 2, 1) let $a := ($a, 1), $b := (2, 1), $c := (2, 1), $d:= (2, 1) order by $a return $a
for $a in (3, 2, 1) let $b := (2, 1), $c := (2, 1), $d := (2, 1), $e := (2, 1) order by $a return $a
for $a in attribute { fn:QName("http://www.example.com/", "xml:foo") } { "bar" }         return name($a)
for $a in attribute { fn:QName("http://www.example.com/", "xmlns:foo") } { "bar" } return name($a)
for $a in attribute { fn:QName("http://www.w3.org/2000/xmlns/", "namespace:foo") } { "bar" } return name($a)
for $a in attribute { fn:QName("http://www.w3.org/XML/1998/namespace", "sgml:foo") } { "bar" }         return name($a)
for $a in attribute { "xmlns" } { "bar" } return name($a)
for $a in (/) return          for $b in $a/child::site return          for $c in $b/child::people return          for $d in $c/child::person return              if ((some $id in $d/attribute::id satisfies                      typeswitch ($id)                      case $n as node() return $id = "person0"                      default $d return ()))              then $d/child::name              else (),          for $b in /site/people/person where $b/@id="person0" return $b/name,          /site/people/person[@id eq "person0"]/name
for $a in ("test", "test1", "test2") return $a
for $b in //book         let $e := $b/*[contains(string(.), "Suciu") and ends-with(local-name(.), "or")]         where exists($e)         return <book> { $b/title } { $e } </book>
for $comment as comment() in //comment() return $comment
for $d in /MyComputer/Drive4 where $d/Folder[@id="128"] return <FolderName>{$d/Folder/@name}</FolderName>
(for $d in <people> <person id="person0"> <name>First</name> </person> <person> <name>Second</name> </person> </people>/person return if (some $id in 1 satisfies typeswitch ($d/@id) case $n as node() return $d/@id = "person0" default $d return ()) then $d/name else ())
for $d in person return $d
for $doc as document-node() in (/) return count( $doc )
for $file as element(File,xs:untyped) in (//Folder)[1]/File return $file/FileName
for $file as in (//Folder)[1]/File return $file
for $file as node() in (//Folder)[1]/File return $file/FileName
for $file at $offset in (//Folder)[1]/File return <File>{ $file/@name }{ attribute offset{ $offset }}</File>
for $file at $offset in (//Folder)[1]/File where $offset mod 2 = 1 return $file/FileName
for $file at $pos as element(Folder,xs:untyped) in (//Folder)[1]/File return (string($file/FileName[1]), $pos)
for $file at $pos in (//Folder)[1]/File, $pos2 in $pos+1 return (string($file/FileName[1]), $pos, $pos2)
for $file at $pos in (//Folder)[1]/File return (string($file/FileName[1]), $pos)
for $file (//Folder)[1]/File return $file/FileName
for $file in //File           let $namelen := string-length($file/FileName)          where ($namelen = 15 and $file//Allow/user = 'system\Hyungjeong')           return $file/FileName
for $file in //File           let $prefix := substring($file/FileName, 1, 4)          where ($prefix = 'File')          where ($file//Allow/user = 'system\Hyungjeong')          return $file/FileName
for $file in //File           where current-date() gt xs:date('1900-01-01')          let $prefix := substring($file/FileName, 1, 4)          where ($prefix = 'File')          where ($file//Allow/user = 'system\Hyungjeong')          return $file/FileName
for $file in (//Folder)[1]/File
for $file in (//Folder)[1]/File, $file in (//Folder)[2]/File return $file/FileName
for $file in (//Folder)[1]/File as element(Folder,xs:untypedAny) return $file/FileName
for $file in (//Folder)[1]/File at $pos return (string($file/FileName[1]), $pos)
for $file in (//Folder)[1]/File return $file/FileName
for $file in (//Folder)[1]/File return $file/parent::Folder/FolderName
for $file in (//Folder)[1]/File return $file return $file
for $file in (//Folder)[1]/File return ($file/Stream/StreamSize)[1] + 1
for $file in (//Folder)[1]/File return ($file/Stream/StreamSize)[1] > 1004
for $file in (//Folder)[1]/File return $undefined
for $file in (//Folder)[1]/File return 1
for $file in (//Folder)[1]/File return data( $file/FileName )
for $file in (//Folder)[1]/File return (//FileName)[1]
for $file in (//Folder)[1]/File return if( $file/FileName='File00000000000' ) then $file/FileName else data( $file/FileName )
for $file in (//Folder)[1]/File return if( $file/FileName='File00000000004' ) then 1 else data( $file/FileName )
for $file in (//Folder)[1]/File return return $file/FileName
for $file in (//Folder)[1]/File return xs:string( data( $file/FileName[1] ))
for $file in (//Folder)[1]/File where $file/SecurityObject/Denies/Deny/security/right="Change" return $file/FileName
for $file in (//Folder)[1]/File where $file/SecurityObject/Denies/Deny/security/right return $file/FileName
for $file in (//Folder)[1]/File where $undefined return $file/FileName
for $file in (//Folder)[1]/File where data( $file/SecurityObject//right ) return $file/FileName
for $file in (//Folder)[1]/File where true() return $file/FileName
for $file in (//Folder)[1]/File where_ true() return $file/FileName
for $file in (//Folder)[1]/File where true(), true() return $file/FileName
for $file in (//Folder)[1]/File where true() where false() return $file/FileName
for $file in for $folder in (//Folder)[1] return $folder/File return $file/FileName
for $fileName as attribute(name,xs:untypedAtomic) in (//Folder)[1]/File/@name return data($fileName)
for $fileName as item() in data( (//Folder)[1]/File/FileName ) return $fileName
for $fileName as text() in (//Folder)[1]/File/FileName/text() return string( $fileName )
for $fileName in //File/FileName,              $folderName in //Folder[contains(description, 'fren')]/FolderName          return ($folderName, $fileName)
for $fileName in //File/FileName for $folderName in //Folder/FolderName return $folderName return $fileName
for $fileName in for $file in //Folder/File return $file/FileName return string( $fileName )
for $f in (concat("one ", ?, " three"), substring-before("one two three", ?), matches(?, "t.*o"), xs:NCName(?))          return $f("two")
for $f in /MyComputer/Drive1/Folder[@creator="Mani"]/File[@creation_date="08/06/00"] return <file>{$f/../@creator}{$f/@creation_date}</file>
for $f in /MyComputer/Drive1/Folder[@creator="Mani"]/File where $f/@creation_date="08/06/00" return $f
for $f in /MyComputer/Drive4/Folder[@id="128"] return <FolderName>{$f/@name}</FolderName>
for $f in /MyComputer//File[@creation_date="08/06/00"]/SecurityObject/Denies/Deny[security/right] return $f/../../@name/string()
for $f in /MyComputer//File where $f/@creation_date="08/06/00" return $f/SecurityObject/Denies/Deny[security/right]/user/string()
(for $fn:name in (1, 1) return $fn:name) instance of xs:integer+
(for $fo in (1, 2, 3) where $fo eq 3 return $fo)
for $folder in $folder/File return <file name="{$folder/File/FileName}"/>
for $folder in //Folder, $file in $folder/File, return $file/FileName
for $folder in //Folder, $file in $folder/File return ( $folder/FolderName, $file/FileName )
for $folder in //Folder, $file in $folder//File return <File folder="{$folder/FolderName}">{string($file/FileName[1])}</File>
for $folder in //Folder, $index in (1, 2, 3) return $folder/File[$index]/FileName
for $folder in //Folder for $file in $folder//File return <File folder="{$folder/FolderName}">{string($file/FileName[1])}</File>
for $folder in //Folder return $folder return $folder
for $folder in //Folder return for $file in $folder/File return string( $file/FileName[1] )
for $folder in //Folder where $folde/@name = "ABC" return <folder/>
for $folder in in .//Folder return $folder
for $folder in /MyComputer/Drive1/Folder[1]          return <folder1> {$folder/FolderName} <files> {                      for $file in ($folder/File)[position() < 6]                      return <f>{$file/FileName/substring(.,13)}</f> } </files>                 </folder1>
for $folder in /MyComputer/Drive2//Folder return <newFolder>{ $folder/FolderName/text() }</newFolder>
for $folder in /MyComputer/Drive2//Folder return <newFolder>{ $folder/@name, $folder/FolderName/text() }</newFolder>
for $folder in /MyComputer/Drive4//Folder return <Folder>{ $folder/@name }{ for $file in /MyComputer/Drive4//File where $file/@idref = $folder/@id return <File>{ $file/@name }</File> }</Folder>
for $foo in ($foo, 2, 3) return 1
for $foo in $foo return 1
for $foo in 1, $bar in 2, $moo in 3, return 4
for $foo in (1, $foo, 3) return 1
for $foo in (1, 2, $foo) return 1
for $foo in 1 return $bar + (for $bar in 2 return $bar)
for $foo in 1 return $NOTEXIST
for $foo in ("a string", "another one") return 1 + subsequence($foo, 1, 1)
for $foo in "foo" return 1 + $foo
for $h in ( ($works//hours) | ($staff//grade[xs:integer(.) gt 12])) order by number($h) return $h
for $h in ( ($works//hours) except ($staff//grade)) order by number($h) return $h
for $h in ( ($works//hours) intersect ($works//hours, $staff//grade)) order by number($h) return $h
for $h in ( ($works//hours) union ($staff//grade[xs:integer(.) gt 12])) order by number($h) return $h
for $h in ( count(($works//hours) except ($staff//grade,$works//hours))) order by number($h) return $h
for $h in ( count((//hours) except (//hours))) order by number($h) return $h
for $h in ( (<hours>0</hours>,<hours>1</hours>) | //hours) order by number($h) return $h
for $h in ( (<hours>0</hours>,<hours>1</hours>) union (//hours)) order by number($h) return $h
for $h in ( (<hours>0</hours>,<hours>40</hours>) | (//hours)) order by number($h) return $h
for $h in ( (<hours>0</hours>,<hours>40</hours>) union (//hours)) order by number($h) return $h
for $h in ( (//hours) intersect (//hours[xs:integer(.) gt 12])) order by number($h) return $h
for $h in ( () | (//hours)) order by number($h) return $h
for $h in ( (//hours[xs:integer(.) le 20]) | (//hours[xs:integer(.) gt 20])) order by number($h) return $h
for $h in ( (//hours[xs:integer(.) le 20]) union (//hours[xs:integer(.) gt 20])) order by number($h) return $h
for $h in ( () union (//hours)) order by number($h) return $h
for $h in (/works[1]/employee[1]) return fn:count(($h/self::employee[1000]))
for $h in ./works[1]/employee[2] return          fn:string-length(fn:name($h/child::text()[last()]))
for $h in (/works/employee[10]) return $h/@name
for $h in (/works/employee[12]/overtime) return $h/day[not(position() = 1)]
for $h in (/works/employee[12]/overtime) return $h/day[not(position() = 1)]/string()
for $h in (/works/employee[12]/overtime) return $h/../@name
for $h in (/works/employee[12]/overtime) return $h/*[position() = position()]/string()
for $h in (/works/employee[12]) return $h/overtime[last() = 1]/*/string()
for $h in (/works/employee[12]) return $h/overtime[last() = last()]/*/string()
for $h in (/works/employee[12]) return ($h/overtime[position() and fn:false()])
for $h in (/works/employee[12]) return $h/overtime[position() and fn:false()]
for $h in (/works/employee[12]) return ($h/overtime[position() and fn:true()]/*/string())
for $h in (/works/employee[12]) return $h/overtime[position() or fn:false()]/*/string()
for $h in (/works/employee[12]) return $h/overtime[position() or fn:true()]/*/string()
for $h in (/works/employee[12]) return $h/overtime[position() = position()]/day/string()
for $h in (/works/employee[1]/hours) return $h/ancestor::employee
(for $h in (/works/employee[1]/hours) return $h/ancestor-or-self::employee)/@name
for $h in (/works/employee[1]/hours) return $h/parent::node()
for $h in (/works/employee[1]) return $h/child::*
for $h in (/works/employee[1]) return $h/child::node()
for $h in (/works/employee[1]) return $h/descendant-or-self::employee
for $h in (/works/employee[1]) return $h/self::employee
for $h in (/works/employee[2]/@name) return fn:name($h/parent::node())
for $h in (/works/employee[2]) return $h/child::node()
for $h in (/works/employee[2]) return $h/following-sibling::employee[fn:position() = 1]
for $h in (/works/employee[2]) return $h/preceding-sibling::employee[fn:position() = 1]
for $h in (/works/employee[2]) return fn:concat(fn:name($h),"A String")
for $h in (./works/employee[2]) return fn:lower-case(fn:name($h))
for $h in (./works/employee[2]) return fn:name($h/descendant::empnum[position() =          1])
for $h in (./works/employee[2]) return fn:name($h/descendant-or-self::empnum[position()          = 1])
for $h in (./works/employee[2]) return fn:name($h/parent::node())
for $h in (./works/employee[2]) return fn:name($h/self::employee)
for $h in (./works/employee[2]) return fn:substring(fn:name($h),2)
for $h in (./works/employee[2]) return fn:upper-case(fn:name($h))
for $h in (/works/employee[4]) return $h/hours/string()
for $h in (/works/employee[6]) return $h/child::*[self::empnum or self::pnum][fn:position() = fn:last()]
for $h in (/works/employee[7]) return $h/child::*[self::pnum or self::empnum]
for $h in (/works/employee) return $h/child::empnum
for $h in (/works/employee) return $h/child::hours[fn:position() > 1]
for $h in (/works/employee) return $h/descendant::empnum
for $h in (/works) return $h/child::*/child::pnum
for $h in (/works) return $h/child::employee[attribute::gender eq 'female'][fn:position() = 5]
for $h in (/works) return $h/child::employee[attribute::name eq "Jane Doe 11"]
for $h in (/works) return $h/child::employee[child::empnum = 'E3']
for $h in (/works) return $h/child::employee[child::status]
for $h in (/works) return $h/child::employee/descendant::empnum
for $h in (/works) return $h/child::employee[fn:position() = 1]
for $h in (/works) return $h/child::employee[fn:position() = fn:last()]
for $h in (/works) return $h/child::employee[fn:position() = fn:last()-1]
for $h in (/works) return $h/.//day/string()
for $h in (/works) return $h/descendant::employee/child::pnum
for $h in (/works) return $h/descendant::employee[fn:position() = 12]
for $h in (/works) return $h/descendant::pnum
for $h in (/works) return $h/employee[1]/@name
for $h in (/works) return $h/employee[5][@gender="female"]/@name
for $h in (/works) return $h/employee[fn:last()]/@name
for $h in (/works) return $h/employee[@gender="female"][5]/@name
for $h in (/works) return $h/employee//hours/string()
for $h in (/works) return $h/employee[last()] << $h/employee[last()]
for $h in (/works) return $h//employee[last() = 13][@name = "Jane Doe 13"]/string(@name)
for $h in (/works) return $h/employee[last()] is $h/employee[last()]
for $h in (/works) return $h/employee[last() = position()]/string(@name)
for $h in (/works) return $h//employee[last()]/string(@name)
for $h in (/works) return $h/employee[@name and @type]/@name
for $h in (/works) return $h/employee[@name="Jane Doe 11"]/@name
for $h in (/works) return $h//employee[@name="Jane Doe 13"][last() = 1]/string(@name)
for $h in (/works) return $h/employee[@name = "Jane Doe 13" or @type="FT"]/@name
for $h in (/works) return $h/employee[@name][position() = 1]/string(@name)
for $h in (/works) return $h/employee[overtime]/@name
for $h in (/works) return $h/employee[position() = 12]/overtime/*/string()
for $h in (/works) return $h/employee[position() = 13]/string(@name)
for $h in (/works) return $h/employee[position() = 1][@name]/string(@name)
for $h in (/works) return $h/employee[position() = 1]/string(@name)
for $h in (/works) return $h/employee[position() = (2 + 2)]/string(@name)
for $h in (/works) return $h/employee[position() = (3 * 2)]/string(@name)
for $h in (/works) return $h/employee[position() = (5 - 2)]/string(@name)
for $h in (/works) return $h/employee[position() = 5 to last()]/@name/string()
for $h in (/works) return $h/employee[position() = (6 div 2)]/string(@name)
for $h in (/works) return $h/employee[position() = (6 idiv 2)]/string(@name)
for $h in (/works) return $h/employee[position() = last()]/string(@name)
for $h in (/works) return $h/employee[status="active"]/@name
for $h in (/works) return $h/employee/(status|overtime)/day/string()
for $h in (/works) return $h/employee/(status union overtime)/day/string()
for $h in (/works) return $h/*/hours/string()
for $h in (/works) return $h//hours/string()
for $h in (/works) return $h//overtime/day/string()
for $i at $p in (1, 2, 3) return $p + "1"
for $i at $p in remove((1, 2, 3), 10) return $p
for $i at $pos in (3 to 6) let $let := $pos + 1 return ($let, $let - 1)
for $i in (1, 2), $j in (3, 4) return ($i, $j)
FOR $i IN (1, 2, 3)
for $i in (1, 2, 3) stable order by 1 return reverse(($i, "FO"))
for $i in (1, 2, current-time())[1] where xs:anyURI("example.com/") return true()
for $i in (1, 3, 2) let $c := 3 stable order by () return $i
for $i in (1, 3, 2) order by $i empty INVALID return ($i, 2)
for $i in (1, 3, 2) order by $i return $i
for $i in (1, 3, 2) order by $i return ($i, 2)
for $i in (1, 3, 2) stable order by () return $i
for $i in 1 to 3 return $i
for $i in 1 where count(($i, 2, timezone-from-time(current-time()))) return true()
(for $i in 1 where true() return $i) eq 1
for $i in (-2, -4, -10, -50, +50, +10, +4, +2) return (xs:yearMonthDuration("P5M") div $i)
for $i in (-3.9, -3.5, -3.1, -0.9, -0.5, -0.1, +0.1, +0.5, +0.9, +3.1, +3.5, +3.9) return xs:yearMonthDuration("P1M") * $i
(for $i in current-time() order by $i return $i) eq current-time()
for $i in <e/>/(., 4, 5, <e/>/((<e/>, 2))) return ($i, $i)
for $i in (false(), true(), true(), false(), true(), false()) order by $i return $i
for $int as xs:int in (xs:int(1), xs:int(2)) return $int
for $item in //news_item          where contains(string(exactly-one($item/content)), "Gorilla Corporation")          return <item_summary> { concat($item/title,". ") }                                { concat($item/date,". ") }                                { string(($item//par)[1]) }                 </item_summary>
for $j in (text{'Az'}, text{'Bx'}, text{'Cy'})           order by $j/substring(., $j/string-length(.))           return $j/string()
for $n in attribute return 1
for $n in attribute return {()} return 1
for $n in document return 1
for $n in element return {()} return 1
for $n in node return 1
for $n in processing-instruction return {()} return 1
for $node in ((//price/text()) , (//price/text())) intersect ((//price/text()) , (//price/text())) return <a> {$node} </a>
for $num as xs:decimal in (xs:integer(1), xs:decimal(2), xs:integer(3)) return $num
for $num as xs:decimal in (xs:integer(1), xs:integer(2), xs:integer(3)) return $num
for $num in ( <one/>, <two/>, <three/> ) return $num
for $PI as processing-instruction() in //processing-instruction() return $PI
for $p in //section[section.title = "Procedure"] where not(some $a in $p//anesthesia satisfies $a << ($p//incision)[1] ) return $p
for $Q{http://example.com/ns}x in 1 to 10 return $Q{http://example.com/ns}x + 1
for $Q{}T in 1 to 5 return $Q{  }T + $T
for $Q{ urn:foo bar }x in 1 to 5 return $Q{urn:foo   bar}x + $Q{urn:foo bar}x
(for $range in             tokenize('65-90;97-122;192-214;216-246;248-305;308-318;321-328;330-382;384-451;461-496;500-501;506-535;592-680;699-705;902-902;904-906;908-908;910-929;931-974;976-982;986-986;988-988;990-990;992-992;994-1011;1025-1036;1038-1103;1105-1116;1118-1153;1168-1220;1223-1224;1227-1228;1232-1259;1262-1269;1272-1273;1329-1366;1369-1369;1377-1414;1488-1514;1520-1522;1569-1594;1601-1610;1649-1719;1722-1726;1728-1742;1744-1747;1749-1749;1765-1766;2309-2361;2365-2365;2392-2401;2437-2444;2447-2448;2451-2472;2474-2480;2482-2482;2486-2489;2524-2525;2527-2529;2544-2545;2565-2570;'||             '2575-2576;2579-2600;2602-2608;2610-2611;2613-2614;2616-2617;2649-2652;2654-2654;2674-2676;2693-2699;2701-2701;2703-2705;2707-2728;2730-2736;2738-2739;2741-2745;2749-2749;2784-2784;2821-2828;2831-2832;2835-2856;2858-2864;2866-2867;2870-2873;2877-2877;2908-2909;2911-2913;2949-2954;2958-2960;2962-2965;2969-2970;2972-2972;2974-2975;2979-2980;2984-2986;2990-2997;2999-3001;3077-3084;3086-3088;3090-3112;3114-3123;3125-3129;3168-3169;3205-3212;3214-3216;3218-3240;3242-3251;3253-3257;3294-3294;3296-3297;3333-3340;3342-3344;3346-3368;3370-3385;3424-3425;3585-3630;3632-3632;'||             '3634-3635;3648-3653;3713-3714;3716-3716;3719-3720;3722-3722;3725-3725;3732-3735;3737-3743;3745-3747;3749-3749;3751-3751;3754-3755;3757-3758;3760-3760;3762-3763;3773-3773;3776-3780;3904-3911;3913-3945;4256-4293;4304-4342;4352-4352;4354-4355;4357-4359;4361-4361;4363-4364;4366-4370;4412-4412;4414-4414;4416-4416;4428-4428;4430-4430;4432-4432;4436-4437;4441-4441;4447-4449;4451-4451;4453-4453;4455-4455;4457-4457;4461-4462;4466-4467;4469-4469;4510-4510;4520-4520;4523-4523;4526-4527;4535-4536;4538-4538;4540-4546;4587-4587;4592-4592;4601-4601;7680-7835;7840-7929;7936-7957;'||             '7960-7965;7968-8005;8008-8013;8016-8023;8025-8025;8027-8027;8029-8029;8031-8061;8064-8116;8118-8124;8126-8126;8130-8132;8134-8140;8144-8147;8150-8155;8160-8172;8178-8180;8182-8188;8486-8486;8490-8491;8494-8494;8576-8578;12353-12436;12449-12538;12549-12588;44032-55203;19968-40869;12295-12295;12321-12329;48-57;1632-1641;1776-1785;2406-2415;2534-2543;2662-2671;2790-2799;2918-2927;3047-3055;3174-3183;3302-3311;3430-3439;3664-3673;3792-3801;3872-3881;768-837;864-865;1155-1158;1425-1441;1443-1465;1467-1469;1471-1471;1473-1474;1476-1476;1611-1618;1648-1648;1750-1764;1767-1768;'||             '1770-1773;2305-2307;2364-2364;2366-2381;2385-2388;2402-2403;2433-2435;2492-2492;2494-2500;2503-2504;2507-2509;2519-2519;2530-2531;2562-2562;2620-2620;2622-2626;2631-2632;2635-2637;2672-2673;2689-2691;2748-2748;2750-2757;2759-2761;2763-2765;2817-2819;2876-2876;2878-2883;2887-2888;2891-2893;2902-2903;2946-2947;3006-3010;3014-3016;3018-3021;3031-3031;3073-3075;3134-3140;3142-3144;3146-3149;3157-3158;3202-3203;3262-3268;3270-3272;3274-3277;3285-3286;3330-3331;3390-3395;3398-3400;3402-3405;3415-3415;3633-3633;3636-3642;3655-3662;3761-3761;3764-3769;3771-3772;3784-3789;3864-3865;'||             '3893-3893;3895-3895;3897-3897;3902-3903;3953-3972;3974-3979;3984-3989;3991-3991;3993-4013;4017-4023;4025-4025;8400-8412;8417-8417;12330-12335;12441-12442;183-183;720-721;903-903;1600-1600;3654-3654;3782-3782;12293-12293;12337-12341;12445-12446;12540-12542;58-58;95-95;45-46;65-90;97-122;192-214;216-246;248-305;308-318;321-328;330-382;384-451;461-496;500-501;506-535;592-680;699-705;902-902;904-906;908-908;910-929;931-974;976-982;986-986;988-988;990-990;992-992;994-1011;1025-1036;1038-1103;1105-1116;1118-1153;1168-1220;1223-1224;1227-1228;1232-1259;1262-1269;1272-1273;1329-1366;'||             '1369-1369;1377-1414;1488-1514;1520-1522;1569-1594;1601-1610;1649-1719;1722-1726;1728-1742;1744-1747;1749-1749;1765-1766;2309-2361;2365-2365;2392-2401;2437-2444;2447-2448;2451-2472;2474-2480;2482-2482;2486-2489;2524-2525;2527-2529;2544-2545;2565-2570;2575-2576;2579-2600;2602-2608;2610-2611;2613-2614;2616-2617;2649-2652;2654-2654;2674-2676;2693-2699;2701-2701;2703-2705;2707-2728;2730-2736;2738-2739;2741-2745;2749-2749;2784-2784;2821-2828;2831-2832;2835-2856;2858-2864;2866-2867;2870-2873;2877-2877;2908-2909;2911-2913;2949-2954;2958-2960;2962-2965;2969-2970;2972-2972;2974-2975;'||             '2979-2980;2984-2986;2990-2997;2999-3001;3077-3084;3086-3088;3090-3112;3114-3123;3125-3129;3168-3169;3205-3212;3214-3216;3218-3240;3242-3251;3253-3257;3294-3294;3296-3297;3333-3340;3342-3344;3346-3368;3370-3385;3424-3425;3585-3630;3632-3632;3634-3635;3648-3653;3713-3714;3716-3716;3719-3720;3722-3722;3725-3725;3732-3735;3737-3743;3745-3747;3749-3749;3751-3751;3754-3755;3757-3758;3760-3760;3762-3763;3773-3773;3776-3780;3904-3911;3913-3945;4256-4293;4304-4342;4352-4352;4354-4355;4357-4359;4361-4361;4363-4364;4366-4370;4412-4412;4414-4414;4416-4416;4428-4428;4430-4430;4432-4432;'||             '4436-4437;4441-4441;4447-4449;4451-4451;4453-4453;4455-4455;4457-4457;4461-4462;4466-4467;4469-4469;4510-4510;4520-4520;4523-4523;4526-4527;4535-4536;4538-4538;4540-4546;4587-4587;4592-4592;4601-4601;7680-7835;7840-7929;7936-7957;7960-7965;7968-8005;8008-8013;8016-8023;8025-8025;8027-8027;8029-8029;8031-8061;8064-8116;8118-8124;8126-8126;8130-8132;8134-8140;8144-8147;8150-8155;8160-8172;8178-8180;8182-8188;8486-8486;8490-8491;8494-8494;8576-8578;12353-12436;12449-12538;12549-12588;44032-55203;19968-40869;12295-12295;12321-12329;48-57;1632-1641;1776-1785;2406-2415;2534-2543;'||             '2662-2671;2790-2799;2918-2927;3047-3055;3174-3183;3302-3311;3430-3439;3664-3673;3792-3801;3872-3881;768-836;864-865;1155-1158;1425-1441;1443-1465;1467-1469;1471-1471;1473-1474;1476-1476;1611-1618;1648-1648;1750-1764;1767-1768;1770-1773;2305-2307;2364-2364;2366-2381;2385-2388;2402-2403;2433-2435;2492-2492;2494-2500;2503-2504;2507-2509;2519-2519;2530-2531;2562-2562;2620-2620;2622-2626;2631-2632;2635-2637;2672-2673;2689-2691;2748-2748;2750-2757;2759-2761;2763-2765;2817-2819;2876-2876;2878-2883;2887-2888;2891-2893;'||             '2902-2903;2946-2947;3006-3010;3014-3016;3018-3021;3031-3031;3073-3075;3134-3140;3142-3144;3146-3149;3157-3158;3202-3203;3262-3268;3270-3272;3274-3277;3285-3286;3330-3331;3390-3395;3398-3400;3402-3405;3415-3415;3633-3633;3636-3642;3655-3662;3761-3761;3764-3769;3771-3772;3784-3789;3864-3865;3893-3893;3895-3895;3897-3897;3902-3903;3953-3972;3974-3979;3984-3989;3991-3991;3993-4013;4017-4023;4025-4025;8400-8412;8417-8417;12330-12335;12441-12442;183-183;720-721;903-903;1600-1600;3654-3654;3782-3782;12293-12293;12337-12341;12445-12446;12540-12542;58-58;95-95;45-46', ';')             let $s := xs:integer(substring-before($range, '-'))              let $e := xs:integer(substring-after($range, '-'))              for $c in ($s to $e)!codepoints-to-string(.)             where not(matches($c, '^([\c])$'))              return string-to-codepoints($c)),                           (for $range in tokenize('161-161', ';')              let $s := xs:integer(substring-before($range, '-'))              let $e := xs:integer(substring-after($range, '-'))              for $c in ($s to $e)!codepoints-to-string(.)             where (matches($c, '^([\c])$'))              return string-to-codepoints($c))
for $s in //section[section.title = "Procedure"] return ($s//incision)[2]/instrument
for $s in //section[section.title = "Procedure"] return ($s//instrument)[position()<=2]
for $s in "var:QName" return QName($s)
for $string in ("  foobar  " cast as xs:NMTOKEN) return not(contains($string, ' ') or contains($string, ' ') or contains($string, ' ') or string-length($string) ne 6)
for $string in ("  foo   bar  " cast as xs:normalizedString)         return not(contains($string, ' ') or                     contains($string, ' ') or                     contains($string, ' ') or                     string-length($string) ne 13)
for $string in ("  foo   bar  " cast as xs:token)          return not(contains($string, ' ') or                     contains($string, ' ') or                     contains($string, ' ') or                     string-length($string) ne 7)
for $string in ("&#xD; foo &#x9; bar &#xA;" cast as xs:normalizedString)         return not(contains($string, '&#x9;') or                     contains($string, '&#xA;') or                     contains($string, '&#xD;') or                     string-length($string) ne 13)
for $string in ("&#xD; foo &#x9; bar &#xA;" cast as xs:token)          return not(contains($string, '&#x9;') or                     contains($string, '&#xA;') or                     contains($string, '&#xD;') or                     string-length($string) ne 7)
for $test as xs:anyAtomicType in ( 1, "string", 1e2, 0.3 ) return $test
for $test as xs:anyAtomicType in ( xs:boolean("true"), xs:base64Binary("abcd"), xs:hexBinary("1234"),                      xs:float("5.7"), xs:double("7.5"), xs:anyURI("http://foo") )          return $test
for $test as xs:anyAtomicType in ( xs:duration("P0Y1347M0D"), xs:dateTime("1999-05-31T13:20:00-05:00"),                      xs:time("13:00:00-05:00"), xs:date("1999-05-10Z"), xs:gYearMonth("2002-03"), xs:gYear("1999"),                      xs:gMonthDay("--05-10"), xs:gDay("---10"), xs:gMonth("--05") )          return $test
for $test as xs:anyAtomicType in ( xs:unsignedByte("10"), xs:short("20"), xs:positiveInteger("30"),                  xs:nonPositiveInteger("-40"), xs:decimal("5.5"), xs:ENTITY("entity1"), xs:NCName("foobar"),                  xs:language("en-US"), xs:string("foobar"), xs:hexBinary("ffff"), xs:gYear("1999") )          return $test
for $test as xs:decimal in ( 1, 0.3 ) return $test
for $test as xs:decimal in ( xs:integer("100"), xs:short("1"), xs:int("10000"),                  xs:nonPositiveInteger("-10"), xs:unsignedShort("100"), xs:positiveInteger("100"), xs:nonNegativeInteger("100") )          return $test
for $test as xs:integer in ( xs:byte("1"), xs:long("10000"), xs:negativeInteger("-10"),                          xs:short("100"), xs:positiveInteger("100"), xs:nonNegativeInteger("100") )          return $test
for $test as xs:normalizedString in ( xs:language("en-US"), xs:NCName("foobar"),              xs:NMTOKEN("token1"), xs:ENTITY("entity1") )          return $test
for $ti in <ti><rangeDate><initDate>17880505</initDate><terminatingDate>19550505</terminatingDate></rangeDate></ti> return <result> { fn:min(if ($ti/singleDate) then let $tmp:=$ti/singleDate/compute return xs:date(fn:concat(fn:substring($tmp, 1, 4), "-", fn:substring($tmp, 5, 2), "-", fn:substring($tmp, 7, 2))) else let $tmp:=$ti/rangeDate/initDate return xs:date(fn:concat(fn:substring($tmp, 1, 4), "-", fn:substring($tmp, 5, 2), "-", fn:substring($tmp, 7, 2)))) } </result>
for $var in (1,2), $var in (2,2) return $var * $var
for $var in (1,2) for $var in (2,2) return $var * $var
for $var in 1 return for $h in (/works) return $h/employee[position() = $var]/string(@name)
for $var in "1" return for $h in (/works) return $h/employee[position() = xs:integer($var)]/string(@name)
for $var in (/works/employee[1]) return $var/(exactly-one(hours) div exactly-one(hours))
for $var in (/works/employee[1]) return $var/(exactly-one(hours) * exactly-one(hours))
for $var in (/works/employee[1]) return $var/(exactly-one(hours) + exactly-one(hours))
for $var in (/works/employee[1]) return $var/(exactly-one(hours) - exactly-one(hours))
for $var in (/works/employee[1]) return $var/(exactly-one(hours) idiv exactly-one(hours))
for $var in (/works/employee[1]) return $var/(exactly-one(hours) mod exactly-one(hours))
for $var in (/works/employee[1]) return $var/fn:avg((hours,hours,hours))
for $var in (/works/employee[1]) return $var/fn:max((hours,exactly-one(hours) + 1,22))
for $var in (/works/employee[1]) return $var/fn:min((hours,hours,22))
for $var in (/works/employee[1]) return $var/fn:not(xs:boolean(exactly-one(hours) - 39))
for $var in (/works/employee[1]) return $var/fn:string-length(exactly-one(hours))
for $var in (/works/employee[1]) return $var/fn:sum((hours,hours))
for $var in (/works/employee[1]) return $var/xs:boolean(exactly-one(hours) - 39)
for $var in (/works/employee[1]) return $var/(xs:boolean(exactly-one(hours) - 39) and xs:boolean(exactly-one(hours) - 39))
for $var in (/works/employee[1]) return $var/(xs:boolean(exactly-one(hours) - 39) or xs:boolean(exactly-one(hours) - 39))
for $var in (/works/employee[1]) return $var/xs:decimal(exactly-one(hours))
for $var in (/works/employee[1]) return $var/xs:double(exactly-one(hours))
for $var in /works/employee[1] return $var/xs:float(exactly-one(hours))
for $var in (/works/employee[1]) return $var/xs:integer(exactly-one(hours))
for $var in /works/employee[1] return $var/xs:string(exactly-one(empnum))
for $x allowing empty in 1 to 5          where $x lt 0          return empty($x)
for $x as xs:error in () return fn:true()
for $x in (1,2,3,"cheese") for $y in (1,2,3,"cheese") where $x = $y return ($x, $y)
for $x in (1,2,3, xs:untypedAtomic("1")) for $y in (1,2,3,"cheese") where $x = $y return ($x, $y)
for $x in (1,2) return (if (($x eq 1)) then ($x) else ($x + 1))
for $x in (13), $y in (13,9,10) return codepoints-to-string($x to $y)
for $x in 13 to 13 return codepoints-to-string($x to $x)
for $x in 13 to 15 return codepoints-to-string($x to $x)
for $x in (1, 'hello', xs:date('2007-11-28')) order by $x return $x
for $x in 1 to 10, $y in 1 to 10 return concat('sum(',$x,' to ',$y,') = ',sum($x to $y))
for $x in (1 to 10)/string() order by $x collation ``[http://www.w3.org/2005/xpath-functions/collation/codepoint]`` return xs:integer($x)
(for $x in (1) where (fn:true()) order by ($x) return ($x))
for $x in (1, xs:decimal(2.5), xs:float(3), xs:double(4), xs:untypedAtomic(5))           return (+$x)
for $x in (1, xs:decimal(2.5), xs:float(3), xs:double(4), xs:untypedAtomic(5))          return (-$x)
for $x in 32 to 64 return boolean(codepoints-to-string($x to $x + 10))
for $x in 65 to 75 return boolean(codepoints-to-string($x[. mod 2 = 0] to ($x+9)[. mod 2 = 0]))
for $x in 65 to 75 return string-length(codepoints-to-string($x to $x+10))
for $x in 9 to 15 return codepoints-to-string($x to $x)
for $x in 9 to 9 return codepoints-to-string($x to $x+1)
for $x in <a/>, $y in <elem>{$x}</elem> return exactly-one($y/a) is $x
for $x in <a/>, $y in element elem {$x} return exactly-one($y/a) is $x
for $x in <a b="b"/>, $y in <elem>{$x/@b}</elem> return $y/@b is $x/@b
for $x in <a b="b"/>, $y in element elem {$x/@b} return $y/@b is $x/@b
for $x in <a>text</a>, $y in <elem>{$x/text()}</elem> return exactly-one($y/text()) is exactly-one($x/text())
for $x in <a>text</a>, $y in element elem {$x/text()} return exactly-one($y/text()) is exactly-one($x/text())
for $x in <!--comment-->, $y in <elem>{$x}</elem> return exactly-one($y/comment()) is $x
for $x in <!--comment-->, $y in element elem {$x} return exactly-one($y/comment()) is $x
for $x in (<e/>, 1, "x") return  typeswitch ($x)   case $i as xs:integer | xs:boolean | element() return 1  default $v return 0
for $x in <elem attr="value"/> return $x is $x/@attr/..
for $x in <parent1 xmlns:foo="http://www.example.com/parent1" foo:attr1="attr1"><child1 attr="child"/></parent1> return <new>{$x//*:child1}</new>
for $x in <parent1 xmlns:foo="http://www.example.com/parent1" foo:attr1="attr1"/> return <new xmlns:foo="http://www.example.com">{$x//@*:attr1}</new>
for $x in <parent2 xmlns:foo="http://www.example.com/parent2" foo:attr2="attr2"><child2 attr="child"/></parent2> return <new xmlns="http://www.example.com">{$x//*:child2}</new>
for $x in <parent3 xmlns:foo="http://www.example.com/parent3"><foo:child3/></parent3> return <new>{$x//*:child3}</new>
for $x in <parent4 xmlns="http://www.example.com/parent4"><child4/></parent4> return <new>{$x//*:child4}</new>
for $x in <?pi content?>, $y in <elem>{$x}</elem> return exactly-one($y/processing-instruction()) is $x
for $x in <?pi content?>, $y in element elem {$x} return exactly-one($y/processing-instruction()) is $x
for $x in <t><r><d>1</d><d>1</d><d>1</d></r><r><d>1</d><d>2</d><d>3</d></r><r><d>2</d><d>3</d><d>4</d></r></t>/r, $y in <t><r><d>1</d><d>1</d><d>1</d></r><r><d>2</d><d>4</d><d>6</d></r><r><d>3</d><d>2</d><d>1</d></r></t>/r where $x/d/string(.) = $y/d/string(.) return concat($x, '=', $y)
for $x in /works/employee[fn:position() lt 5][fn:position() mod 2 eq 1] return (fn:data($x/empnum), fn:data($x/pnum))
for $x in /works/employee[fn:position() mod 2 eq 1][fn:position() lt 5] return (fn:data($x/empnum), fn:data($x/pnum))
for $x in (xs:integer("123"), xs:integer("234")) for $y in (xs:integer("123"), xs:integer("456")) where $x = $y return $x
for $x in (xs:integer(1), xs:decimal(1)) return (((($x + 1) * 2) - 1) instance of xs:integer)
for $x in (xs:untypedAtomic("123"), xs:untypedAtomic("234")) for $y in (xs:string("123"), xs:float(123), xs:double(123)) where $x = $y return $x
for $x in (xs:untypedAtomic("2.0"), xs:untypedAtomic("3"), xs:double("3.0")) for $y in (xs:untypedAtomic("2"), xs:untypedAtomic("3"), xs:double("3")) where $x = $y return $x
for $x in zero-or-one((1 to 10)[. div 2 = 0]) return ()
(for $xs:name in (1, 1) return $xs:name) instance of xs:integer+
for-each((1,4,9,16,25), Q{http://www.w3.org/2005/xpath-functions/math}sqrt#1)
for-each((<a>1</a>, <b>22</b>, <c>33</c>),                     function($a as xs:string) as xs:integer {string-length($a)})
for-each(("aa", "bb", "cc", "dd", 12), ())
for-each(("aa", "bb", "cc", "dd", 12), upper-case#1)
for-each(("aa", "bb", "cc", "dd", "ee"), starts-with#2)
for-each(("aa", "bb", "cc", "dd", "ee"), upper-case#1)
for-each(for-each(("john", "mary", "jane", "anne", "peter", "ian"), function($n as xs:string){upper-case($n)}), function($e as xs:string) as xs:string { lower-case($e) })
for-each(("john", "jane"), string-to-codepoints#1)
for-each(("john", "mary", "jane", "anne", "peter", "ian"), function($x){$x[contains(., 'e')]})
for-each(("john", "mary", "jane", "anne", "peter", "ian"), function($x){upper-case($x)})
for-each(namespace-uri-from-QName(function-name(xs:int#1)), upper-case#1)
for-each((), round#1)
for for $folder in //Folder return $folder
for in 1 return 4
for return 4
<fragment-result>{ for $folder in /MyComputer/Drive3/Folder ,$file in /MyComputer/Drive3/Folder/File return <Folder>{ $folder/@name, $folder/@id }<file>{ $file/@idref }{ data($file/@name) }</file> </Folder> }</fragment-result>
<fragment-result>{ for $folder in /MyComputer/Drive3/Folder ,$file in /MyComputer/Drive3/Folder/File where $folder/@id = $file/@idref return <Folder> { $folder/@name, $folder/@id } <file>{ $file/@idref, $file/FileName/text() }</file> </Folder> }</fragment-result>
<frequent_bidder> {              for $u in $users//user_tuple              where every $item in $items//item_tuple                    satisfies some $b in $bids//bid_tuple                              satisfies ($item/itemno = $b/itemno and $u/userid = $b/userid)              return $u/name          } </frequent_bidder>
func-does-not-exist(1, 2, 3)
function()
function($a as xs:integer, $b as xs:double) as xs:double { $a * $b + 5 }(3, 2)
function($a as xs:integer) as xs:integer { $a + 5 }(3)
function($a) { "lala", $a }, $a
function($a) { let $a := "monkey" return ("lala", $a) }("gibbon")
function($in as xs:double*) as xs:double {sum($in, 0.0e0)}((1, xs:float(0.25), xs:decimal(0.5)))
function($in as xs:string*) as xs:string {string-join($in, ';')}((xs:anyURI('http://one.com/'), xs:anyURI('http://two.com/')))
function($Q{http://local/}foo, $Q{http://local/}bar, $fn:foo) {                 "lala", $Q{http://local/}foo, $Q{http://local/}bar }("gibbon", "monkey", "ape")
function($x, $y) {$x + $y} (12, 5)
function($x, $y) {$x + $y} [function-arity(.) = 2] (12, 5)
function() as xs:integer { 5 }()
function gt function
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'anyURI'), 1)('http://www.example.org/')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'banana'), 1)
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'base64Binary'), 1)('D74D35D35D35')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'boolean'), 1)('1')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'byte'), 1)('1')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'date'), 1)('1970-01-02Z')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'dateTime'), 1)('1970-01-02T04:05:06Z')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'dayTimeDuration'), 1)('PT15H')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'decimal'), 1)('1')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'double'), 1)('1')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'duration'), 1)('P5Y2M10DT15H')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'ENTITIES'), 1)('ENTITY1 ENTITY2 ENTITY3')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'ENTITY'), 1)('ENTITY')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'float'), 1)('1')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'gDay'), 1)('---01Z')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'gMonth'), 1)('--11Z')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'gMonthDay'), 1)('--11-01Z')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'gYear'), 1)('2012Z')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'gYearMonth'), 1)('2001-10Z')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'hexBinary'), 1)('0fb7')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'ID'), 1)('ID')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'IDREF'), 1)('IDREF')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'IDREFS'), 1)('ID1 ID2 ID3')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'int'), 1)('1')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'integer'), 1)('1')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'integer'), 2)
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'language'), 1)('en')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'long'), 1)('1')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'Name'), 1)('Name')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'NCName'), 1)('NCName')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'negativeInteger'), 1)('-1')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'NMTOKEN'), 1)('NMTOKEN')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'NMTOKENS'), 1)('NMTOKEN1 NMTOKEN2 NMTOKEN3')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'nonNegativeInteger'), 1)('1')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'nonPositiveInteger'), 1)('-1')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'normalizedString'), 1)('normalized string')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'positiveInteger'), 1)('1')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'QName'), 1)('fn:QName')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'short'), 1)('1')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'string'), 1)('string')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'time'), 1)('01:02:03Z')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'token'), 1)('token')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'unsignedByte'), 1)('1')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'unsignedInt'), 1)('1')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'unsignedLong'), 1)('1')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'unsignedShort'), 1)('1')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'untypedAtomic'), 1)('string')
function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'yearMonthDuration'), 1)('P1Y')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'abs'), 1)(-1)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'append'), 2)([], 3)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'filter'), 2)(["A", "B", 1, 2], function($z) {$z instance of xs:integer})
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'flatten'), 1)([1, 4, 6, 5, 3])
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'fold-left'), 3)([1,2,3,4,5,6], 0, function($z,$a){$z + $a})
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'fold-right'), 3)([1,2,3,4,5,6], 0, function($a,$z){$a + $z})
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'for-each'), 2)(["A", "B", 1, 2], function($z) {$z instance of xs:integer})
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'for-each-pair'), 3)(["A", "B", "C"], [1, 2, 3], function($x, $y) {[$x, $y]})
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'get'), 2)([5,6,7], 1)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'head'), 1)([5,6,7,8])
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'insert-before'), 3)(["a", "b", "c", "d"], 3, ("x", "y"))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'join'), 1)(([1,2],[3,4]))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'put'), 3)(["a", "b", "c", "d"], 3, ("x", "y"))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'remove'), 2)(["a","b","c","d"], 1)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'reverse'), 1)(["a", "b", "c", "d"])
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'size'), 1)([1])
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'sort'), 1)(["Red", "green", "blUE", "PINK", "ORanGE"])
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'subarray'), 2)(["a", "b", "c", "d"], 2)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'subarray'), 3)([1, (2,2), 3], 3, 0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/array', 'tail'), 1)([5,6,7,8])
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'avg'), 1)((1, 3))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'banana'), 1)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'boolean'), 1)("string")
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'ceiling'), 1)(0.9)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'codepoint-equal'), 2)('string', 'string')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'codepoints-to-string'), 1)((65, 66))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'compare'), 2)('string', 'string')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'concat'), 3)('a', 'bc', 'def')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'contains'), 2)('string', 'rin')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'count'), 1)((1, true()))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'current-date'), 0)()
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'current-dateTime'), 0)()
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'current-time'), 0)()
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'data'), 1)(/root/child[1])
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'dateTime'), 2)(xs:date('2012-01-01Z'), xs:time('00:00:00Z'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'day-from-date'), 1)(xs:date('2012-02-01Z'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'day-from-dateTime'), 1)(xs:dateTime('2012-04-03T02:01:00Z'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'days-from-duration'), 1)(xs:dayTimeDuration("P3DT10H"))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'deep-equal'), 2)((1, true()), (1, true()))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'empty'), 1)((1, true()))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'encode-for-uri'), 1)(' ')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'ends-with'), 2)('string', 'ing')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'exactly-one'), 1)(1)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'exists'), 1)((1, true()))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'false'), 0)()
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'filter'), 2)(1 to 10, function($a) {$a mod 2 = 0})
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'floor'), 1)(1.1)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'fold-left'), 3)(1 to 5, "", fn:concat(?, ".", ?))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'fold-right'), 3)(1 to 5, "", fn:concat(?, ".", ?))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'for-each'), 2)(("23", "29"), xs:int#1)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'function-arity'), 1)(fn:abs#1)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'function-lookup'), 2)(fn:QName('http://www.example.org', 'foo:bar'), 1)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'function-name'), 1)(fn:abs#1)
/function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'has-children'), 0)()
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'has-children'), 1)(/)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'head'), 1)((1, true()))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'hours-from-dateTime'), 1)(xs:dateTime('2012-04-03T02:01:00Z'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'hours-from-duration'), 1)(xs:dayTimeDuration("P3DT10H"))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'hours-from-time'), 1)(xs:time('02:01:00Z'))
/function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'id'), 1)(('id1', 'id2'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'id'), 2)(('id1', 'id2'), /)
/function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'idref'), 1)(('id1', 'id2'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'idref'), 2)(('id1', 'id2'), /)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'implicit-timezone'), 0)()
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'innermost'), 1)(())
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'insert-before'), 3)((1, 2, 3), 2, ('a', 'b', 'c'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'iri-to-uri'), 1)('http://www.example.com/')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'local-name'), 1)(/root)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'local-name-from-QName'), 1)(fn:QName('http://www.example.org', 'foo:bar'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'lower-case'), 1)('STRING')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/map', 'contains'), 2)(map{}, 0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/map', 'for-each'), 2)(map{}, concat#2)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/map', 'get'), 2)(map{}, 1)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/map', 'keys'), 1)(map{})
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/map', 'remove'), 2)(map{},1)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/map', 'size'), 1)(map{})
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'matches'), 2)('string', 'string')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'acos'), 1)(1e0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'asin'), 1)(1e0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'atan'), 1)(1e0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'atan2'), 2)(1e0, 1e0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'cos'), 1)(1e0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'exp10'), 1)(1e0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'exp'), 1)(1e0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'log10'), 1)(1e0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'log'), 1)(1e0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'pi'), 0)()
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'pow'), 2)(1e0, 1)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'sin'), 1)(1e0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'sqrt'), 1)(1e0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions/math', 'tan'), 1)(1e0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'max'), 1)((1, 3))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'min'), 1)((1, 3))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'minutes-from-dateTime'), 1)(xs:dateTime('2012-04-03T02:01:00Z'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'minutes-from-duration'), 1)(xs:dayTimeDuration("P3DT10H"))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'minutes-from-time'), 1)(xs:time('02:01:00Z'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'month-from-date'), 1)(xs:date('2012-02-01Z'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'month-from-dateTime'), 1)(xs:dateTime('2012-04-03T02:01:00Z'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'months-from-duration'), 1)(xs:yearMonthDuration("P20Y15M"))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'name'), 1)(/root)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'name'), 2)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'namespace-uri'), 1)(/root/*[2])
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'namespace-uri-from-QName'), 1)(fn:QName('http://www.example.org', 'foo:bar'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'node-name'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'node-name'), ())
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'node-name'), 1, ())
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'node-name'), (1, 2))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'node-name'), 1)(/root)
function-lookup((fn:QName('http://www.w3.org/2005/xpath-functions', 'node-name'), fn:QName('http://www.w3.org/2005/xpath-functions', 'node-name')), 1)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'normalize-space'), 1)(' string ')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'not'), 1)("string")
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'number'), 1)('1')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'one-or-more'), 1)(1)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'outermost'), 1)(())
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'parse-json'), 1)( 'true' )
/function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'path'), 0)()
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'path'), 1)(/)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'prefix-from-QName'), 1)(fn:QName('http://www.example.org', 'foo:bar'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'QName'), 2)('http://www.example.org/', 'ns:local')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'remove'), 2)(('a', 'b', 'c'), 2)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'reverse'), 1)(1 to 3)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'root'), 1)(())
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'round'), 1)(1.1)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'round'), 2)(1.1, 0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'round-half-to-even'), 1)(1.1)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'round-half-to-even'), 2)(1.1, 0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'seconds-from-dateTime'), 1)(xs:dateTime('2012-04-03T02:01:00Z'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'seconds-from-duration'), 1)(xs:dayTimeDuration("P3DT10H12.5S"))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'seconds-from-time'), 1)(xs:time('02:01:00Z'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'starts-with'), 2)('string', 'str')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'string'), 1)(1)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'string-join'), 1)(('abc', 'def'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'string-join'), 2)(('abc', 'def'), '-')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'string-length'), 1)('string')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'string-to-codepoints'), 1)('A')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'subsequence'), 2)((1, true()), 2e0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'subsequence'), 3)((1, true()), 1e0, 1e0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'substring'), 2)('string', 2e0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'substring'), 3)('string', 1e0, 1e0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'substring-after'), 2)('string', 'str')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'substring-before'), 2)('string', 'ing')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'sum'), 1)((1, 2))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'sum'), 2)((1, 2), 0)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'tail'), 1)((1, true()))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'timezone-from-date'), 1)(xs:date('2012-01-01Z'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'timezone-from-dateTime'), 1)(xs:dateTime('2012-01-01T00:00:00Z'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'timezone-from-time'), 1)(xs:time('02:01:00Z'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'tokenize'), 1)('a b')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'tokenize'), 2)('string', 'i')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'trace'), 2)(1, 'label')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'translate'), 3)('string', 'i', 'o')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'true'), 0)()
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'unordered'), 1)(1)
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'upper-case'), 1)('string')
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'year-from-date'), 1)(xs:date('2012-02-01Z'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'year-from-dateTime'), 1)(xs:dateTime('2012-04-03T02:01:00Z'))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'years-from-duration'), 1)(xs:yearMonthDuration("P20Y15M"))
function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'zero-or-one'), 1)(1)
function-lookup(fn:QName('http://www.w3.org/2005/xquery-local-functions', 'missing'), 1)("arg")
function-lookup(QName("http://www.w3.org/2001/XMLSchema", "time"), 1)("12:30:00Z")
function-lookup(QName("http://www.w3.org/2005/xpath-functions", "abs"), 1)(-3)
function-lookup(QName("http://www.w3.org/2005/xpath-functions", "concat"), 3)("a", "b", "c")
function-lookup(QName("http://www.w3.org/2005/xpath-functions/math", "pi"), 0)() idiv 1
function-lookup(QName("http://www.w3.org/2005/xpath-functions", "round"), 2)(?, 3)(1.2345678)
function-lookup(QName("http://www.w3.org/2005/xpath-functions", "round"), 2) !                     (function-name(.) ! (namespace-uri-from-QName(.), local-name-from-QName(.)), function-arity(.))
function-lookup(QName("http://www.w3.org/2005/xquery-local-functions", "cube"), 1)
function-lookup(QName("", "round"), 2)
function-lookup(xs:QName('math:pi'), 0)()
function-name(function() { 5 })
function-name(function-name#1)
function-name(let $a := 92, $b := true() return function($c) { $a, $b, $c })
"gobbledygook" castable as xs:language
"&gt;"
head(3 to 10)
head(("a", "b", current-dateTime()))
head(/works/cucumber)
"He said, ""I don't like it."""
'He said, "I don''t like it."'
*(:hey:):(:hey:) ncname
*(:hey:):ncname
*:(:hey:)ncname
//hours => count()
hours-from-dateTime()
hours-from-dateTime(()) instance of xs:integer?
hours-from-dateTime((), "Wrong param")
hours-from-dateTime(xs:dateTime("2001-02-03T08:23:12.43")) eq 8
(hours-from-dateTime( xs:dateTime('2006-08-15T10:30:23')))
(hours-from-dateTime( xs:dateTime('2006-08-15T10:30:23-05:00')))
(hours-from-dateTime( xs:dateTime('2006-08-15T10:30:23')), hours-from-dateTime( xs:dateTime('2006-08-15T10:30:23-05:00')))
hours-from-duration()
hours-from-duration(()) instance of xs:integer?
hours-from-duration((), "Wrong param")
(hours-from-duration( xs:dayTimeDuration('P1DT5H')))
(hours-from-duration( xs:dayTimeDuration('P1DT5H')), hours-from-duration( xs:dayTimeDuration('-PT36H')), hours-from-duration( xs:dayTimeDuration('PT1H90M')), hours-from-duration( xs:dayTimeDuration('PT2H59M')), hours-from-duration( xs:dayTimeDuration('PT3600S')))
hours-from-duration(xs:dayTimeDuration("-P3DT8H2M1.03S")) eq -8
hours-from-duration(xs:dayTimeDuration("P3DT8H2M1.03S")) eq 8
(hours-from-duration( xs:dayTimeDuration('PT1H90M')))
(hours-from-duration( xs:dayTimeDuration('PT2H59M')))
(hours-from-duration( xs:dayTimeDuration('PT3600S')))
(hours-from-duration( xs:dayTimeDuration('-PT36H')))
hours-from-duration(xs:duration("-P3Y4M8DT1H23M2.34S")) eq -1
hours-from-time()
hours-from-time(()) instance of xs:integer?
hours-from-time((), "Wrong param")
(hours-from-time( xs:time('10:30:23')))
(hours-from-time( xs:time('10:30:23-05:00')))
(hours-from-time( xs:time('10:30:23')), hours-from-time( xs:time('10:30:23-05:00')))
hours-from-time(xs:time("23:11:12.43")) eq 23
"http://example.com?query=" cast as xs:anyURI
("http:\\invalid>URI\someURI") castable as xs:anyURI
id((), ())
() idiv 1
idref((), ())
if()
if((1, 2, 3, hours-from-time(current-time()))[1]) then true() else false()
if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else if (1) then 1 else ()
if (2 != 4) then 1 else 0
(if(2) then 1 else 0) eq 1
( if (3 != 2) then 16 else 0 ) + ( if (8 = 7) then 4 else 1 )
(if (3 != 2) then 16 else 0) + (if (8 = 7) then 4 else 1)
if(5 < exactly-one((1 to 10)[. div 2 = 5])) then codepoints-to-string(32 to exactly-one((1 to 100)[. div 2 = 40])) else ()
if (//CompanyName) then <elem1/> else <elem2/>
if(count((1, 2, 3, current-time(), 4))) then true() else 4
if ( count( for $f in //* where $f/File return $f/File[1] ) = count( //File[1]) ) then <Same/> else <notSame/>
(if (current-date() gt xs:date('2000-12-31')) then upper-case#1 else lower-case#1)("Mike")
(if(current-time()) then 1 else 0) eq 1
if (/doc/widget1/@unit-cost = /doc/widget2/@unit-cost) then /doc/widget1/@name else /doc/widget2/@name
if(//(employee[location = "Denver"]/ancestor::*)) then 1 else 3
if(false()) then name() else true()
if(false()) then normalize-space() else true()
if(false()) then string-length() else true()
if //File[1] then "true" else "false"
if (fn:false()) then <elem1/> else <elem2/>
if (fn:true()) then <elem1/> else <elem2/>
if(for $i in <e> <a id="3"/> <b id="2"/> <c id="1"/> </e>/* order by xs:integer($i/@id) return $i) then 4 else 9
if (if (5 != 3) then fn:true() else fn:empty(/doc/widget1)) then "search" else "assume"
if (implicit-timezone() eq xs:dayTimeDuration('PT1H'))             then xs:gDay("---31+01:01") eq xs:gDay("---31")             else xs:gDay("---31+01:00") eq xs:gDay("---31")
if (implicit-timezone() eq xs:dayTimeDuration('PT1H'))             then xs:gDay("---31") eq xs:gDay("---31+01:01")             else xs:gDay("---31") eq xs:gDay("---31+01:00")
if (implicit-timezone() eq xs:dayTimeDuration('PT1M'))             then xs:gMonthDay("--12-30") eq xs:gMonthDay("--12-31+01:01")             else xs:gMonthDay("--12-30") eq xs:gMonthDay("--12-31+01:00")
if (implicit-timezone() eq xs:dayTimeDuration('PT1M'))             then xs:gMonthDay("--12-31+01:01") eq xs:gMonthDay("--12-30")             else xs:gMonthDay("--12-31+01:00") eq xs:gMonthDay("--12-30")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gDay("---30") eq xs:gDay("---31-09:01")             else xs:gDay("---30") eq xs:gDay("---31-09:00")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gDay("---30") eq xs:gDay("---31+09:01")             else xs:gDay("---30") eq xs:gDay("---31+09:00")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gDay("---30") ne xs:gDay("---31-09:01")             else xs:gDay("---30") ne xs:gDay("---31-09:00")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gDay("---30") ne xs:gDay("---31+09:01")             else xs:gDay("---30") ne xs:gDay("---31+09:00")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gDay("---31-09:01") eq xs:gDay("---30")             else xs:gDay("---31-09:00") eq xs:gDay("---30")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gDay("---31+09:01") eq xs:gDay("---30")             else xs:gDay("---31+09:00") eq xs:gDay("---30")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gDay("---31-09:01") ne xs:gDay("---30")             else xs:gDay("---31-09:00") ne xs:gDay("---30")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gDay("---31+09:01") ne xs:gDay("---30")             else xs:gDay("---31+09:00") ne xs:gDay("---30")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gMonth("--06-09:01") eq xs:gMonth("--06")             else xs:gMonth("--06-09:00") eq xs:gMonth("--06")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gMonth("--06+09:01") eq xs:gMonth("--06")             else xs:gMonth("--06+09:00") eq xs:gMonth("--06")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gMonth("--06-09:01") ne xs:gMonth("--06")             else xs:gMonth("--06-09:00") ne xs:gMonth("--06")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gMonth("--06+09:01") ne xs:gMonth("--06")             else xs:gMonth("--06+09:00") ne xs:gMonth("--06")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gMonth("--06") eq xs:gMonth("--06-09:01")             else xs:gMonth("--06") eq xs:gMonth("--06-09:00")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gMonth("--06") eq xs:gMonth("--06+09:01")             else xs:gMonth("--06") eq xs:gMonth("--06+09:00")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gMonth("--06") ne xs:gMonth("--06-09:01")             else xs:gMonth("--06") ne xs:gMonth("--06-09:00")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gMonth("--06") ne xs:gMonth("--06+09:01")             else xs:gMonth("--06") ne xs:gMonth("--06+09:00")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gMonthDay("--12-30") eq xs:gMonthDay("--12-31-09:01")             else xs:gMonthDay("--12-30") eq xs:gMonthDay("--12-31-09:00")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gMonthDay("--12-30") eq xs:gMonthDay("--12-31+09:01")             else xs:gMonthDay("--12-30") eq xs:gMonthDay("--12-31+09:00")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gMonthDay("--12-30") ne xs:gMonthDay("--12-31-09:01")             else xs:gMonthDay("--12-30") ne xs:gMonthDay("--12-31-09:00")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gMonthDay("--12-30") ne xs:gMonthDay("--12-31+09:01")             else xs:gMonthDay("--12-30") ne xs:gMonthDay("--12-31+09:00")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gMonthDay("--12-31-09:01") eq xs:gMonthDay("--12-30")             else xs:gMonthDay("--12-31-09:00") eq xs:gMonthDay("--12-30")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gMonthDay("--12-31+09:01") eq xs:gMonthDay("--12-30")             else xs:gMonthDay("--12-31+09:00") eq xs:gMonthDay("--12-30")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gMonthDay("--12-31-09:01") ne xs:gMonthDay("--12-30")             else xs:gMonthDay("--12-31-09:00") ne xs:gMonthDay("--12-30")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gMonthDay("--12-31+09:01") ne xs:gMonthDay("--12-30")             else xs:gMonthDay("--12-31+09:00") ne xs:gMonthDay("--12-30")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gYear("2008-09:01") eq xs:gYear("2008")             else xs:gYear("2008-09:00") eq xs:gYear("2008")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gYear("2008+09:01") eq xs:gYear("2008")             else xs:gYear("2008+09:00") eq xs:gYear("2008")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gYear("2008-09:01") ne xs:gYear("2008")             else xs:gYear("2008-09:00") ne xs:gYear("2008")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gYear("2008+09:01") ne xs:gYear("2008")             else xs:gYear("2008+09:00") ne xs:gYear("2008")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gYear("2008") eq xs:gYear("2008-09:01")             else xs:gYear("2008") eq xs:gYear("2008-09:00")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gYear("2008") eq xs:gYear("2008+09:01")             else xs:gYear("2008") eq xs:gYear("2008+09:00")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gYear("2008") ne xs:gYear("2008-09:01")             else xs:gYear("2008") ne xs:gYear("2008-09:00")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gYear("2008") ne xs:gYear("2008+09:01")             else xs:gYear("2008") ne xs:gYear("2008+09:00")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gYearMonth("2008-01-09:01") eq xs:gYearMonth("2008-01")             else xs:gYearMonth("2008-01-09:00") eq xs:gYearMonth("2008-01")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gYearMonth("2008-01+09:01") eq xs:gYearMonth("2008-01")             else xs:gYearMonth("2008-01+09:00") eq xs:gYearMonth("2008-01")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gYearMonth("2008-01-09:01") ne xs:gYearMonth("2008-01")             else xs:gYearMonth("2008-01-09:00") ne xs:gYearMonth("2008-01")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gYearMonth("2008-01+09:01") ne xs:gYearMonth("2008-01")             else xs:gYearMonth("2008-01+09:00") ne xs:gYearMonth("2008-01")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gYearMonth("2008-01") eq xs:gYearMonth("2008-01-09:01")             else xs:gYearMonth("2008-01") eq xs:gYearMonth("2008-01-09:00")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gYearMonth("2008-01") eq xs:gYearMonth("2008-01+09:01")             else xs:gYearMonth("2008-01") eq xs:gYearMonth("2008-01+09:00")
if (implicit-timezone() eq xs:dayTimeDuration('-PT9M'))             then xs:gYearMonth("2008-01") ne xs:gYearMonth("2008-01-09:01")             else xs:gYearMonth("2008-01") ne xs:gYearMonth("2008-01-09:00")
if (implicit-timezone() eq xs:dayTimeDuration('PT9M'))             then xs:gYearMonth("2008-01") ne xs:gYearMonth("2008-01+09:01")             else xs:gYearMonth("2008-01") ne xs:gYearMonth("2008-01+09:00")
if (max(for $x in 1 to 10 return $x mod 9 = 0)) then true() else false()
if (//MissingNode) then <elem3/> else if (/Root/Customers[@CustomerID='ALFKI']//Country = "Germany") then <elem1/> else <elem2/>
if (//NodeDoesNotExist) then <elem1/> else <elem2/>
if(not(count(remove((1, 2, 3, current-time()), 1)))) then 3 else true()
if ( /Root/Customers[1]/@CustomerID = 'ALFKI' and /Root/Customers[1]/FullAddress/City = 'Berlin') then "pass" else "fail"
if (/Root/Customers[1]/@CustomerID = 'ALFKI' or /Root/Customers[1]/FullAddress/City = 'Non-Existent') then "pass" else "fail"
if(()) then false() else true()
if(!true()) then 2 else 3
if(true()) then true() else string()
"I love brownies&amp;cookies." eq "I love brownies&amp;cookies."
implicit-timezone() ge xs:dayTimeDuration('-PT14H') and implicit-timezone() le xs:dayTimeDuration('PT14H')
implicit-timezone("WRONG PARAM")
(implicit-timezone() + xs:dayTimeDuration('PT1S')) div (implicit-timezone() + xs:dayTimeDuration('PT1S'))
import gt import
import module "%gg"; true()
import module "http://www.example.org/foo"; import module "http://www.example.org/foo"; 1
import module namespace m="http://example.com/hof-003";          let $f := m:f#1 return $f(17)
import schema namespace NCName := "http://example.com/Dummy"; 1
index-of()
index-of(1)
index-of((1, 2, 3), 1, ())
index-of(1 to 10,(1 to 10)[. div 2 = 0][1])
index-of((1 to 10,(1 to 10)[. mod 2 = 0]),4)
index-of(1 to 5,4)
index-of(4, 4)
(index-of( (4, 5, 6, 4), 04.0))
(index-of( (4, 5, 6, 4), 4))
(index-of( (), 'a'))
(index-of( (<a>1</a>, <b>1</b>), <c>1</c> ))
(index-of( ('a', 'b', 'c'), 'a'))
(index-of( ('a', 'b', 'c'), 'd'))
index-of('a', 'b', 'http://www.cbcl.co.u,/collation')
index-of("a string", "a string", "http://www.example.com/COLLATION/NOT/SUPPORTED")
index-of("a string", "a string", "http://www.w3.org/2005/xpath-functions/collation/codepoint", "wrong param")
index-of(exactly-one((1 to 10)[. div 5 = 1]),5)
index-of(xs:untypedAtomic("example.com/"), xs:anyURI("example.com/"))
"inf" cast as xs:decimal
"-inF " cast as xs:decimal
"-inF" cast as xs:decimal
"inF " cast as xs:decimal
"inF" cast as xs:decimal
('Ingratitude, ' ||  'thou ' ||  'marble-hearted' ||  ' fiend!')
innermost(//*) except //*
innermost(//rubbish)
insert-before()
insert-before((), 1, 3) eq 3
insert-before((), 1, "a string") eq "a string"
insert-before((1 to 10,(20 to 30)[. mod 2 = 0],30 to 40),12,"blah")
insert-before(1 to 10,5,20 to 30)
insert-before((), 30, 7) eq 7
insert-before((), -31, "a string") eq "a string"
(insert-before( (), 3, ('a', 'b', 'c') ))
insert-before(9, 30, ()) eq 9
(insert-before( ('a', 'b', 'c'), 0, ('x', 'y')))
(insert-before( ('a', 'b', 'c'), 10, ('x', 'y')))
(insert-before( ('a', 'b', 'c'), 1, ('x', 'y')))
(insert-before( ('a', 'b', 'c'), 1, ('x', 'y')), insert-before( ('a', 'b', 'c'), 2, ('x', 'y')), insert-before( ('a', 'b', 'c'), 10, ('x', 'y')), insert-before( ('a', 'b', 'c'), 0, ('x', 'y')), insert-before( ('a', 'b', 'c'), 2, ()), insert-before( (), 3, ('a', 'b', 'c') ))
(insert-before( ('a', 'b', 'c'), 2, ()))
(insert-before( ('a', 'b', 'c'), 2, ('x', 'y')))
insert-before((), (), "a string")
insert-before("wrong params", 2)
insert-before("wrong params", 2, 3, 4)
(() ||  ()) instance of xs:string
(//integer[fn:not(fn:false())])
(//integer[fn:true()])
(//integer[fn:true() and fn:true()])
(//integer[fn:true() or fn:true()])
() intersect ()
<?invalid|char ?>
iri-to-uri(" ")
iri-to-uri("<> ""{}|\^`")
iri-to-uri('')
iri-to-uri('',())
iri-to-uri(())
iri-to-uri()
iri-to-uri(1)
iri-to-uri(12)
iri-to-uri("a string", "a string")
iri-to-uri(("a string", "a string"))
iri-to-uri(codepoints-to-string(15000 to 16000))
iri-to-uri(codepoints-to-string(32 to 294))
iri-to-uri(()) eq ""
(iri-to-uri( 'http://datypic.com/Sales Numbers.pdf'))
iri-to-uri("http://example.com/", "wrong param")
iri-to-uri("http://www.example.com/00/Weather/CA/Los%20Angeles#ocean")
iri-to-uri("http://www.example.com/~bb")
iri-to-uri(xs:anyURI("a string"))
iri-to-uri(xs:untypedAtomic("a string"))
() is
is ()
item()
"it is " || 10 to 1 || "already"
key('func', "a value")
key("id")
<keywords> <ancestor-or-self/> <ancestor/> <and/> <as/> <ascending/> <at/> <attribute/>        <base-uri/> <boundary-space/> <by/>        <case/> <cast/> <castable/> <child/> <collation/> <comment/> <construction/> <copy-namespaces/>        <declare/> <default/> <descendant-or-self/> <descendant/> <descending/> <div/> <document-node/> <document/>        <element/> <else/> <empty-sequence/> <empty/> <encoding/> <eq/> <every/> <except/> <external/>        <following-sibling/> <following/> <for/> <function/>        <ge/> <greatest/> <gt/>        <idiv/> <if/> <import/> <in/> <inherit/> <instance/> <intersect/> <is/> <item/>        <lax/> <le/> <least/> <let/> <lt/>        <mod/> <module/> <module/>        <namespace/> <ne/> <no-inherit/> <no-preserve/> <node/>        <of/> <option/> <or/> <order/> <ordered/> <ordering/>        <parent/> <preceding-sibling/> <preceding/> <preserve/> <processing-instruction/>        <return/>        <satisfies/> <schema-attribute/> <schema-element/> <schema/> <self/> <some/> <stable/> <strict/> <strip/>        <text/> <then/> <to/> <treat/> <typeswitch/>        <union/> <unordered/>        <validate/> <variable/> <version/>        <where/>        <xquery/> </keywords>/name()
<keywords>            <exponent-separator/>         </keywords>/name()
<keywords>            <NaN/>            <allowing/>            <ancestor-or-self/>            <ancestor/>            <and/>            <as/>            <ascending/>            <at/>            <attribute/>            <base-uri/>            <boundary-space/>            <by/>            <case/>            <cast/>            <castable/>            <catch/>            <child/>            <collation/>            <comment/>            <construction/>            <context/>            <copy-namespaces/>            <count/>            <decimal-format/>            <decimal-separator/>            <declare/>            <default/>            <descendant-or-self/>            <descendant/>            <descending/>            <digit/>            <div/>            <document-node/>            <document/>            <element/>            <else/>            <empty-sequence/>            <empty/>            <encoding/>            <end/>            <eq/>            <every/>            <except/>            <external/>            <following-sibling/>            <following/>            <for/>            <function/>            <ge/>            <greatest/>            <group/>            <grouping-separator/>            <gt/>            <idiv/>            <if/>            <import/>            <in/>            <infinity/>            <inherit/>            <instance/>            <intersect/>            <is/>            <item/>            <lax/>            <le/>            <least/>            <let/>            <lt/>            <minus-sign/>            <mod/>            <module/>            <namespace-node/>            <namespace/>            <ne/>            <next/>            <no-inherit/>            <no-preserve/>            <node/>            <of/>            <only/>            <option/>            <or/>            <order/>            <ordered/>            <ordering/>            <parent/>            <pattern-separator/>            <per-mille/>            <percent/>            <preceding-sibling/>            <preceding/>            <preserve/>            <previous/>            <processing-instruction/>            <return/>            <satisfies/>            <schema-attribute/>            <schema-element/>            <schema/>            <self/>            <sliding/>            <some/>            <stable/>            <start/>            <strict/>            <strip/>            <switch/>            <text/>            <then/>            <to/>            <treat/>            <try/>            <tumbling/>            <type/>            <typeswitch/>            <union/>            <unordered/>            <validate/>            <variable/>            <version/>            <when/>            <where/>            <window/>            <xquery/>            <zero-digit/>         </keywords>/name()
last()
last(1)
let
let $a := $b return ($a)
let $a := 1 let $b := $a let $c := $a+$b return ($c)
let $a := 1 return                  for $b in 1 return                      if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else if ($b) then 1                              else ()
(let $a := 92, $b := true() return function($c) { $a, $b, $c })("lala")
(let $a := 92, $b := true() return function($c) { $a, $b, $c })((xs:QName("foo"), 5.0e3))
let $A := ["A", "B", "C", "D"] return array:for-each-pair($A, array:tail($A), concat#2)
let $abc := ("a", "b", "c")                       return                   fn:insert-before($abc, 0, "z")
let $abc := ("a", "b", "c")                       return                   fn:insert-before($abc, 1, "z")
let $abc := ("a", "b", "c")                       return                   fn:insert-before($abc, 2, "z")
let $abc := ("a", "b", "c")                       return                   fn:insert-before($abc, 3, "z")
let $abc := ("a", "b", "c")                       return                   fn:insert-before($abc, 4, "z")
let $abc := ("a", "b", "c")                       return                   fn:remove($abc, 0)
let $abc := ("a", "b", "c")                       return                   fn:remove($abc, 1)
let $abc := ("a", "b", "c")                       return                   fn:remove($abc, 6)
let $abc := ("a", "b", "c")                       return                   fn:remove((), 3)
let $abc := ("a", "b", "c")                       return                   fn:reverse($abc)
let $abc := ("a", "b", "")                       return                   fn:boolean($abc[0])
let $abc := ("a", "b", "")                       return                   fn:boolean($abc[1])
let $abc := ("a", "b", "")                       return                   fn:boolean($abc[3])
let $add := function($x, $y){$x + $y} return $add(4, 2)
let $add := function($x, $y) {$x + $y} return function-arity($add)
let $add := function($x, $y) {$x + $y} return function-name($add)
let $add := function($x, $y) as xs:double {$x + $y}          return $add(3, 4)
let $add := function($x, $y) as xs:integer {$x + $y}          return $add(3, 4)
let $add := function($x, $y) as xs:integer {$x + $y}          return $add(3, 4.1)
let $add := function($x as xs:integer, $y as xs:integer){$x + $y}          return $add(3,4)
let $add := function($x as xs:integer, $y as xs:integer){$x + $y}          return $add(3,4.2)
let $add := %Q{http://example.com/speed}fast %Q{http://example.com/origin}author("Mike") function($x, $y) {$x + $y} return $add(2,2)
let $add := %Q{http://example.com/speed}fast() %Q{http://example.com/origin}author("Mike") function($x, $y) {$x + $y} return $add(2,2)
let $add := %Q{http://example.com/speed}fast(true())  function($x, $y) {$x + $y} return $add(2,2)
let $add := % Q{http://example.com/speed}speed (-1)  function($x, $y) {$x + $y} return $add(2,2)
let $add := % Q{http://example.com/speed}speed (())  function($x, $y) {$x + $y} return $add(2,2)
let $address := '123 Main Street Traverse City, MI 49684' return (matches($address, 'Main Street'))
let $address := '123 Main Street Traverse City, MI 49684' return (matches($address, 'street'))
let $address := '123 Main Street Traverse City, MI 49684' return (matches($address, 'Street$'))
let $address := '123 Main Street Traverse City, MI 49684' return (matches($address, 'Street.*City'))
let $address := '123 Main Street Traverse City, MI 49684' return (matches((), 'q' ))
let $address := '123 Main Street Traverse City, MI 49684' return (matches('query', '[a-z]{5}'))
let $address := '123 Main Street Traverse City, MI 49684' return (matches('query', 'q'))
let $address := '123 Main Street Traverse City, MI 49684' return (matches('query', 'q.*'))
let $address := '123 Main Street Traverse City, MI 49684' return (matches('query', '^qu'))
let $address := '123 Main Street Traverse City, MI 49684' return (matches('query', 'qu$'))
let $address := '123 Main Street Traverse City, MI 49684' return (matches('query', 'ue'))
let $address := '123 Main Street Traverse City, MI 49684' return (matches('query', '[ux]'))
let $a := (<elem1/>, <elem2/>, <elem3 att="test"/>) return <root>{$a}</root>
let $a := <elem/> let $b := <elem2/> return ($a,$b)
let $allbikes := $items//item_tuple [contains(exactly-one(description), "Bicycle") or contains(exactly-one(description), "Tricycle")]          let $bikebids := $bids//bid_tuple[itemno = $allbikes/itemno]          return <high_bid> { max($bikebids/bid) } </high_bid>
let $a := "monkey" return function($a) { "lala", $a }("gibbon")
let $ancestor-or-self := 1        let $ancestor := 1        let $and := 1        let $as := 1        let $ascending := 1        let $at := 1        let $attribute := 1        let $base-uri := 1        let $boundary-space := 1        let $by := 1        let $case := 1        let $cast := 1        let $castable := 1        let $child := 1        let $collation := 1        let $comment := 1        let $construction := 1        let $copy-namespaces := 1        let $declare := 1        let $default := 1        let $descendant-or-self := 1        let $descendant := 1        let $descending := 1        let $div := 1        let $document-node := 1        let $document := 1        let $element := 1        let $else := 1        let $empty-sequence := 1        let $empty := 1        let $encoding := 1        let $eq := 1 let $every := 1 let $except := 1 let $external := 1 let $following-sibling := 1        let $following := 1 let $for := 1 let $function := 1 let $ge := 1 let $greatest := 1        let $gt := 1 let $idiv := 1 let $if := 1 let $import := 1 let $in := 1 let $inherit := 1        let $instance := 1 let $intersect := 1 let $is := 1 let $item := 1 let $lax := 1        let $le := 1 let $least := 1 let $let := 1 let $lt := 1 let $mod := 1 let $module := 1        let $module := 1 let $namespace := 1 let $ne := 1 let $no-inherit := 1        let $no-preserve := 1 let $node := 1 let $of := 1 let $option := 1 let $or := 1        let $order := 1 let $ordered := 1 let $ordering := 1 let $parent := 1 let $preceding-sibling := 1        let $preceding := 1 let $preserve := 1 let $processing-instruction := 1 let $return := 1        let $satisfies := 1 let $schema-attribute := 1 let $schema-element := 1 let $schema := 1        let $self := 1 let $some := 1 let $stable := 1 let $strict := 1 let $strip := 1        let $text := 1 let $then := 1 let $to := 1 let $treat := 1 let $typeswitch := 1        let $union := 1 let $unordered := 1 let $validate := 1 let $variable := 1 let $version := 1        let $where := 1 let $xquery := 1 return 2
let $a := . return fn:count(.[/=$a])
let $a := . return fn:count(.[/ is $a])
let $array:= ['a','b','c','d','e'] return 3=>$array()
let $a := string-join(?, "")          return $a(("foo", "bar", "baz"))
let $at :=            <attendees> <name last='Parker'             first='Peter'/> <name last='Barker' first='Bob'/> <name last='Parker'             first='Peter'/> </attendees>            return                   fn:deep-equal($at, $at/*)
let $at :=            <attendees> <name last='Parker'             first='Peter'/> <name last='Barker' first='Bob'/> <name last='Parker'             first='Peter'/> </attendees>            return                   fn:deep-equal($at/name[1], $at/name[2])
let $at :=            <attendees> <name last='Parker'             first='Peter'/> <name last='Barker' first='Bob'/> <name last='Parker'             first='Peter'/> </attendees>            return                   fn:deep-equal($at/name[1], $at/name[3])
let $at :=            <attendees> <name last='Parker'             first='Peter'/> <name last='Barker' first='Bob'/> <name last='Parker'             first='Peter'/> </attendees>            return                   fn:deep-equal($at/name[1], 'Peter Parker')
let $attr1 := attribute attr { 'foo' } return let $attr2 := attribute attr { 'bar' } return <a>{$attr1, $attr2 }</a>
let $attribute as attribute(*) := attribute foo { } return count($attribute/self::*:bar)
let $attribute as attribute(*) := attribute foo { } return count($attribute/self::bar)
let $attribute as attribute(foo) := attribute foo { }              return count($attribute/self::*:bar)
let $attribute as attribute(foo) := attribute foo { } return count($attribute/self::bar)
let $a := /works/employee[@gender='female']/@name return tail($a)/string()
let $a := /works/employee return count(tail($a/z))
let $a := /works/* return (head($a) is $a[1])
let $a := /works return head($a/*)/string(@name)
let $a := /works return name(head($a))
let $bonus := 10,              $outer := function($x) {                 let $inner := function($y) {$y + $x + $bonus}                 return $inner(5)              }          return $outer(3)
let $calc := map{             "+" : function($a, $b) {$a + $b},             "-" : function($a, $b) {$a - $b},             "*" : function($a, $b) {$a * $b},             "/" : function($a, $b) {$a div $b}}          return $calc("*")(2,3)
let $cat := (/) return (data($cat//number))
let $cat := (/) return (data($cat//product[1]/colorChoices))
let $cat := (/) return (data($cat//product[1]/@dept))
let $cat := (/) return (data($cat//product[1]/number))
let $cat := (/) return (data($cat//product[4]/desc))
let $comment as comment() := <!--comment--> return count($comment/self::*)
let $comment as comment() := <!--comment--> return count($comment/self::*:foo)
let $comment as comment() := <!--comment--> return count($comment/self::foo)
let $data := (/employees)               return filter($data/emp, function($x as element(emp)){xs:int($x/@salary) lt 300})
let $d := codepoints-to-string(13) return (          (every $s in tokenize(' '||$d||'a '||$d||'b', ',') satisfies (matches($s, '^(?:\n\ra\n\rb)$'))) and          (every $s in tokenize('', ',') satisfies not(matches($s, '^(?:\n\ra\n\rb)$'))))
let $d := codepoints-to-string(13) return (         matches($d||$d||'a'||$d||$d||'b'||$d||$d,          '^\r\ra\r\rb\r\r$'),         matches($d||$d||'a'||$d||$d||'b'||$d||$d,          '^\r+a\r+b\r+$'),         matches($d||$d||'b'||$d||$d||'a'||$d||$d,          '^\r\ra\r\rb\r\r$'),         matches($d||$d||'a'||$d||$d||'b'||$d||' ',     '^\r\ra\r\rb\r\r$'))
let $d := codepoints-to-string(13) return (         matches('a'||$d||' b', '^(?:a\r\nb)$'), matches('ab', '^(?:a\r\nb)$'))
let $d := current-date() return (['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])?($d)
let $d := current-date() return (['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[ .?($d) = 'b']
let $d := current-date() return (['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[ ?($d) = 'b']
let $d := function($x) {$x + .?2} return $d(12)
let $d := function($x) {$x?2} return $d([12, 13])
let $doc1 := <?cheese brie?> let $doc2 := <?cheese stilton?> return deep-equal($doc1, $doc2)
let $doc1 := <doc><?processing-instruction content ?></doc> let $doc2 := <doc><!--comment--></doc> return deep-equal($doc1, $doc2)
let $doc1 := <?foo bar?> let $doc2 := <?foo bar?> return deep-equal($doc1, $doc2)
let $doc1 := <?foo test?> let $doc2 := <?bar test?> return deep-equal($doc1, $doc2)
let $doc :=     <catalog>        <product dept="WMN">         <number>557</number>         <name language="en">Fleece Pullover</name>         <colorChoices>navy black</colorChoices>        </product>        <product dept="ACC">         <number>563</number>         <name language="en">Floppy Sun Hat</name>        </product>        <product dept="ACC">         <number>443</number>         <name language="en">Deluxe Travel Bag</name>        </product>        <product dept="MEN">         <number>784</number>         <name language="en">Cotton Dress Shirt</name>         <colorChoices>white gray</colorChoices>         <desc>Our <i>favorite</i> shirt!</desc>        </product>    </catalog>    let $prods := $doc//product    for $prod in $prods    where $prod << $prods[@dept = $prod/@dept][last()]    return $prod
let $doc :=            <doc>   <chap>     <section xml:id="xyz"/>   </chap> </doc>            return                   $doc//section ! fn:string-join(ancestor-or-self::*/name(), '/')
let $doc :=            <doc>   <chap>     <section xml:id="xyz"/>   </chap> </doc>            return                   $doc//@xml:id ! fn:string-join((node-name(), '="', ., '"'))
let $doc := (/)          return (11 to 15)!             (for $file at $c in $doc//File             where $c = last()             return string($file/FileName))
let $e := (0,1) return $e eq 0
let $e := (1,2) return $e eq 0
let $e := <a attr1 = "abc1"/>        return exists($e/self::Q{}*)
let $e := <a attr1 = "abc1"/>        return exists($e/self::Q{}:*)
let $e := <a attr1 = "abc1"/>        return exists($e/self::Q{}a)
let $e := <a attr1 = "abc1" xmlns="http://example.org/nametest-19"/>        return exists($e/self::Q{http://example.org/nametest-19}*)
let $e := <a attr1 = "abc1" xmlns="http://example.org/nametest-19"/>        return exists($e/self::Q{http://example.org/nametest-19}a)
let $e := <e><a>1</a><b>2</b><c>3</c></e>          return fn:string-join($e/*)
let $e := <e><a>1</a><b></b><c>3</c></e>          return fn:string-join($e/*)
let $e := <e><a>1</a><b></b><c>3</c></e>          return fn:string-join($e/d)
let $element as element(foo) := <foo/> return count($element/self::*:bar)
let $element as element(foo) := <foo/> return count($element/self::bar)
let $element as element(*) := <foo/> return count($element/self::*:bar)
let $element as element(*) := <foo/> return count($element/self::bar)
let $emp :=                         <employee xml:id="ID21256">                <empnr>E21256</empnr>                <first>John</first>                <last>Brown</last>             </employee>                      return                   fn:path($emp)
let $emp :=                         <employee xml:id="ID21256">                <empnr>E21256</empnr>                <first>John</first>                <last>Brown</last>             </employee>                      return                   fn:path($emp/empnr)
let $emp :=                         <employee xml:id="ID21256">                <empnr>E21256</empnr>                <first>John</first>                <last>Brown</last>             </employee>                      return                   fn:path($emp/@xml:id)
let $ex :=    <bla><n>10</n>       <n>123</n>       <n> 1234 </n>       <n> 2345.6 </n>       <n>          1555       </n>       <n> 12345 </n>    </bla>    return    $ex//n[.>1000] ! xs:decimal(.)
let $ex :=    <bla><n> -2 </n>       <n> -3.0e5 </n>       <n> +2345.6e0 </n>       <n>          +5678e0       </n>       <n>          1.2345e4       </n>       <n>          5.6789e+4       </n>       <n>          INF       </n>    </bla>    return    $ex//n[.>1000] ! xs:double(.)
let $exponent-separator := 1         return 2
let $f:= (ceiling#1, floor#1, round#1, abs#1)=>head() return 4.54=>$f()
let $f:= "ceiling" return 5.4=>$f()
let $f := concat#123456, $n := function-name($f)          return (local-name-from-QName($n), namespace-uri-from-QName($n), function-arity($f))
let $f := concat#8 return $f('a','b','c','d','e','f','g','h')
let $f := false#0 return 3[$f()]
let $f := fn:concat#3(?, '*', ?) let $g := $f('[', ?) return <out>{$g(']')}</out>
let $f := fn:contains(?, "e")          return for $s in ("Mike", "John", "Dave", "Mary", "Jane") return $f($s)
let $f := fn:function-name#1, $n := function-name($f)          return (local-name-from-QName($n), namespace-uri-from-QName($n), function-arity($f))
let $f := fn:round#1 return $f(1.2345)
let $f := fn:substring-before#2(?, '-') return <out>{$f('the-end-of-the-world')}</out>
let $f := function($a, $b){($b, $a)} return fold-right(1 to 5, (), $f)
let $f := function($a as xs:integer, $b as xs:integer) as xs:integer {           data(<a>{$a}{$b}</a>)         }         return $f(12, 34)
let $f := function($a as xs:string, $b as xs:string) {              starts-with($a, $b) and ends-with($a, $b)}(?, 'a')          return <out>{$f('abracadabra')}</out>
let $f := function($a) { node-name(.), $a }          return <a/>/$f(5)
let $f := function($ff as (function(item()) as item()), $s as xs:string){$ff($ff($s))} return           for-each((upper-case#1, lower-case#1, normalize-space#1, concat(?, '!')), $f(?, ' Say NO! '))
let $f := function ($in as xs:boolean) as xs:boolean { $in }          return $f(<a>0</a>)
let $f := function($Q{''}a, $Q{http:}a) { $Q{''}a + $Q{http:}a }          return $f(15, 27)
let $f := function($x){$x+1} return $f(2)
let $f := function($x as xs:double) {1 to $x}          return $f(3)
let $f := function($x as xs:double*){for-each($x,round#1)} return $f((1.2345, 6.789))
let $f := function($x as xs:integer) as xs:integer { (: there's nothing here :) }          return $f(2)
let $f := function($x as xs:integer) as xs:integer? { (: there's nothing here :)}          return $f(2)
let $f := function($x as xs:string) as xs:string { upper-case($x) }          let $n := function-name($f)          return <a loc="{local-name-from-QName($n)}" uri="{namespace-uri-from-QName($n)}"          arity="{function-arity($f)}" eloc="{empty(local-name-from-QName($n))}" euri="{empty(namespace-uri-from-QName($n))}"/>
let $f := function($x) {}          return $f(2)
let $f := function($x) { (: there's nothing here :)}          return $f(2)
let $f := function() { fn:boolean(.) } return $f()
let $f := function-lookup(fn:QName('http://www.w3.org/2001/XMLSchema', 'dateTimeStamp'), 1)       return if (exists($f)) then year-from-dateTime($f('2012-05-25T11:42:00+01:00')) else 2012
let $f := function-lookup(QName("http://exist-db.org/xquery/datetime", "days-in-month"), 1)         return if (exists($f)) then $f(xs:date("2012-02-28")) else "not-available"
let $f := function-lookup(QName("http://exslt.org/dates-and-times", "month-abbreviation"), 1)         return if (exists($f)) then $f("2012-02-28") else "not-available"
let $f :=function() { subsequence((1, 2, 3), 1) } return $f()
let $f :=function() { subsequence(subsequence((1, 2, 3, 4), 3, 1), 1, 4) } return $f()
let $f := if (current-date() gt xs:date('1900-01-01')) then head#1 else (abs#1, abs#1, abs#1, abs#1)         return $f[1](/works/cucumber)
let $f := if (current-date() gt xs:date('1900-01-01')) then head#1 else count#1         return $f(5 to 10)
let $firstSeq := (<a/>, <b/>, <e><c/></e>) let $secondSeq := (<a attr=""/>, <b>text</b>, <e><c/></e>) return some $i in $firstSeq satisfies $secondSeq[deep-equal(.,$i)]
let $f:= tokenize#1 return "the cat sat on the mat"=>$f()=>count()
let $f:= tokenize#2 return "the cat sat on the mat"=>($f)("\s+")=>count()
let $f:= tokenize#2 return "the cat sat on the mat"=>$f("\s+")=>count()
let $f := xs:date#1 return $f('2008-01-31')
let $f := xs:dateTime#1, $n := function-name($f)          return (local-name-from-QName($n), namespace-uri-from-QName($n), function-arity($f))
let $highbid := max($bids//bid_tuple/bid)          return <result> { for $item in $items//item_tuple,                                $b in $bids//bid_tuple[itemno = $item/itemno]                            where $b/bid = $highbid                            return <expensive_item> { $item/itemno } { $item/description }                                      <high_bid>{ $highbid }</high_bid>                                   </expensive_item>                 } </result>
let $hours := function ($emp as element(employee)) as xs:integer { sum($emp/hours/xs:integer(.)) },                 $highest := function ($f as function(item()) as xs:anyAtomicType, $seq as item()*)  {                                fold-left($seq, (), function($highestSoFar as item()*, $this as item()*) as item()* {                           if (empty($highestSoFar))                           then $this                           else let $thisValue := $f($this),                                    $highestValue := $f($highestSoFar[1])                                return if ($thisValue gt $highestValue)                                       then $this                                       else if ($thisValue eq $highestValue)                                            then ($highestSoFar, $this)                                            else $highestSoFar                        })             }                          return $highest($hours, /works/employee)
let $i := (1, 2, 3) order by $i return $i
let $i := (1, 2, 3) stable order by $i return $i
let $i := (1, 3, 2), $b := (4, 6, 5) order by $b return $b
let $i := (1, 3, 2) order by $i return $i
let $i := (1, 3, 2) stable order by $i return $i
let $i := (1, 3) return (['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])?($i)
let $i := (1, 3) return (['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[ .?($i) = 'b']
let $i := (1, 3) return (['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[ ?($i) = 'b']
let $i := 1 return (['a', 'b'], ['c', 'd'])?($i)
let $i := 1 return (['a', 'b'], ['c', 'd'])[.?($i) eq 'c']
let $i := 1 return (['a', 'b'], ['c', 'd'])[?($i) eq 'c']
let $i2 := (//incision)[2] for $a in (//action)[. >> $i2][position()<=2] return $a//instrument
let $i := 5, $j := 20 * $i return $i, $j
let $i = 5 return 3
let $i := (<e>1</e>, <e>3</e>, <e>2</e>) order by $i return $i
let $i := (<e>1</e>, <e>3</e>, <e>2</e>) order by 1 return $i
let $i := (<e>1</e>, <e>3</e>, <e>2</e>) stable order by $i return $i
let $i := <e/>/(., 4, 5, <e/>/((<e/>, 2))) return ($i, $i)
let $i := <e> <a/> <b/> <c/> </e>/a , $t := $i/following-sibling::b return (($i union ($i, $i)), (($t, $t) union $t))
let $i := <e><e/><e/><e/><e/><e/><e/><e/><b xml:id="foo"/><e/></e>return id("foo", $i)
let $i := <e xmlns:p="http://example.com" p:anAttribute="attrValue"/> return <a>{$i/@*}</a>
let $i := <e xml:space="preserve"/> return <a>{$i/@*}</a>
let $i := <html> <head/> <body> <p attr="foo"> </p> <p attr="boo"> </p> <p> </p> <p> </p> <p> </p> </body> </html>          return $i//p[1]/following::*
let $i in 5 return 3
let $in := <a><b>ABC</b><b>XYZ</b></a> return $in//string-to-codepoints(.)
let $index-of-node := function($seqParam as node()*, $srchParam as node()) as xs:integer*                                      { filter( 1 to count($seqParam), function($this as xs:integer) as xs:boolean                                               {$seqParam[$this] is $srchParam} ) },             $nodes := /*/*,             $perm := ($nodes[1], $nodes[2], $nodes[3], $nodes[1], $nodes[2], $nodes[4], $nodes[2], $nodes[1])              return $index-of-node($perm, $nodes[2])
let $in := for $x in //* order by local-name($x) return $x             return deep-equal(fn:innermost(($in, $in))/local-name(), fn:innermost(//*)/local-name())
let $in := for $x in //* order by local-name($x) return $x             return deep-equal(fn:innermost($in)/local-name(), fn:innermost(//*)/local-name())
let $in := for $x in //* order by local-name($x) return $x             return deep-equal(fn:outermost(($in, $in))/local-name(), fn:outermost(//*)/local-name())
let $in := for $x in //* order by local-name($x) return $x             return deep-equal(fn:outermost($in)/local-name(), fn:outermost(//*)/local-name())
let $initial := fn:substring(?, 1, 1) return                   fn:function-arity($initial)
let $initial := fn:substring(?, 1, 1)              return fn:function-name( $initial )
let $in := <r> <e xmlns="http://example.com/&lt;&gt;&quot;&apos;"""/> <e xmlns='http://example.com/&lt;&gt;&quot;&apos;'''/> <p:e xmlns:p="http://example.com/&lt;&gt;&quot;&apos;"""/> <p:e xmlns:p='http://example.com/&lt;&gt;&quot;&apos;'''/> </r> return <r>{for $n in $in/*/namespace-uri(.) return <e ns="{$n}"/>}</r>
let $in-xml-2 := <product dept="MEN"> <number>784</number> <name language="en">Cotton Dress Shirt</name> <colorChoices>white gray</colorChoices> <desc>Our <i>favorite</i> shirt!</desc> </product> return (string($in-xml-2/@dept))
let $in-xml-2 := <product dept="MEN"> <number>784</number> <name language="en">Cotton Dress Shirt</name> <colorChoices>white gray</colorChoices> <desc>Our <i>favorite</i> shirt!</desc> </product> return (string($in-xml-2/desc))
let $in-xml-2 := <product dept="MEN"> <number>784</number> <name language="en">Cotton Dress Shirt</name> <colorChoices>white gray</colorChoices> <desc>Our <i>favorite</i> shirt!</desc> </product> return (string($in-xml-2/number))
let $in-xml-2 := <product dept="MEN"> <number>784</number> <name language="en">Cotton Dress Shirt</name> <colorChoices>white gray</colorChoices> <desc>Our <i>favorite</i> shirt!</desc> </product> return (string($in-xml-2/number), string($in-xml-2/desc), string($in-xml-2/@dept))
let $in-xml := <a><x>123</x></a> return (root($in-xml/x))
let $in-xml := <in-xml> <a>1</a> <c>2</c> <a>3</a> <a>4</a> <a>5</a> </in-xml> return ($in-xml/a[position() > 2])
let $in-xml := <in-xml> <a>1</a> <c>2</c> <a>3</a> <a>4</a> <a>5</a> </in-xml> return ($in-xml/a[position() = 3])
let $in-xml := <in-xml> <a>1</a> <c>2</c> <a>3</a> <a>4</a> <a>5</a> </in-xml> return ($in-xml/*[position() > 2])
let $in-xml := <in-xml> <a>1</a> <c>2</c> <a>3</a> <a>4</a> <a>5</a> </in-xml> return ($in-xml/*[position() > 2], $in-xml/a[position() > 2], $in-xml/a[position() = 3])
let $in-xml := <in-xml> <a></a> <b/> <c>xyz</c> </in-xml> return (empty( () ))
let $in-xml := <in-xml> <a></a> <b/> <c>xyz</c> </in-xml> return (empty($in-xml/a))
let $in-xml := <in-xml> <a></a> <b/> <c>xyz</c> </in-xml> return (empty($in-xml/b))
let $in-xml := <in-xml> <a></a> <b/> <c>xyz</c> </in-xml> return (empty($in-xml/c))
let $in-xml := <in-xml> <a></a> <b/> <c>xyz</c> </in-xml> return (empty($in-xml/foo))
let $in-xml := <in-xml> <a></a> <b/> <c>xyz</c> </in-xml> return (empty(0))
let $in-xml := <in-xml> <a></a> <b/> <c>xyz</c> </in-xml> return (empty( ('a', 'b', 'c') ))
let $in-xml := <in-xml> <a></a> <b/> <c>xyz</c> </in-xml> return (empty( ('a', 'b', 'c') ), empty( () ), empty(0), empty($in-xml/a), empty($in-xml/b), empty($in-xml/c), empty($in-xml/foo))
let $item := $items//item_tuple [end_date >= xs:date("1999-03-01") and end_date <= xs:date("1999-03-31")]              return <item_count> { count($item) } </item_count>
let $items := for $x in 1 to 100 return $x mod 10, $distinct-items := for $y in 1 to (count($items) idiv 10) return $y mod 10 for $dist in $distinct-items return if ($dist = 0) then 0 else min( for $item in $items where $item = $dist return fn:round(1000 div $item))
let $i := (xs:date("2001-02-03"), xs:time("01:02:03Z")) order by $i return $i
let $i := (xs:date("2001-02-03"), xs:time("01:02:03Z")) stable order by $i return $i
let $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) order by $i[1] return $i
let $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) order by $i return $i
let $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) stable order by $i[1] return $i
let $i := (xs:hexBinary("FF"), xs:hexBinary("FF")) stable order by $i return $i
let $i := (xs:hexBinary("FF"), xs:time("03:03:03Z"), xs:hexBinary("FF")) order by $i[1] return $i
let $i := (xs:hexBinary("FF"), xs:time("03:03:03Z"), xs:hexBinary("FF")) stable order by $i[1] return $i
let $k := 2 to 3 return ['A', 'B', 'C']?($k)
let $m := array {                 true(),                 true(),                 false(),                 true(),                 true(),                 false(),                 false() }           let $indices := (1 to 7)           return fn:filter($indices,$m)
let $m:= map{1:2, 2:4, 3:6} return 2=>$m()
let $m := map{'a':1} return map:size(map{$m?a:true()})
let $m := map {                 "Tuesday" : true(),                 "Wednesday" : true(),                 "Friday" : true(),                 "Monday" : true(),                 "Sunday" : false(),                 "Saturday" : false() }           let $days := ("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday")                return fn:filter($days,$m)
let $m := map {                 "Tuesday" : true(),                 "Wednesday" : true(),                 "Thursday" : false(),                 "Friday" : true(),                 "Monday" : true(),                 "Sunday" : false(),                 "Saturday" : false() }           let $days := ("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday")                return fn:filter($days,$m)
let $name := "ncname" return <e/>/processing-instruction($name))
let $NaN := 1         let $allowing := 1         let $ancestor-or-self := 1         let $ancestor := 1         let $and := 1         let $as := 1         let $ascending := 1         let $at := 1         let $attribute := 1         let $base-uri := 1         let $boundary-space := 1         let $by := 1         let $case := 1         let $cast := 1         let $castable := 1         let $catch := 1         let $child := 1         let $collation := 1         let $comment := 1         let $construction := 1         let $context := 1         let $copy-namespaces := 1         let $count := 1         let $decimal-format := 1         let $decimal-separator := 1         let $declare := 1         let $default := 1         let $descendant-or-self := 1         let $descendant := 1         let $descending := 1         let $digit := 1         let $div := 1         let $document-node := 1         let $document := 1         let $element := 1         let $else := 1         let $empty-sequence := 1         let $empty := 1         let $encoding := 1         let $end := 1         let $eq := 1         let $every := 1         let $except := 1         let $external := 1         let $following-sibling := 1         let $following := 1         let $for := 1         let $function := 1         let $ge := 1         let $greatest := 1         let $group := 1         let $grouping-separator := 1         let $gt := 1         let $idiv := 1         let $if := 1         let $import := 1         let $in := 1         let $infinity := 1         let $inherit := 1         let $instance := 1         let $intersect := 1         let $is := 1         let $item := 1         let $lax := 1         let $le := 1         let $least := 1         let $let := 1         let $lt := 1         let $minus-sign := 1         let $mod := 1         let $module := 1         let $namespace-node := 1         let $namespace := 1         let $ne := 1         let $next := 1         let $no-inherit := 1         let $no-preserve := 1         let $node := 1         let $of := 1         let $only := 1         let $option := 1         let $or := 1         let $order := 1         let $ordered := 1         let $ordering := 1         let $parent := 1         let $pattern-separator := 1         let $per-mille := 1         let $percent := 1         let $preceding-sibling := 1         let $preceding := 1         let $preserve := 1         let $previous := 1         let $processing-instruction := 1         let $return := 1         let $satisfies := 1         let $schema-attribute := 1         let $schema-element := 1         let $schema := 1         let $self := 1         let $sliding := 1         let $some := 1         let $stable := 1         let $start := 1         let $strict := 1         let $strip := 1         let $switch := 1         let $text := 1         let $then := 1         let $to := 1         let $treat := 1         let $try := 1         let $tumbling := 1         let $type := 1         let $typeswitch := 1         let $union := 1         let $unordered := 1         let $validate := 1         let $variable := 1         let $version := 1         let $when := 1         let $where := 1         let $window := 1         let $xquery := 1         let $zero-digit := 1         return 2
let $node := <a> <b/> <c/> </a>         return not(exactly-one($node/b[1]) << exactly-one($node/c[1]))
let $node := <a> <b/> <c/> </a>         return not(exactly-one($node/b[1]) >> exactly-one($node/c[1]))
let $node := <a> <b/> <c/> </a>         return not(exactly-one($node/b[1]) is exactly-one($node/c[1]))
let $node := <a> <b/> <c/> </a>         return not(not(exactly-one($node/b[1]) << exactly-one($node/c[1])))
let $node := <a> <b/> <c/> </a>         return not(not(exactly-one($node/b[1]) >> exactly-one($node/c[1])))
let $node := <a> <b/> <c/> </a>         return not(not(exactly-one($node/b[1]) is exactly-one($node/c[1])))
let $numbers := (1, 2, 1.3, 3e3, xs:double("NaN"), xs:double("-INF"), xs:double("INF")) return (for $i in $numbers order by $i empty least return $i, "SEP", for $i in $numbers order by $i empty greatest return $i)
let $numbers := (1, 2, 1.3, 3e3, xs:double("NaN"), xs:double("-INF"), xs:double("INF")) return (for $i in $numbers stable order by $i empty least return $i, "SEP", for $i in $numbers order by $i empty greatest return $i)
let $numbers := (<e>NaN</e>, <e/>, <e/>, <e>NaN</e>, <e>NaN</e>, <e>INF</e>, <e>NaN</e>, <e/>, <e>3</e>, comment{"3"}) return (for $i in $numbers order by xs:double($i/text()) empty least return xs:double($i/text()), "SEP", for $i in $numbers order by xs:double($i/text()) empty greatest return xs:double($i/text()))
let $numbers := (<e>NaN</e>, <e/>, <e/>, <e>NaN</e>, <e>NaN</e>, <e>INF</e>, <e>NaN</e>, <e/>, <e>3</e>, comment{"3"}) return (for $i in $numbers stable order by xs:double($i/text()) empty least return xs:double($i/text()), "SEP", for $i in $numbers stable order by xs:double($i/text()) empty greatest return xs:double($i/text()))
let $ops := substring-before(?, 2) return $ops('Michael Kay')
let $ops := substring-before('abc', ' ', (), ?) return $ops('Michael Kay')
let $ops := substring-before(?, ?) return $ops('Michael Kay')
let $ordDoc := (/) return (avg( () ))
let $ordDoc := (/) return (avg($ordDoc//item/@quantity))
let $ordDoc := (/) return (boolean( () ))
let $ordDoc := (/) return (boolean(''))
let $ordDoc := (/) return (boolean($ordDoc/noSuchChild))
let $ordDoc := (/) return (boolean($ordDoc/order[1]))
let $ordDoc := (/) return (boolean('0'))
let $ordDoc := (/) return (boolean(0))
let $ordDoc := (/) return (boolean(<a>false</a>))
let $ordDoc := (/) return (boolean( () ), boolean(''), boolean(0), boolean('0'), boolean('false'), boolean(xs:float('NaN')), boolean($ordDoc/order[1]), boolean($ordDoc/noSuchChild), boolean(<a>false</a>))
let $ordDoc := (/) return (boolean('false'))
let $ordDoc := (/) return (boolean(xs:float('NaN')))
let $ordDoc := (/) return (count( () ))
let $ordDoc := (/) return (count($ordDoc//item))
let $ordDoc := (/) return (count( (1, 2, 3) ))
let $ordDoc := (/) return (count( (1, 2, 3, () ) ))
let $ordDoc := (/) return (max($ordDoc//item/string(@dept)))
let $ordDoc := (/) return (max( 2 ))
let $ordDoc := (/) return (max( (2, 1, 5, 4, 3) ))
let $ordDoc := (/) return (max( (2, 1, 5, 4, 3) ), max( ('a', 'b', 'c') ), max( 2 ), max($ordDoc//item/string(@dept)))
let $ordDoc := (/) return (max( ('a', 'b', 'c') ))
let $ordDoc := (/) return (min($ordDoc//item/@color/string(.)))
let $ordDoc := (/) return (min($ordDoc//item//string(@color)))
let $ordDoc := (/) return (min( (2.0, 1, 3.5, 4) ))
let $ordDoc := (/) return (min( (2.0, 1, 3.5, 4) ), min( ('a', 'b', 'c') ), min($ordDoc//item//string(@color)), min($ordDoc//item/@color/string(.)))
let $ordDoc := (/) return (min( ('a', 'b', 'c') ))
let $ordDoc := (/) return (sum( () ))
let $ordDoc := (/) return (sum( (), () ))
let $ordDoc := (/) return (sum($ordDoc//item/@quantity))
let $ordDoc := (/) return (sum( (1, 2, 3) ))
let $ordDoc := (/) return (sum( (1, 2, 3, () ) ))
let $outer := function($x) {             let $inner := function($y) {$y + $x}             return $inner(5)          }          return $outer(3)
let $para :=             <para>In a hole in the ground there lived a <term author="Tolkien">hobbit</term>.</para>                      return                   data($para)
let $para :=             <para>In a hole in the ground there lived a <term author="Tolkien">hobbit</term>.</para>                      return                   data($para/term/@author)
let $para :=             <para>In a hole in the ground there lived a <term author="Tolkien">hobbit</term>.</para>                      return                   string($para)
let $pi := function(){3.14159} return $pi()
let $poem :=             <poem author="Wilhelm Busch"> Kaum hat dies der Hahn gesehen, Fngt er auch schon an zu krhen: Kikeriki! Kikikerikih!! Tak, tak, tak! - da kommen sie. </poem>            return                   fn:matches($poem, "^Kaum.*gesehen,$")
let $poem :=             <poem author="Wilhelm Busch"> Kaum hat dies der Hahn gesehen, Fngt er auch schon an zu krhen: Kikeriki! Kikikerikih!! Tak, tak, tak! - da kommen sie. </poem>            return                   fn:matches($poem, "Kaum.*krhen")
let $po :=            <PurchaseOrder> <line-item>          <description>Large widget</description> <price>8.95</price>          <quantity>5.0</quantity> </line-item> <line-item>          <description>Small widget</description> <price>3.99</price>          <quantity>2.0</quantity> </line-item> <line-item>          <description>Tiny widget</description> <price>1.49</price>a          <quantity>805</quantity> </line-item>          </PurchaseOrder>            return                     let $item1 := $po/line-item[1]                       return                   fn:number($item1/quantity)
let $po :=            <PurchaseOrder> <line-item>          <description>Large widget</description> <price>8.95</price>          <quantity>5.0</quantity> </line-item> <line-item>          <description>Small widget</description> <price>3.99</price>          <quantity>2.0</quantity> </line-item> <line-item>          <description>Tiny widget</description> <price>1.49</price>a          <quantity>805</quantity> </line-item>          </PurchaseOrder>            return                     let $item1 := $po/line-item[1]                       return                     let $item2 := $po/line-item[2]                       return                     let $seq1 := ($item1, $item2)                       return                   fn:count($seq1)
let $po :=            <PurchaseOrder> <line-item>          <description>Large widget</description> <price>8.95</price>          <quantity>5.0</quantity> </line-item> <line-item>          <description>Small widget</description> <price>3.99</price>          <quantity>2.0</quantity> </line-item> <line-item>          <description>Tiny widget</description> <price>1.49</price>a          <quantity>805</quantity> </line-item>          </PurchaseOrder>            return                     let $item2 := $po/line-item[2]                       return                   fn:number($item2/description)
let $priceDoc := (/) return ($priceDoc// prod/price[number() >          35])
let $priceDoc := (/) return (number( () ))
let $priceDoc := (/) return (number( $priceDoc//prod[1]/@currency))
let $priceDoc := (/) return (number( $priceDoc//prod[1]/price))
let $priceDoc := (/)           return (number( $priceDoc//prod[1]/price), number( $priceDoc//prod[1]/@currency),                            number('29.99'), number('ABC'), number( () ),                            $priceDoc// prod/price[number() > 35])
let $priceDoc := (/) return (number('29.99'))
let $priceDoc := (/) return (number('ABC'))
let $process := function($op, $x, $y) as function(*) {if ($op = "+") then function() {$x + $y} else function() {$x - $y}}          return $process("+", 3, 4)()
let $processing-instruction as processing-instruction() := <?processing instruction?>          return count($processing-instruction/self::*)
let $processing-instruction as processing-instruction() := <?processing instruction?>          return count($processing-instruction/self::*:processing)
let $processing-instruction as processing-instruction() := <?processing instruction?>          return count($processing-instruction/self::processing)
let $prod1 := <product dept='MEN' id='P123'> <number>784</number> </product> return let $prod2 := <product id='P123' dept='MEN'><!--comment--> <number>784</number> </product> return (deep-equal( $prod1, $prod2 ))
let $prod1 := <product dept='MEN' id='P123'> <number>784</number> </product> return let $prod2 := <product id='P123' dept='MEN'><!--comment--> <number>784</number> </product> return (deep-equal( $prod1/number, $prod2/number ))
let $prod1 := <product dept='MEN' id='P123'> <number>784</number> </product> return let $prod2 := <product id='P123' dept='MEN'><!--comment--> <number>784</number> </product> return (deep-equal( 1, 1 ))
let $prod1 := <product dept='MEN' id='P123'> <number>784</number> </product> return let $prod2 := <product id='P123' dept='MEN'><!--comment--> <number>784</number> </product> return (deep-equal( (1, 1), (1, 1) ))
let $prod1 := <product dept='MEN' id='P123'> <number>784</number> </product> return let $prod2 := <product id='P123' dept='MEN'><!--comment--> <number>784</number> </product> return (deep-equal( 1, 1 ), deep-equal( (1, 1), (1, 1) ), deep-equal( (1, 2), (1.0, 2.0) ), deep-equal( (1, 2), (2, 1) ), deep-equal( $prod1, $prod2 ), deep-equal( $prod1/number, $prod2/number ))
let $prod1 := <product dept='MEN' id='P123'> <number>784</number> </product> return let $prod2 := <product id='P123' dept='MEN'><!--comment--> <number>784</number> </product> return (deep-equal( (1, 2), (1.0, 2.0) ))
let $prod1 := <product dept='MEN' id='P123'> <number>784</number> </product> return let $prod2 := <product id='P123' dept='MEN'><!--comment--> <number>784</number> </product> return (deep-equal( (1, 2), (2, 1) ))
let $salary as xs:decimal := "cat" return $salary * 2
let $seq2 := (98.5, 98.3, 98.9)                       return                   fn:count($seq2)
let $seq2 := (98.5, 98.3, 98.9)                       return                   fn:count($seq2[. > 100])
let $seq3 := (3, 4, 5)                       return                   fn:avg($seq3)
let $seq3 := (3, 4, 5)                       return                   fn:avg(($seq3, xs:float('NaN')))
let $seq3 := (3, 4, 5)                       return                   fn:sum($seq3)
let $seq3 := ()                       return                   fn:count($seq3)
let $seq := ("item1", "item2", "item3", "item4", "item5")                       return                   fn:subsequence($seq, 3, 2)
let $seq := ("item1", "item2", "item3", "item4", "item5")                       return                   fn:subsequence($seq, 4)
let $string := ("&#xD;&#xA;&#x9; foobar &#xA;&#xD;&#x9;" cast as xs:NMTOKEN) return not(contains($string, '&#x9;') or contains($string, '&#xA;') or contains($string, '&#xD;') or string-length($string) ne 6)
let $text := "Peter Piper picked a peck of pickled peppers A peck of pickled peppers Peter Piper picked" let $tokens := tokenize($text, '\s') let $counter := function($result, $word){   let $word-count := $result[@value = $word]   return     if(empty($word-count)) then       ($result, <word value="{$word}" count="1" />)     else     (       $result except $word-count,       <word value="{$word-count/@value}" count="{number($word-count/@count) + 1}" />     ) } let $words := fold-left($tokens, (), $counter) return (   number($words[@value="Peter"]/@count),   number($words[@value="Piper"]/@count),   number($words[@value="pickled"]/@count) )
let $tree := <e> <a id="1"/> <a id="2"/> <a id="3"/> </e> for $i at $pos in ("a", "b", "c") return ($tree/a/@id = $pos, $pos)
let $tree := <e> <a id="1"/> <a id="2"/> <a id="3"/> </e> for $i at $pos in ("a", "b", "c") return ($tree/@id eq $pos, $pos)
let $t := true#0 return 3[$t()]
let $users := [map { "userid" : "W0342", "firstname" : "Walter", "lastname" : "Denisovich" }, map { "userid" : "M0535", "firstname" : "Mick", "lastname" : "Goulish" }]?*          let $holdings := [map { "userid" : "W0342", "ticker" : "DIS", "shares" : 153212312 }, map { "userid" : "M0535", "ticker" : "DIS", "shares" : 10 }, map { "userid" : "M0535", "ticker" : "AIG", "shares" : 23412 }]?*            return array {           for $u in $users           order by $u("userid")           return map { "userid" : $u("userid"),                         "first" :  $u("firstname"),                         "last" :   $u("lastname"),                         "holdings" : array {                           for $h in $holdings                           where $h("userid") = $u("userid")                           order by $h("ticker")         return map { "ticker" : $h("ticker"), "share" : $h("shares") }     }                  }         }
let $value := xs:byte(10.0) return $value cast as xs:float
let $value := xs:decimal(10.0) return $value cast as xs:float
let $value := xs:decimal(10E2) return $value cast as xs:double
let $value := xs:double(10E2) return $value cast as xs:decimal
let $value := xs:double(10E2) return $value cast as xs:int
let $value := xs:double(10E2) return $value cast as xs:integer
let $value := xs:double(10E2) return $value cast as xs:long
let $value := xs:double(10E2) return $value cast as xs:positiveInteger
let $value := xs:double(10E2) return $value cast as xs:short
let $value := xs:double(10E2) return $value cast as xs:unsignedLong
let $value := xs:float(10.0) return $value cast as xs:byte
let $value := xs:float(10.0) return $value cast as xs:decimal
let $value := xs:float(10.0) return $value cast as xs:int
let $value := xs:float(10.0) return $value cast as xs:long
let $value := xs:float(-10.0) return $value cast as xs:negativeInteger
let $value := xs:float(10.0) return $value cast as xs:nonNegativeInteger
let $value := xs:float(-10.0) return $value cast as xs:nonPositiveInteger
let $value := xs:float(10.0) return $value cast as xs:positiveInteger
let $value := xs:float(10.0) return $value cast as xs:short
let $value := xs:float(10.0) return $value cast as xs:unsignedByte
let $value := xs:float(10.0) return $value cast as xs:unsignedInt
let $value := xs:float(10.0) return $value cast as xs:unsignedLong
let $value := xs:float(10.0) return $value cast as xs:unsignedShort
let $value := xs:int(10.0) return $value cast as xs:float
let $value := xs:int(10E2) return $value cast as xs:double
let $value := xs:integer(10.0) return $value cast as xs:byte
let $value := xs:integer(10.0) return $value cast as xs:float
let $value := xs:integer(10.0) return $value cast as xs:int
let $value := xs:integer(10.0) return $value cast as xs:long
let $value := xs:integer(-10.0) return $value cast as xs:negativeInteger
let $value := xs:integer(10.0) return $value cast as xs:nonNegativeInteger
let $value := xs:integer(-10.0) return $value cast as xs:nonPositiveInteger
let $value := xs:integer(10.0) return $value cast as xs:positiveInteger
let $value := xs:integer(10.0) return $value cast as xs:short
let $value := xs:integer(10.0) return $value cast as xs:unsignedByte
let $value := xs:integer(10.0) return $value cast as xs:unsignedInt
let $value := xs:integer(10.0) return $value cast as xs:unsignedLong
let $value := xs:integer(10.0) return $value cast as xs:unsignedShort
let $value := xs:integer(10E2) return $value cast as xs:double
let $value := xs:long(10.0) return $value cast as xs:float
let $value := xs:long(10.0) return $value cast as xs:integer
let $value := xs:long(10.0) return $value cast as xs:nonNegativeInteger
let $value := xs:long(10E2) return $value cast as xs:double
let $value := xs:long(10) return $value cast as xs:byte
let $value := xs:long(10) return $value cast as xs:int
let $value := xs:long(-10) return $value cast as xs:negativeInteger
let $value := xs:long(10) return $value cast as xs:positiveInteger
let $value := xs:long(10) return $value cast as xs:short
let $value := xs:long(10) return $value cast as xs:unsignedInt
let $value := xs:long(10) return $value cast as xs:unsignedLong
let $value := xs:negativeInteger(-10.0) return $value cast as xs:float
let $value := xs:nonNegativeInteger(10.0) return $value cast as xs:float
let $value := xs:nonPositiveInteger(-10.0) return $value cast as xs:float
let $value := xs:positiveInteger(10.0) return $value cast as xs:float
let $value := xs:positiveInteger(10E2) return $value cast as xs:double
let $value := xs:short(10.0) return $value cast as xs:float
let $value := xs:short(10E2) return $value cast as xs:double
let $value := xs:unsignedByte(10.0) return $value cast as xs:float
let $value := xs:unsignedInt(10.0) return $value cast as xs:float
let $value := xs:unsignedLong(10.0) return $value cast as xs:float
let $value := xs:unsignedLong(10E2) return $value cast as xs:double
let $value := xs:unsignedShort(10.0) return $value cast as xs:float
let $var := 100 where fn:count(($var)) = 1 return fn:count(($var))
let $var := 100 where typeswitch($var) case $i as xs:string return fn:false() case $i as xs:integer return fn:true() default return fn:false() return $var
let $var := 1           where every $x in (1, 1) satisfies fn:string($var) = "1"           return fn:string($var )
let $var := 1           where some $x in (1, 2) satisfies fn:string($var) = "1"           return fn:string($var )
let $var := <a attr1 = "abc1"><b attr2 = "abc2">context2</b></a> return $var/b
let $var := <a attr1 = "abc1"><b attr2 = "abc2">context2</b></a> return $var/child::*
let $var := <a attr1 = "abc1"><b attr2 = "abc2">context2</b></a> return $var/child::*:b
let $var := <a attr1 = "abc1"><b attr2 = "abc2">context2</b></a> return $var/child::b
let $var := <a attr1 = "abc1"><b attr2 = "abc2">context2</b></a> return $var/child::pr:*
let $var := <a attr1 = "abc1"><b attr2 = "abc2">context2</b></a> return $var/child::pr:b
let $var := <a attr1 = "abc1"><b attr2 = "abc2">context2</b></a> return fn:count(($var/empty-node-list)[1])
let $var := <a attr1 = "abc1"><b attr2 = "abc2">context2</b></a> return fn:count(fn:namespace-uri(exactly-one($var/child::b)))
let $var := <a attr1 = "abc1"><b attr2 = "abc2">context2</b></a> return fn:node-name(exactly-one($var/b))
let $var := "abc" cast as xs:ENTITY return $var instance of xs:ENTITY
let $var := ("a","b","c") cast as xs:ENTITY return count($var) lt 10
let $var := <!-- A Comment Node --> return fn:root($var)
let $var := <anElement>An Element Content</anElement> return fn:root($var)
let $var := <!-- An Element Node --> return fn:count(fn:namespace-uri(fn:root($var)))
let $var := <anElement>Some content</anElement> return $var/20[child::text()]
let $var := <anElement>Some Content</anElement> return $var/ancestor-or-self::*
let $var := <anElement>Some Content</anElement> return fn:count($var/ancestor::*)
let $var := <anElement>Some Content</anElement> return fn:count($var/following::*)
let $var := <anElement>Some Content</anElement> return fn:count($var/preceding::*)
let $var := <anElement>Some Content</anElement> return fn:count($var/preceding-sibling::*)
let $var := <anElement>Some content</anElement> where $var is $var return $var is $var
let $var as xs:boolean := fn:false() return $var
let $var as xs:boolean := fn:not(fn:true()) return $var
let $var as xs:boolean := fn:true() and fn:true() return $var
let $var as xs:boolean := fn:true() return $var
let $var as xs:boolean := if (fn:true()) then fn:true() else fn:false() return $var
let $var as xs:dateTime := xs:dateTime("1999-05-31T13:20:00Z") return $var
let $var as xs:date := xs:date("1999-05-31Z") return $var
let $var as xs:decimal := 100 return $var
let $var as xs:double := 100E1 return $var
let $var as xs:float := xs:float(100) return $var
let $var as xs:integer := 100+200 return $var
let $var as xs:integer := 100 return $var
let $var as xs:integer := 100 return $var + 1
let $var as xs:integer := fn:count((100,200)) return $var
let $var as xs:integer := fn:string-length("A String") return $var
let $var as xs:string := "A String" return $var
let $var as xs:string := typeswitch(fn:true()) case $i as xs:boolean return "Test Passed" default return "Test failed" return $var
let $var as xs:string := xs:string(fn:true()) return $var
let $var as xs:string := xs:string((xs:decimal(100))) return $var
let $var as xs:string := xs:string((xs:double(100E2))) return $var
let $var as xs:string := xs:string((xs:integer(100))) return $var
let $var as xs:time := xs:time("21:23:00Z") return $var
let $var := element anElement {attribute anAttribute {"Attribute Value"}} return fn:root($var)
let $var := element anElement {"Element Content"} return fn:count(fn:namespace-uri(fn:root($var)))
let $var := element anElement {"Element Content"} return fn:root($var) is fn:root($var)
let $var := (fn:false()) where fn:not($var and fn:false()) return $var and fn:false()
let $var := (fn:false()) where fn:not($var or fn:false()) return $var or fn:false()
let $var := fn:max((xs:long(20),xs:short(13))) return $var instance of xs:integer
let $var := fn:min((xs:long(22),xs:short(10))) return $var instance of xs:integer
let $var := (fn:true()) where $var and fn:true() return $var and fn:true()
let $var := (fn:true()) where $var or fn:true() return $var or fn:true()
let $var := <?format role="output" ?> return fn:count(fn:namespace-uri(fn:root($var)))
let $var := <?format role="output" ?> return fn:root($var)
let $var := "String" where fn:string($var) = "String" return $var
let $var := "String" where fn:string-length($var) = 6 return fn:string-length($var)
let $var := text {"A text node"} return fn:count(fn:namespace-uri(fn:root($var)))
let $var := text {"a text Node"} return fn:root($var)
let $var := /works[1]/child::employee[12]/overtime return $var/child::* intersect $var/child::day
let $var := /works[1]/child::employee[12]/overtime return fn:count($var/child::* except $var/child::day)
let $var := /works/employee[12]/overtime return $var/child::*:day[1] | $var/child::*:day[2]
let $var := /works return fn:count($var/child::*)
let $var := /works return fn:count($var/child::*:employee)
let $var := /works return fn:count($var/child::employee)
let $var := xs:byte(120) cast as xs:unsignedByte return $var instance of xs:unsignedByte
let $var := xs:int(120) cast as xs:long return $var instance of xs:long
let $var := xs:long(120) cast as xs:int return $var instance of xs:int
let $var := xs:long(120) cast as xs:short return $var instance of xs:short
let $var := xs:nonNegativeInteger(120) cast as xs:positiveInteger return $var instance of xs:positiveInteger
let $var := xs:nonPositiveInteger(-120) cast as xs:negativeInteger return $var instance of xs:negativeInteger
let $var := xs:short(120) cast as xs:long return $var instance of xs:long
let $var := xs:short(120) cast as xs:unsignedShort return $var instance of xs:unsignedShort
let $var := xs:unsignedInt(120) cast as xs:unsignedShort return $var instance of xs:unsignedShort
let $var := xs:unsignedShort(120) cast as xs:unsignedInt return $var instance of xs:unsignedInt
let $void := function(){} return $void()
let $v := . return 1
let $week := map{0:"Sonntag", 1:"Montag", 2:"Dienstag",      3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 6:"Samstag"}                       return                   map:contains($week, 2)
let $week := map{0:"Sonntag", 1:"Montag", 2:"Dienstag",      3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 6:"Samstag"}                       return                   map:contains($week, 9)
let $week := map{0:"Sonntag", 1:"Montag", 2:"Dienstag",      3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 6:"Samstag"}                       return                   map:get($week, 4)
let $week := map{0:"Sonntag", 1:"Montag", 2:"Dienstag",      3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 6:"Samstag"}                       return                   map:get($week, 9)
let $week := map{0:"Sonntag", 1:"Montag", 2:"Dienstag",      3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 6:"Samstag"}                       return                   map:merge(($week, map{6:"Sonnabend"}), map{"duplicates":"combine"})
let $week := map{0:"Sonntag", 1:"Montag", 2:"Dienstag",      3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 6:"Samstag"}                       return                   map:merge(($week, map{6:"Sonnabend"}), map{"duplicates":"use-first"})
let $week := map{0:"Sonntag", 1:"Montag", 2:"Dienstag",      3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 6:"Samstag"}                       return                   map:merge(($week, map{6:"Sonnabend"}), map{"duplicates":"use-last"})
let $week := map{0:"Sonntag", 1:"Montag", 2:"Dienstag",      3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 6:"Samstag"}                       return                   map:merge(($week, map{7:"Unbekannt"}))
let $week := map{0:"Sonntag", 1:"Montag", 2:"Dienstag",        3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 6:"Samstag"}                       return                   map:put($week, -1, "Unbekannt")
let $week := map{0:"Sonntag", 1:"Montag", 2:"Dienstag",        3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 6:"Samstag"}                       return                   map:put($week, 6, "Sonnabend")
let $week := map{0:"Sonntag", 1:"Montag", 2:"Dienstag",        3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 6:"Samstag"}                       return                   map:remove($week, ())
let $week := map{0:"Sonntag", 1:"Montag", 2:"Dienstag",        3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 6:"Samstag"}                       return                   map:remove($week, (0, 6 to 7))
let $week := map{0:"Sonntag", 1:"Montag", 2:"Dienstag",        3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 6:"Samstag"}                       return                   map:remove($week, 23)
let $week := map{0:"Sonntag", 1:"Montag", 2:"Dienstag",        3:"Mittwoch", 4:"Donnerstag", 5:"Freitag", 6:"Samstag"}                       return                   map:remove($week, 4)
let $weirdo := function($x, $f) {if ($x=0) then 0 else $f($x - 1, $f)}           return $weirdo(12, $weirdo)
let $x := (0,0.1e-1,2.0,'a',"cat",'',true(), ('<a> <b> <c> 123 </c> </b> </a>')/a/b) return $x
let $x := (0,0.1e-1,2.0,'a',"cat",'',true()) return $x
let $x:=1, $y:=$x+1 return $x
let $x := "1", $y := $x+1 return $y
let $x:=1, $y:=<a>{$x+1}</a> return $y
let $x:=(1,2,3), $y:=$x+1 return $y
let $x := 1               let $array := [0,0,0]               for $i in 1 to array:size($array) + 1               return                  array:insert-before($array, $i, $x)
let $x := 1               let $array := [0,0,0]               for $i in 1 to array:size($array)               return                  array:put($array, $i, $x)
let $x :=(1 to 100)[. mod 5 eq 0], $y := $x[. mod 10 eq 0] return $y
let $x :=(1 to 100)[. mod 5 eq 0] return $x
let $x := (1 to 10)[. mod 2 = 0] return subsequence((0,$x),3,count($x) div 2)
let $x := 1 to 10          where $x = 1          return $x
let $x := 1 to 10          where count($x) = 1          return $x
let $x:= 4 return ($x<=3.2)=>boolean()
let $x:= 4 return $x<=3.2=>ceiling()
let $x := 92233720368547758+1 return $x
let $x := 92233720368547758 return $x
let $x := "92233720368547758" return $x
let $x:=<a>{1+1}</a> return $x
let $x := (<a> <b> <c> 123 </c> </b> </a>) return $x
let $x := <a><b/><c/><d/></a> return count(($x/(node() except b) | $x/(node() except b)))
let $x as xs:error := 1 return fn:true()
let $x := ( attribute a { "a" }, element b { "b" }, attribute c { "c" } ) return <foo> { $x } </foo>
let $x := <a xmlns="http://sj31/"><b/><c/><d/></a> return fn:string-join($x//*/node-name(), '-')
let $x := <c/>               let $array := [<a/>, <b/>]               let $insert1 := array:insert-before($array, 1, $x)               let $insert2 := array:insert-before($array, 2, $x)               for $element in (array:flatten($insert1) union array:flatten($insert2))               let $name := $element/name()               order by $name               return $name
let $x := <c/>               let $array := [<a/>, <b/>]               let $insert1 := array:put($array, 1, $x)               let $insert2 := array:put($array, 2, $x)               for $element in (array:flatten($insert1) union array:flatten($insert2))               let $name := $element/name()               order by $name               return $name
let $x := codepoints-to-string(12) return ($x = $x)
let $x := <e><f>1</f></e>        return $x/data()
let $x := exists((1 to 10)[. mod 2 = 0]) return (1 to 100)[position() mod 2 = 0 and position() mod 3 = 0 and $x]
let $x := function($a, $b) {$a + $b},               $y := function($a, $b) {$a - $b},              $c := function($x, $y) {$x = $y}          return $c($x, $y)
let $x:="hello", $y:=concat($x," there") return $y
let $x := map{"div":18} return $x?div
let $x := map{"div":81, "div-2":18} return $x?div-2
let $x := map{"else":18} return exists($x[?else = 18])
let $x := map{"else":81, "else-2":18} return exists($x[?else-2 = 18])
let $x := (/)        return $x /ancestor-or-self /ancestor /and /as /ascending /at /attribute        /base-uri /boundary-space /by        /case /cast /castable /child /collation /comment /construction /copy-namespaces        /declare /default /descendant-or-self /descendant /descending /div /document-node /document        /element /else /empty-sequence /empty /encoding /eq /every /except /external        /following-sibling /following /for /function        /ge /greatest /gt        /idiv /if /import /in /inherit /instance /intersect /is /item        /lax /le /least /let /lt         /mod /module /module         /namespace /ne /no-inherit /no-preserve /node         /of /option /or /order /ordered /ordering         /parent /preceding-sibling /preceding /preserve /processing-instruction         /return         /satisfies /schema-attribute /schema-element /schema /self /some /stable /strict /strip         /text /then /to /treat /typeswitch         /union /unordered         /validate /variable /version         /where        /xquery
let $x := (/)         return $x/exponent-separator
let $x := (/)         return $x         /NaN         /allowing         /ancestor-or-self         /ancestor         /and         /as         /ascending         /at         /attribute         /base-uri         /boundary-space         /by         /case         /cast         /castable         /catch         /child         /collation         /comment         /construction         /context         /copy-namespaces         /count         /decimal-format         /decimal-separator         /declare         /default         /descendant-or-self         /descendant         /descending         /digit         /div         /document-node         /document         /element         /else         /empty-sequence         /empty         /encoding         /end         /eq         /every         /except         /external         /following-sibling         /following         /for         /function         /ge         /greatest         /group         /grouping-separator         /gt         /idiv         /if         /import         /in         /infinity         /inherit         /instance         /intersect         /is         /item         /lax         /le         /least         /let         /lt         /minus-sign         /mod         /module         /namespace-node         /namespace         /ne         /next         /no-inherit         /no-preserve         /node         /of         /only         /option         /or         /order         /ordered         /ordering         /parent         /pattern-separator         /per-mille         /percent         /preceding-sibling         /preceding         /preserve         /previous         /processing-instruction         /return         /satisfies         /schema-attribute         /schema-element         /schema         /self         /sliding         /some         /stable         /start         /strict         /strip         /switch         /text         /then         /to         /treat         /try         /tumbling         /type         /typeswitch         /union         /unordered         /validate         /variable         /version         /when         /where         /window         /xquery         /zero-digit
let $x := (<x>1</x>, <y>2</y>) return $x / .?1
let $x := (<x>1</x>, <y>2</y>) return $x / ?1
let $x := <x/>            let $array := [<e/>, <f/>, <g/>]               for $i in 1 to array:size($array) + 1               return               array:insert-before($array, $i, $x)
let $x := <x/>            let $array := [<e/>, <f/>, <g/>]               for $i in 1 to array:size($array)               return               array:put($array, $i, $x)
let $x := xs:double("1.7976931348623157E308") return $x
let $x := year-from-date(current-date()) return count( 1 to $x ) = $x
let $x := zero-or-one((1 to 10)[. div 2 = 2])         return if(empty($x)) then () else xs:string($x)
let $x := zero-or-one((1 to 10)[. div 2 = 2])         return if(exists($x)) then xs:string($x) else ()
let $y := for $x in 1 to 10 return $x * $x return subsequence($y, count($y), 3)
let $z := (1 to 10)[. mod 2 = 0] return subsequence(for $x in $z return floor($x),2,4)
"line1 line2"
'line1 line2'
local:func-does-not-exist(1, 2, 3)
local:myFunction(1)
local-name(<elem attr="{attribute name {" content "}}"/>/@attr)
local-name(<elem attr="{comment {" content "}}"/>/@attr)
local-name(<elem attr="{processing-instruction name {" content "}}"/>/@attr)
(local-name-from-QName( () ))
local-name-from-QName()
local-name-from-QName(1, 2)
local-name-from-QName(function-name((upper-case#1, lower-case#1)[.("Mike") = "MIKE"]))
local-name-from-QName( QName("example.com/", "pre:lname")) eq "lname"
(local-name-from-QName( QName('http://datypic.com/prod', 'number')))
(local-name-from-QName( QName('http://datypic.com/prod', 'number')), local-name-from-QName(QName ('', 'number')), local-name-from-QName( () ))
(local-name-from-QName(QName ('', 'number')))
local-name(<?PREFIXxml content?>)
local-name(<?PREFIXxmlSUFFIX content?>)
local-name(unordered(<a><b/><c/></a>/*[1]))
::local:ncname
lower-case()
lower-case("ABc!D") eq "abc!d"
lower-case(()) eq ""
(lower-case('Query'))
(lower-case('QUERY'))
(lower-case('QUERY123'))
(lower-case('QUERY'), lower-case('Query'), lower-case('QUERY123'))
lower-case("string", "wrong param")
"&lt;"
"&lt; &gt; &amp; &quot; &apos; &#x48; &#48;" eq "< > &amp; "" ' &#x48; &#48;"
<!--<?&-&lt;&#x20;><![CDATA[x]]>-->
map()
(map{1.1:1, 2.2:2, 3.3:3},  map{1.1:2, 2.2:3, 3.3:4})?(2.2)
(map{1.1:1, 2.2:2, 3.3:3},  map{1.1:2, 2.2:3, 3.3:4})?2.2
(map{1.1:1, 2.2:2, 3.3:3},  map{1.1:2, 2.2:3, 3.3:4})[?2.2 = 3]
(map{1.1:1, 2.2:2, 3.3:3},  map{1.1:2, 2.2:3, 3.3:4})[?(2.2) = 3]?(3.3)
(map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4})?()
(map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4})[.?(1 to 2) = 3]
(map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4})[?(1 to 2) = 3]
(map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4})?2
(map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4})[.?2 eq 3]
(map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4})[?2 eq 3]
(map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4})[.?* = 3]
(map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4})[?* = 3]
(map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4})[exists(.?())]
(map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4})[exists(?())]
(map{1:1, 2:2, 3:3},  map{2:3, 3:4, 4:5})?(1 to 2)
map{1:1} eq 1
(map{'a-1':1, 'b-1':2, 'c-1':3},  map{'a-1':2, 'b-1':3, 'c-1':4})[.?b-1 eq 3]
(map{'a-1':1, 'b-1':2, 'c-1':3},  map{'a-1':2, 'b-1':3, 'c-1':4})[?b-1 eq 3]
(map{'a-1':1, 'b-1':2, 'c-1':3},  map{'a-1':2, 'b-1':3, 'c-1':4})?c-1
(map{'a-1':1, 'b-1':2, 'c-1':3},  map{'a-1':2, 'b-1':3, 'c-1':4})? (:confusing.?:) b-1
(map{'a-1':1, 'b-1':2, 'c-1':3},  map{'a-1':2, 'b-1':3, 'c-1':4})[.? (:confusing.?:) b-1 eq 3]
(map{'a-1':1, 'b-1':2, 'c-1':3},  map{'a-1':2, 'b-1':3, 'c-1':4})[? (:confusing?:) b-1 eq 3]
(map{'a':1, 'b':2, 'c':3},  map{'a':2, 'b':3, 'c':4})?b
(map{'a':1, 'b':2, 'c':3},  map{'a':2, 'b':3, 'c':4})[.?b eq 3]
(map{'a':1, 'b':2, 'c':3},  map{'a':2, 'b':3, 'c':4})[?b eq 3]
map:contains((), "a")
map:contains(("a", "b", "c"), "a")
map:contains(abs#1, "a")
map:contains(map{1:"Sunday",2:"Monday",3:"Tuesday",4.0e0:"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, 4)
map:contains(map{1:"Sunday",2:"Monday",3:"Tuesday",4:(),5:"Thursday",6:"Friday",7:"Saturday"}, 4)
map:contains(map{1:"Sunday",2:"Monday",3:"Tuesday",4:"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, 23)
map:contains(map{1:"Sunday",2:"Monday",3:"Tuesday",4:"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, 4)
map:contains(map{1:"Sunday",2:"Monday",3:"Tuesday",4:"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, 4.0e0)
map:contains(map{1:"Sunday",2:"Monday",3:"Tuesday",number('NaN'):"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, (1 to 5)[10])
map:contains(map{1:"Sunday",2:"Monday",3:"Tuesday",number('NaN'):"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, (1 to 5)[. mod 2 = 0])
map:contains(map{1:"Sunday",2:"Monday",3:"Tuesday",number('NaN'):"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, number('NaN'))
map:contains(map{1:"Sunday",2:"Monday",3:"Tuesday","urn:weds":"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, xs:anyURI("urn:weds"))
map:contains(map{1:"Sunday",2:"Monday",3:"Tuesday",xs:anyURI("urn:weds"):"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, number('NaN'))
map:contains(map{1:"Sunday",2:"Monday",3:"Tuesday",xs:anyURI("urn:weds"):"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, "urn:weds")
map:contains(map{}, 23)
map:contains(map{"abc":23, "xyz":()}, "xyz")
map:contains(map:entry(12, "bar"), xs:untypedAtomic("12"))
map:contains(map:entry("foo", "bar"), "baz")
map:contains(map:entry("foo", "bar"), "foo")
map:contains(map:entry("foo", "bar"), xs:untypedAtomic("foo"))
map:contains(map:entry(xs:untypedAtomic("12"), "bar"), 12)
map:contains(map:entry(xs:untypedAtomic("foo"), "bar"), "foo")
map:contains((map{}, map{"a":"b"}), "a")
map:contains(map{"su":"Sunday","mo":"Monday","tu":"Tuesday","we":"Wednesday","th":"Thursday","fr":"Friday","sa":"Saturday"}, "TH")
map:contains(map{}, "xyz")
map:contains(map{"xyz":23}, "xyz")
map{'decimal':true(), 'integer':true(), 'polygon':[11,22,33]}?polygon?2
[map{'decimal':true(), 'integer':true(), 'polygon':false()}, map{}] ?1?decimal
map{'decimal':true(), 'integer':true(), 'polygon':false()} ? Q{}integer
map:entry("M", "Monday")
map:entry(number('NaN'), 'NaN')
map:entry(xs:float('NaN'), 'NaN')
map{} eq ()
map{'f':floor#1, 'c':ceiling#1, 'r':round#1, 'a':abs#1}[1]?("c")(1.3)
map{'f':floor#1, 'c':ceiling#1, 'r':round#1, 'a':abs#1}?("c")(1.3)
map{'f':floor#1, 'c':ceiling#1, 'r':round#1, 'a':abs#1}?c(1.3)
map:for-each(map{"a":1, "b":2}, function($k,$v){$k})
map:for-each(map{"a":1, "b":2}, function($k,$v){$k||$v})
map:for-each(map{"a":1}, function($k,$v){$k})
map:for-each(map{}, concat#2)
map:for-each(map:entry("a", "1"), function($k,$v){$k})
map:for-each(map:merge(()), function($k,$v){$k||$v})
map:for-each(map:merge((map:entry("a",1), map:entry("a",2))), function($k,$v){$k})
map:for-each(map:merge((map:entry("a", "1"), map:entry("b", 2))), function($k,$v){$k})
map:for-each(map{number('NaN'):1,"b":2}, function($k,$v){$k})
map:for-each(map:remove(map{"a":1,"b":2}, "b"), function($k,$v){$k})
map:for-each(map:remove(map{"a":1,"b":2}, "c"), function($k,$v){$k})
map:for-each(map:remove(map:entry(1,2),1), function($k,$v){$k})
map:for-each(map:remove(map:remove(map{"a":1,"b":2},"b"),"a"), function($k,$v){$k})
map:get((), "a")
map:get(("a", "b", "c"), "a")
map:get(abs#1, "a")
map:get(map{1:"Sunday",2:"Monday",3:"Tuesday",4.0e0:"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, 4)
map:get(map{1:"Sunday",2:"Monday",3:"Tuesday",4:(),5:"Thursday",6:"Friday",7:"Saturday"}, 4)
map:get(map{1:"Sunday",2:"Monday",3:"Tuesday",4:"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, 23)
map:get(map{1:"Sunday",2:"Monday",3:"Tuesday",4:"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, 4)
map:get(map{1:"Sunday",2:"Monday",3:"Tuesday",4:"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, 4.0e0)
map:get(map{1:"Sunday",2:"Monday",3:"Tuesday",number('NaN'):"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, (1 to 5)[10])
map:get(map{1:"Sunday",2:"Monday",3:"Tuesday",number('NaN'):"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, (1 to 5)[. mod 2 = 0])
map:get(map{1:"Sunday",2:"Monday",3:"Tuesday",number('NaN'):"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, number('NaN'))
map:get(map{1:"Sunday",2:"Monday",3:"Tuesday","urn:weds":"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, xs:anyURI("urn:weds"))
map:get(map{1:"Sunday",2:"Monday",3:"Tuesday",xs:anyURI("urn:weds"):"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, number('NaN'))
map:get(map{1:"Sunday",2:"Monday",3:"Tuesday",xs:anyURI("urn:weds"):"Wednesday",5:"Thursday",6:"Friday",7:"Saturday"}, "urn:weds")
map:get(map{}, 23)
map:get(map:entry(12, "bar"), xs:untypedAtomic("12"))
map:get(map:entry(7,()), 7)
map:get(map:entry("foo", "bar"), "baz")
map:get(map:entry("foo", "bar"), "foo")
map:get(map:entry("foo", "bar"), xs:untypedAtomic("foo"))
map:get(map:entry(xs:untypedAtomic("12"), "bar"), 12)
map:get(map:entry(xs:untypedAtomic("foo"), "bar"), "foo")
map:get(map{"foo":"bar", "bar":"foo"}, xs:untypedAtomic("foo"))
map:get((map{}, map{"a":"b"}), "a")
map:get(map{number('NaN'):100, 12e6:101}, xs:float('NaN'))
map:get(map{"su":"Sunday","mo":"Monday","tu":"Tuesday","we":"Wednesday","th":"Thursday","fr":"Friday","sa":"Saturday"}, "TH")
map:get(map{xs:untypedAtomic("foo"):"bar", xs:untypedAtomic("bar"):"foo"}, "foo")
map:keys(map{})
map:keys(map{"a":1})
map:keys(map{"a":1, "b":2})
map:keys(map:entry("a", "1"))
map:keys(map:merge(()))
map:keys(map:merge((map:entry("a",1), map:entry("a",2))))
map:keys(map:merge((map:entry("a", "1"), map:entry("b", 2))))
map:keys(map{number('NaN'):1,"b":2})
map:keys(map:remove(map{"a":1,"b":2}, "b"))
map:keys(map:remove(map{"a":1,"b":2}, "c"))
map:keys(map:remove(map:entry(1,2),1))
map:keys(map:remove(map:remove(map{"a":1,"b":2},"b"),"a"))
map{} => map:put(xs:double('NaN'), 10) => map:put(xs:float('NaN'), 20) => map:size()
map:merge(())
map:merge()
map:merge((map:entry(0, "no"), map:entry(1, "yes")))
map:merge((map:entry("foo", 3), map:entry("foo", 4)))
map:merge((map:entry("foo", 3), map:entry("foo", 4)), map{"duplicates": "reject"})
map:merge((map:entry("foo", 3), map:entry("foo", 4)), map{"duplicates": "use-any"})
map:merge(map:for-each(map{"a":1, "b":2}, function($k,$v){map{$v : $k}}))
map:merge(map:for-each(map{"a":1, "b":2}, function($k,                   $v){map:entry($k, $v+1)}))
map{'or':true(), 'and':true(), 'but':false()} ? or or 2 = 3
map:remove(map{}, 1)
map:remove(map{"a":1}, "a")
map:remove(map:entry("a", "1"), "b")
map:remove(map:merge(()), "abcd")
map:remove(map:merge((map:entry("a", "1"), map:entry("b", 2))), "b")
map:remove(map:merge((map:entry("a", "1"), map:entry("b", 2))), "c")
map:size(<a><b>x</b></a>/map{* :b})
map:size(<a><b>x</b></a>/map{b:2})
map:size(<a><b>x</b></a>/map{*:b:b})
map:size(<a><b>x</b></a>/map{self::a: b})
map:size(<a><self>x</self></a>/map{self:2})
map:size(map {})
map:size(map{     })
map:size(map{})
map:size(map{(1 to 5)[. gt year-from-date(current-date())]:93})
map:size(map{(1 to 5)[. lt year-from-date(current-date())]:93})
map:size(map {2:<a>x{25}y</a>})
map:size(map {2:<a>x</a>})
map:size(map{2:map{3:4}})
map:size(map{"a":1})
map:size(map{"a":1, "b":2})
map:size(map {"a":2, })
map:size(map {,"a":2})
map:size(map{ "a" : 2 })
map:size(map{"a":2})
map:size(map {"a":2,3})
map:size(map { "a" : 2 , "b" : 3 })
map:size(map{"a":2,"b":3})
map:size(map {"a","b":2})
map:size(map {<a>x</a>:2})
map:size(map:entry("a", "1"))
map:size(map:merge(()))
map:size(map:merge((map:entry("a",1), map:entry("a",2))))
map:size(map:merge((map:entry("a", "1"), map:entry("b", 2))))
map:size(map{number('NaN'):1,"b":2})
map:size(map:remove(map{"a":1,"b":(2,3), "c":1 to 5}, ())) = 3
map:size(map:remove(map{"a":1,"b":2}, "b"))
map:size(map:remove(map{"a":1,"b":2}, "c"))
map:size(map:remove(map:entry(1,2),1))
map:size(map:remove(map:remove(map{"a":1,"b":2},"b"),"a"))
map:size(map{"true":1, "false":0})
map{'xs:decimal':true(), 'xs:integer':true(), 'xs:polygon':false()} ? xs:integer
map{xs:double('1.25'):0}             => map:remove(xs:float('1.25'))              => map:size()
matches('$', '^\$$') and not(matches('\$', '^\$$'))
matches('$$9', '((((((((((.))))))))))(\11)9')
matches('$$9', '(.)(\2)')
matches('$$9', '(.)\2')
matches('$', '[\$]') and not(matches('\$', '^[\$]$'))
matches("abcd", "1[asd\0]")
matches("abcd", "(asd)[\1]")
matches("abcd", "(asd)[asd\0]")
matches("abcd", "(asd)[asd\1]")
matches("abcdef", "abc.def")
matches("abcdef", "abc[-]def")
matches("abc&#x1D157;def", "abc.def")
matches("abc&#x1D157;def", "abc[&#x1D156;-&#x1D158;]def")
matches('alpha', 'alp${2,4}ha')
matches('alpha', 'alp$?ha')
matches('alpha', 'alp^+ha')
matches('alpha', 'alp^?ha')
matches('alpha', 'alpha$+') and not(matches('alphax', 'alpha$+'))
matches('a&#xD;&#xA;b', '^(?:a\r\nb)$'), matches('ab', '^(?:a\r\nb)$')
matches(format-dateTime(current-dateTime(), "[M01]/[D01]/[Y0001] at [H01]:[m01]:[s01]"), "[0-1][0-9]/[0-3][0-9]/[0-9]{4} at [0-9]{2}:[0-9]{2}:[0-9]{2}")
matches(format-dateTime(current-dateTime(), "[M01]/[D01]/[Y0001] at [H01]:[m01]:[s01]", (), (), ()), "../../.... at ..:..:..")
matches(format-dateTime(current-dateTime(), "[Y0001]-[M01]-[D01]", (), (), ()), "....-..-..")
matches(format-dateTime(current-dateTime(), "[Y0001]-[M01]-[D01]"), "[0-9]{4}-[0-9]{2}-[0-9]{2}")
matches("input")
matches("input", ())
matches("input", "\3")
matches("input", "pattern", "", ())
matches('qwerty','(')
matches('qwerty','((?>[^()]+)|\([^()]*\))+')
matches('qwerty','([[.]+)')
matches('qwerty','([[:]+)')
matches('qwerty','([[=]+)')
matches('qwerty',')')
matches('qwerty','))((')
matches('qwerty','*')
matches('qwerty','+')
matches('qwerty','++')
matches('qwerty',':(?:')
matches('qwerty','?')
matches('qwerty','[')
matches('qwerty','[>-=]')
matches('qwerty','[\]')
matches('qwerty','\')
matches('qwerty','\060(\061)?\061')
matches('qwerty','[^0-9]+(?>[0-9]+)3')
matches('qwerty','\1')
matches('qwerty','\10((((((((((a))))))))))')
matches('qwerty','{1}a')
matches('qwerty','()?(?(1)a|b)')
matches('qwerty','(?(1)a|b)()?')
matches('qwerty','(?(1?)a|b)')
matches('qwerty','(?(1)a|b|c)')
matches('qwerty','\1(abc)')
matches('qwerty','(?(1)a|b)(x)?')
matches('qwerty','\1([a-c]*)')
matches('qwerty','\1a(\d*){0,2}')
matches('qwerty','\1a(\d*){0,2}?')
matches('qwerty','\1a(\d*){2,}')
matches('qwerty','\1a(\d*){2,}?')
matches('qwerty','()(?(1)b|a)')
matches('qwerty','()?(?(1)b|a)')
matches('qwerty','(?(1)b|a)()')
matches('qwerty','(?(1)b|a)()?')
matches('qwerty','(?(1)b|a)(x)?')
matches('qwerty','\1\d(ab)')
matches('qwerty','([1-\P{Ll}][\p{Ll}]*)\s([\P{Ll}][\p{Ll}]*)')
matches('qwerty','\2')
matches('qwerty','(\2b*?([a-c]))*')
matches('qwerty','(\2b*?([a-c])){3}')
matches('qwerty','^(?:?(2)(\())blah(\))?$')
matches('qwerty','^(?:?(2)(\())blah(\)+)?$')
matches('qwerty','((\3|b)\2(a)){2,}')
matches('qwerty','((\3|b)\2(a)x)+')
matches('qwerty','{5')
matches('qwerty','{5,')
matches('qwerty','{5,6')
matches('qwerty','([5-\D]*)bar')
matches('qwerty','((a)')
matches('qwerty','(?:(?:(?:(?:(?:(?:(?:(?:(?:(a))))))))))')
matches('qwerty','(?:..)*?a')
matches('qwerty','(?:..)*a')
matches('qwerty','(a))')
matches('qwerty','*a')
matches('qwerty','+a')
matches('qwerty','?a')
matches('qwerty','[a-;]')
matches('qwerty','[a-\[]')
matches('qwerty','[a-\\]')
matches('qwerty','a**')
matches('qwerty','a[')
matches('qwerty','a\')
matches('qwerty','a]')
matches('qwerty','[A-[]+')
matches('qwerty','a{1,0}')
matches('qwerty','(a\1|(?(1)\1)){0,2}')
matches('qwerty','(a\1|(?(1)\1)){0,2}?')
matches('qwerty','(a\1|(?(1)\1)){1,2}')
matches('qwerty','(a\1|(?(1)\1)){1,2}?')
matches('qwerty','(a\1|(?(1)\1)){2,}')
matches('qwerty','(a\1|(?(1)\1)){2,}?')
matches('qwerty','(a\1|(?(1)\1)){2}')
matches('qwerty','^(?:a(?(1)\1)){4}$')
matches('qwerty','^(?:a\1?){4}$')
matches('qwerty','(?=(a+?))(\1ab)')
matches('qwerty','^(?:?=(a+?))\1ab')
matches('qwerty','a{,2}')
matches('qwerty','a{2,1}')
matches('qwerty','((a)\3(\2|b)){2,}')
matches('qwerty','a{37,17}')
matches('qwerty','(a)|\6')
matches('qwerty','(?(?!a)a|b)')
matches('qwerty','(?(?=a)a|b)')
matches('qwerty','((?>a+)b)')
matches('qwerty','(?>(a+))b')
matches('qwerty','(?>a+)b')
matches('qwerty','[^[a-b]]')
matches('qwerty','[a--b]')
matches('qwerty','a(?!b).')
matches('qwerty','a[]]b')
matches('qwerty','a[]b')
matches('qwerty','^(?:?:a?b?)*$')
matches('qwerty','(ab){2,0}')
matches('qwerty','(?(?!a)b|a)')
matches('qwerty','(?(?=a)b|a)')
matches('qwerty','a[b-a]')
matches('qwerty','((a*(b*)((a))*(a))))')
matches('qwerty','(abbc)(?(1)111|222)')
matches('qwerty','(?:(?:(?:(?:(?:(?:(?:(?:(?:(a|b|c))))))))))')
matches('qwerty','(abc')
matches('qwerty','[a\-[\-\-bc]+')
matches('qwerty','[a\-[bc]+')
matches('qwerty','a[^]b]c')
matches('qwerty','abc)')
matches('qwerty','(a+)(?:b*)(ccc)')
matches('qwerty','[ab\-\[cd-[-[]]]]')
matches('qwerty','[ab\-\[cd-[[]]]]')
matches('qwerty','a(?:b|c|d)(.)')
matches('qwerty','a(?:b|c|d)*(.)')
matches('qwerty','a(?:b|c|d)+(.)')
matches('qwerty','a(?:b|c|d)+?(.)')
matches('qwerty','^[abcd]*+$')
matches('qwerty','^[abcd]*?+$')
matches('qwerty','^[abcd]+*$')
matches('qwerty','^[abcd]+?*$')
matches('qwerty','^[abcd]?*$')
matches('qwerty','^[abcd]??*$')
matches('qwerty','^[abcd]{0,16}*$')
matches('qwerty','^[abcd]{0,16}?*$')
matches('qwerty','^[abcd]*{0,5}$')
matches('qwerty','^[abcd]+{0,5}$')
matches('qwerty','^[abcd]?{0,5}$')
matches('qwerty','^[abcd]{1,}*$')
matches('qwerty','^[abcd]{1,}?*$')
matches('qwerty','^[abcd]{1}*$')
matches('qwerty','^[abcd]{1}?*$')
matches('qwerty','a(?:b|c|d){2}(.)')
matches('qwerty','a(?:b|c|d){4,5}(.)')
matches('qwerty','a(?:b|c|d){4,5}?(.)')
matches('qwerty','a(?:b|c|d){5,6}(.)')
matches('qwerty','a(?:b|c|d){5,6}?(.)')
matches('qwerty','a(?:b|c|d){5,7}(.)')
matches('qwerty','a(?:b|c|d){5,7}?(.)')
matches('qwerty','a(?:b|c|d){6,7}(.)')
matches('qwerty','a(?:b|c|d){6,7}?(.)')
matches('qwerty','[[abcd]-[bc]]+')
matches('qwerty','[abcd\-d\-[bc]+')
matches('qwerty','a(?:b|(c|e){1,2}?|d)+?(.)')
matches('qwerty','abc(?!XXX)\w+')
matches('qwerty','abc(?=XXX)\w+')
matches('qwerty','ab|(d))')
matches('qwerty','[a - c - [ b ] +')
matches('qwerty','[a - c - [ b ] ]+')
matches('qwerty','a(?=c|d).')
matches('qwerty','a(?=d).')
matches('qwerty','[a-d\-[b]+')
matches('qwerty','[\[\]a-f-[[]]+')
matches('qwerty','[\[\]a-f-[]]]+')
matches('qwerty','[a-f-[]]+')
matches('qwerty','\A(foo)\s+(bar)')
matches('qwerty','[^a-f-[\x00-\x60\u007B-\uFFFF]]+')
matches('qwerty','^a(?#xxx){3}c')
matches('qwerty','^a (?#xxx) (?#yyy) {3}c')
matches('qwerty','[a[:xyz:')
matches('qwerty','[a[:xyz:]')
matches('qwerty','([a[:xyz:]b]+)')
matches('qwerty','a\Z')
matches('qwerty','(*)b')
matches('qwerty','^(?:?:b|a(?=(.)))*\1')
matches('qwerty','ba\1(?=(a+?))$')
matches('qwerty','(ba\2)(?=(a+?))')
matches('qwerty','\ba\b')
matches('qwerty','\Ba\B')
matches('qwerty','[^-[bc]]')
matches('qwerty','(.)(?:b|c|d){2}a')
matches('qwerty','(.)(?:b|c|d){4,5}a')
matches('qwerty','(.)(?:b|c|d){4,5}?a')
matches('qwerty','(.)(?:b|c|d){5,6}a')
matches('qwerty','(.)(?:b|c|d){5,6}?a')
matches('qwerty','(.)(?:b|c|d){5,7}a')
matches('qwerty','(.)(?:b|c|d){5,7}?a')
matches('qwerty','(.)(?:b|c|d){6,7}a')
matches('qwerty','(.)(?:b|c|d){6,7}?a')
matches('qwerty','(.)(?:b|c|d)*a')
matches('qwerty','(.)(?:b|c|d)+?a')
matches('qwerty','(.)(?:b|c|d)+a')
matches('qwerty','(.)(?:b|c|d)a')
matches('qwerty','(.)(?:b|(c|e){1,2}?|d)+?a')
matches('qwerty','[B-D\u0130]+')
matches('qwerty','\b,foo')
matches('qwerty','\b@foo')
matches('qwerty','\b\[foo')
matches('qwerty','\B,foo')
matches('qwerty','\B@foo')
matches('qwerty','\B\[foo')
matches('qwerty','^(?:\()?blah(?(1)(\)))$')
matches('qwerty','^(?:\(+)?blah(?(1)(\)))$')
matches('qwerty','.*\B(SUCCESS)\B.*')
matches('qwerty','.*\b(\w+)\b')
matches('qwerty','\by\b')
matches('qwerty','\by\B')
matches('qwerty','\By\b')
matches('qwerty','\By\B')
matches('qwerty','b\z')
matches('qwerty','b\Z')
matches('qwerty','((c*)(?(1)a|b))')
matches('qwerty','(?:c|d)(?:)(?:aaaaaaaa(?:)(?:bbbbbbbb)(?:bbbbbbbb(?:))(?:bbbbbbbb(?:)(?:bbbbbbbb)))')
matches('qwerty','(?:c|d)(?:)(?:a(?:)(?:b)(?:b(?:))(?:b(?:)(?:b)))')
matches('qwerty','(?c:foo)')
matches('qwerty','(?>\d+)3')
matches('qwerty','(?e:foo)')
matches('qwerty','[-[e-g]+')
matches('qwerty','(?<first_name>\\S+)\\s(?<last_name>\\S+)')
matches('qwerty','(foo)(\040)')
matches('qwerty','(foo)(\077)')
matches('qwerty','(foo)(\300)')
matches('qwerty','(foo)(\377)')
matches('qwerty','(foo)(\40)')
matches('qwerty','(foo)(\400)')
matches('qwerty','(foo)(\477)')
matches('qwerty','foo([6-\s]*)bar')
matches('qwerty','(foo)(\7)')
matches('qwerty','(foo)(\77)')
matches('qwerty','(foo)(\777)')
matches('qwerty','(foo)(\7770)')
matches('qwerty','foo([7-\w]*)')
matches('qwerty','foo([a-\d]*)bar')
matches('qwerty','foo(?(?afdfoo)bar)')
matches('qwerty','foo([a-\W]*)bar')
matches('qwerty','(?:(f)(o)(o)|(b)(a)(r))*')
matches('qwerty','(foo)(\c?*)(bar)')
matches('qwerty','foo(?(?#COMMENT)foo)')
matches('qwerty','foo([c-\S]*)')
matches('qwerty','(foo) (?#foo) \s+ (?#followed by 1 or more whitespace')
matches('qwerty','(foo) (?#foo) \s+ (?#followed by 1 or more whitespace) (bar)  (?#followed by bar)')
matches('qwerty','(foo)([\o]*)(bar)')
matches('qwerty','(foo)\s+(bar)\z')
matches('qwerty','(foo)\s+(bar)\Z')
matches('qwerty','(foo)([\u0041]*)(bar)')
matches('qwerty','(foo)(\x2a*)(bar)')
matches('qwerty','(foo)(\x2A*)(bar)')
matches('qwerty','(foo)(\x2b*)(bar)')
matches('qwerty','(foo)(\x2B*)(bar)')
matches('qwerty','(foo)(\x2c*)(bar)')
matches('qwerty','(foo)(\x2C*)(bar)')
matches('qwerty','(foo)(\x2d*)(bar)')
matches('qwerty','(foo)(\x2D*)(bar)')
matches('qwerty','(foo)(\x2e*)(bar)')
matches('qwerty','(foo)(\x2E*)(bar)')
matches('qwerty','(foo)(\x2f*)(bar)')
matches('qwerty','(foo)(\x2F*)(bar)')
matches('qwerty','(foo)([\x41]*)(bar)')
matches('qwerty','([f-\p{Lu}]\w*)\s([\p{Lu}]\w*)')
matches('qwerty','((?-i)a)b')
matches('qwerty','((?-i:a))b')
matches('qwerty','((?-i:a.))b')
matches('qwerty','((?i)a)b')
matches('qwerty','((?i:a))b')
matches('qwerty','(?-i:a)b')
matches('qwerty','(?:(?-i)a)b')
matches('qwerty','(?:(?i)a)b')
matches('qwerty','(?i:a)b')
matches('qwerty','(?+i:foo)')
matches('qwerty','((?m)^b)')
matches('qwerty','(?m)^(b)')
matches('qwerty','(?m)^b')
matches('qwerty','((?m)^b$)')
matches('qwerty','(?n:(foo)(\s+)(bar))')
matches('qwerty','\n((?m)^b)')
matches('qwerty','(\p{')
matches('qwerty','[\p]')
matches('qwerty','[\P]')
matches('qwerty','([\pfoo])')
matches('qwerty','([\Pfoo])')
matches('qwerty','\p{Is}')
matches('qwerty','\P{Is}')
matches('qwerty','\p{IsaA0-a9}')
matches('qwerty','\p{klsak')
matches('qwerty','\p{\\L}')
matches('qwerty','(\p{Ll')
matches('qwerty','\p{Nd}{4}-\[{Nd}{2}')
matches('qwerty','((q*)(?(1)a|b))')
matches('qwerty','((q*)(?(1)b|a))')
matches('qwerty','(?r:foo)')
matches('qwerty','round\(((?>[^()]+))\)')
matches('qwerty','((?s)^a(.))((?m)^b$)')
matches('qwerty','((?s)b.)c(?!.)')
matches('qwerty','((?s).)c(?!.)')
matches('qwerty','((?s-i:a.))b')
matches('qwerty','(\u0034)')
matches('qwerty','[\u0100\u0102\u0104]+')
matches('qwerty','[\u013B\u013D\u013F]+')
matches('qwerty','[\u0554-\u0557]+')
matches('qwerty','(\w(?=aa)aa)')
matches('qwerty','(x)?(?(1)a|b)')
matches('qwerty','(x)?(?(1)b|a)')
matches('qwerty','(\x30\x31\x32)')
matches('qwerty','(x(a)\3(\2|b))+')
matches('qwerty','x(~~)*(?:(?:F)?)?')
matches('qwerty','[X-\u00C0]+')
matches('qwerty','[X-\u0533]+')
matches('qwerty','[-[xyz]]')
matches('qwerty','[^-[xyz]]')
matches('qwerty','z\1a(\d*){2,}?')
matches('&#xD;&#xD;a&#xD;&#xD;b&#xD;&#xD;',         '^\r\ra\r\rb\r\r$'),         matches('&#xD;&#xD;a&#xD;&#xD;b&#xD;&#xD;',         '^\r\ra\r\rb\r\r$'),         matches('&#xD;&#xD;a&#xD;&#xD;b&#xD;',              '^(?:\r\ra\r\rb\r\r)$'),         matches('&#xD;a&#xD;&#xD;b&#xD;&#xD;',              '^(?:\r\ra\r\rb\r\r)$'),         matches('&#xD;&#xD;a&#xD;&#xD;&#xD;&#xD;',          '^(?:\r\ra\r\rb\r\r)$'),         matches('&#xD;&#xD;a&#xD;&#xA;&#xD;b&#xD;&#xD;',    '^(?:\r\ra\r\rb\r\r)$')
math:acos(())
math:acos(0)
math:acos(-0.0e0)
math:acos(-1.0e0)
math:acos(1.0e0)
math:acos(2.0e0)
math:acos(xs:double('-INF'))
math:acos(xs:double('INF'))
math:acos(xs:double('NaN'))
math:asin(())
math:asin(0)
math:asin(-0.0e0)
math:asin(-1.0e0)
math:asin(1.0e0)
math:asin(2.0e0)
math:asin(xs:double('-INF'))
math:asin(xs:double('INF'))
math:asin(xs:double('NaN'))
math:atan(())
math:atan(0)
math:atan(-0.0e0)
math:atan(-1.0e0)
math:atan(1.0e0)
math:atan2(+0.0e0, -0.0e0)
math:atan2(+0.0e0, 0.0e0)
math:atan2(-0.0e0, -0.0e0)
math:atan2(-0.0e0, 0.0e0)
math:atan2(+0.0e0, +1)
math:atan2(+0.0e0, -1)
math:atan2(-0.0e0, +1)
math:atan2(-0.0e0, -1)
math:atan2(+1, 0.0e0)
math:atan2(-1, -0.0e0)
math:atan2(-1, 0.0e0)
math:atan(xs:double('-INF'))
math:atan(xs:double('INF'))
math:atan(xs:double('NaN'))
math:cos(())
math:cos(0)
math:cos(-0.0e0)
math:cos(math:pi())
math:cos(-math:pi() div 2)
math:cos(math:pi() div 2)
math:cos(xs:double('-INF'))
math:cos(xs:double('INF'))
math:cos(xs:double('NaN'))
math:exp(())
math:exp(0)
math:exp(-1)
math:exp(1)
math:exp10(())
math:exp10(0)
math:exp10(0.5)
math:exp10(-1)
math:exp10(1)
math:exp10(xs:double('-INF'))
math:exp10(xs:double('INF'))
math:exp10(xs:double('NaN'))
math:exp(xs:double('-INF'))
math:exp(xs:double('INF'))
math:exp(xs:double('NaN'))
math:log(())
math:log(0)
math:log(-1)
math:log10(())
math:log10(0)
math:log10(-1)
math:log10(1.0e-3)
math:log10(1.0e3)
math:log10(2)
math:log(1.0e-3)
math:log10(xs:double('-INF'))
math:log10(xs:double('INF'))
math:log10(xs:double('NaN'))
math:log(2)
math:log(math:exp(1))
math:log(xs:double('-INF'))
math:log(xs:double('INF'))
math:log(xs:double('NaN'))
math:pi()
math:pi#0()
math:pow(0, 0)
math:pow(0, -4)
math:pow(0, 4)
math:pow(-0e0, -3)
math:pow(-0e0, 3)
math:pow(0e0, -3)
math:pow(0e0, 3)
math:pow(-0e0, -3.0e0)
math:pow(-0e0, 3.0e0)
math:pow(0e0, -3.0e0)
math:pow(0e0, 3.0e0)
math:pow(-0e0, -3.1e0)
math:pow(-0e0, 3.1e0)
math:pow(0e0, -3.1e0)
math:pow(0e0, 3.1e0)
math:pow(0e0, -4)
math:pow(0e0, 4)
math:pow(16, 0.25e0)
math:pow(16, 0.5e0)
math:pow(-1, xs:double('-INF'))
math:pow(-1, xs:double('INF'))
math:pow(1, xs:double('-INF'))
math:pow(1, xs:double('INF'))
math:pow(1, xs:double('NaN'))
math:pow(2, 0)
math:pow(-2, -3)
math:pow(-2, 3)
math:pow(2, -3)
math:pow(2, 3)
math:pow(-2.5e0, 2.00000001e0)
math:pow(-2.5e0, 2.0e0)
math:pow((), 93.7)
math:pow(-math:pi(), 0)
math:pow(xs:double('INF'), 0)
math:pow(xs:double('NaN'), 0)
math:sin(())
math:sin(0)
math:sin(-0.0e0)
math:sin(math:pi())
math:sin(-math:pi() div 2)
math:sin(math:pi() div 2)
math:sin(math:pi()) lt 1e-15
math:sin(xs:double('-INF'))
math:sin(xs:double('INF'))
math:sin(xs:double('NaN'))
math:sqrt(())
math:sqrt(-0.0e0)
math:sqrt(0.0e0)
math:sqrt(1.0e6)
math:sqrt(-2.0e0)
math:sqrt(2.0e0)
math:sqrt(xs:double('-INF'))
math:sqrt(xs:double('INF'))
math:sqrt(xs:double('NaN'))
math:tan(())
math:tan(0)
math:tan(-0.0e0)
math:tan(math:pi())
math:tan(-math:pi() div 4)
math:tan(math:pi() div 4)
math:tan(-math:pi() div 4) + 1
math:tan(math:pi() div 4) - 1
math:tan(xs:double('-INF'))
math:tan(xs:double('INF'))
math:tan(xs:double('NaN'))
max()
max((1.0, 1, 1.0, 1, 1)) instance of xs:decimal
max((1.0, 1, 1, 1, 1)) instance of xs:decimal
max((1, 1, 1, 1, 1.0)) instance of xs:decimal
max((1, 1, 1, 1, 1, 3)) eq 3
max([1,2,3,4,5])
max((1, xs:float(2), xs:decimal(3))) instance of xs:float
max((1, xs:float(2), xs:untypedAtomic("3"))) eq 3
max((1, xs:float(2), xs:untypedAtomic("3"))) instance of xs:double
max((1, xs:untypedAtomic("3"), xs:float(2))) instance of xs:double
max((3, 1, 1, 1, 1, 1)) eq 3
max((3, 1, 5, 1, 1, 3)) eq 5
max((3, 3, 3, 3, 3, 3)) eq 3
max((3,4,5)) eq 5
max((3,4, "Zero"))
max((3, -5.0, 5, 1, -3, 3)) eq 5
max((3, 5.0e0)) eq 5.0e0
max((3, 5.0e0)) instance of xs:double
max((3, xs:double("NaN"))) instance of xs:double
max((5.0e0, 3)) eq 5.0e0
max((5.0e0, 3)) instance of xs:double
max((5.0e0, 5)) eq 5.0e0
max((5.0e0, 5)) instance of xs:double
max((5, 3.0e0)) instance of xs:double
max((5, 5.0e0)) eq 5.0e0
max((5, 5.0e0)) instance of xs:double
max(("a", "b", "c", "d"))
max(("a", "b", "c")) eq "c"
max(('a', 'b'), 'http://www.cbcl.co.u,/collation')
max(("a string")) eq "a string"
max("a string", "http://www.w3.org/2005/xpath-functions/collation/codepoint", "wrong param")
max(("a string", QName("example.com/", "ncname")))
max(("a string", xs:untypedAtomic("3")))
max((current-date(), xs:date("1999-01-01"))) eq current-date()
max(map{'decimal':12, 'integer':18, 'polygon':-4}?*)
max(("str1", "str2"), "http://example.com/UNSUPPORTED_COLLATION")
max(("str1", "str2"), "http://www.w3.org/2005/xpath-functions/collation/codepoint", ())
max(xs:anyURI("example.com/")) eq xs:anyURI("example.com/")
max((xs:anyURI("example.com/"), xs:anyURI("example.com/"))) eq xs:anyURI("example.com/")
max((xs:anyURI("http://a.com"), xs:anyURI("http://b.com")))
max((xs:anyURI("http://c.com"), "http://b.com"))
max((xs:anyURI("http://example.com/8"), xs:anyURI("http://example.com/4"))) eq xs:anyURI("http://example.com/8")
max((xs:anyURI("http://example.com/A"), xs:anyURI("http://example.com/A"))) eq xs:anyURI("http://example.com/A")
max((xs:anyURI("http://example.com/B"), xs:anyURI("http://example.com/A"))) eq xs:anyURI("http://example.com/B")
max(xs:anyURI("str1"), "max://example.com/UNSUPPORTED_COLLATION")
max((xs:date('1066-10-02'), xs:date('1588-08-08'), xs:date('2011-06-29')))
max((xs:dayTimeDuration("P1D"), xs:dayTimeDuration("PT2H"))) instance of xs:dayTimeDuration
max((xs:double("NaN"), 1, 1, 2, xs:float("NaN"))) instance of xs:double
max((xs:float(-3), xs:untypedAtomic("3"), xs:double("NaN"))) instance of xs:double
max((xs:float("NaN"), 1, 1, 2, xs:double("NaN"))) instance of xs:double
max((xs:float("NaN"), 1, xs:untypedAtomic("one")))
max((xs:float("NaN"), xs:untypedAtomic("3"), xs:float(2))) instance of xs:double
max((xs:NCName('c'), xs:ID('b'), xs:token('a')))
max((xs:positiveInteger(123), xs:unsignedShort(124)))
max(xs:unsignedShort("1")) instance of xs:unsignedShort
max((xs:untypedAtomic("3"), 1, 2)) instance of xs:double
max((xs:untypedAtomic("3"), "a string"))
max(xs:untypedAtomic("3")) eq 3
max(xs:untypedAtomic("3")) instance of xs:double
max((xs:untypedAtomic("one"), 1, xs:float("NaN")))
max(xs:untypedAtomic("three"))
max((xs:yearMonthDuration("P1Y"), xs:yearMonthDuration("P1M"))) instance of xs:yearMonthDuration
min()
min((1.0, 1, 1.0, 1, 1)) instance of xs:decimal
min((1.0, 1, 1, 1, 1)) instance of xs:decimal
min((1, 1, 1, 1, 1.0)) instance of xs:decimal
min((1, 1, 1, 1, 1, 3)) eq 1
min([1,2,3,4,5])
min((1, xs:float(2), xs:decimal(3))) instance of xs:float
min((3, 1, 1, 1, 1, 1)) eq 1
min((3, 1, 5, 1, 1, 3)) eq 1
min((3, 3, 3, 3, 3, 3)) eq 3
min((3,4,5)) eq 3
min((3,4, "Zero"))
min((3, -5.0, 5, 1, -3, 3)) eq -5.0
min((3, 5.0e0)) eq 3
min((3, 5.0e0)) instance of xs:double
min((3, xs:double("NaN"))) instance of xs:double
min((3, xs:float(2), xs:untypedAtomic("1"))) eq 1
min((3, xs:float(2), xs:untypedAtomic("1"))) instance of xs:double
min((3, xs:untypedAtomic("1"), xs:float(2))) instance of xs:double
min((5.0e0, 3)) eq 3
min((5.0e0, 3)) instance of xs:double
min((5.0e0, 5)) eq 5.0e0
min((5.0e0, 5)) instance of xs:double
min((5, 5.0e0)) eq 5.0e0
min((5, 5.0e0)) instance of xs:double
min(("a", "b", "c", "d"))
min(("a", "b", "c")) eq "a"
min(('a', 'b'), 'http://www.cbcl.co.u,/collation')
min(("a string")) eq "a string"
min("a string", "http://www.w3.org/2005/xpath-functions/collation/codepoint", "wrong param")
min(("a string", QName("example.com/", "ncname")))
min(("a string", xs:untypedAtomic("3")))
min(("str1", "str2"), "http://example.com/UNSUPPORTED_COLLATION")
min(("str1", "str2"), "http://www.w3.org/2005/xpath-functions/collation/codepoint", ())
minutes-from-dateTime()
minutes-from-dateTime(()) instance of xs:integer?
minutes-from-dateTime((), "Wrong param")
minutes-from-dateTime(xs:dateTime("2001-02-03T08:23:12.43")) eq 23
(minutes-from-dateTime( xs:dateTime('2006-08-15T10:30:23')))
minutes-from-duration()
minutes-from-duration(()) instance of xs:integer?
minutes-from-duration((), "Wrong param")
minutes-from-duration(xs:dayTimeDuration("-P3DT8H2M1.03S")) eq -2
minutes-from-duration(xs:dayTimeDuration("P3DT8H2M1.03S")) eq 2
(minutes-from-duration( xs:dayTimeDuration('PT1M90S')))
(minutes-from-duration( xs:dayTimeDuration('PT30M')))
(minutes-from-duration( xs:dayTimeDuration('PT30M')), minutes-from-duration( xs:dayTimeDuration('-PT90M')), minutes-from-duration( xs:dayTimeDuration('PT1M90S')), minutes-from-duration( xs:dayTimeDuration('PT3H')), minutes-from-duration( xs:dayTimeDuration('PT60M')))
(minutes-from-duration( xs:dayTimeDuration('PT3H')))
(minutes-from-duration( xs:dayTimeDuration('PT60M')))
(minutes-from-duration( xs:dayTimeDuration('-PT90M')))
minutes-from-duration(xs:duration("-P3Y4M8DT1H23M2.34S")) eq -23
minutes-from-time()
minutes-from-time(()) instance of xs:integer?
minutes-from-time((), "Wrong param")
(minutes-from-time(xs:time('10:30:23')))
minutes-from-time(xs:time("23:11:12.43")) eq 11
min(xs:anyURI("example.com/")) eq xs:anyURI("example.com/")
min((xs:anyURI("example.com/"), xs:anyURI("example.com/"))) eq xs:anyURI("example.com/")
min((xs:anyURI("http://a.com"), "http://b.com"))
min((xs:anyURI("http://a.com"), xs:anyURI("http://b.com")))
min((xs:anyURI("http://example.com/8"), xs:anyURI("http://example.com/4"))) eq xs:anyURI("http://example.com/4")
min((xs:anyURI("http://example.com/A"), xs:anyURI("http://example.com/A"))) eq xs:anyURI("http://example.com/A")
min((xs:anyURI("http://example.com/B"), xs:anyURI("http://example.com/A"))) eq xs:anyURI("http://example.com/A")
min(xs:anyURI("str1"), "http://example.com/UNSUPPORTED_COLLATION")
min((xs:date('1066-10-02'), xs:date('1588-08-08'), xs:date('2011-06-29')))
min((xs:date("2005-01-01"), xs:date("2001-01-01"))) eq xs:date("2001-01-01")
min((xs:dayTimeDuration("P1D"), xs:dayTimeDuration("PT2H"))) instance of xs:dayTimeDuration
min((xs:double("NaN"), 1, 1, 2, xs:float("NaN"))) instance of xs:double
min((xs:float(0.0E0), xs:float(-0.0E0))) eq xs:float("-0")
min((xs:float(-3), xs:untypedAtomic("3"), xs:double("NaN"))) instance of xs:double
min((xs:float("NaN"), 1, 1, 2, xs:double("NaN"))) instance of xs:double
min((xs:float("NaN"), xs:untypedAtomic("3"), xs:double(2))) instance of xs:double
min((xs:NCName('a'), xs:ID('b'), xs:token('c')))
min((xs:positiveInteger(123), xs:unsignedShort(124)))
min(xs:unsignedShort("1")) instance of xs:unsignedShort
min((xs:untypedAtomic("1"), 3, 2)) instance of xs:double
min((xs:untypedAtomic("3"), "a string"))
min(xs:untypedAtomic("3")) eq 3
min(xs:untypedAtomic("3")) instance of xs:double
min(xs:untypedAtomic("three"))
min((xs:yearMonthDuration("P1Y"), xs:yearMonthDuration("P1M"))) instance of xs:yearMonthDuration
() mod 1
module namespace prefix = "http://example.com"; declare function prefix:myFunction() { 1 };
module namespace prefix = "http://www.example.com/";
month-from-date()
month-from-date(()) instance of xs:integer?
month-from-dateTime()
month-from-dateTime(()) instance of xs:integer?
month-from-dateTime((), "Wrong param")
month-from-dateTime(xs:dateTime("2001-02-03T08:23:12.43")) eq 2
(month-from-dateTime( xs:dateTime('2006-08-15T10:30:23')))
month-from-date((), "Wrong param")
month-from-date(xs:date("2000-02-03")) eq 2
(month-from-date(xs:date('2006-08-15')))
months-from-duration()
months-from-duration(()) instance of xs:integer?
months-from-duration((), "Wrong param")
months-from-duration(xs:duration("-P3Y4M4DT1H23M2.34S")) eq -4
months-from-duration(xs:yearMonthDuration("-P0003Y2M")) eq -2
months-from-duration(xs:yearMonthDuration("P0003Y2M")) eq 2
(months-from-duration( xs:yearMonthDuration('P12M')))
(months-from-duration( xs:yearMonthDuration('-P18M')))
(months-from-duration( xs:yearMonthDuration('P1Y')))
(months-from-duration( xs:yearMonthDuration('P3M')))
(months-from-duration( xs:yearMonthDuration('P3M')), months-from-duration( xs:yearMonthDuration('-P18M')), months-from-duration( xs:yearMonthDuration('P1Y')), months-from-duration( xs:yearMonthDuration('P12M')))
-((<n>1</n> | ())[1])
name(/*)
name((//*[.='1983'])[1])
'N A M E' castable as xs:Name
name((//comment())[1]) = ''
(: Name: Excluded-char-2 :) (: Written by: Nicolae Brinza :) (: Description: The character #x0100 is excluded from the start of a Name :) (:              in XML 1.0 4th edition and older                          :) xquery version "1.0" encoding "utf-8"; < node/>
name(:hey:):*
name((//processing-instruction())[1])
<name>some, if(1) then else</name> instance of element()
namespace::*
namespace-node(1)
namespace-node {"p"} {"abc"}
namespace-uri(<e xmlns="http://example.com/{{1}}"/>)
namespace-uri(<e xmlns='http://ns.example.com/ns?val=''asd'/>)
(namespace-uri-from-QName( () ))
namespace-uri-from-QName()
namespace-uri-from-QName(1, 2)
namespace-uri-from-QName(node-name(exactly-one(<e xmlns="http://example.com/">{attribute attr {()} }/</e>/@attr))) eq ""
namespace-uri-from-QName( QName("example.com/", "pre:lname")) eq xs:anyURI("example.com/")
namespace-uri-from-QName( QName("example.com/", "pre:lname")) instance of xs:anyURI
(namespace-uri-from-QName( QName ('http://datypic.com/pre', 'prefixed')))
(namespace-uri-from-QName( QName ('http://datypic.com/pre', 'prefixed')), namespace-uri-from-QName( QName ('', 'unprefixed')), namespace-uri-from-QName( () ))
(namespace-uri-from-QName( QName ('', 'unprefixed')))
namespace-uri-from-QName(xs:QName("ncname"))
namespace-uri(<p:e xmlns:p="http://example.com/{{{{{{}}}}}}asd"/>)
namespace-uri(<p:e xmlns:p="http://ns.example.com/ns?val=""""""asd"/>)
namespace-uri(<p:e xmlns:p="http://ns.example.com/ns?val=""asd"/>)
namespace-uri(<p:e xmlns:p='http://ns.example.com/ns?val=''''''asd'/>)
name((//*:Start)[1]/@*)
nametest/
nametest//
nametest : nametest
nametest :nametest
nametest: nametest
name((//text())[1]) = ''
name((), "wrong param")
name((//@xml:*)[1])
<name xmlns:ns="http://example.com/NS"/>, ns:nametest
(: Name: XQueryComment001 :) (: Description: Simple use case for XQuery comments :) (: This is a comment :) <result/>
(: Name: XQueryComment002 :) (: Description: Simple use case for XQuery comments :) (: This is a comment :) (//fs:Folder)[1]/fs:File[1]/fs:FileName
(: Name: XQueryComment003 :) (: Description: Simple use case for XQuery comment containing '-' :) (:This is a comment-:) <result/>
(: Name: XQueryComment004 :) (: Description: Comment containing only '-' :) (:-:) <result/>
(: Name: XQueryComment004 :) (: Description: Empty comment :) (::) <result/>
(: Name: XQueryComment006 :) (: Description: Comment containing ':' :) (: this is a comment ::) <result/>
(: Name: XQueryComment007 :) (: Description: Comment containing ')' :) (: this is a comment ):) <result/>
(: Name: XQueryComment008 :) (: Description: Simple example of embedded comments :) (: this is a comment (: this is an embedded comment :):) <result/>
(: Name: XQueryComment009 :) (: Description: Comments inside a conditional expression :) if (:test (: yada (: neato :) :) :) (/fs:MyComputer)  then (: yada :) "true" else "false"
(: Name: XQueryComment010 :) (: Description: Comments inside a conditional expression :) if (: comment :)    ( //fs:Folder[1]/fs:FolderName/text() = "Folder00000000000" )  then (: this is the then case :) ( true() ) else (: this is the else case :) ( false() )
(: Name: XQueryComment011 :) (: Description: Comments inside a conditional expression :) if (:test:)(:t2:)(:t3:) (/fs:MyComputer)  then "true" else "false"
(: Name: XQueryComment012 :) (: Description: Comments that looks like a function call :) /south(: test :)
(: Name: XQueryComment013 :) (: Description: Comments inside a sequence expression :) (1, 2, (: comment :) 3, 4)
(: Name: XQueryComment015 :) (: Description: Incorrect comment syntax :) (! Wrong syntax :) <empty/>
(: Name: XQueryComment016 :) (: Description: Invalid comment :) (:) <empty/>
(: Name: XQueryComment017 :) (: Description: Invalid comment :) (:: ) <empty/>
(: Name: XQueryComment018 :) (: Description: Invalid comment :) -- Wrong comment format <empty/>
(: Name: XQueryComment019 :) (: Description: Old style comment syntax :) {-- Wrong comment format --} <empty/>
(: Name: XQueryComment020 :) (: Description: Comment containing an enclosed expression :) (: { "comment" } :) <result/>
" naN" cast as xs:decimal
"naN" cast as xs:decimal
* :ncname
::ncname
ncname :*
ncname: *
<ncname (:a misplaced comment:)/>
'NCName' castable as xs:Name
'NC:Name' castable as xs:NCName
'NCName' castable as xs:NCName
<ncname>content</ncname > = 'content'
ncname:(:hey:)*
<ncname></ ncname>
<ncname></ncname (:a misplaced comment:)>
<ncname></ncnameNOTBALANCED>
<new>{//*:child1}</new>
<new>{//*:child3}</new>
<new>{//*:child4}</new>
//news_item/title[contains(., "Foobar Corporation")]
<new xml:attr="foo"/>
<new xmlns:foo="http://www.example.com">{//@*:attr1}</new>
<new xmlns:foo="http://www.example.com">{//*:child1}</new>
<new xmlns:foo="http://www.example.com/parent1">{//*:child1}</new>
<new xmlns="http://www.example.com">{//*:child2}</new>
<new xmlns="http://www.example.com">{//*:child4}</new>
<new xmlns="http://www.example.com/parent4">{//*:child4}</new>
no-binding:*
node(*)
node(1)
node-name()
node-name(/*, ())
node-name(3.3)
node-name( (<a/>, <b/>))
node-name( (<a/>, "mystring"))
node-name(/*) instance of xs:QName
node-name( node-name(<a/>))
node-name("string")
node-name((), "wrong param")
<node xmlns="http://example.com/ns"/>/node-name()
<node xml:space="preserve" xmlns="http://example.com/ns"/>/@xml:space/node-name()
(normalize-space(' '))
(normalize-space(''))
(normalize-space(()))
normalize-space(())
normalize-space(" 143 1239 fhjkls ") eq "143 1239 fhjkls"
normalize-space("a string", "wrong param")
(normalize-space( <element> query </element>))
normalize-space(()) eq ""
normalize-space(" foo") eq "foo"
normalize-space("f o o ") eq "f o o"
normalize-space("foo ") eq "foo"
normalize-space("foo") eq "foo"
normalize-space(iri-to-uri(("somestring", current-time())[1])) eq "somestring"
normalize-space(normalize-space(("foo", current-time())[1])) eq "foo"
(normalize-space(' query '))
(normalize-space('query'))
(normalize-space('query'), normalize-space(' query '), normalize-space('xml query'), normalize-space('xml query'), normalize-space('xml query'), normalize-space(''), normalize-space(' '), normalize-space(()), normalize-space( <element> query </element>))
normalize-space(string((//*:Price)[1]))
(normalize-space('xml query'))
normalize-unicode("f oo") eq "f oo
(not(''))
(not(()))
not("")
not('')
not((() = ()))
not(() != () )
not(() < () )
not(() <= () )
not(() = ())
not(() > () )
not(() >= () )
not(())
not()
not(//*)
(not(0))
not(0)
not(0.0)
not(0.0e0)
not(0 = count((1, 2, timezone-from-time(current-time()))))
not(0 eq count((1, 2, timezone-from-time(current-time()))))
not(0 or 0)
not(0 or xs:anyURI(""))
not((() = 1))
not(() != 1 )
not(() < 1 )
not(() <= 1 )
not(() = 1 )
not(() > 1 )
not(() >= 1 )
not(1 != () )
not(1 < () )
not(1 <= () )
not(1 = ())
not(1 > () )
not(1 >= () )
not(((10)div(3)) instance of xs:integer)
not(1.1 instance of xs:integer)
not((1, 2, 1.1, 4, 5) instance of xs:integer*)
not((1, 2) = (3, 4))
not(1, 2, 3, 4, 5, 6)
not((1, 2, 3, 4, 5) instance of xs:integer)
not((1, 2, 3, 4, 5) instance of xs:integer?)
not((1, 2, 3) castable as xs:integer)
not((1, 2, "a string", 4, 5) instance of xs:integer*)
not((1, 2, "a string", 4, 5) instance of xs:string*)
not(1 ge xs:double("NaN"))
not(1 ge xs:float("NaN"))
not(1 gt xs:double("NaN"))
not(1 gt xs:float("NaN"))
not(1 instance of comment())
not(1 instance of element())
not(1 instance of node())
not(1 instance of processing-instruction())
not(1 instance of text())
not(1 le xs:double("NaN"))
not(1 le xs:float("NaN"))
not(1 lt xs:double("NaN"))
not(1 lt xs:float("NaN"))
not(1 != xs:untypedAtomic("1"))
not((/, 23))
not((23, /))
not("2" = xs:untypedAtomic("1"))
(not(32 >          20))
(not(32 > 20), not((/) //product), not(true()), not(()), not(''), not(0), not(<e>false</e>))
not("abc" eq concat("a", "bc"))
not("abc" eq string(/works/@id))
not("abc" eq /works/@id)
not("abc" eq xs:string(/works/@id))
not('abc' gt 'abc')
not('abc' le 'a')
not('abc' lt 'a')
not("abc" ne concat("a", "bc"))
not("abc" ne string(/works/@id))
not("abc" ne /works/@id)
not("abc" ne xs:string(/works/@id))
not(<!-- a comment --> instance of xs:string)
not(<!-- a comment --> instance of xs:untypedAtomic)
not('a' ge 'abc')
not("" and 0)
not("a string" != "a string")
not("a string" = "a stringDIFF")
not("a string" instance of xs:NOTATION)
not("a string" instance of xs:QName)
not("a string" instance of xs:untypedAtomic)
not("a string" != xs:untypedAtomic("a string"))
not("a string" = xs:untypedAtomic("a stringDIFF"))
"notation is abstract" castable as xs:NOTATION
"notation is abstract" castable as xs:NOTATION?
"notation is abstract" cast as xs:NOTATION
"notation is abstract" cast as xs:NOTATION?
not(//banana)
not(boolean(""))
not(boolean(()))
not(boolean(false()))
not(boolean(for $x in 1 to 10 return $x * $x))
not(boolean(xs:anyURI("")))
not(boolean(xs:untypedAtomic("")))
not(() castable as xs:integer)
not(() castable as xs:QName)
not(contains("", "a string"))
not(contains("tattoo", "ttt"))
not(count((1, 2, current-time(), 4))) eq false()
not(count((1, 2, current-time())) eq 0)
not(data(<!-- a comment -->) instance of xs:untypedAtomic)
not(data(<name>some text</name>) instance of xs:string)
not(data(<?target content?>) instance of xs:untypedAtomic)
not(deep-equal((), (1, 1, 1)))
not(deep-equal((1, 1, 1), ()))
not(deep-equal(((), 1, 1), (1, 1, 1)))
not(deep-equal((1, (), 1), (1, 1, 1)))
not(deep-equal((1, 1), (1, 1, 1)))
not(deep-equal((1, 1, ()), (1, 1, 1)))
not(deep-equal((1, 1, 1), ((), 1, 1)))
not(deep-equal((1, 1, 1), (1, (), 1)))
not(deep-equal((1, 1, 1), (1, 1)))
not(deep-equal((1, 1, 1), (1, 1, ())))
not(deep-equal((1, 1, 1), (1, 1, 3)))
not(deep-equal((1, 1, 1), (1, 3, 1)))
not(deep-equal((1, 1, 1), (3, 1, 1)))
not(deep-equal((1, 1, 3), (1, 1, 1)))
not(deep-equal((1, 2, 3), (1, 2, QName("example.com", "ncname"))))
not(deep-equal((1, 2, 3), (1, xs:hexBinary("FF"), 3)))
not(deep-equal((1, 2, 3), (xs:base64Binary("FFFF"), 2, 3)))
not(deep-equal((1, 2, xs:anyURI("example.com")), (1, 2, 3)))
not(deep-equal((1, 3, 1), (1, 1, 1)))
not(deep-equal((1, xs:decimal("2.2"), 3), (1, 2, 3)))
not(deep-equal((3, 1, 1), (1, 1, 1)))
not(deep-equal(current-time(), current-date()))
not(deep-equal(QName("example.com", "ncname"), 3e2))
not(deep-equal((true(), 2, 3), (1, 2, 3)))
not(deep-equal(xs:decimal("1"), xs:anyURI("example.com")))
not(deep-equal(xs:double(0), xs:double("NaN")))
not(deep-equal(xs:double("NaN"), xs:double(0)))
not(deep-equal(xs:float(0), xs:float("NaN")))
not(deep-equal(xs:float("NaN"), xs:float(0)))
(not(<e>false</e>))
not(empty(((), 1, 2)))
not(empty((1, 2)))
not(empty((1, 2, 3)[1]))
not(empty((1, 2, 3)[3]))
not(empty( ((), 1, "string") ))
not(empty((1, "string")))
not(empty((1, (), "string")))
not(empty(remove((current-time(), 1), 1)))
not(empty(reverse((1))))
not(empty("string"))
not(ends-with ((), "a string"))
not(ends-with("tattoo", "atto"))
not('equal' ne 'equal')
not(every $foo in 1 satisfies false())
not(every $var in (1, 2, 3) satisfies $var eq 3)
not(every $var in (false(), true(), true()) satisfies $var)
not(every $var in (true(), false(), true()) satisfies $var)
not(every $var in (true(), true(), false()) satisfies $var)
not(exists( ((), (), (), ()) ))
not(exists(()))
not(exists(remove(remove((current-time(), 1), 1), 1)))
not(exists(reverse(())))
not(false())
not(false() and false())
not("false" instance of xs:boolean)
not(false() != xs:untypedAtomic("false"))
not(false() > xs:untypedAtomic("true"))
not(fn:number(()))
not(fn:number("results in NaN"))
not(matches('', '^(?:\n\na\n\nb\n\n)$')) and          (every $s in tokenize(' a b; , a b; , a b; ', ',')                  satisfies not(matches($s, '^(?:\n\na\n\nb\n\n)$')))
not('nada' eq 'equalness')
not(<name>some text</name> instance of xs:untypedAtomic)
'not' ne 'equal'
not(not(true()))
not(not(xs:anyURI("example.com/")))
not(("one", "two") castable as xs:string?)
not("" or 0)
(not((/) //product))
not(QName("", "lname") castable as xs:integer)
not(reverse(()))
not(some $a as empty-sequence() in (), $b as xs:integer in $a satisfies $b)
not(some $foo in 1 satisfies false())
not(some $i in () satisfies $i)
not(some $var in (false(), false(), false()) satisfies $var)
not(starts-with("", "a string"))
not(starts-with("tattoo", "att"))
not('string' castable as xs:boolean)
not(string(current-time()) eq "now")
not(string(current-time()) ge "now")
not(string(current-time()) gt "now")
not(string(current-time()) le "now")
not(string(current-time()) lt "now")
not(string(current-time()) ne "now")
not(string(/works/@id) eq "abc")
not(string(/works/@id) ne "abc")
not(<?target content?> instance of xs:untypedAtomic)
not("three" castable as xs:decimal)
not("three" castable as xs:double)
not("three" castable as xs:float)
not("three" castable as xs:integer)
(not(true()))
not(true() cast as xs:boolean eq false())
not((true(), false()))
not(true() < xs:untypedAtomic("false"))
not(works/@id eq "abc")
not(works/@id ne "abc")
not(xs:anyURI(""))
not(xs:anyURI("") and xs:anyURI("example.com/"))
not(xs:anyURI("example.com/") and xs:anyURI(""))
not(xs:anyURI("example.com/") castable as xs:integer)
not(xs:anyURI("http://example.com/A") eq xs:anyURI("http://example.com/B"))
not(xs:anyURI("http://example.com/A") eq xs:string("http://example.com/B"))
not(xs:anyURI("http://example.com/A") gt xs:anyURI("http://example.com/B"))
not(xs:anyURI("http://example.com/A") ne xs:anyURI("http://example.com/A"))
not(xs:anyURI("http://example.com/A") ne xs:string("http://example.com/A"))
not(xs:anyURI("http://example.com/B") le xs:anyURI("http://example.com/A"))
not(xs:anyURI("http://example.com/B") le xs:string("http://example.com/A"))
not(xs:anyURI("http://example.com/B") lt xs:anyURI("http://example.com/A"))
not(xs:anyURI("http://example.com/B") lt xs:string("http://example.com/A"))
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:base64Binary)
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:boolean)
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:date)
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:dateTime)
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:dayTimeDuration)
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:decimal)
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:double)
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:duration)
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:float)
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:gDay)
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:gMonth)
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:gMonthDay)
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:gYear)
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:gYearMonth)
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:hexBinary)
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:integer)
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:NOTATION)
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:time)
not(xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:yearMonthDuration)
not(xs:anyURI("http://www.example.com/") instance of xs:string)
not(xs:anyURI("") or 0)
not(xs:base64Binary("aaaa") castable as xs:anyURI)
not(xs:base64Binary("aaaa") castable as xs:boolean)
not(xs:base64Binary("aaaa") castable as xs:date)
not(xs:base64Binary("aaaa") castable as xs:dateTime)
not(xs:base64Binary("aaaa") castable as xs:dayTimeDuration)
not(xs:base64Binary("aaaa") castable as xs:decimal)
not(xs:base64Binary("aaaa") castable as xs:double)
not(xs:base64Binary("aaaa") castable as xs:duration)
not(xs:base64Binary("aaaa") castable as xs:float)
not(xs:base64Binary("aaaa") castable as xs:gDay)
not(xs:base64Binary("aaaa") castable as xs:gMonth)
not(xs:base64Binary("aaaa") castable as xs:gMonthDay)
not(xs:base64Binary("aaaa") castable as xs:gYear)
not(xs:base64Binary("aaaa") castable as xs:gYearMonth)
not(xs:base64Binary("aaaa") castable as xs:integer)
not(xs:base64Binary("aaaa") castable as xs:NOTATION)
not(xs:base64Binary("aaaa") castable as xs:time)
not(xs:base64Binary("aaaa") castable as xs:yearMonthDuration)
not(xs:boolean("true") castable as xs:anyURI)
not(xs:boolean("true") castable as xs:base64Binary)
not(xs:boolean("true") castable as xs:date)
not(xs:boolean("true") castable as xs:dateTime)
not(xs:boolean("true") castable as xs:dayTimeDuration)
not(xs:boolean("true") castable as xs:duration)
not(xs:boolean("true") castable as xs:gDay)
not(xs:boolean("true") castable as xs:gMonth)
not(xs:boolean("true") castable as xs:gMonthDay)
not(xs:boolean("true") castable as xs:gYear)
not(xs:boolean("true") castable as xs:gYearMonth)
not(xs:boolean("true") castable as xs:hexBinary)
not(xs:boolean("true") castable as xs:NOTATION)
not(xs:boolean("true") castable as xs:time)
not(xs:boolean("true") castable as xs:yearMonthDuration)
not(xs:date("2004-07-11") ge xs:date("2004-07-12"))
not(xs:date("2004-07-12") gt xs:date("2004-07-12"))
not(xs:date("2004-07-12") gt xs:date("2004-07-13"))
not(xs:date("2004-07-12") ne xs:date("2004-07-12"))
not(xs:date("2004-07-13") le xs:date("2004-07-12"))
not(xs:date("2004-07-13") lt xs:date("2004-07-12"))
not(xs:date("2004-07-13") lt xs:date("2004-07-13"))
not(xs:date("2004-08-12") eq xs:date("2003-08-12"))
not(xs:date("2004-10-13") castable as xs:anyURI)
not(xs:date("2004-10-13") castable as xs:base64Binary)
not(xs:date("2004-10-13") castable as xs:boolean)
not(xs:date("2004-10-13") castable as xs:dayTimeDuration)
not(xs:date("2004-10-13") castable as xs:decimal)
not(xs:date("2004-10-13") castable as xs:double)
not(xs:date("2004-10-13") castable as xs:duration)
not(xs:date("2004-10-13") castable as xs:float)
not(xs:date("2004-10-13") castable as xs:hexBinary)
not(xs:date("2004-10-13") castable as xs:integer)
not(xs:date("2004-10-13") castable as xs:NOTATION)
not(xs:date("2004-10-13") castable as xs:time)
not(xs:date("2004-10-13") castable as xs:yearMonthDuration)
not(xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:anyURI)
not(xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:base64Binary)
not(xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:boolean)
not(xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:dayTimeDuration)
not(xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:decimal)
not(xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:double)
not(xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:duration)
not(xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:float)
not(xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:hexBinary)
not(xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:integer)
not(xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:NOTATION)
not(xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:yearMonthDuration)
not(xs:dateTime("2004-07-11T23:01:04.12") ge xs:dateTime("2004-07-12T23:01:04.12"))
not(xs:dateTime("2004-07-12T23:01:04.12") gt xs:dateTime("2004-07-12T23:01:04.12"))
not(xs:dateTime("2004-07-12T23:01:04.12") gt xs:dateTime("2004-07-13T23:01:04.12"))
not(xs:dateTime("2004-07-12T23:01:04.12") ne xs:dateTime("2004-07-12T23:01:04.12"))
not(xs:dateTime("2004-07-13T23:01:04.12") le xs:dateTime("2004-07-12T23:01:04.12"))
not(xs:dateTime("2004-07-13T23:01:04.12") lt xs:dateTime("2004-07-12T23:01:04.12"))
not(xs:dateTime("2004-07-13T23:01:04.12") lt xs:dateTime("2004-07-13T23:01:04.12"))
not(xs:dateTime("2004-08-12T23:01:04.12") eq xs:dateTime("2004-08-12T23:01:04.13"))
not(xs:dayTimeDuration("P3DT08H34M12.043S") eq xs:dayTimeDuration("P3DT08H34M12.143S"))
not(xs:dayTimeDuration("P3DT08H34M12.143S") ge xs:dayTimeDuration("P3DT08H34M12.144S"))
not(xs:dayTimeDuration("P3DT08H34M12.143S") le xs:dayTimeDuration("P3DT08H34M12.142S"))
not(xs:dayTimeDuration("P3DT08H34M12.143S") lt xs:dayTimeDuration("P3DT08H34M12.143S"))
not(xs:dayTimeDuration("P3DT08H34M12.143S") ne xs:dayTimeDuration("P3DT08H34M12.143S"))
not(xs:dayTimeDuration("P3DT08H34M12.144S") gt xs:dayTimeDuration("P3DT08H34M12.144S"))
not(xs:dayTimeDuration("P3DT08H34M12.144S") gt xs:dayTimeDuration("P3DT08H34M12.145S"))
not(xs:dayTimeDuration("P3DT08H34M12.144S") lt xs:dayTimeDuration("P3DT08H34M12.143S"))
not(xs:dayTimeDuration("P3DT2H") castable as xs:anyURI)
not(xs:dayTimeDuration("P3DT2H") castable as xs:base64Binary)
not(xs:dayTimeDuration("P3DT2H") castable as xs:boolean)
not(xs:dayTimeDuration("P3DT2H") castable as xs:date)
not(xs:dayTimeDuration("P3DT2H") castable as xs:dateTime)
not(xs:dayTimeDuration("P3DT2H") castable as xs:decimal)
not(xs:dayTimeDuration("P3DT2H") castable as xs:double)
not(xs:dayTimeDuration("P3DT2H") castable as xs:float)
not(xs:dayTimeDuration("P3DT2H") castable as xs:gDay)
not(xs:dayTimeDuration("P3DT2H") castable as xs:gMonth)
not(xs:dayTimeDuration("P3DT2H") castable as xs:gMonthDay)
not(xs:dayTimeDuration("P3DT2H") castable as xs:gYear)
not(xs:dayTimeDuration("P3DT2H") castable as xs:gYearMonth)
not(xs:dayTimeDuration("P3DT2H") castable as xs:hexBinary)
not(xs:dayTimeDuration("P3DT2H") castable as xs:integer)
not(xs:dayTimeDuration("P3DT2H") castable as xs:NOTATION)
not(xs:dayTimeDuration("P3DT2H") castable as xs:time)
not(xs:decimal("10.01") castable as xs:anyURI)
not(xs:decimal("10.01") castable as xs:base64Binary)
not(xs:decimal("10.01") castable as xs:date)
not(xs:decimal("10.01") castable as xs:dateTime)
not(xs:decimal("10.01") castable as xs:dayTimeDuration)
not(xs:decimal("10.01") castable as xs:duration)
not(xs:decimal("10.01") castable as xs:gDay)
not(xs:decimal("10.01") castable as xs:gMonth)
not(xs:decimal("10.01") castable as xs:gMonthDay)
not(xs:decimal("10.01") castable as xs:gYear)
not(xs:decimal("10.01") castable as xs:gYearMonth)
not(xs:decimal("10.01") castable as xs:hexBinary)
not(xs:decimal("10.01") castable as xs:NOTATION)
not(xs:decimal("10.01") castable as xs:time)
not(xs:decimal("10.01") castable as xs:yearMonthDuration)
not(xs:double("3.3e3") castable as xs:anyURI)
not(xs:double("3.3e3") castable as xs:base64Binary)
not(xs:double("3.3e3") castable as xs:date)
not(xs:double("3.3e3") castable as xs:dateTime)
not(xs:double("3.3e3") castable as xs:dayTimeDuration)
not(xs:double("3.3e3") castable as xs:duration)
not(xs:double("3.3e3") castable as xs:gDay)
not(xs:double("3.3e3") castable as xs:gMonth)
not(xs:double("3.3e3") castable as xs:gMonthDay)
not(xs:double("3.3e3") castable as xs:gYear)
not(xs:double("3.3e3") castable as xs:gYearMonth)
not(xs:double("3.3e3") castable as xs:hexBinary)
not(xs:double("3.3e3") castable as xs:NOTATION)
not(xs:double("3.3e3") castable as xs:time)
not(xs:double("3.3e3") castable as xs:yearMonthDuration)
not(xs:double("NaN"))
not(xs:double('NaN'))
not(xs:double("NaN") ge 1)
not(xs:double("NaN") gt 1)
not(xs:double("NaN") le 1)
not(xs:double("NaN") lt 1)
not(xs:duration("P1999Y10M3DT08H34M12.043S") eq xs:duration("P1999Y10M3DT08H34M12.143S"))
not(xs:duration("P1999Y10M3DT08H34M12.143S") ne xs:duration("P1999Y10M3DT08H34M12.143S"))
not(xs:duration("P1Y2M3DT10H30M") castable as xs:anyURI)
not(xs:duration("P1Y2M3DT10H30M") castable as xs:base64Binary)
not(xs:duration("P1Y2M3DT10H30M") castable as xs:boolean)
not(xs:duration("P1Y2M3DT10H30M") castable as xs:date)
not(xs:duration("P1Y2M3DT10H30M") castable as xs:dateTime)
not(xs:duration("P1Y2M3DT10H30M") castable as xs:decimal)
not(xs:duration("P1Y2M3DT10H30M") castable as xs:double)
not(xs:duration("P1Y2M3DT10H30M") castable as xs:float)
not(xs:duration("P1Y2M3DT10H30M") castable as xs:gDay)
not(xs:duration("P1Y2M3DT10H30M") castable as xs:gMonth)
not(xs:duration("P1Y2M3DT10H30M") castable as xs:gMonthDay)
not(xs:duration("P1Y2M3DT10H30M") castable as xs:gYear)
not(xs:duration("P1Y2M3DT10H30M") castable as xs:gYearMonth)
not(xs:duration("P1Y2M3DT10H30M") castable as xs:hexBinary)
not(xs:duration("P1Y2M3DT10H30M") castable as xs:integer)
not(xs:duration("P1Y2M3DT10H30M") castable as xs:NOTATION)
not(xs:duration("P1Y2M3DT10H30M") castable as xs:time)
not(xs:float("3.4e5") castable as xs:anyURI)
not(xs:float("3.4e5") castable as xs:base64Binary)
not(xs:float("3.4e5") castable as xs:date)
not(xs:float("3.4e5") castable as xs:dateTime)
not(xs:float("3.4e5") castable as xs:dayTimeDuration)
not(xs:float("3.4e5") castable as xs:duration)
not(xs:float("3.4e5") castable as xs:gDay)
not(xs:float("3.4e5") castable as xs:gMonth)
not(xs:float("3.4e5") castable as xs:gMonthDay)
not(xs:float("3.4e5") castable as xs:gYear)
not(xs:float("3.4e5") castable as xs:gYearMonth)
not(xs:float("3.4e5") castable as xs:hexBinary)
not(xs:float("3.4e5") castable as xs:NOTATION)
not(xs:float("3.4e5") castable as xs:time)
not(xs:float("3.4e5") castable as xs:yearMonthDuration)
not(xs:float("NaN"))
not(xs:float('NaN'))
not(xs:float("NaN") ge 1)
not(xs:float("NaN") gt 1)
not(xs:float("NaN") le 1)
not(xs:float("NaN") lt 1)
not(xs:gDay("---01") ne xs:gDay("---01"))
not(xs:gDay("---03") castable as xs:anyURI)
not(xs:gDay("---03") castable as xs:base64Binary)
not(xs:gDay("---03") castable as xs:boolean)
not(xs:gDay("---03") castable as xs:date)
not(xs:gDay("---03") castable as xs:dateTime)
not(xs:gDay("---03") castable as xs:dayTimeDuration)
not(xs:gDay("---03") castable as xs:decimal)
not(xs:gDay("---03") castable as xs:double)
not(xs:gDay("---03") castable as xs:duration)
not(xs:gDay("---03") castable as xs:float)
not(xs:gDay("---03") castable as xs:gMonth)
not(xs:gDay("---03") castable as xs:gMonthDay)
not(xs:gDay("---03") castable as xs:gYear)
not(xs:gDay("---03") castable as xs:gYearMonth)
not(xs:gDay("---03") castable as xs:hexBinary)
not(xs:gDay("---03") castable as xs:integer)
not(xs:gDay("---03") castable as xs:NOTATION)
not(xs:gDay("---03") castable as xs:time)
not(xs:gDay("---03") castable as xs:yearMonthDuration)
not(xs:gDay("---31") eq xs:gDay("---01"))
not(xs:gMonth("--03") ne xs:gMonth("--03"))
not(xs:gMonth("--11") castable as xs:anyURI)
not(xs:gMonth("--11") castable as xs:base64Binary)
not(xs:gMonth("--11") castable as xs:boolean)
not(xs:gMonth("--11") castable as xs:date)
not(xs:gMonth("--11") castable as xs:dateTime)
not(xs:gMonth("--11") castable as xs:dayTimeDuration)
not(xs:gMonth("--11") castable as xs:decimal)
not(xs:gMonth("--11") castable as xs:double)
not(xs:gMonth("--11") castable as xs:duration)
not(xs:gMonth("--11") castable as xs:float)
not(xs:gMonth("--11") castable as xs:gDay)
not(xs:gMonth("--11") castable as xs:gMonthDay)
not(xs:gMonth("--11") castable as xs:gYear)
not(xs:gMonth("--11") castable as xs:gYearMonth)
not(xs:gMonth("--11") castable as xs:hexBinary)
not(xs:gMonth("--11") castable as xs:integer)
not(xs:gMonth("--11") castable as xs:NOTATION)
not(xs:gMonth("--11") castable as xs:time)
not(xs:gMonth("--11") castable as xs:yearMonthDuration)
not(xs:gMonth("--11") eq xs:gMonth("--01"))
not(xs:gMonthDay("--03-03") eq xs:gMonthDay("--04-03"))
not(xs:gMonthDay("--04-11") ne xs:gMonthDay("--04-11"))
not(xs:gMonthDay("--11-13") castable as xs:anyURI)
not(xs:gMonthDay("--11-13") castable as xs:base64Binary)
not(xs:gMonthDay("--11-13") castable as xs:boolean)
not(xs:gMonthDay("--11-13") castable as xs:date)
not(xs:gMonthDay("--11-13") castable as xs:dateTime)
not(xs:gMonthDay("--11-13") castable as xs:dayTimeDuration)
not(xs:gMonthDay("--11-13") castable as xs:decimal)
not(xs:gMonthDay("--11-13") castable as xs:double)
not(xs:gMonthDay("--11-13") castable as xs:duration)
not(xs:gMonthDay("--11-13") castable as xs:float)
not(xs:gMonthDay("--11-13") castable as xs:gDay)
not(xs:gMonthDay("--11-13") castable as xs:gMonth)
not(xs:gMonthDay("--11-13") castable as xs:gYear)
not(xs:gMonthDay("--11-13") castable as xs:gYearMonth)
not(xs:gMonthDay("--11-13") castable as xs:hexBinary)
not(xs:gMonthDay("--11-13") castable as xs:integer)
not(xs:gMonthDay("--11-13") castable as xs:NOTATION)
not(xs:gMonthDay("--11-13") castable as xs:time)
not(xs:gMonthDay("--11-13") castable as xs:yearMonthDuration)
not(xs:gYear("1956") eq xs:gYear("1958"))
not(xs:gYear("1956") ne xs:gYear("1956"))
not(xs:gYear("1999") castable as xs:anyURI)
not(xs:gYear("1999") castable as xs:base64Binary)
not(xs:gYear("1999") castable as xs:boolean)
not(xs:gYear("1999") castable as xs:date)
not(xs:gYear("1999") castable as xs:dateTime)
not(xs:gYear("1999") castable as xs:dayTimeDuration)
not(xs:gYear("1999") castable as xs:decimal)
not(xs:gYear("1999") castable as xs:double)
not(xs:gYear("1999") castable as xs:duration)
not(xs:gYear("1999") castable as xs:float)
not(xs:gYear("1999") castable as xs:gDay)
not(xs:gYear("1999") castable as xs:gMonth)
not(xs:gYear("1999") castable as xs:gMonthDay)
not(xs:gYear("1999") castable as xs:gYearMonth)
not(xs:gYear("1999") castable as xs:hexBinary)
not(xs:gYear("1999") castable as xs:integer)
not(xs:gYear("1999") castable as xs:NOTATION)
not(xs:gYear("1999") castable as xs:time)
not(xs:gYear("1999") castable as xs:yearMonthDuration)
not(xs:gYearMonth("1995-11") ne xs:gYearMonth("1995-11"))
not(xs:gYearMonth("1999-11") castable as xs:anyURI)
not(xs:gYearMonth("1999-11") castable as xs:base64Binary)
not(xs:gYearMonth("1999-11") castable as xs:boolean)
not(xs:gYearMonth("1999-11") castable as xs:date)
not(xs:gYearMonth("1999-11") castable as xs:dateTime)
not(xs:gYearMonth("1999-11") castable as xs:dayTimeDuration)
not(xs:gYearMonth("1999-11") castable as xs:decimal)
not(xs:gYearMonth("1999-11") castable as xs:double)
not(xs:gYearMonth("1999-11") castable as xs:duration)
not(xs:gYearMonth("1999-11") castable as xs:float)
not(xs:gYearMonth("1999-11") castable as xs:gDay)
not(xs:gYearMonth("1999-11") castable as xs:gMonth)
not(xs:gYearMonth("1999-11") castable as xs:gMonthDay)
not(xs:gYearMonth("1999-11") castable as xs:gYear)
not(xs:gYearMonth("1999-11") castable as xs:hexBinary)
not(xs:gYearMonth("1999-11") castable as xs:integer)
not(xs:gYearMonth("1999-11") castable as xs:NOTATION)
not(xs:gYearMonth("1999-11") castable as xs:time)
not(xs:gYearMonth("1999-11") castable as xs:yearMonthDuration)
not(xs:gYearMonth("2001-03") eq xs:gYearMonth("2000-03"))
not(xs:hexBinary("0FB7") castable as xs:anyURI)
not(xs:hexBinary("0FB7") castable as xs:boolean)
not(xs:hexBinary("0FB7") castable as xs:date)
not(xs:hexBinary("0FB7") castable as xs:dateTime)
not(xs:hexBinary("0FB7") castable as xs:dayTimeDuration)
not(xs:hexBinary("0FB7") castable as xs:decimal)
not(xs:hexBinary("0FB7") castable as xs:double)
not(xs:hexBinary("0FB7") castable as xs:duration)
not(xs:hexBinary("0FB7") castable as xs:float)
not(xs:hexBinary("0FB7") castable as xs:gDay)
not(xs:hexBinary("0FB7") castable as xs:gMonth)
not(xs:hexBinary("0FB7") castable as xs:gMonthDay)
not(xs:hexBinary("0FB7") castable as xs:gYear)
not(xs:hexBinary("0FB7") castable as xs:gYearMonth)
not(xs:hexBinary("0FB7") castable as xs:integer)
not(xs:hexBinary("0FB7") castable as xs:NOTATION)
not(xs:hexBinary("0FB7") castable as xs:time)
not(xs:hexBinary("0FB7") castable as xs:yearMonthDuration)
not(xs:hexBinary("FF") eq xs:hexBinary("aa"))
not(xs:integer("6789") castable as xs:anyURI)
not(xs:integer("6789") castable as xs:base64Binary)
not(xs:integer("6789") castable as xs:date)
not(xs:integer("6789") castable as xs:dateTime)
not(xs:integer("6789") castable as xs:dayTimeDuration)
not(xs:integer("6789") castable as xs:duration)
not(xs:integer("6789") castable as xs:gDay)
not(xs:integer("6789") castable as xs:gMonth)
not(xs:integer("6789") castable as xs:gMonthDay)
not(xs:integer("6789") castable as xs:gYear)
not(xs:integer("6789") castable as xs:gYearMonth)
not(xs:integer("6789") castable as xs:hexBinary)
not(xs:integer("6789") castable as xs:NOTATION)
not(xs:integer("6789") castable as xs:time)
not(xs:integer("6789") castable as xs:yearMonthDuration)
not(xs:NOTATION("prefix:local") castable as xs:anyURI)
not(xs:NOTATION("prefix:local") castable as xs:base64Binary)
not(xs:NOTATION("prefix:local") castable as xs:boolean)
not(xs:NOTATION("prefix:local") castable as xs:date)
not(xs:NOTATION("prefix:local") castable as xs:dateTime)
not(xs:NOTATION("prefix:local") castable as xs:dayTimeDuration)
not(xs:NOTATION("prefix:local") castable as xs:decimal)
not(xs:NOTATION("prefix:local") castable as xs:double)
not(xs:NOTATION("prefix:local") castable as xs:duration)
not(xs:NOTATION("prefix:local") castable as xs:float)
not(xs:NOTATION("prefix:local") castable as xs:gDay)
not(xs:NOTATION("prefix:local") castable as xs:gMonth)
not(xs:NOTATION("prefix:local") castable as xs:gMonthDay)
not(xs:NOTATION("prefix:local") castable as xs:gYear)
not(xs:NOTATION("prefix:local") castable as xs:gYearMonth)
not(xs:NOTATION("prefix:local") castable as xs:hexBinary)
not(xs:NOTATION("prefix:local") castable as xs:integer)
not(xs:NOTATION("prefix:local") castable as xs:NOTATION)
not(xs:NOTATION("prefix:local") castable as xs:QName)
not(xs:NOTATION("prefix:local") castable as xs:string)
not(xs:NOTATION("prefix:local") castable as xs:time)
not(xs:NOTATION("prefix:local") castable as xs:untypedAtomic)
not(xs:NOTATION("prefix:local") castable as xs:yearMonthDuration)
not(xs:QName("ncname") castable as xs:anyURI)
not(xs:QName("ncname") castable as xs:base64Binary)
not(xs:QName("ncname") castable as xs:boolean)
not(xs:QName("ncname") castable as xs:date)
not(xs:QName("ncname") castable as xs:dateTime)
not(xs:QName("ncname") castable as xs:dayTimeDuration)
not(xs:QName("ncname") castable as xs:decimal)
not(xs:QName("ncname") castable as xs:double)
not(xs:QName("ncname") castable as xs:duration)
not(xs:QName("ncname") castable as xs:float)
not(xs:QName("ncname") castable as xs:gDay)
not(xs:QName("ncname") castable as xs:gMonth)
not(xs:QName("ncname") castable as xs:gMonthDay)
not(xs:QName("ncname") castable as xs:gYear)
not(xs:QName("ncname") castable as xs:gYearMonth)
not(xs:QName("ncname") castable as xs:hexBinary)
not(xs:QName("ncname") castable as xs:integer)
not(xs:QName("ncname") castable as xs:NOTATION)
not(xs:QName("ncname") castable as xs:time)
not(xs:QName("ncname") castable as xs:yearMonthDuration)
not(xs:string("an arbitrary string") castable as xs:NOTATION)
not(xs:string("http://example.com/A") eq xs:anyURI("http://example.com/B"))
not(xs:string("http://example.com/A") gt xs:anyURI("http://example.com/B"))
not(xs:string("http://example.com/A") ne xs:anyURI("http://example.com/A"))
not(xs:string(/works/@id) eq "abc")
not(xs:string(/works/@id) ne "abc")
not(xs:time("03:20:00-05:00") castable as xs:anyURI)
not(xs:time("03:20:00-05:00") castable as xs:base64Binary)
not(xs:time("03:20:00-05:00") castable as xs:boolean)
not(xs:time("03:20:00-05:00") castable as xs:date)
not(xs:time("03:20:00-05:00") castable as xs:dateTime)
not(xs:time("03:20:00-05:00") castable as xs:dayTimeDuration)
not(xs:time("03:20:00-05:00") castable as xs:decimal)
not(xs:time("03:20:00-05:00") castable as xs:double)
not(xs:time("03:20:00-05:00") castable as xs:duration)
not(xs:time("03:20:00-05:00") castable as xs:float)
not(xs:time("03:20:00-05:00") castable as xs:gDay)
not(xs:time("03:20:00-05:00") castable as xs:gMonth)
not(xs:time("03:20:00-05:00") castable as xs:gMonthDay)
not(xs:time("03:20:00-05:00") castable as xs:gYear)
not(xs:time("03:20:00-05:00") castable as xs:gYearMonth)
not(xs:time("03:20:00-05:00") castable as xs:hexBinary)
not(xs:time("03:20:00-05:00") castable as xs:integer)
not(xs:time("03:20:00-05:00") castable as xs:NOTATION)
not(xs:time("03:20:00-05:00") castable as xs:yearMonthDuration)
not(xs:untypedAtomic("1") != 1)
not((xs:untypedAtomic("1"), xs:untypedAtomic("2")) = (xs:untypedAtomic("2.0"), 3.0))
not(xs:untypedAtomic("2") = 1)
not(xs:untypedAtomic("an arbitrary string(untypedAtomic source)") castable as xs:NOTATION)
not(xs:untypedAtomic("a string") and xs:untypedAtomic(""))
not(xs:untypedAtomic("a string") != "a string")
not(xs:untypedAtomic("a string") = "a stringDIFF")
not(xs:untypedAtomic(current-time()) eq xs:untypedAtomic("now"))
not(xs:untypedAtomic(current-time()) ge xs:untypedAtomic("now"))
not(xs:untypedAtomic(current-time()) gt xs:untypedAtomic("now"))
not(xs:untypedAtomic(current-time()) le xs:untypedAtomic("now"))
not(xs:untypedAtomic(current-time()) lt xs:untypedAtomic("now"))
not(xs:untypedAtomic(current-time()) ne xs:untypedAtomic("now"))
not(xs:untypedAtomic("false") != false())
not(xs:untypedAtomic("false") > true())
not(xs:untypedAtomic("true") < false())
not(xs:untypedAtomic("true") = false())
not(xs:yearMonthDuration("P1999Y10M") gt xs:yearMonthDuration("P1999Y10M"))
not(xs:yearMonthDuration("P1999Y10M") gt xs:yearMonthDuration("P1999Y11M"))
not(xs:yearMonthDuration("P1999Y10M") le xs:yearMonthDuration("P1999Y9M"))
not(xs:yearMonthDuration("P1999Y10M") lt xs:yearMonthDuration("P1999Y10M"))
not(xs:yearMonthDuration("P1999Y10M") lt xs:yearMonthDuration("P1999Y9M"))
not(xs:yearMonthDuration("P1999Y10M") ne xs:yearMonthDuration("P1999Y10M"))
not(xs:yearMonthDuration("P1999Y9M") ge xs:yearMonthDuration("P1999Y10M"))
not(xs:yearMonthDuration("P1999Y") eq xs:yearMonthDuration("P1999Y10M"))
not(xs:yearMonthDuration("P1Y12M") castable as xs:anyURI)
not(xs:yearMonthDuration("P1Y12M") castable as xs:base64Binary)
not(xs:yearMonthDuration("P1Y12M") castable as xs:boolean)
not(xs:yearMonthDuration("P1Y12M") castable as xs:date)
not(xs:yearMonthDuration("P1Y12M") castable as xs:dateTime)
not(xs:yearMonthDuration("P1Y12M") castable as xs:decimal)
not(xs:yearMonthDuration("P1Y12M") castable as xs:double)
not(xs:yearMonthDuration("P1Y12M") castable as xs:float)
not(xs:yearMonthDuration("P1Y12M") castable as xs:gDay)
not(xs:yearMonthDuration("P1Y12M") castable as xs:gMonth)
not(xs:yearMonthDuration("P1Y12M") castable as xs:gMonthDay)
not(xs:yearMonthDuration("P1Y12M") castable as xs:gYear)
not(xs:yearMonthDuration("P1Y12M") castable as xs:gYearMonth)
not(xs:yearMonthDuration("P1Y12M") castable as xs:hexBinary)
not(xs:yearMonthDuration("P1Y12M") castable as xs:integer)
not(xs:yearMonthDuration("P1Y12M") castable as xs:NOTATION)
not(xs:yearMonthDuration("P1Y12M") castable as xs:time)
number(1, 2)
number("  -22e0  ")
number("+22e0")
number( (/atomic:root/atomic:integer) except (/atomic:root/atomic:string))
number(false())
number(implicit-timezone())
number(true())
number(xs:untypedAtomic("1000"))
of
one-or-more( () )
one-or-more()
one-or-more(1, 2)
one-or-more((1 to 10)[. div 2 = 0])
(one-or-more('a'))
(one-or-more( ('a', 'b') ))
(one-or-more('a'), one-or-more( ('a', 'b') ))
one-or-more("one")
("one", "two") castable as xs:string+
("one two three four five" => Q{http://www.w3.org/2005/xpath-functions}tokenize(" ")) ! upper-case(.)
"one two three four five" => tokenize(" ") ! upper-case(.)
("one two three four five" => tokenize(" ")) ! upper-case(.)
<! oo -->
<!- oo -->
<!-- oo ->
<!--- oo ->
"" or ''
() or ()
() or (0)
() or (1)
"" or 'a'
order eq order
ordering eq ordering
<out>{1, <!-- content -->/ancestor-or-self::node(), 1}</out>
<out>{1, <e attr=""/>/descendant-or-self::node(), 1}</out>
<out>{1, <e/>/descendant-or-self::node(), 1}</out>
<out>{1, <element/>/ancestor-or-self::node(), 1}</out>
<out>{1, <?target data?>/ancestor-or-self::node(), 1}</out>
<out>{[<a/>, [<b/>, <c/>]]}</out>
<out>{array:flatten((<a/>, <b/>, <c/>))}</out>
<out>{array:flatten([<a/>, [<b/>, <c/>]])}</out>
<out>{ (<a xmlns:ex="http://www.example.com/ ns"><ex:b>93.7</ex:b></a>) /Q{ http://www.example.com/ ns }b/namespace-uri() }</out>
<out>{ (<a xmlns:ex="http://www.example.com/ns?p='23'"><ex:b>93.7</ex:b></a>) /Q{http://www.example.com/ns?p='23'}:b }</out>
<out>{ (<a xmlns:ex="http://www.example.com/ns?p='23'"><ex:b>93.7</ex:b></a>) /Q{http://www.example.com/ns?p='23'}}b }</out>
<out>{ (<a xmlns:ex="http://www.example.com/ns?p='23'"><ex:b>93.7</ex:b></a>) /Q{http://www.example.com/ns?p='23'}b }</out>
outermost(//*) except //*
outermost(//rubbish)
<out>{fn:count(//center/comment())}</out>
<out>{fn:count(//center/processing-instruction('a-pi'))}</out>
<out>{fn:count(//center/processing-instruction())}</out>
<out>{fn:count(//center/text())}</out>
<out>{fn:count(//comment())}</out>
<out>{fn:count(//processing-instruction('a-pi'))}</out>
<out>{fn:count(//processing-instruction())}</out>
<out>{ if (1 != 0) then if (4 != 5) then 1 else 2 else 3 }</out>
<out>{ (<my:a xmlns:my="http://www.example.com/ns/my"><my:b>42</my:b></my:a>) / Q{http://www.example.com/ns/my}* + 5 }</out>
<out>{ (<my:a xmlns:my="http://www.example.com/ns/my"><my:b>42</my:b></my:a>) / Q{http://www.example.com/ns/my}b }</out>
<out>{ <Q{http://www.example.com/ns}/> }</out>
<out xmlns="http://www.example.com/one">{ (<my:a xmlns:my="http://www.example.com/ns/my"><my:b>42</my:b><b xmlns="">93</b></my:a>) / Q{}* + 5 }</out>
"P11768614336404564651D" cast as xs:dayTimeDuration
"-P11768614336404564651D" cast as xs:duration
"-P768614336404564651Y" cast as xs:duration
"P768614336404564651Y" cast as xs:duration
"-P768614336404564651Y" cast as xs:yearMonthDuration
"P768614336404564651Y" cast as xs:yearMonthDuration
parent::
<parent><child xmlns:cm="http://www.example.com"/><child>{count(//cm:b)}</child></parent>
parent::self()
parse-json("[]")
parse-json("{}")
parse-json('')
parse-json('["\""]')
parse-json('["\"]')
parse-json('["\/"]')
parse-json('["\\"]')
parse-json('[00.00]')
parse-json('[01]')
parse-json('[-0.123]')
parse-json('[0.123]')
parse-json('[-0.123e+2]')
parse-json('[-0.123e-2[')
parse-json('[-0.123e-2]')
parse-json('[-0.123e2]')
parse-json('["\1"]')
parse-json('"111\333"')
parse-json('[1, 2, [], [1], [1,2], [1,2,3]]')
parse-json('[1,2,3,]')
parse-json("[12345]")
parse-json('[1.234f0]')
parse-json('         [   1,     2,  3,          "abc",  "def",   true,          false,  null ]         ')
parse-json('[1,2,3, "abc", "def", true, false, null]')
parse-json('[+23]')
parse-json('23,24')
parse-json('[.3]')
parse-json('3.14eg')
parse-json('314eg')
parse-json('3.14Eg')
parse-json('[(5)]')
parse-json('[{5}]')
parse-json('93.7')
parse-json('{"a"')
parse-json('{"a":=13}')
parse-json('{"a":13')
parse-json('{"a":13,,"b":15}')
parse-json('"aaa\"')
parse-json('["aa\u0030aa"]')
parse-json('{"a" "b"}')
parse-json('{"a":{"b":12}')
parse-json('{"a":{"b":12}}}')
parse-json('["abc]')
parse-json('{"abc":12e0}')
parse-json('{"abc":-1.2e0}')
parse-json('"abcd"')
parse-json('["abcd"]')
parse-json('{"abc":false}')
parse-json('{"abc":null}')
parse-json('{"abc":true}')
parse-json('    {   "abc"   :   true    ,             "xyz"   :   false                }   ')
parse-json(' { "abc" : true , "xyz" : false } ')
parse-json('{"abc":true,"xyz":false}')
parse-json('{"'||codepoints-to-string((10, 37))||'":"x", "yyy":"y"}')
parse-json("[false]")
parse-json('[false')
parse-json('false')
parse-json('[falsehood]')
parse-json('["\n"]')
parse-json("[null]")
parse-json('null')
parse-json('["\r"]')
parse-json('["\s"]')
parse-json("[true]")
parse-json('true')
parse-json('["\u123u"]')
parse-json('["\u2"]')
parse-json('["\uD834\udD1E"]')
parse-json("['wrong']")
parse-json('{"x":[12,3], "y":[14,9]}')
parse-json('[{"x":12,"y":5}, {"x":13,"y":6}]')
parse-json('{"x":1, "y":[3,4,5]}')
parse-json('["\x20"]')
parse-json('[{x:23}]')
parse-json('{"x":"\\", "y":"\u0025"}')
<people id=""/>/(some $id in @id satisfies true())
<p>FA&#18446744073709551862;IL</p>
<p>FA&#4294967542;IL</p>
<p>FA&#xFF000000F6;IL</p>
<p>FA&#xFFFFFFFF000000F6;IL</p>
p:f:lname()
<?pi ?>
<?pi ?>?>
<?pi content?>
<?pi <?&--&lt;&#x20;><![CDATA[x]]> ?>
<pi>{string-to-codepoints(<?pi x ?>)}</pi>
<pi>{string-to-codepoints(<?pi x?>)}</pi>
pod_pod
position()
position(1)
preceding-or-ancestor::*
preceeding::node()
prefix:
<prefix: foo/>
<prefix:foo
prefix-from-QName()
prefix-from-QName(1, 2)
prefix-from-QName( QName("example.com/", "pre:lname")) eq "pre"
((//price/text()) , (//price/text())) except (//price/text())
/processing-instruction()
processing-instruction(*)
processing-instruction(1)
processing-instruction {123} {'text'}
processing-instruction {1,2} {'text'}
processing-instruction {//a} {'text'}
/processing-instruction() | /bib/book[2]/title
(/processing-instruction() except /bib/book[2]/title)/name()
/processing-instruction() except /processing-instruction()
(/processing-instruction() except /processing-instruction(PI1))/name()
/processing-instruction() intersect /bib/book[2]/title
(/processing-instruction() intersect /processing-instruction())/name()
processing-instruction "name" {"content"}
processing-instruction('ncname')
processing-instruction {//*:NCName[1]} {'text'}
processing-instruction {'one', 'two'} {'text'}
processing-instruction pi {''}
processing-instruction pi {'?>'}
processing-instruction pi {()}
processing-instruction pi {., .}
processing-instruction pi {1,'',2}
processing-instruction pi {1,<a/>,2}
/processing-instruction(PI1) | /bib/book[3]/title
(/processing-instruction(PI1) except /bib/book)/name()
/processing-instruction(PI1) intersect /bib/book
(/processing-instruction(PI1) intersect /processing-instruction())/name()
processing-instruction pi {1,'string',3.14,xs:float('1.2345e-2'),xs:dateTime('2002-04-02T12:00:00-01:00')}
/processing-instruction(PI1) union /bib/book[3]/title
processing-instruction(``[pi-action]``)
processing-instruction {'pi'[current-date() lt xs:date('1900-01-01')]} {'text'}
processing-instruction {('pi'[current-date() lt xs:date('1900-01-01')], xs:anyURI('pi'))} {'text'}
processing-instruction {('pi'[current-date() lt xs:date('1900-01-01')], xs:duration('P1D'))} {'text'}
processing-instruction pi {<elem>123</elem>, (<elem attr='456'/>)/@attr, (<elem>789</elem>)/text()}
processing-instruction pi {/root}
processing-instruction {'p i'} {'text'}
processing-instruction {'pi', ()} {'text'}
processing-instruction {'pi'} {'text'}
processing-instruction {(), 'pi'} {'text'}
processing-instruction pi {'?>text'}
processing-instruction pi {'text'}
processing-instruction pi {'text?>text'}
processing-instruction {//*:QName} {'text'}
processing-instruction target { '?>' }
processing-instruction {()} {'text'}
processing-instruction {"thename"} {"asdas?>"}
/processing-instruction() union /bib/book[2]/title
processing-instruction {"xml"} {"content"}
processing-instruction {'xml'} {'pi'}
processing-instruction xml {'pi'}
processing-instruction {'XmL'} {'pi'}
processing-instruction XmL {'pi'}
processing-instruction {xs:dateTime("1999-05-31T13:20:00")} {'text'}
processing-instruction {xs:untypedAtomic('one'), xs:untypedAtomic('two')} {'text'}
processing-instruction {xs:untypedAtomic('p i')} {'text'}
processing-instruction {xs:untypedAtomic('pi')} {'text'}
[//product,( "a", "b", "c"),"d"]
(: Purpoose: For each person, list the number of items currently on sale           whose price does not exceed 0.02% of the person's income. :)           <XMark-result-Q11> {              let $auction := (/) return              for $p in $auction/site/people/person              let $l := for $i in $auction/site/open_auctions/open_auction/initial              where $p/profile/@income > 5000 * exactly-one($i/text())              return $i return <items name="{$p/name/text()}">{count($l)}</items> } </XMark-result-Q11>
(: Purpose: For each richer-than-average person, list the           number of items currently on sale whose price does not exceed 0.02% of the person's income. :)           <XMark-result-Q12> {              let $auction := (/) return              for $p in $auction/site/people/person              let $l := for $i in $auction/site/open_auctions/open_auction/initial              where $p/profile/@income > 5000.0 * exactly-one($i/text())              return $i where $p/profile/@income > 50000.0              return <items person="{$p/profile/@income}">{count($l)}</items> } </XMark-result-Q12>
(: Purpose: Give an alphabetically ordered list of all items along with their location. :)           <XMark-result-Q19> {              let $auction := (/) return              for $b in $auction/site/regions//item              let $k := $b/name/text() stable order by zero-or-one($b/location) ascending empty greatest              return <item name="{$k}">{$b/location/text()}</item> } </XMark-result-Q19>
(: Purpose: List the names of items registered in Australia along with their descriptions. :)           <XMark-result-Q13> {              let $auction := (/) return              for $i in $auction/site/regions/australia/item              return <item name="{$i/name/text()}">{$i/description}</item> } </XMark-result-Q13>
(: Purpose: List the names of persons and the names of the items           they bought in Europe(joins person, closed auction, item). :)           <XMark-result-Q9> {              let $auction := (/)              return let $ca := $auction/site/closed_auctions/closed_auction              return let $ei := $auction/site/regions/europe/item              for $p in $auction/site/people/person              let $a := for $t in $ca where $p/@id = $t/buyer/@person              return let $n := for $t2 in $ei where $t/itemref/@item = $t2/@id              return $t2 return <item>{$n/name/text()}</item>              return <person name="{$p/name/text()}">{$a}</person> } </XMark-result-Q9>
(: Purpose: List the names of persons and the number of items they bought. (joins person, closed\_auction). :)           <XMark-result-Q8> { let $auction := (/) return           for $p in $auction/site/people/person           let $a := for $t in $auction/site/closed_auctions/closed_auction           where $t/buyer/@person = $p/@id return $t           return <item person="{$p/name/text()}">{count($a)}</item> } </XMark-result-Q8>
(: Purpose: List the reserves of those open auctions where a certain person issued a bid before another person. :)          <XMark-result-Q4> {              let $auction := (/) return              for $b in $auction/site/open_auctions/open_auction              where some $pr1 in $b/bidder/personref[@person = "person20"], $pr2 in $b/bidder/personref[@person = "person51"] satisfies $pr1 << $pr2              return <history>{$b/reserve/text()}</history> }          </XMark-result-Q4>
(: Purpose: Return the IDs of all open auctions whose current increase is at least twice as high as the initial increase. :)          <XMark-result-Q3> {              let $auction := (/)              return for $b in $auction/site/open_auctions/open_auction              where zero-or-one($b/bidder[1]/increase/text()) * 2.0 <= $b/bidder[last()]/increase/text()                  return <increase first="{$b/bidder[1]/increase/text()}" last="{$b/bidder[last()]/increase/text()}"/> }          </XMark-result-Q3>
(: Purpose: Return the IDs of those auctions that have one or more keywords in emphasis. (cf. Q15) :)           <XMark-result-Q16> {              let $auction := (/) return              for $a in $auction/site/closed_auctions/closed_auction              where not( empty( $a/annotation/description/parlist/listitem/parlist/listitem/text/emph/ keyword/ text() ) )              return <person id="{$a/seller/@person}"/> } </XMark-result-Q16>
(: Purpose: Return the names of all items whose description contains the word `gold'. :)           <XMark-result-Q14> {              let $auction := (/) return              for $i in $auction/site//item              where contains(string(exactly-one($i/description)), "gold")              return $i/name/text() } </XMark-result-Q14>
/Q{%gg}SomeElement
/Q{  http://www.example.com/AuctionWatch}AuctionWatchList/          Q{   http://www.example.com/AuctionWatch}Auction[2]/          @Q{  http://www.example.com/auctioneers          #yabadoo}ID
Q{http://www.w3.org/2001/XMLSchema}anyURI#1('http://www.example.org/')
Q{http://www.w3.org/2001/XMLSchema}base64Binary#1('D74D35D35D35')
Q{http://www.w3.org/2001/XMLSchema}boolean#1('1')
Q{http://www.w3.org/2001/XMLSchema}byte#1('1')
Q{http://www.w3.org/2001/XMLSchema}date#1('1970-01-02Z')
Q{http://www.w3.org/2001/XMLSchema}dateTime#1('1970-01-02T04:05:06Z')
Q{http://www.w3.org/2001/XMLSchema}dayTimeDuration#1('PT15H')
Q{http://www.w3.org/2001/XMLSchema}decimal#1('1')
Q{http://www.w3.org/2001/XMLSchema}double#1('1')
Q{http://www.w3.org/2001/XMLSchema}duration#1('P5Y2M10DT15H')
Q{http://www.w3.org/2001/XMLSchema}ENTITIES#1('ENTITY1 ENTITY2 ENTITY3')
Q{http://www.w3.org/2001/XMLSchema}ENTITY#1('ENTITY')
Q{http://www.w3.org/2001/XMLSchema}float#1('1')
Q{http://www.w3.org/2001/XMLSchema}gDay#1('---01Z')
Q{http://www.w3.org/2001/XMLSchema}gMonth#1('--11Z')
Q{http://www.w3.org/2001/XMLSchema}gMonthDay#1('--11-01Z')
Q{http://www.w3.org/2001/XMLSchema}gYear#1('2012Z')
Q{http://www.w3.org/2001/XMLSchema}gYearMonth#1('2001-10Z')
Q{http://www.w3.org/2001/XMLSchema}hexBinary#1('0fb7')
Q{http://www.w3.org/2001/XMLSchema}ID#1('ID')
Q{http://www.w3.org/2001/XMLSchema}IDREF#1('IDREF')
Q{http://www.w3.org/2001/XMLSchema}IDREFS#1('ID1 ID2 ID3')
Q{http://www.w3.org/2001/XMLSchema}int#1('1')
Q{http://www.w3.org/2001/XMLSchema}integer#1('1')
Q{http://www.w3.org/2001/XMLSchema}language#1('en')
Q{http://www.w3.org/2001/XMLSchema}long#1('1')
Q{http://www.w3.org/2001/XMLSchema}Name#1('Name')
Q{http://www.w3.org/2001/XMLSchema}NCName#1('NCName')
Q{http://www.w3.org/2001/XMLSchema}negativeInteger#1('-1')
Q{http://www.w3.org/2001/XMLSchema}NMTOKEN#1('NMTOKEN')
Q{http://www.w3.org/2001/XMLSchema}NMTOKENS#1('NMTOKEN1 NMTOKEN2 NMTOKEN3')
Q{http://www.w3.org/2001/XMLSchema}nonNegativeInteger#1('1')
Q{http://www.w3.org/2001/XMLSchema}nonPositiveInteger#1('-1')
Q{http://www.w3.org/2001/XMLSchema}normalizedString#1('normalized string')
Q{http://www.w3.org/2001/XMLSchema}positiveInteger#1('1')
Q{http://www.w3.org/2001/XMLSchema}QName#1('fn:QName')
Q{http://www.w3.org/2001/XMLSchema}short#1('1')
Q{http://www.w3.org/2001/XMLSchema}string#1('string')
Q{http://www.w3.org/2001/XMLSchema}time#1('01:02:03Z')
Q{http://www.w3.org/2001/XMLSchema}token#1('token')
Q{http://www.w3.org/2001/XMLSchema}unsignedByte#1('1')
Q{http://www.w3.org/2001/XMLSchema}unsignedInt#1('1')
Q{http://www.w3.org/2001/XMLSchema}unsignedLong#1('1')
Q{http://www.w3.org/2001/XMLSchema}unsignedShort#1('1')
Q{http://www.w3.org/2001/XMLSchema}untypedAtomic#1('string')
Q{http://www.w3.org/2001/XMLSchema}yearMonthDuration#1('P1Y')
Q{http://www.w3.org/2005/xpath-functions}abs#1(-1)
Q{http://www.w3.org/2005/xpath-functions}avg#1((1, 3))
Q{http://www.w3.org/2005/xpath-functions}boolean#1("string")
Q{http://www.w3.org/2005/xpath-functions}ceiling#1(0.9)
Q{http://www.w3.org/2005/xpath-functions}codepoint-equal#2('string', 'string')
Q{http://www.w3.org/2005/xpath-functions}codepoints-to-string#1((65, 66))
Q{http://www.w3.org/2005/xpath-functions}compare#2('string', 'string')
Q{http://www.w3.org/2005/xpath-functions}concat#3('a', 'bc', 'def')
Q{http://www.w3.org/2005/xpath-functions}contains#2('string', 'rin')
Q{http://www.w3.org/2005/xpath-functions}count#1((1, true()))
Q{http://www.w3.org/2005/xpath-functions}current-date#0()
Q{http://www.w3.org/2005/xpath-functions}current-dateTime#0()
Q{http://www.w3.org/2005/xpath-functions}current-time#0()
Q{http://www.w3.org/2005/xpath-functions}data#1(/root/child[1])
Q{http://www.w3.org/2005/xpath-functions}dateTime#2(xs:date('2012-01-01Z'), xs:time('00:00:00Z'))
Q{http://www.w3.org/2005/xpath-functions}day-from-date#1(xs:date('2012-02-01Z'))
Q{http://www.w3.org/2005/xpath-functions}day-from-dateTime#1(xs:dateTime('2012-04-03T02:01:00Z'))
Q{http://www.w3.org/2005/xpath-functions}days-from-duration#1(xs:dayTimeDuration("P3DT10H"))
Q{http://www.w3.org/2005/xpath-functions}deep-equal#2((1, true()), (1, true()))
Q{http://www.w3.org/2005/xpath-functions}empty#1((1, true()))
Q{http://www.w3.org/2005/xpath-functions}encode-for-uri#1(' ')
Q{http://www.w3.org/2005/xpath-functions}ends-with#2('string', 'ing')
Q{http://www.w3.org/2005/xpath-functions}exactly-one#1(1)
Q{http://www.w3.org/2005/xpath-functions}exists#1((1, true()))
Q{http://www.w3.org/2005/xpath-functions}false#0()
Q{http://www.w3.org/2005/xpath-functions}filter#2(1 to 10, function($a) {$a mod 2 = 0})
Q{http://www.w3.org/2005/xpath-functions}floor#1(1.1)
Q{http://www.w3.org/2005/xpath-functions}fold-left#3(1 to 5, "", fn:concat(?, ".", ?))
Q{http://www.w3.org/2005/xpath-functions}fold-right#3(1 to 5, "", fn:concat(?, ".", ?))
Q{http://www.w3.org/2005/xpath-functions}for-each#2(("23", "29"), xs:int#1)
Q{http://www.w3.org/2005/xpath-functions}function-arity#1(fn:abs#1)
Q{http://www.w3.org/2005/xpath-functions}function-lookup#2(fn:QName('http://www.example.org', 'foo:bar'), 1)
Q{http://www.w3.org/2005/xpath-functions}function-name#1(fn:abs#1)
/Q{http://www.w3.org/2005/xpath-functions}has-children#0()
Q{http://www.w3.org/2005/xpath-functions}has-children#1(/)
Q{http://www.w3.org/2005/xpath-functions}head#1((1, true()))
Q{http://www.w3.org/2005/xpath-functions}hours-from-dateTime#1(xs:dateTime('2012-04-03T02:01:00Z'))
Q{http://www.w3.org/2005/xpath-functions}hours-from-duration#1(xs:dayTimeDuration("P3DT10H"))
Q{http://www.w3.org/2005/xpath-functions}hours-from-time#1(xs:time('02:01:00Z'))
/Q{http://www.w3.org/2005/xpath-functions}id#1(('id1', 'id2'))
Q{http://www.w3.org/2005/xpath-functions}id#2(('id1', 'id2'), /)
/Q{http://www.w3.org/2005/xpath-functions}idref#1(('id1', 'id2'))
Q{http://www.w3.org/2005/xpath-functions}idref#2(('id1', 'id2'), /)
Q{http://www.w3.org/2005/xpath-functions}implicit-timezone#0()
Q{http://www.w3.org/2005/xpath-functions}innermost#1(())
Q{http://www.w3.org/2005/xpath-functions}insert-before#3((1, 2, 3), 2, ('a', 'b', 'c'))
Q{http://www.w3.org/2005/xpath-functions}iri-to-uri#1('http://www.example.com/')
Q{http://www.w3.org/2005/xpath-functions}local-name#1(/root)
Q{http://www.w3.org/2005/xpath-functions}local-name-from-QName#1(fn:QName('http://www.example.org', 'foo:bar'))
Q{http://www.w3.org/2005/xpath-functions}lower-case#1('STRING')
Q{http://www.w3.org/2005/xpath-functions}matches#2('string', 'string')
Q{http://www.w3.org/2005/xpath-functions/math}acos#1(1e0)
Q{http://www.w3.org/2005/xpath-functions/math}asin#1(1e0)
Q{http://www.w3.org/2005/xpath-functions/math}atan#1(1e0)
Q{http://www.w3.org/2005/xpath-functions/math}atan2#2(1e0, 1e0)
Q{http://www.w3.org/2005/xpath-functions/math}cos#1(1e0)
Q{http://www.w3.org/2005/xpath-functions/math}exp10#1(1e0)
Q{http://www.w3.org/2005/xpath-functions/math}log10#1(1e0)
Q{http://www.w3.org/2005/xpath-functions/math}log#1(1e0)
Q{            http://www.w3.org/2005/xpath-functions/math          }pi()
Q{  http://www.w3.org/2005/xpath-functions/math}pi()
Q{{http://www.w3.org/2005/xpath-functions/math}pi()
Q{http://www.w3.org/2005/xpath-functions/math   }pi()
Q{http://www.w3.org/2005/xpath-functions/math pi()
Q{http://www.w3.org/2005/xpath-functions/math}}pi()
Q{http://www.w3.org/2005/xpath-functions/math}pi()
Q{http://www.w3.org/2005/ xpath-functions/math}pi()
Q{http://www.w3.org/2005/xpath-functions/math}pi#0()
Q{http://www.w3.org/2005/xpath-functions/math}pow#2(1e0, 1)
Q{http://www.w3.org/2005/xpath-functions/math}sin#1(1e0)
Q{http://www.w3.org/2005/xpath-functions/math}sqrt#1(1e0)
Q{http://www.w3.org/2005/xpath-functions/math}tan#1(1e0)
Q{http://www.w3.org/2005/xpath-functions}max#1((1, 3))
Q{http://www.w3.org/2005/xpath-functions}min#1((1, 3))
Q{http://www.w3.org/2005/xpath-functions}minutes-from-dateTime#1(xs:dateTime('2012-04-03T02:01:00Z'))
Q{http://www.w3.org/2005/xpath-functions}minutes-from-duration#1(xs:dayTimeDuration("P3DT10H"))
Q{http://www.w3.org/2005/xpath-functions}minutes-from-time#1(xs:time('02:01:00Z'))
Q{http://www.w3.org/2005/xpath-functions}month-from-date#1(xs:date('2012-02-01Z'))
Q{http://www.w3.org/2005/xpath-functions}month-from-dateTime#1(xs:dateTime('2012-04-03T02:01:00Z'))
Q{http://www.w3.org/2005/xpath-functions}months-from-duration#1(xs:yearMonthDuration("P20Y15M"))
Q{http://www.w3.org/2005/xpath-functions}name#1(/root)
Q{http://www.w3.org/2005/xpath-functions}namespace-uri#1(/root/*[2])
Q{http://www.w3.org/2005/xpath-functions}namespace-uri-from-QName#1(fn:QName('http://www.example.org', 'foo:bar'))
Q{http://www.w3.org/2005/xpath-functions}node-name#1(/root)
Q{http://www.w3.org/2005/xpath-functions}normalize-space#1(' string ')
Q{http://www.w3.org/2005/xpath-functions}not#1("string")
Q{http://www.w3.org/2005/xpath-functions}number#1('1')
Q{http://www.w3.org/2005/xpath-functions}one-or-more#1(1)
Q{http://www.w3.org/2005/xpath-functions}outermost#1(())
/Q{http://www.w3.org/2005/xpath-functions}path#0()
Q{http://www.w3.org/2005/xpath-functions}path#1(/)
Q{http://www.w3.org/2005/xpath-functions}prefix-from-QName#1(fn:QName('http://www.example.org', 'foo:bar'))
Q{http://www.w3.org/2005/xpath-functions}QName#2('http://www.example.org/', 'ns:local')
Q{http://www.w3.org/2005/xpath-functions}remove#2(('a', 'b', 'c'), 2)
Q{http://www.w3.org/2005/xpath-functions}reverse#1(1 to 3)
Q{http://www.w3.org/2005/xpath-functions}root#1(())
Q{http://www.w3.org/2005/xpath-functions}round#1(1.1)
Q{http://www.w3.org/2005/xpath-functions}round#2(1.1, 0)
Q{http://www.w3.org/2005/xpath-functions}round-half-to-even#1(1.1)
Q{http://www.w3.org/2005/xpath-functions}round-half-to-even#2(1.1, 0)
Q{http://www.w3.org/2005/xpath-functions}seconds-from-dateTime#1(xs:dateTime('2012-04-03T02:01:00Z'))
Q{http://www.w3.org/2005/xpath-functions}seconds-from-duration#1(xs:dayTimeDuration("P3DT10H12.5S"))
Q{http://www.w3.org/2005/xpath-functions}seconds-from-time#1(xs:time('02:01:00Z'))
Q{http://www.w3.org/2005/xpath-functions}starts-with#2('string', 'str')
Q{http://www.w3.org/2005/xpath-functions}string#1(1)
Q{http://www.w3.org/2005/xpath-functions}string-join#1(('abc', 'def'))
Q{http://www.w3.org/2005/xpath-functions}string-join#2(('abc', 'def'), '-')
Q{http://www.w3.org/2005/xpath-functions}string-length#1('string')
Q{http://www.w3.org/2005/xpath-functions}string-to-codepoints#1('A')
Q{http://www.w3.org/2005/xpath-functions}subsequence#2((1, true()), 2e0)
Q{http://www.w3.org/2005/xpath-functions}subsequence#3((1, true()), 1e0, 1e0)
Q{http://www.w3.org/2005/xpath-functions}substring#2('string', 2e0)
Q{http://www.w3.org/2005/xpath-functions}substring#3('string', 1e0, 1e0)
Q{http://www.w3.org/2005/xpath-functions}substring-after#2('string', 'str')
Q{http://www.w3.org/2005/xpath-functions}substring-before#2('string', 'ing')
Q{http://www.w3.org/2005/xpath-functions}sum#1((1, 2))
Q{http://www.w3.org/2005/xpath-functions}sum#2((1, 2), 0)
() => (Q{http://www.w3.org/2005/xpath-functions}sum#2(?, 'foo'))()
Q{http://www.w3.org/2005/xpath-functions}tail#1((1, true()))
Q{http://www.w3.org/2005/xpath-functions}timezone-from-date#1(xs:date('2012-01-01Z'))
Q{http://www.w3.org/2005/xpath-functions}timezone-from-dateTime#1(xs:dateTime('2012-01-01T00:00:00Z'))
Q{http://www.w3.org/2005/xpath-functions}timezone-from-time#1(xs:time('02:01:00Z'))
Q{http://www.w3.org/2005/xpath-functions}tokenize#1('a b c ')
Q{http://www.w3.org/2005/xpath-functions}tokenize#2('string', 'i')
Q{http://www.w3.org/2005/xpath-functions}trace#1(1)
Q{http://www.w3.org/2005/xpath-functions}trace#2(1, 'label')
Q{http://www.w3.org/2005/xpath-functions}translate#3('string', 'i', 'o')
Q{http://www.w3.org/2005/xpath-functions}true#0()
Q{http://www.w3.org/2005/xpath-functions}unordered#1(1)
Q{http://www.w3.org/2005/xpath-functions}upper-case#1('string')
Q{http://www.w3.org/2005/xpath-functions}year-from-date#1(xs:date('2012-02-01Z'))
Q{http://www.w3.org/2005/xpath-functions}year-from-dateTime#1(xs:dateTime('2012-04-03T02:01:00Z'))
Q{http://www.w3.org/2005/xpath-functions}years-from-duration#1(xs:yearMonthDuration("P20Y15M"))
Q{http://www.w3.org/2005/xpath-functions}zero-or-one#1(1)
QName()
QName("", "2localName")
QName("", "error:ncname")
QName((), "error:ncname")
QName("example.com/", "p:ncname") eq QName("example.com/", "pdifferent:ncname")
QName("example.com/", "p:ncname") eq QName("example.com/", "p:ncname")
QName("example.com/", "p:ncname") eq xs:anyURI("org")
QName("example.com/", "p:ncname") ge QName("example.com/", "p:ncname")
QName("example.com/", "p:ncname") gt QName("example.com/", "p:ncname")
QName("example.com/", "p:ncname") le QName("example.com/", "p:ncname")
QName("example.com/", "p:ncname") lt 1
QName("example.com/", "p:ncname") lt QName("example.com/", "p:ncname")
QName("example.com/", "p:ncname") ne QName("example.com/Nope", "p:ncname")
QName("example.com/", "p:ncname") ne QName("example.com/", "p:ncnameNope")
(QName('http://datypic.com/prod', 'pre:product'))
(QName('http://datypic.com/prod','product'))
(QName('http://datypic.com/prod','product'), QName('http://datypic.com/prod', 'pre:product'), QName('', 'product'))
(QName("http://example.com/ANamespace", "ncname"), QName("http://example.com/ANamespace", "ncname2"), QName("http://example.com/ANamespace", "ncname3")) castable as xs:QName
(QName("http://example.com/ANamespace", "ncname"), QName("http://example.com/ANamespace", "ncname2"), QName("http://example.com/ANamespace", "ncname3")) castable as xs:QName?
QName("http://www.example.com/")
QName("http://www.example.com/", "1asd:error")
QName("http://www.example.com/", "ncname", "error")
QName("http://www.w3.org/", "1")
QName("http://www.w3.org/", "1prefix:localName")
QName("http://www.w3.org/2005/xpath-functions", "prefix:local") eq xs:QName("fn:local")
QName("http://www.w3.org/", "prefix:2localName")
QName("", "lname") castable as xs:QName
QName("", "local") eq xs:QName("local")
QName((), "local") eq xs:QName("local")
QName("my:qName", "http://example.com/MyErrorNS")
QName("", "prefix:localName")
(QName('', 'product'))
/Q{###}SomeElement
"&quot;"
Q{&#x7D;http://www.w3.org/2005/xpath-functions/math}pi()
<r> <a> <b> <c/> </b> </a> </r>/a/b/c/(ancestor::*[1], ancestor::*[2], ancestor::*[last()], ancestor::*[10])
<r> <a> <b> <c/> </b> </a> </r>/a/b/c/(ancestor-or-self::*[1], ancestor-or-self::*[2], ancestor-or-self::*[last()], ancestor-or-self::*[10])
random-number-generator()?number
("red", "blue", "green")!position()
("red", "blue", "green")!(position() = last())
("red", "blue", "green")!string-length()
("red", "blue", "green") ! string-length() ! (.+1)
remove()
remove((1, 2, 3, current-time()), 4)[last()]
remove((1, 2, 3, current-time()), 4)[last() - 1]
remove((1, 2, 3, current-time()), 9)[last() - 1]
remove((1, 2, "three"), 3) instance of xs:integer+
remove(1, 2, "wrong param")
remove(1 to 10, "1")
remove(1 to 10, 1.0)
remove(1 to 10, 1.0e0)
remove(1 to 10,4)
remove(1 to 10,exactly-one((1 to 10)[. div 2 = 2]))
remove((1 to 10)[. mod 2 = 0],4)
remove(((1 to 10)[. mod 2 = 0],"blah",(1 to 10)[. mod 2 = 0]),4)
(remove((1, "two"), 2) + 1) eq 2
(remove((1, "two"), 2) + xs:untypedAtomic("1")) eq 2
remove((1, "two", 3), 2) instance of xs:integer+
remove((3.1, "four"), 1)
(remove((5, 1e0), 2) + 1) eq 6
remove((5, 1e0), 2) eq 5
remove((6, "a string"), 1) = 6
remove((6, "a string"), 2) = xs:untypedAtomic("6")
(remove( ('a', 'b', 'c'), 0))
(remove( ('a', 'b', 'c'), 10))
(remove( ('a', 'b', 'c'), 2) )
(remove( ('a', 'b', 'c'), 2) , remove( ('a', 'b', 'c'), 10), remove( ('a', 'b', 'c'), 0))
remove(("one", 2, 3), 1) instance of xs:integer+
(remove((xs:untypedAtomic("1"), "two"), 2) + 1) eq 2
(remove((xs:untypedAtomic("6"), "a string"), 2)) = 6
<r> { //(employee[location = "Denver"] except //employee[last()])/./location } </r>
<r> { //(employee[location = "Denver"] union //employee[last()])/./location } </r>
<result> { <a><b/></a>/*/following::*[2] } </result>
<result> {/bib/book/editor/affiliation/text()} </result>
<result> { (((//chapter)[2]//section)[3]//para)[2] } </result>
<result> { <e> <a>1</a> <b>2</b> </e>/(b, a)/. } </result>
<result> { for $c in //chapter where empty($c/intro) return $c/section/intro/para } </result>
<result> {              for $highbid in $bids//bid_tuple,                  $user in $users//user_tuple              where $user/userid = $highbid/userid and $highbid/bid = max($bids//bid_tuple[itemno=$highbid/itemno]/bid)              order by exactly-one($highbid/itemno)              return <high_bid> { $highbid/itemno } { $highbid/bid }                       <bidder>{ $user/name/text() }</bidder>                     </high_bid>          } </result>
<result> { for $id in //xref/@xrefid return //topic[@topicid = $id] } </result>
<result> {              for $i in $items//item_tuple              let $b := $bids//bid_tuple[itemno = $i/itemno]              where contains(exactly-one($i/description), "Bicycle")              order by $i/itemno              return <item_tuple> { $i/itemno } { $i/description } <high_bid>{ max($b/bid) }</high_bid> </item_tuple> }          </result>
<result> {              for $i in $items//item_tuple              where $i/start_date <= xs:date("1999-01-31")                  and $i/end_date >= xs:date("1999-01-31")                  and contains(exactly-one($i/description), "Bicycle")              order by $i/itemno              return <item_tuple> { $i/itemno } { $i/description } </item_tuple> }          </result>
<result> {              for $i in $items//item_tuple              where empty ($bids//bid_tuple[itemno = $i/itemno])              return <no_bid_item> { $i/itemno } { $i/description } </no_bid_item>          } </result>
<result> { for $i in //intro/para[1] return <first_letter>{ substring(string($i), 1, 1) }</first_letter> } </result>
<result> {              for $item in $items//item_tuple              let $b := $bids//bid_tuple[itemno = $item/itemno]              let $z := max($b/bid)              where exactly-one($item/reserve_price) * 2 < $z              return <successful_item> { $item/itemno } { $item/description } { $item/reserve_price }                      <high_bid>{$z }</high_bid>                     </successful_item>          } </result>
<result> { for $s in //section/@shorttitle return <stitle>{ $s }</stitle> } </result>
<result> {              for $u in $users//user_tuple              for $i in $items//item_tuple              where $u/rating > "C" and $i/reserve_price > 1000 and $i/offered_by = $u/userid              return <warning> { $u/name } { $u/rating } { $i/description } { $i/reserve_price } </warning> }          </result>
<result> {              for $u in $users//user_tuple              let $b := $bids//bid_tuple[userid=$u/userid and bid>=100]              where count($b) > 1              return <big_spender>{ $u/name/text() }</big_spender>          } </result>
<result> {              for $u in $users//user_tuple              let $b := $bids//bid_tuple[userid = $u/userid]              order by exactly-one($u/userid)              return <user> { $u/userid } { $u/name } {                  if (empty($b))                  then <status>inactive</status>                  else <status>active</status> } </user>          } </result>
<result> { //intro/para } </result>
<result> { let $x := //xref[@xrefid = "top4"], $t := //title[. << exactly-one($x)] return $t[last()] } </result>
<result> { (//node())[last()]/preceding::node(), empty((//node())[last()]/preceding::node()) } </result>
<result> { (//node())[last()]/preceding::node() } </result>
<result> {//overtime/node() and fn:false()} </result>
<result> {//overtime/node() and fn:true()} </result>
<result> {//overtime/node() or fn:false()} </result>
<result> {//overtime/node() or fn:true()} </result>
<result> { //para[@security = "c"] } </result>
<result> { //report//para } </result>
<result> { //section[.//title[contains(., "is SGML")]] } </result>
<result> { //section[.//title/text()[contains(., "is SGML")]] } </result>
<results> {         for $b in /bib/book, $t in $b/title, $a in $b/author         return <result> { $t } { $a } </result> }         </results>
<results> {         for $b in /bib/book         return <result> { $b/title } { $b/author } </result> }         </results>
<results> {         for $t in //(chapter | section)/title         where contains(exactly-one($t/text()), "XML")         return $t }         </results>
<results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by string($x) ascending return string($x) } </results>
<results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by string($x) return string($x) } </results>
<results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by (xs:decimal($x) * -1) descending return (xs:decimal($x) * -1) } </results>
<results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by (xs:decimal($x) * -1) return (xs:decimal($x) * -1) } </results>
<results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by xs:decimal($x) ascending return xs:decimal($x) } </results>
<results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by xs:decimal($x) ascending return xs:decimal($x) } </results>
<results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by xs:decimal($x) descending return xs:decimal($x) } </results>
<results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by xs:decimal($x) descending return xs:decimal($x) } </results>
<results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by xs:decimal($x) return xs:decimal($x) } </results>
<results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by xs:decimal($x) return xs:decimal($x) } </results>
<results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by (xs:decimal($x) + xs:decimal($x)) descending return xs:decimal($x) + xs:decimal($x) } </results>
<results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by (xs:decimal($x) + xs:decimal($x)) descending return xs:decimal($x) + xs:decimal($x) } </results>
<results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by (xs:decimal($x) + xs:decimal($x)) return xs:decimal($x) + xs:decimal($x) } </results>
<results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by (xs:decimal($x) + xs:decimal($x)) return xs:decimal($x) + xs:decimal($x) } </results>
<results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by xs:integer($x) descending return xs:integer($x) } </results>
<results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by xs:integer($x) descending return xs:integer($x) } </results>
<results> { for $x in (-100000000000000000,-10000000000000000,-1000000000000000,-100000000000000,-10000000000000,-1000000000000,-100000000000,-10000000000,-1000000000,-100000000,-10000000,-1000000,-100000,-10000,-1000,-100,-10,-1,-0) order by xs:integer($x) return xs:integer($x) } </results>
<results> { for $x in (100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000,1000000000000,100000000000,10000000000,1000000000,100000000,10000000,1000000,100000,10000,1000,100,10,1,0) order by xs:integer($x) return xs:integer($x) } </results>
<results>{ for $x in (<a>0.000000000000000001</a>,<a>0.00000000000000001</a>,<a>0.0000000000000001</a>,<a>0.000000000000001</a>,<a>0.00000000000001</a>,<a>0.0000000000001</a>,<a>0.000000000001</a>,<a>0.00000000001</a>,<a>0.0000000001</a>,<a>0.000000001</a>,<a>0.00000001</a>,<a>0.0000001</a>,<a>0.000001</a>,<a>0.00001</a>,<a>0.0001</a>,<a>0.001</a>,<a>0.01</a>,<a>0.1</a>,<a>0.0</a>) order by $x is $x ascending return $x is $x}</results>
<results>{ for $x in (<a>0.000000000000000001</a>,<a>0.00000000000000001</a>,<a>0.0000000000000001</a>,<a>0.000000000000001</a>,<a>0.00000000000001</a>,<a>0.0000000000001</a>,<a>0.000000000001</a>,<a>0.00000000001</a>,<a>0.0000000001</a>,<a>0.000000001</a>,<a>0.00000001</a>,<a>0.0000001</a>,<a>0.000001</a>,<a>0.00001</a>,<a>0.0001</a>,<a>0.001</a>,<a>0.01</a>,<a>0.1</a>,<a>0.0</a>) order by $x is $x descending return $x is $x }</results>
<results> { for $x in (<a>A String</a>,<a>B String</a>,<a>C String</a>,<a>D String</a>,<a>E String</a>,<a>F String</a>,<a>G String</a>,<a>H String</a>,<a>I String</a>, <a>J String</a>,<a>K String</a>,<a>L String</a>,<a>M String</a>,<a>N String</a>,<a>O String</a>,<a>P String</a>,<a>R String</a>,<a>S String</a>,<a>T String</a>, <a>U String</a>,<a>V String</a>,<a>W String</a>,<a>X String</a>,<a>Y String</a>,<a>Z String</a>) order by $x is $x return $x is $x } </results>
<results> { for $x in (<a>A String</a>,<a>B String</a>,<a>C String</a>,<a>D String</a>,<a>E String</a>,<a>F String</a>,<a>G String</a>,<a>H String</a>,<a>I String</a>, <a>J String</a>,<a>K String</a>,<a>L String</a>,<a>M String</a>,<a>N String</a>,<a>O String</a>,<a>P String</a>,<a>R String</a>,<a>S String</a>,<a>T String</a>, <a>U String</a>,<a>V String</a>,<a>W String</a>,<a>X String</a>,<a>Y String</a>,<a>Z String</a>) order by string-length($x) return string-length($x) } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat("another String Before",xs:string($x)) ascending return concat("another String Before",xs:string($x)) } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat("another String Before",xs:string($x)) descending return concat("another String Before",xs:string($x)) } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat("another String Before",xs:string($x)) return concat("another String Before",xs:string($x)) } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),"another String After") ascending return concat(xs:string($x),"another String After") } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),"another String After") descending return concat(xs:string($x),"another String After") } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),"another String After") return concat(xs:string($x),"another String After") } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String",         "I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String",         "U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),"()")          ascending return concat(xs:string($x),"()") } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat("",xs:string($x)) ascending return concat("",xs:string($x)) } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),"") ascending return concat(xs:string($x),"") } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat("",xs:string($x)) descending return concat("",xs:string($x)) } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),"") descending return concat(xs:string($x),"") } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),"()") descending return concat(xs:string($x),"()") } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat("",xs:string($x)) return concat("",xs:string($x)) } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),"") return concat(xs:string($x),"") } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),"()") return concat(xs:string($x),"()") } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),xs:string($x)) ascending return concat(xs:string($x),xs:string($x)) } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by concat(xs:string($x),xs:string($x)) return concat(xs:string($x),xs:string($x)) } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by count(xs:string($x)) ascending return count(xs:string($x)) } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by count(xs:string($x)) return count(xs:string($x)) } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by string-length(xs:string($x)) ascending return string-length(xs:string($x)) } </results>
<results> { for $x in("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by string-length(xs:string($x)) ascending return string-length(xs:string($x)) } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String",         "I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String",         "U String","V String","W String","X String","Y String","Z String") order by xs:string($x)          ascending return xs:string($x) } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String",         "I String","J String","K String","L String","M String","N String","O String","P String","R String","S String",         "T String","U String","V String","W String","X String","Y String","Z String") order by xs:string($x)          descending return xs:string($x) } </results>
<results> { for $x in ("A String","B String","C String","D String","E String","F String","G String","H String","I String","J String","K String","L String","M String","N String","O String","P String","R String","S String","T String","U String","V String","W String","X String","Y String","Z String") order by xs:string($x) return xs:string($x) } </results>
<results> { for $x in (<orderData>-0.000000000000000001</orderData>,<orderData>-0.00000000000000001</orderData>,<orderData>-0.0000000000000001</orderData>,<orderData>-0.000000000000001</orderData>,<orderData>-0.00000000000001</orderData>,<orderData>-0.0000000000001</orderData>, <orderData>-0.000000000001</orderData>,<orderData>-0.00000000001</orderData>,<orderData>-0.0000000001</orderData>,<orderData>-0.000000001</orderData>, <orderData>-0.00000001</orderData>,<orderData>-0.0000001</orderData>,<orderData>-0.000001</orderData>,<orderData>-0.00001</orderData>,<orderData>-0.0001</orderData>,<orderData>-0.001</orderData>,<orderData>-0.01</orderData>,<orderData>-0.0</orderData>, <orderData>-0.1</orderData>) order by $x is $x return $x is $x } </results>
<results> { for $x in (<orderData>0.000000000000000001</orderData>,<orderData>0.00000000000000001</orderData>,<orderData>0.0000000000000001</orderData>,<orderData>0.000000000000001</orderData>, <orderData>0.00000000000001</orderData>,<orderData>0.0000000000001</orderData>,<orderData>0.000000000001</orderData>,<orderData>0.00000000001</orderData>,<orderData>0.0000000001</orderData>, <orderData>0.000000001</orderData>,<orderData>0.00000001</orderData>,<orderData>0.0000001</orderData>,<orderData>0.000001</orderData>,<orderData>0.00001</orderData>, <orderData>0.0001</orderData>,<orderData>0.001</orderData>,<orderData>0.01</orderData>,<orderData>0.1</orderData>,<orderData>0.0</orderData>) order by $x is $x return $x is $x } </results>
<results> { for $x in (<orderData>-100000000000000000</orderData>,<orderData>-10000000000000000</orderData>,<orderData>-1000000000000000</orderData>,<orderData>-100000000000000</orderData>, <orderData>-10000000000000</orderData>,<orderData>-1000000000000</orderData>,<orderData>-100000000000</orderData>,<orderData>-10000000000</orderData>,<orderData>-1000000000</orderData>, <orderData>-100000000</orderData>,<orderData>-10000000</orderData>,<orderData>-1000000</orderData>,<orderData>-100000</orderData>,<orderData>-10000</orderData>,<orderData>-1000</orderData>, <orderData>-100</orderData>,<orderData>-10</orderData>,<orderData>-1</orderData>,<orderData>-0</orderData>) order by $x is $x return $x is $x } </results>
<results> { for $x in (<orderData>100000000000000000</orderData>,<orderData>10000000000000000</orderData>,<orderData>1000000000000000</orderData>, <orderData>100000000000000</orderData>,<orderData>10000000000000</orderData>,<orderData>1000000000000</orderData>,<orderData>100000000000</orderData>, <orderData>10000000000</orderData>,<orderData>1000000000</orderData>,<orderData>100000000</orderData>,<orderData>10000000</orderData>, <orderData>1000000</orderData>,<orderData>100000</orderData>,<orderData>10000</orderData>,<orderData>1000</orderData>,<orderData>100</orderData>, <orderData>10</orderData>,<orderData>1</orderData>,<orderData>0</orderData>) order by $x is $x return $x is $x } </results>
<result>{ ("test1", "test2") }</result>
<result> {//text() and fn:false()} </result>
<result> {//text() and fn:true()} </result>
<result> {//text() or fn:false()} </result>
<result> {//text() or fn:true()} </result>
<result> {              unordered (                  for $seller in $users//user_tuple,                      $buyer in $users//user_tuple,                      $item in $items//item_tuple,                      $highbid in $bids//bid_tuple                  where $seller/name = "Tom Jones"                    and $seller/userid = $item/offered_by                    and contains(exactly-one($item/description), "Bicycle")                    and $item/itemno = $highbid/itemno                    and $highbid/userid = $buyer/userid                    and $highbid/bid = max( $bids//bid_tuple [itemno = $item/itemno]/bid )                  return <jones_bike> { $item/itemno } { $item/description }                          <high_bid>{ $highbid/bid }</high_bid>                          <high_bidder>{ $buyer/name }</high_bidder>                         </jones_bike> )          } </result>
return 1
(reverse( () ))
reverse()
reverse(1, 2)
(reverse( (1, 2, 3, 4, 5) ))
(reverse( (1, 2, 3, 4, 5) ), reverse( (6, 2, 4) ), reverse( () ))
reverse((1, 2, 3))[last() - 1]
reverse((1, 2, 3))[last() - 2]
reverse((1, 2, 3))[last()] eq 1
reverse((1, 2, current-time(), 3))[last() - 0]
reverse((1, 2, current-time(), 3))[last() - 1]
reverse((1, current-time())[1])
(reverse( (6, 2, 4) ))
reverse((<a> <b> <c/> <d/> </b> <e/> </a> , <f/>))
<r>{<e xml:lang="ene"/>/(ancestor-or-self::*/@xml:lang)[last()]}</r>
<r> { for $i in 1 order by () return () } </r>
<r> { for $i in attribute name {()} order by () return () } </r>
<r> { let $i := <e> <a/> <b/> <c/> </e>/a , $t := $i/following-sibling::b return (($i except ($i, $i)), (($t, $t) except $t)) } </r>
<r> { let $i := <e> <a/> <b/> <c/> </e>/a , $t := $i/following-sibling::b return (($i intersect ($i, $i)), (($t, $t) intersect $t)) } </r>
<r> { let $i := <e> <a/> <b/> </e> let $b := ($i/b, $i/a, $i/b, $i/a) return ()/$b } </r>
<r> { let $i := <e> <a/> <b/> </e> let $b := ($i/b, $i/a, $i/b, $i/a) return $b/. } </r>
<r> { let $i := <e> <a/> <b/> </e> let $b := ($i/b, $i/a, $i/b, $i/a) return <e/>/./$b } </r>
<r> { let $i := <e> <a/> <b/> </e> let $b := ($i/b, $i/a, $i/b, $i/a) return <e/>/$b } </r>
<r> { let $i := <e> <a/> <b/> </e> return () | ($i/b, $i/a, $i/b, $i/a) } </r>
<r> { let $i := <e> <a/> <b/> </e> return ($i/b, $i/a, $i/b, $i/a) | () } </r>
root(2)
Root(2)
/root/*[2]/function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'namespace-uri'), 0)()
/root/*[2]/Q{http://www.w3.org/2005/xpath-functions}namespace-uri#0()
/root/@attribute/fn:has-children()
(/root/boolean[xs:boolean(.) = fn:true()])
<root> <child/> <child/> <child attr="foo" attr2="foo"/> </root>/child[1]/following-sibling::node()
<root> <child/> <child/> <child/> </root>/child[1]/following-sibling::node()
/root/child/function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'data'), 0)()
/root/child/function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'normalize-space'), 0)()
/root/child/function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'number'), 0)()
/root/child/function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'string'), 0)()
/root/child/function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'string-length'), 0)()
/root/child/Q{http://www.w3.org/2005/xpath-functions}data#0()
/root/child/Q{http://www.w3.org/2005/xpath-functions}normalize-space#0()
/root/child/Q{http://www.w3.org/2005/xpath-functions}number#0()
/root/child/Q{http://www.w3.org/2005/xpath-functions}string#0()
/root/child/Q{http://www.w3.org/2005/xpath-functions}string-length#0()
/root/comment()/fn:has-children()
<root> {//Customers} </root>
(/root/date[xs:date(.) = xs:date("2000-01-01+05:00")])
(/root/decimal[(xs:decimal(.) = 12678967.543233)])
(/root/decimal[xs:decimal(.) = 12678967.543233])
<root> {/doc/part/*/text()/..} </root>
(/root/double[xs:double(.) = 1267.43233E12])
/root/empty/fn:has-children()
(/root/float[xs:float(.) = xs:float(1267.43233E12)])
/root/fn:has-children()
/root/function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'local-name'), 0)()
/root/function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'name'), 0)()
/root/function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'node-name'), 0)()
/root/function-lookup(fn:QName('http://www.w3.org/2005/xpath-functions', 'root'), 0)()
(/root/integer[xs:integer(.) = 12678967543233])
/root/node()/fn:has-children()
/root/node()/fn:has-children(.)
/root/non-empty/fn:has-children()
/root/processing-instruction()/fn:has-children()
/root/Q{http://www.w3.org/2005/xpath-functions}local-name#0()
/root/Q{http://www.w3.org/2005/xpath-functions}name#0()
/root/Q{http://www.w3.org/2005/xpath-functions}node-name#0()
/root/Q{http://www.w3.org/2005/xpath-functions}root#0()
<root> {//@*/..} </root>
(/root/string[xs:string(.) = "A String Function"])
/root/text()/fn:has-children()
round()
round(1.1) eq 1
round(1, 2)
round(1) eq 1
round(2.4999) eq 2
round(-2.5) eq -2
(round(5))
(round(5.1))
(round(-5.5))
(round(5.5))
(round(-5.51))
(round(5), round(5.1), round(5.5), round(-5.5), round(-5.51))
round-half-to-even()
round-half-to-even(0.5) eq 0
round-half-to-even(1.000005e0, 2)
round-half-to-even(1.0) eq 1
round-half-to-even(1.1, 3, "wrong param")
round-half-to-even(-123.355, 2)
round-half-to-even(123.355, 2)
round-half-to-even(-123.365, 2)
round-half-to-even(123.365, 2)
round-half-to-even(-123.375, 2)
round-half-to-even(123.375, 2)
round-half-to-even(-123.385, 2)
round-half-to-even(123.385, 2)
round-half-to-even(1.234567, 2)
round-half-to-even(-12350.00, -2)
round-half-to-even(12350.00, -2)
round-half-to-even(-12350, -2)
round-half-to-even(12350, -2)
round-half-to-even(-12350e0, -2)
round-half-to-even(12350e0, -2)
round-half-to-even(-12450.00, -2)
round-half-to-even(12450.00, -2)
round-half-to-even(-12450, -2)
round-half-to-even(12450, -2)
round-half-to-even(-12450e0, -2)
round-half-to-even(12450e0, -2)
round-half-to-even(-12550.00, -2)
round-half-to-even(12550.00, -2)
round-half-to-even(-12550, -2)
round-half-to-even(12550, -2)
round-half-to-even(-12550e0, -2)
round-half-to-even(12550e0, -2)
round-half-to-even(1.5) eq 2
round-half-to-even(1) eq 1
round-half-to-even(2.5) eq 2
round-half-to-even(35612.25, -2) eq 35600
round-half-to-even(3.567812E+3, 2) eq 3567.81E0
round-half-to-even(4561.000005e0, 0)
round-half-to-even(4561.000005e0, -2)
round-half-to-even(4561.234567, 0)
round-half-to-even(4561234567, 0)
round-half-to-even(4561.234567, -2)
round-half-to-even(4561234567, -2)
round-half-to-even(4.7564E-3, 2) eq 0.0E0
(round-half-to-even(5.5))
(round-half-to-even(5.5), round-half-to-even(6.5), round-half-to-even(9372.253, 2), round-half-to-even(9372.253, 0), round-half-to-even(9372.253, -3))
(round-half-to-even(6.5))
(round-half-to-even(9372.253, 0))
(round-half-to-even(9372.253, 2))
(round-half-to-even(9372.253, -3))
round-half-to-even("a string")
round-half-to-even(xs:byte("0")) instance of xs:byte
round-half-to-even(xs:double("-0"))
round-half-to-even(xs:double("-1.75e-3") cast as xs:decimal,5)
round-half-to-even(xs:double("-INF"))
round-half-to-even(xs:double("INF"))
round-half-to-even(xs:double("NaN"))
round-half-to-even(xs:float("-0"))
round-half-to-even(xs:float('1.000005e0'), 2)
round-half-to-even(xs:float("-1.75e-3") cast as xs:decimal,5)
round-half-to-even(xs:float('3.75'), 1)
round-half-to-even(xs:float('4561.000005e0'), 0)
round-half-to-even(xs:float('4561.000005e0'), -2)
round-half-to-even(xs:float("-INF"))
round-half-to-even(xs:float("INF"))
round-half-to-even(xs:float("NaN"))
round-half-to-even(xs:int("0")) instance of xs:int
round-half-to-even(xs:long("0")) instance of xs:long
round-half-to-even(xs:negativeInteger("-1")) instance of xs:negativeInteger
round-half-to-even(xs:nonNegativeInteger("0")) instance of xs:nonNegativeInteger
round-half-to-even(xs:nonPositiveInteger("0")) instance of xs:nonPositiveInteger
round-half-to-even(xs:positiveInteger("1")) instance of xs:positiveInteger
round-half-to-even(xs:short("0")) instance of xs:short
round-half-to-even(xs:unsignedByte("0")) instance of xs:unsignedByte
round-half-to-even(xs:unsignedInt("0")) instance of xs:unsignedInt
round-half-to-even(xs:unsignedLong("0")) instance of xs:unsignedLong
round-half-to-even(xs:unsignedShort("0")) instance of xs:unsignedShort
round-half-to-even( (xs:yearMonthDuration("P42Y10M") div xs:yearMonthDuration("P20Y10M")) div (xs:yearMonthDuration("P20Y11M") div xs:yearMonthDuration("P18Y11M")), 15)
round(xs:byte(.)) instance of xs:byte
round(xs:double("-0"))
round(xs:double("0"))
round(xs:double(1)) eq 1
round(xs:double("-INF"))
round(xs:double("INF"))
round(xs:float("-0"))
round(xs:float("0"))
round(xs:float(1)) eq 1
round(xs:float("-INF"))
round(xs:float("INF"))
round(xs:int(.)) instance of xs:int
round(xs:long(.)) instance of xs:long
round(xs:negativeInteger(.)) instance of xs:negativeInteger
round(xs:nonNegativeInteger(.)) instance of xs:nonNegativeInteger
round(xs:nonPositiveInteger(.)) instance of xs:nonPositiveInteger
round(xs:positiveInteger(.)) instance of xs:positiveInteger
round(xs:short(.)) instance of xs:short
round(xs:unsignedByte(.)) instance of xs:unsignedByte
round(xs:unsignedInt(.)) instance of xs:unsignedInt
round(xs:unsignedLong(.)) instance of xs:unsignedLong
round(xs:unsignedShort(.)) instance of xs:unsignedShort
<r> <xs:element/> <local:element/> <fn:element/> <xml:element/> </r>
schema-attribute()
schema-attribute(*)
schema-attribute("quotesAreNotAllowed")
schema-element()
schema-element(*)
schema-element("quotesAreNotAllowed")
schema gt schema
seconds-from-dateTime()
seconds-from-dateTime(()) instance of xs:decimal?
seconds-from-dateTime((), "Wrong param")
seconds-from-dateTime(xs:dateTime("2001-02-03T08:23:12.43")) eq 12.43
(seconds-from-dateTime( xs:dateTime('2006-08-15T10:30:23.5')))
seconds-from-duration()
seconds-from-duration(implicit-timezone()) le 0 or seconds-from-duration(implicit-timezone()) gt 0
seconds-from-duration(()) instance of xs:decimal?
seconds-from-duration((), "Wrong param")
(seconds-from-duration( xs:dayTimeDuration('PT1M')))
(seconds-from-duration( xs:dayTimeDuration('PT30.5S')))
(seconds-from-duration( xs:dayTimeDuration('PT30.5S')), seconds-from-duration( xs:dayTimeDuration('-PT90.5S')), seconds-from-duration( xs:dayTimeDuration('PT1M')), seconds-from-duration( xs:dayTimeDuration('PT60S')))
(seconds-from-duration( xs:dayTimeDuration('PT60S')))
(seconds-from-duration( xs:dayTimeDuration('-PT90.5S')))
seconds-from-time()
seconds-from-time(()) instance of xs:decimal?
seconds-from-time((), "Wrong param")
(seconds-from-time(xs:time('10:30:23.5')))
seconds-from-time(xs:time("23:11:12.43")) eq 12.43
<section_count>{ count(//section) }</section_count>, <figure_count>{ count(//figure) }</figure_count>
<section_list> { for $s in //section let $f := $s/figure return <section title="{ $s/title/text() }" figcount="{ count($f) }"/> } </section_list>
<shoe name=" """" "/>
<shoe name=" '''''''' "/>
some $aaa in (1, 2, 3), $bbb in (3, 2, 1) satisfies $aaa + $bbb eq 4
some $a as empty-sequence()? in (1, 2) satisfies $a
some $a as item() at $p in (1, 2) satisfies $a
some $a as item()* in (1, 2), $b as item()* in $a satisfies $b
some $a as item()+ in (1, 2), $b as item()+ in $a satisfies $b
some $a as item()? in (1, 2), $b as item()? in $a satisfies $b
some $a as xs:integer in (1, 2), $b as xs:integer in $a satisfies $b
some $a at $p in (1, 2) satisfies $a
some $a in (1, 2), $b in $a satisfies $b
some $a in (1, 2), $b in (1, 2), $c in (1, 2) satisfies 1, $a
some $a in (1, 2), $b in (1, 2), $c in (1, 2) satisfies 1, $b
some $a in (1, 2), $b in (1, 2), $c in (1, 2) satisfies 1, $c
some $a in (1, 2), $b in (1, 2) satisfies 1, $b
some $a in (1, 2, 3), $b in ($a, 4) satisfies $b gt 0
some $a in (1, 2, 3), $b in (1, 2, 3, $b) satisfies $a eq $b
some $foo in ($foo, 2, 3) satisfies 1
some $foo in $foo satisfies 1
some $foo in (1, $2) return 1
some $foo in (1, $foo, 3) satisfies 1
some $foo in (1, $foo) satisfies 1
some $foo in (1, 2, $foo) satisfies 1
some $foo in 1 satisfies $bar + (every $bar in 2 satisfies $bar)
some $foo in 1 satisfies $bar + (some $bar in 2 satisfies $bar)
some $foo in 1 satisfies $foo eq "1"
some $foo in 1 satisfies $NOTEXIST
some $foo in 1 satisfies 1
some $foo in 1 satisfies "a string"
some $foo in 1 satisfies QName("example.com/", "ncname")
some $foo in 1 satisfies true()
some $id in attribute::id satisfies $id
some $i in (0, 2, 3) satisfies count($i)
SOME $i in (1, 2, 3) satisfies $i
some $i in (1, 2, 3) satisfies ($i, $i)
some $var in (1, 2, 3) satisfies $var eq 1 or $var eq 2 or $var eq 3
some $var in (1, 2, 3) satisfies $var eq 3
some $var in (false(), true(), true()) satisfies $var
some $var in (false(), xs:hexBinary("FF"), true()) satisfies $var
some $var in (true(), false(), true()) satisfies $var
some $var in (true(), true(), false()) satisfies $var
some $var in (true(), true(), true()) satisfies $var
some $var in (true(), true(), xs:hexBinary("FF")) satisfies $var
some $var in (xs:hexBinary("FF"), false(), true()) satisfies $var
some $x as xs:integer in (1, 2, 3), $y as xs:float in (xs:float(2), xs:float(3)) satisfies $x + $y = 5
some $x as xs:integer in (1, 2, 3) , $y as xs:integer in (2, 3, 4) satisfies $x + $y = 4
some $x as xs:string in ("cat","dog","rat") satisfies fn:string-length($x) = 3
some $x in (1,2,3), $y in (4,5,6) satisfies $x * $y = 10
some $x in (1,2,3), $y in (4,5,6) satisfies $x + $y = 5
some $x in (1,2,3), $y in (4,5,6) satisfies $x - $y = 5
some $x in (1,2,3), $y in (4,5,6) satisfies $x div $y = 2
some $x in (1,2,3), $y in (4,5,6) satisfies $x idiv $y = 2
some $x in (1,2,3), $y in (4,5,6) satisfies fn:string($x) = fn:string($y)
some $x in (1,2,3), $y in (4,5,6) satisfies xs:decimal($x) = xs:decimal($y)
some $x in (1,2,3), $y in (4,5,6) satisfies xs:double($x) = xs:double($y)
some $x in (1,2,3), $y in (4,5,6) satisfies xs:float($x) = xs:float($y)
some $x in (1,2,3), $y in (4,5,6) satisfies xs:integer($x) = xs:integer($y)
some $x in (1, 2) satisfies $x + $x = 2
some $x in (1, 2) satisfies $x + $x = 3
some $x in (1, 2) satisfies $x = 1 and ($x +1) = 2
some $x in (1, 2) satisfies $x = 1 or $x = 2
some $x in (1, 2) satisfies $x - 2 = 0
some $x in (1, 2) satisfies $x - 2 = 2
some $x in (1, 2) satisfies $x * 2 = 4
some $x in (1, 2) satisfies $x div 2 = 1
some $x in (1, 2) satisfies $x idiv 2 = 1
some $x in (1, 2) satisfies fn:avg(($x, 1)) = 1
some $x in (1, 2) satisfies fn:count(($x)) = 1
some $x in (1, 2) satisfies fn:false()
some $x in (1, 2) satisfies fn:not($x)
some $x in (1, 2) satisfies fn:string($x) = "1"
some $x in (1, 2) satisfies fn:string-length(xs:string($x)) = 1
some $x in (1, 2) satisfies fn:true()
some $x in ("1980-05-05T13:13:13Z", "1980-05-05T13:13:13Z"), $y in ("1980-05-05T13:13:13Z","1980-05-05T13:13:13Z") satisfies xs:dateTime($x) = xs:dateTime($y)
some $x in ("1985-07-05Z", "1985-07-05Z"), $y in ("1985-07-05Z","1985-07-05Z") satisfies xs:date($x) = xs:date($y)
some $x in (1 to 10)[. div 2 = 11] satisfies true()
some $x in ("A","B","C") satisfies $x = "A"
some $x in map{'decimal':true(), 'integer':true(), 'polygon':false()}?* satisfies $x
some $x in ("true", "false"), $y in ("false","true") satisfies xs:boolean($x) = xs:boolean($y)
<!-- some - - - - content - - - >>>>> << >>><>& ;& --> eq " some - - - - content - - - >>>>> << >>><>&amp; ;&amp; "
<? spaceIsNotAllowedBefore ?>
(/staff[1]/employee[1]/empnum[1]) << <a>50000</a>
(/staff[1]/employee[1]/empnum[1]) >> <a>50000</a>
(/staff[1]/employee[1]/empnum[1]) is <a>50000</a>
(/staff[1]/employee[1]/empnum[1]) is (/staff[1]/employee[1]/empnum[1])
((/staff[1]/employee[1]/empnum[1]) is (/staff[1]/employee[1]/empnum[1])) ge ((/staff[1]/employee[1]/empnum[1]) is (/staff[1]/employee[1]/empnum[1]))
((/staff[1]/employee[1]/empnum[1]) is (/staff[1]/employee[1]/empnum[1])) gt ((/staff[1]/employee[1]/empnum[1]) is (/staff[1]/employee[1]/empnum[1]))
(/staff[1]/employee[1]/empnum[1]) is (/staff[1]/employee[1]/empnum[1]) is (/staff[1]/employee[1]/empnum[1])
((/staff[1]/employee[1]/empnum[1]) is (/staff[1]/employee[1]/empnum[1])) le ((/staff[1]/employee[1]/empnum[1]) is (/staff[1]/employee[1]/empnum[1]))
((/staff[1]/employee[1]/empnum[1]) is (/staff[1]/employee[1]/empnum[1])) lt ((/staff[1]/employee[1]/empnum[1]) is (/staff[1]/employee[1]/empnum[1]))
(/staff[1]/employee[1]/empnum[1]) << (/staff[1]/employee[1]/empnum[1])
(/staff[1]/employee[1]/empnum[1]) >> (/staff[1]/employee[1]/empnum[1])
((/staff[1]/employee[1]/empnum[1]) << (/staff[1]/employee[1]/empnum[1]))           ge          ((/staff[1]/employee[1]/empnum[1]) << (/staff[1]/employee[1]/empnum[1]))
((/staff[1]/employee[1]/empnum[1]) >> (/staff[1]/employee[1]/empnum[1]))           ge ((/staff[1]/employee[1]/empnum[1]) >> (/staff[1]/employee[1]/empnum[1]))
((/staff[1]/employee[1]/empnum[1]) << (/staff[1]/employee[1]/empnum[1]))           gt ((/staff[1]/employee[1]/empnum[1]) << (/staff[1]/employee[1]/empnum[1]))
((/staff[1]/employee[1]/empnum[1]) >> (/staff[1]/employee[1]/empnum[1]))           gt ((/staff[1]/employee[1]/empnum[1]) >> (/staff[1]/employee[1]/empnum[1]))
((/staff[1]/employee[1]/empnum[1]) << (/staff[1]/employee[1]/empnum[1]))           le ((/staff[1]/employee[1]/empnum[1]) << (/staff[1]/employee[1]/empnum[1]))
((/staff[1]/employee[1]/empnum[1]) >> (/staff[1]/employee[1]/empnum[1]))           le ((/staff[1]/employee[1]/empnum[1]) >> (/staff[1]/employee[1]/empnum[1]))
((/staff[1]/employee[1]/empnum[1]) << (/staff[1]/employee[1]/empnum[1]))           lt           ((/staff[1]/employee[1]/empnum[1]) << (/staff[1]/employee[1]/empnum[1]))
((/staff[1]/employee[1]/empnum[1]) >> (/staff[1]/employee[1]/empnum[1]))           lt ((/staff[1]/employee[1]/empnum[1]) >> (/staff[1]/employee[1]/empnum[1]))
(starts-with('', ''))
starts-with(())
starts-with((), ())
starts-with()
starts-with('a', 'b', 'http://www.cbcl.co.u,/collation')
starts-with("a string", ())
starts-with("a string", "a string", "http://www.example.com/COLLATION/NOT/SUPPORTED")
starts-with("foo", "foo")
starts-with((), (), "http://www.w3.org/2005/xpath-functions/collation/codepoint", "wrong param")
(starts-with('', 'query'))
(starts-with('query', ''))
(starts-with('query', ()))
(starts-with(' query', 'q'))
(starts-with('query', 'que'))
(starts-with('query', 'query'))
(starts-with('query', 'que'), starts-with('query', 'query'), starts-with('query', 'u'), starts-with('query', ''), starts-with('', 'query'), starts-with('', ''), starts-with('query', ()), starts-with(' query', 'q'))
(starts-with('query', 'u'))
starts-with("tattoo", "tat")
((), (), ((), (), ((), (), ("str")), ()), (), (())) eq "str"
"string" * 1
"string" + 1
"string" - 1
"string" << 1
"string" >> 1
string([1])
string( (1, 2) )
string(1, 2)
string((1, 2, 3))
string([[1, 2], [3, 4]])
string(1) eq "1"
string(23)
string(3 * xs:double("NaN")) eq "NaN"
string(3 + xs:double("NaN")) eq "NaN"
string(3 - xs:double("NaN")) eq "NaN"
string(3 * xs:float("NaN")) eq "NaN"
string(3 + xs:float("NaN")) eq "NaN"
string(3 - xs:float("NaN")) eq "NaN"
string(<a> {1} <b> {1} </b> </a>)
string(<a>aaaa<b/>aaaa</a>)
string(<a attr="content"><!-- NOTINC -->1<b>2<c><!-- NOTINC -->34</c><!-- NOTINC --><d/>56</b>7</a>) eq "1234567"
string(abs#1)
string(array{})
string(avg((1, 2, 3, xs:double("NaN")))) eq "NaN"
string(avg((1, 2, 3, xs:float("NaN")))) eq "NaN"
string(avg((1, 2, xs:double("NaN"), 1, 2, 3))) eq "NaN"
string(avg((1, 2, xs:float("NaN"), 1, 2, 3))) eq "NaN"
string(avg((3, 3, xs:double("NaN")))) eq "NaN"
string(avg(((3, 4, 5), xs:float('NaN')))) eq "NaN"
string(avg((3, xs:double("NaN"), 3))) eq "NaN"
string(avg((xs:double("NaN"), 1, 2, 3))) eq "NaN"
string(avg((xs:double("NaN"), 3, 3))) eq "NaN"
string(avg((xs:float('INF'), xs:float('-INF')))) eq "NaN"
string(avg((xs:float("NaN"), 1, 2, 3))) eq "NaN"
'string' castable as attribute()
'string' castable as empty-sequence()
'string' castable as item()
'string' castable as node()
'string' castable as xs:anyAtomicType
'string' castable as xs:anySimpleType
'string' castable as xs:anyType*
'string' castable as xs:string*
'string' castable as xs:string+
'string' cast as attribute()
'string' cast as empty-sequence()
'string' cast as item()
'string' cast as node()
'string' cast as xs:anyAtomicType
'string' cast as xs:anySimpleType
'string' cast as xs:anyType*
'string' cast as xs:string*
'string' cast as xs:string+
string((//comment())[1])
string(<!-- content&amp;amp;ss&amp;amp;#00; &amp;#x2014;-->) eq " content&amp;amp;amp;ss&amp;amp;amp;#00; &amp;amp;#x2014;"
string(current-date())
string(dateTime(xs:date("2011-06-29"), xs:time("24:00:00")))
"string" div 1
string(<e>123<!-- a comment -->ab<!-- another comment -->c</e>)
string(<e>123<b>XX</b>abc</e>)
string(<e>123<?target content ?>ab<?target2 content?>c</e>)
string(<e>{1}A{1}</e>)
string(<e/>)/3
string(<e> &#32; </e>)
string(<e>'a''a'''a"a""a"""a"</e>) eq "'a''a'''a""a""""a""""""a"""
string(<e>a<!--data tar-->b</e>)
string(<e> <![CDATA[ ]]> </e>)
string(<e>]]></e>)
string(<e>e<b>ddd</b></e>)
string(<eg> (: an (:example:) </eg>)
string(<elem>{1}{text{""}}{2}</elem>)
string(<elem attr="{attribute name {" content "}}"/>/@attr)
string(<elem attr="{comment {" content "}}"/>/@attr)
string(<elem><![CDATA[cdata&<>'"< ]]>asda <?target content?>asdad</elem>) eq "cdata&amp;<>'""&lt;&#x20;asda asdad"
string(<elem><![CDATA[cdat]]><!-- a comment --><?target content?></elem>)
string(<elem><![CDATA[con<<< ]] >""'*"*">>tent]]&#00;&#x12;&amp;&quot;&notrecognized;&apos]]></elem>) eq "con&lt;&lt;&lt; ]] &gt;""""'*""*""&gt;&gt;tent]]&amp;#00;&amp;#x12;&amp;amp;&amp;quot;&amp;notrecognized;&amp;apos"
string(<elem> <![CDATA[]]> </elem>)
string(<elem><![CDATA[str]]>str<![CDATA[str]]><![CDATA[str]]><![CDATA[str]]>strstr{ "str", "str", "strstr", "str"}strstr<![CDATA[str]]>s<?target str?>tr</elem>) eq "strstrstrstrstrstrstrstr str strstr strstrstrstrstr"
string(<elem> content <![CDATA[ content ]]> content </elem>)
string(()) eq ""
"string" eq 1
string(<e>text</e>)
string(exactly-one((for $fo in (1, 2, 3) where $fo eq 3 return $fo)))
string(false())
string(<foo attr=""""/>/@attr)
string(<foo attr="''"/>/@attr)
string(<foo attr='""'/>/@attr)
string(<foo attr=''''/>/@attr)
string(for $i in current-date() order by $i return $i)
string(function($a, $b) {$a + $b})
"string" ge 1
"string" gt 1
"string" idiv 1
"string" is 1
(string-join((), '/*'))
string-join#1(("a", "b", "c", "d", "e", "f", "g", "h", "i", "j"))
string-join#1 eq string-join#1
string-join#1 is string-join#1
(string-join( 'a', '/*'))
(string-join( ('a', 'b', 'c'), ''))
(string-join( ('a', 'b', 'c'), '/*'))
string-join(("abc", "def"), "") eq "abcdef"
(string-join( ('a', 'b', 'c'), ''), string-join( ('a', 'b', 'c'), '/*'), string-join( ('a', '', 'c'), '/*'), string-join( 'a', '/*'), string-join((), '/*'))
(string-join( ('a', '', 'c'), '/*'))
string-join(<a foo="3" bar="5" xml:space="preserve"/> / @Q{}*, '.')
string-join("a string")
string-join("a string", ())
string-join("a string", "a string", "wrong param")
string-join((<a>X</a>, <a>Y</a>, <a>Z</a>), '')
string-join(('Blow, ', 'blow, ', 'thou ', 'winter ', 'wind!'), '') eq "Blow, blow, thou winter wind!"
string-join((/comment() intersect /comment()), "|")
string-join(for $code in string-to-codepoints("example.com/") return string($code), "") eq "10112097109112108101469911110947"
string-join((for $node in /bib/book/title/text() except /bib/book[3]/title/text() return $node/string()), "|")
string-join((for $node in ((//price/text()) , (//price/text())) except (//price) return $node)/string(), "|")
string-join(for $node in ((//price/text()) , (//price/text())) union ((//price/text()) , (//price/text())) return $node, "|")
string-join(('Now', 'is', 'the', 'time', '...'), ' ') eq "Now is the time ..."
string-join(reverse(((//*:Open)[1])/ancestor-or-self::*/local-name()), '~')
string-join((), 'separator') eq ""
string-join(("START",         string(QName("http://example.com",         "prefix:localName")),         string(QName("http://example.com", "localName")),         string(QName("http://example.com", "localName")),         string(QName("", "localName")),         string(QName((), "localName")),         "END"), " ")
string-join(("START",         string(QName("http://example.com", "prefix:localName")),         string(QName("http://example.com", "localName")),         string(QName("http://example.com", "localName")),         string(QName("", "localName")),         string(QName((), "localName")),         "END"), " ")
string-join(tokenize( 'a    b c', '\s'), '|')
string-join( (xs:anyURI('http://www.microsoft.com'), xs:anyURI('http://www.google.com/')), ' ')
"string" le 1
(string-length(''))
(string-length(()))
string-length("abcdef")
string-length("abc&#x1D156;def")
string-length("a string", "wrong param")
string-length("ebv") eq 3
string-length("ebv") instance of xs:integer
string-length("") eq 0
string-length(()) eq 0
string-length("Harp not on that string, madam; that is past.") eq 45
string-length(()) instance of xs:integer
(string-length(normalize-space(' query ')))
string-length(("one", "two"))
(string-length('  query  '))
(string-length('query'))
(string-length('query'), string-length('  query   '), string-length(normalize-space('   query   ')), string-length('xml query'), string-length(''), string-length(()))
string-length(string(xs:string(current-time()))) gt 2
(string-length('xml query'))
string-length(xs:token(' '))
string-length(xs:token('&#x9;'))
string-length("")
string(map{})
string(map{1:2})
string(map:entry("a","string"))
string(max((1, xs:untypedAtomic("NaN"), xs:float(2)))) eq "NaN"
string(max((3, xs:double("NaN")))) eq "NaN"
string(max((3, xs:float("NaN")))) eq "NaN"
string(max(xs:double("NaN"))) eq "NaN"
string(max((xs:double("NaN"), xs:double("NaN")))) eq "NaN"
string(max((xs:float(-3), xs:untypedAtomic("3"), xs:double("NaN")))) eq "NaN"
string(max(xs:float("NaN"))) eq "NaN"
string(max((xs:float("NaN"), xs:float("NaN")))) eq "NaN"
string(max((xs:float("NaN"), xs:untypedAtomic("3"), xs:float(2)))) eq "NaN"
string(min((1, xs:untypedAtomic("NaN"), xs:float(2)))) eq "NaN"
string(min((3, xs:double("NaN")))) eq "NaN"
string(min((3, xs:float("NaN")))) eq "NaN"
string(min(xs:double("NaN"))) eq "NaN"
string(min((xs:double("NaN"), xs:double("NaN")))) eq "NaN"
string(min((xs:float(-3), xs:untypedAtomic("3"), xs:double("NaN")))) eq "NaN"
string(min(xs:float("NaN"))) eq "NaN"
string(min((xs:float("NaN"), xs:float("NaN")))) eq "NaN"
string(min((xs:float("NaN"), xs:untypedAtomic("3"), xs:float(2)))) eq "NaN"
"string" mod 1
"string" ne 1
string(number("1")) eq "1"
string(number(xs:anyURI("1"))) eq "NaN"
string(number(xs:anyURI("example.com/"))) eq "NaN"
string(number(xs:gYear("2005"))) eq "NaN"
string((//*:Open)[1])
string("Paris")
string(<pi>{<?pi x?>}</pi>) eq ""
string((//processing-instruction())[1])
string(processing-instruction {"thename"} {"asdas? >"})
string(processing-instruction {"thename"} {"content {1+ } {"})
string(          /Q{  http://www.example.com/AuctionWatch}AuctionWatchList/          Q{   http://www.example.com/AuctionWatch}Auction[2]/          @Q{  http://www.example.com/auctioneers#yabadoo}ID)
string((//Q{  http://www.example.com/AuctionWatch  }Start)[1])
string((//Q{http://www.example.com/AuctionWatch}Start)[1])
string(QName("http://www.w3.org/", "test:example"))
string((//*:Start)[1]/@*)
string(["string"])
string(string#1)
string(sum((1, 2, 3, xs:double("NaN")))) eq "NaN"
string(sum((1, 2, 3, xs:float("NaN")))) eq "NaN"
string(sum((1, 2, xs:double("NaN"), 1, 2, 3))) eq "NaN"
string(sum((1, 2, xs:float("NaN"), 1, 2, 3))) eq "NaN"
string(sum((xs:double("NaN"), 1, 2, 3))) eq "NaN"
string(sum((xs:float("NaN"), 1, 2, 3))) eq "NaN"
string(<?target ""''content&amp;amp;ss&amp;#00; &amp;#x2014;?>) eq """""''content&amp;amp;amp;ss&amp;amp;#00; &amp;amp;#x2014;"
string(<?target content ?>) eq "content "
string(text {""}) eq ""
string((//text())[normalize-space(.)][1])
(string-to-codepoints(''))
string-to-codepoints(())
string-to-codepoints()
string-to-codepoints(12)
(string-to-codepoints('a'))
(string-to-codepoints('abc'))
string-to-codepoints('abc','def')
(string-to-codepoints('abc'), string-to-codepoints('a'), string-to-codepoints(''))
string-to-codepoints(<a>   |&#xD; &#xD;&#xA;</a>)
string-to-codepoints('b')
string-to-codepoints(codepoints-to-string(14))
string-to-codepoints(codepoints-to-string(31))
string-to-codepoints("e")
string-to-codepoints(<elem>&amp;</elem>)
string-to-codepoints(<elem>&apos;</elem>)
string-to-codepoints(<elem>&gt;</elem>)
string-to-codepoints(<elem>&lt;</elem>)
string-to-codepoints(<elem>&quot;</elem>)
string-to-codepoints("str", "INVALID")
string-to-codepoints(substring("A", 2, 1))
string-to-codepoints(substring("&#x10FC00;A", 2, 1))
string-to-codepoints("Thrse")[0 + last()]
string-to-codepoints("Thrse")[last()]
string-to-codepoints("Thrse")[last() - 0]
string-to-codepoints("Thrse")[last() - 1]
string-to-codepoints("Thrse")[last() - 2]
string-to-codepoints("Thrse")[last() - 6]
string-to-codepoints(xs:normalizedString(codepoints-to-string((32, 09, 48, 13, 10, 48, 160, 32, 09))))
string-to-codepoints(xs:token(codepoints-to-string((32, 09, 48, 13, 10, 48, 160, 32, 09))))
string(/works/@id) eq "abc"
string(/works/@id) ne "abc"
string((//@xml:*)[1])
string(xs:dateTime("2000-08-01T12:44:05")) eq "2000-08-01T12:44:05"
string(xs:double("NaN") * 3) eq "NaN"
string(xs:double("NaN") + 3) eq "NaN"
string(xs:double("NaN") - 3) eq "NaN"
string(xs:duration("P24M"))
string(xs:float("NaN") * 3) eq "NaN"
string(xs:float("NaN") + 3) eq "NaN"
string(xs:float("NaN") - 3) eq "NaN"
string(xs:time("12:44:05")) eq "12:44:05"
string(xs:time("24:00:00"))
string(xs:time("24:00:00")) eq "00:00:00"
subsequence()
subsequence(1)
subsequence(1, 1, 1, 1)
subsequence((1, 2, 3), 1, 0)
subsequence((1, 2, 3), 1, 1) eq 1
subsequence((1, 2, 3.1, "four"), 1, 1)
subsequence(("1", 2, 3.1, "four"), 1, 1) eq 1
subsequence((1, 2, 3.1, "four"), 3, 1) instance of xs:decimal
subsequence((1, 2, 3.1, "four"), 4)
subsequence((1, 2, 3.1, "four"), 4, 1)
subsequence((1, 2, 3), 1, "string")
subsequence((1, 2, 3), 3) eq 3
subsequence((1, 2, 3, 4, 5), 4, -1)
subsequence((1, 2, 3, current-time(), 5, 6, 7), 1, 1)[1]
subsequence((1, 2, 3, current-time(), 5, 6, 7), 4)[last() - 1]
subsequence((1, 2, 3, current-time(), 5, 6, 9), 7)[last()]
subsequence((1, 2, for $x in 1 to 10 return 2*$x), -1, sum((1 to 10)[. mod 10 = 3]))
subsequence((1, 2, for $x in 1 to 10 return 2*$x), 2, year-from-date(current-date()))
subsequence(1 to 100, 99, 2147483648)
subsequence((1 to 100)[. mod 2 = 0],1,xs:double(string-join(('I','N','F')[position() mod 2 >= 0],'')))
subsequence((1 to 10)[. mod 2 = 0] instance of xs:integer+,1)
subsequence((1 to 20)[. mod 2 = 0][position() < 5],2)
(subsequence( (), 3))
subsequence(-3 to -1, 1, 1) eq -3
subsequence(-3 to -1, 3, 1) eq -1
subsequence((5, 6, 7, 8), 2, 1) eq 6
(subsequence( ('a', 'b', 'c', 'd', 'e'), 10))
(subsequence( ('a', 'b', 'c', 'd', 'e'), -2, 5))
(subsequence( ('a', 'b', 'c', 'd', 'e'), 3) )
(subsequence( ('a', 'b', 'c', 'd', 'e'), 3, 10))
(subsequence( ('a', 'b', 'c', 'd', 'e'), 3, 2))
(subsequence( ('a', 'b', 'c', 'd', 'e'), 3) , subsequence( ('a', 'b', 'c', 'd', 'e'), 3, 2), subsequence( ('a', 'b', 'c', 'd', 'e'), 3, 10), subsequence( ('a', 'b', 'c', 'd', 'e'), 10), subsequence( ('a', 'b', 'c', 'd', 'e'), -2, 5), subsequence( (), 3))
subsequence("a string", 1, 1) + 1
subsequence(("dummy", 1.1, xs:anyURI("http://www.example.com/an/arbitrary/URI.ext")), 3, 1) instance of xs:anyURI
subsequence(("dummy", 1.1, xs:base64Binary("aaaa")), 3, 1) instance of xs:base64Binary
subsequence(("dummy", 1.1, xs:boolean("true")), 3, 1) instance of xs:boolean
subsequence(("dummy", 1.1, xs:date("2004-10-13")), 3, 1) instance of xs:date
subsequence(("dummy", 1.1, xs:dateTime("2002-10-10T12:00:00-05:00")), 3, 1) instance of xs:dateTime
subsequence(("dummy", 1.1, xs:dayTimeDuration("P3DT2H")), 3, 1) instance of xs:dayTimeDuration
subsequence(("dummy", 1.1, xs:decimal("10.01")), 3, 1) instance of xs:decimal
subsequence(("dummy", 1.1, xs:double("3.3e3")), 3, 1) instance of xs:double
subsequence(("dummy", 1.1, xs:duration("P1Y2M3DT10H30M")), 3, 1) instance of xs:duration
subsequence(("dummy", 1.1, xs:float("3.4e5")), 3, 1) instance of xs:float
subsequence(("dummy", 1.1, xs:gDay("---03")), 3, 1) instance of xs:gDay
subsequence(("dummy", 1.1, xs:gMonth("--11")), 3, 1) instance of xs:gMonth
subsequence(("dummy", 1.1, xs:gMonthDay("--11-13")), 3, 1) instance of xs:gMonthDay
subsequence(("dummy", 1.1, xs:gYear("1999")), 3, 1) instance of xs:gYear
subsequence(("dummy", 1.1, xs:gYearMonth("1999-11")), 3, 1) instance of xs:gYearMonth
subsequence(("dummy", 1.1, xs:hexBinary("0FB7")), 3, 1) instance of xs:hexBinary
subsequence(("dummy", 1.1, xs:integer("6789")), 3, 1) instance of xs:integer
subsequence(("dummy", 1.1, xs:QName("ncname")), 3, 1) instance of xs:QName
subsequence(("dummy", 1.1, xs:string("an arbitrary string")), 3, 1) instance of xs:string
subsequence(("dummy", 1.1, xs:time("03:20:00-05:00")), 3, 1) instance of xs:time
subsequence(("dummy", 1.1, xs:untypedAtomic("an arbitrary string(untypedAtomic source)")), 3, 1) instance of xs:untypedAtomic
subsequence(("dummy", 1.1, xs:yearMonthDuration("P1Y12M")), 3, 1) instance of xs:yearMonthDuration
subsequence(for $x in (1 to 100) return -$x, 3, 5)
subsequence(for $x in 1 to 10 return $x * $x,2)
subsequence(for $x in 1 to 10 return $x[. mod 2 = 0],2)
subsequence(for $x in 1 to 10 return $x[. mod 2 = 0],2,4)
subsequence(for $x in 1 to 10 return 1 to $x, 1.2, xs:double("INF"))
subsequence(for $x in 1 to 10 return 1 to $x, 4.2, xs:double("INF"))
subsequence( for $x in 1 to 10 return 1 to $x, count(for $x in 0 to 10 return 1 to $x), 1)
subsequence(reverse(1 to 3), 1, 1) eq 3
subsequence(reverse(1 to 3), 3, 1) eq 1
subsequence(reverse(1 to 4), 2, 1) eq 3
subsequence(reverse(1 to 4), 3, 1) eq 2
subsequence(reverse(-4 to -1), 2, 1) eq -2
(substring('', 1))
(substring((), 1))
substring("12345", 0, 3) eq "12"
substring("12345", 0 div 0E0, 3) eq ""
substring("12345", 1, 0 div 0E0) eq ""
substring("12345", 1.5, 2.6) eq "234"
substring("12345", -1 div 0E0, 1 div 0E0) eq ""
substring("12345", -3.1e0, 5.2e0) eq "1"
substring("12345", -3, 5) eq "1"
substring("12345", -42, 1 div 0E0) eq "12345"
substring("12345", 5, -3) eq ""
substring((), 1, 2) eq ""
substring((), 1, 3) eq ""
substring((), 1) eq ""
substring("abcdef", 4)
substring("abcdef", 5)
substring("abcdefgh", 5, 2)
substring("abcdefgh", 6)
substring("abc&#x1D156;def", 4)
substring("abc&#x1D156;def", 5)
substring-after(())
substring-after()
substring-after("abcdef", "")
substring-after("abcdefgedij", "def") eq "gedij"
substring-after("abc&#x1D156;def", "&#x1D156;")
substring-after("a string", ()) eq "a string"
substring-after("a string", "not in other") eq ""
substring-after((), ()) eq ""
substring-after((), (), "http://www.w3.org/2005/xpath-functions/collation/codepoint", "wrong param")
(substring-after('query', ''))
(substring-after('queryquery', 'ue'))
(substring-after('query', 'u'))
(substring-after('query', 'u'), substring-after('queryquery', 'ue'), substring-after('query', 'y'), substring-after('query', 'x'), substring-after('query', ''), substring-after('', 'x'))
(substring-after('query', 'x'))
(substring-after('query', 'y'))
substring-after("tattoo", "tat") eq "too"
substring-after("tattoo", "tattoo") eq ""
(substring-after('', 'x'))
substring-after("", "")
sub-string("a string")
sub-string("a string", 1, 2, "wrong param")
substring-before(())
substring-before()
substring-before("abcdef", "")
substring-before("abcdef", "f")
substring-before("abc&#x1D156;def", "f")
substring-before("abc&#x1D156;def", "&#x1D156;")
substring-before("a string", "") eq ""
substring-before("a string", "not in other") eq ""
substring-before((), ()) eq ""
substring-before((), (), "http://www.w3.org/2005/xpath-functions/collation/codepoint",          "wrong param")
(substring-before('query', ''))
(substring-before('query', ()))
(substring-before('query', 'ery'))
(substring-before('query', 'query'))
(substring-before('queryquery', 'ery'))
(substring-before('query', 'r'))
(substring-before('query', 'r'), substring-before('query', 'ery'), substring-before('queryquery', 'ery'), substring-before('query', 'query'), substring-before('query', 'x'), substring-before('query', ''), substring-before('query', ()))
(substring-before('query', 'x'))
substring-before("tattoo", "attoo") eq "t"
substring-before("tattoo", "tatto") eq ""
substring-before("", "")
substring("metadata", 4, 3) eq "ada"
substring("motor car", 6) eq " car"
(substring('query', 1))
(substring('query', 1, 0))
(substring('query', 1, 1))
(substring('query', 1), substring('query', 3), substring('query', 1, 1), substring('query', 2, 3), substring('query', 2, 850), substring('query', 6, 2), substring('query', -2), substring('query', -2, 5), substring('query', 1, 0), substring('', 1), substring((), 1))
(substring('query', -2))
(substring('query', 2, 3))
(substring('query', -2, 5))
(substring('query', 2, 850))
(substring('query', 3))
(substring('query', 6, 2))
substring("", 0, 2)
substring("", 0, 3)
substring("", 1, 2)
substring("", 2, 1)
substring("", 0)
substring("", 3)
sum((), ())
sum()
sum((), 0.0) eq 0.0
sum((), 0.0) instance of xs:decimal
sum(1, 1, "wrong param")
sum((1, 2, 3, xs:anyURI("a string"), xs:double("NaN")))
sum((1, 2, 3, xs:anyURI("a string"), xs:double("NaN")), 3)
sum((1, 2, xs:untypedAtomic("3"))) eq 6
sum((1, 2, xs:untypedAtomic("3"))) instance of xs:double
sum((1,exactly-one((1 to 10)[. div 2 = 2])))
sum(1 to 10)
sum((1 to 100)[. < 0], 0) eq 0
sum((1 to 5)[. gt year-from-date(current-date())], "No data")
sum((1 to 5)[. lt year-from-date(current-date())], 17)
sum((1 to 5)[. lt year-from-date(current-date())], "bonkers")
sum((3, 4, 5)) eq 12
sum((), 3) eq 3
sum((), 3) instance of xs:integer
sum((-5, -0, -3, -6)) eq -14
sum("a string")
sum(((),())) eq 0
sum(()) eq 0
sum(for $i in 1 to 6 return              let $add := function($x){$x + $i} return $add(4))
sum(for $x in 1 to 10 return 5)
sum(()) instance of xs:integer
sum(remove((1.0, xs:float(1), 2, xs:untypedAtomic("3")), 1)) eq 6
sum(sum((1 to 10)[. mod 2 = 0],()))
sum(xs:anyURI("a string"))
sum((), xs:dayTimeDuration("PT0S"))
sum((), xs:duration("P0M"))
sum(xs:duration("P1Y1M1D"))
sum(xs:duration("P1Y1M1D"), xs:duration("PT0S"))
sum((xs:float(1), 2, xs:untypedAtomic("3"))) eq 6
sum((xs:float(1), 2, xs:untypedAtomic("3"))) instance of xs:double
sum((xs:float('NaN'), 2, 3.3, 4, xs:double('NaN'))) instance of xs:double
sum((xs:float('NaN'), 2, 3, 4, xs:double('NaN'))) instance of xs:double
sum(xs:untypedAtomic("3")) instance of xs:double
sum((), xs:yearMonthDuration("P0M"))
sum((xs:yearMonthDuration("P1Y"), xs:dayTimeDuration("P1D")))
sum((xs:yearMonthDuration("P20Y"), (3, 4, 5)))
sum((xs:yearMonthDuration("P20Y"), xs:yearMonthDuration("P10M")) [. < xs:yearMonthDuration("P3M")], xs:yearMonthDuration("P0M")) eq xs:yearMonthDuration("P0M")
switch()
system-property("property")
system-property("xsl:vendor")
tail(12 to 15)
tail(("a", "b", "c"))
<?target ]]>?>
<?target {1 + 1}?>
<?target 1?> eq 1
<?target content?> instance of processing-instruction()
"t" eq "t"
"t" eq "&#x74;"
"test
"test"
"test'
'test
'test"
'test'
<test check='He said, "I don''t like it."' />
//test:comparable[1]/test:int eq //test:comparable[2]/test:int
<?test data?>/node-name()
<test>{ 'He said, "I don''t like it."' }</test>
(:*******************************************************:) (: Test: K2-DirectConElemAttr-75                         :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:21+01:00                       :) (: Purpose: Mix several ways for creating text for various kinds of nodes. This test is useful if an implementation is performing normalization of such constructors. :) (:*******************************************************:) <e attribute="{ "abc", "def", "ghi", 1, 2, 3, xs:untypedAtomic("abc"), text {"a text node"}, text {"a text node"}, xs:untypedAtomic("def"), xs:untypedAtomic("ghi"), xs:hexBinary("FF"), xs:untypedAtomic("abc"), xs:string("def"), xs:untypedAtomic("ghi") } textNode {"xs:string"} textNode {"xs:string"} textNode {"xs:string"} text {"a text node"}, {"xs:string"} {"xs:string"}textnode"> {  attribute name { text {"a text node"}, text {"a text node"}, "abc", "def", text {"a text node"}, "ghi", 1, 2, text {"a text node"}, 3, xs:untypedAtomic("abc"), xs:untypedAtomic("def"), text {"a text node"}, xs:untypedAtomic("ghi"), xs:hexBinary("FF"), xs:untypedAtomic("abc"), xs:string("def"), xs:untypedAtomic("ghi"), "xs:string", xs:untypedAtomic("ghi"), "xs:string", "xs:string", "xs:string", xs:untypedAtomic("ghi") } } { text {"a text node"}, text {"a text node"}, "abc", "def", text {"a text node"}, "ghi", 1, 2, text {"a text node"}, 3, xs:untypedAtomic("abc"), text {"a text node"}, xs:untypedAtomic("def"), xs:untypedAtomic("ghi"), xs:hexBinary("FF"), xs:untypedAtomic("abc"), xs:string("def"), xs:untypedAtomic("ghi") } textNode {"xs:string"} textNode {"xs:string"} textNode {"xs:string"} {"xs:string"} {"xs:string"} text {"a text node"}, text {"a text node"}, text {"a text node"}, text {"a text node"}, { comment { "abc", "def", "ghi", 1, 2, 3, xs:untypedAtomic("abc"), xs:untypedAtomic("def"), xs:untypedAtomic("ghi"), xs:hexBinary("FF"), xs:untypedAtomic("abc"), xs:string("def"), xs:untypedAtomic("ghi"), "xs:string", "xs:string", xs:untypedAtomic("ghi"), "xs:string", text {"a text node"}, text {"a text node"}, "xs:string", xs:untypedAtomic("ghi"), "xs:string" }, processing-instruction target { "abc", "def", "ghi", 1, 2, 3, xs:untypedAtomic("abc"), xs:untypedAtomic("def"), xs:untypedAtomic("ghi"), text {"a text node"}, text {"a text node"}, xs:hexBinary("FF"), xs:untypedAtomic("abc"), xs:string("def"), xs:untypedAtomic("ghi"), "xs:string", "xs:string", xs:untypedAtomic("ghi"), "xs:string", "xs:string", xs:untypedAtomic("ghi"), text {"a text node"}, "xs:string" }, text { text {"a text node"}, text {"a text node"}, text {"a text node"}, text {"a text node"}, "abc", "def", "ghi", 1, 2, text {"a text node"}, 3, xs:untypedAtomic("abc"), text {"a text node"}, xs:untypedAtomic("def"), xs:untypedAtomic("ghi"), xs:hexBinary("FF"), xs:untypedAtomic("abc"), xs:string("def"), xs:untypedAtomic("ghi"), "xs:string", "xs:string", xs:untypedAtomic("ghi"), "xs:string", "xs:string", xs:untypedAtomic("ghi"), "xs:string", text {"a text node"} } } </e>
(:*******************************************************:) (: Test: K2-DirectConOther-49                            :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:21+01:00                       :) (: Purpose: Check that an attribute value's value is properly read and serialized. Since the whitespace is expressed with character references they are preserved and hence aren't subject to for instance end-of-line handling. Subsequently, the serialization process must escape such characters in order to not have the parser normalize the values when being read back in. :) (:*******************************************************:) <e attr="&#x20;&#xD;&#xA;&#x9;&#xD;&#xD;&#xD;&#xD;      &#xD; &#xD;     &#xD;&#xA; &#xD;&#xA; &#xD;&#xA;"/>
(:*******************************************************:) (: Test: K2-DirectConOther-50                            :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:21+01:00                       :) (: Purpose: Ensure that EOL-normalization also takes place in CDATA sections. :) (:*******************************************************:) string(<e><![CDATA[ ]]></e>) eq "&#xA;"
(:*******************************************************:) (: Test: K2-DirectConOther-51                            :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:21+01:00                       :) (: Purpose: Ensure that EOL-normalization also takes place in CDATA sections(#2). :) (:*******************************************************:) string(<e><![CDATA[ ]]></e>) eq "&#xA;"
(:*******************************************************:) (: Test: K2-DirectConOther-52                            :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:21+01:00                       :) (: Purpose: Ensure that EOLs are normalized in text nodes. :) (:*******************************************************:) <e>a    string literal  </e>
(:*******************************************************:) (: Test: K2-DirectConOther-53                            :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:21+01:00                       :) (: Purpose: Ensure that EOLs are normalized in comment nodes. :) (:*******************************************************:) <e><!--a    string literal  --></e>
(:*******************************************************:) (: Test: K2-DirectConOther-54                            :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:21+01:00                       :) (: Purpose: Ensure that EOLs are normalized in processing instructions. :) (:*******************************************************:) <e><?target a    string literal  ?></e>
(:*******************************************************:) (: Test: K2-Literals-28                                  :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:21+01:00                       :) (: Purpose: Ensure that EOLs are normalized in string literals. :) (:*******************************************************:) "a   string literal  "
(:*******************************************************:) (: Test: K2-Literals-39                                  :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:21+01:00                       :) (: Purpose: Ensure that EOLs are normalized in string literals, using single quotes. :) (:*******************************************************:) 'a    string literal  '
(:*******************************************************:) (: Test: K2-XQueryComment-1                              :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:21+01:00                       :) (: Purpose: An invalid comment after a name test.        :) (:*******************************************************:) let $i := <e>                                             <b/>                                             <b/>                                             <b/>                                         </e>                               return $i/b(:
(:*******************************************************:) (: Test: K2-XQueryComment-2                              :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:21+01:00                       :) (: Purpose: An invalid comment after a name test(#2).    :) (:*******************************************************:) let $i := <e>                                             <b/>                                             <b/>                                             <b/>                                         </e>                               return $i/b(: some : content (:some content
(:*******************************************************:) (: Test: K2-XQueryComment-3                              :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:21+01:00                       :) (: Purpose: Have a computed comment constructor as a last step. :) (:*******************************************************:) let $i := <e>                                             <b/>                                             <b/>                                             <b/>                                         </e>                                         return $i/b/comment(: some : content (:some content:):){"content"}
(:*******************************************************:) (: Test: K2-XQueryComment-4                              :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:21+01:00                       :) (: Purpose: Have a direct comment constructor as a last step. :) (:*******************************************************:) let $i := <e>                                             <b/>                                             <b/>                                             <b/>                                         </e>                                         return $i/(: some : content (:some content:):)<!--content-->
(:*******************************************************:) (: Test: K2-XQueryComment-5                              :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:21+01:00                       :) (: Purpose: Have a direct comment constructor as a last step(#2). :) (:*******************************************************:) let $i := <e>                                             <b/>                                             <b/>                                             <b/>                                         </e>                                         return $i/b/(: some : content (:some content:):)<!--content-->
(:*******************************************************:) (: Test: K-XQueryComment-10                              :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: An empty comment at the very beginning of an expression. :) (:*******************************************************:) (::) 1 eq 1
(:*******************************************************:) (: Test: K-XQueryComment-11                              :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: An empty comment after a function's paranteses. :) (:*******************************************************:) true()(::)
(:*******************************************************:) (: Test: K-XQueryComment-12                              :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: A for loop with a comment inbetween.         :) (:*******************************************************:) for (: set up loop :) $i in 3 return $i eq 3
(:*******************************************************:) (: Test: K-XQueryComment-13                              :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: A test whose essence is: `if((: comment inbetween :)) then 1 else 1`. :) (:*******************************************************:) if((: comment inbetween :)) then 1 else 1
(:*******************************************************:) (: Test: K-XQueryComment-14                              :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: A syntactically invalid comment that never ends. :) (:*******************************************************:) 1(: this comment does not end:
(:*******************************************************:) (: Test: K-XQueryComment-15                              :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: A comment inside a comment that isn't terminated. :) (:*******************************************************:) 1(: content (: this comment does not end :)
(:*******************************************************:) (: Test: K-XQueryComment-16                              :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: A comment inside a comment that does not start properly. :) (:*******************************************************:) 1(: content this comment does not start properly :) :)
(:*******************************************************:) (: Test: K-XQueryComment-17                              :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: Colons and paranteses appearing freely in comment content. :) (:*******************************************************:) 1(: ((( : )) ))ladl:  :(): ()()(dahsi ()()( dad: ) :) eq 1
(:*******************************************************:) (: Test: K-XQueryComment-18                              :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: Three comments appearing serially inside a comment. :) (:*******************************************************:) 1(: (:one comment:) content (:another comment:) content (:a third:):)    eq 1
(:*******************************************************:) (: Test: K-XQueryComment-19                              :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: A test stressing many nested comments.       :) (:*******************************************************:) 1(:(:(:(:(:(:(:(::):):):):):):):) eq 1
(:*******************************************************:) (: Test: K-XQueryComment-1                               :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: A test whose essence is: `(3(: comment inbetween :)- 1) eq 2`. :) (:*******************************************************:) (3(: comment inbetween :)- 1) eq 2
(:*******************************************************:) (: Test: K-XQueryComment-20                              :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: A syntactically invalid comment that doesn't properly start. :) (:*******************************************************:) : :) 1
(:*******************************************************:) (: Test: K-XQueryComment-2                               :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: A test whose essence is: `1 (: a (: nested :) comment :) eq 1`. :) (:*******************************************************:) 1 (: a (: nested :) comment :) eq 1
(:*******************************************************:) (: Test: K-XQueryComment-3                               :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: A test whose essence is: `1 (: comment (: inside :) comment :) eq 1`. :) (:*******************************************************:) 1 (: comment (: inside :) comment :) eq 1
(:*******************************************************:) (: Test: K-XQueryComment-4                               :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: Comparison of two string literals, whose content reminds of comments. :) (:*******************************************************:) "reminds of a comment :)" eq     "reminds of a comment :)"
(:*******************************************************:) (: Test: K-XQueryComment-5                               :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: A test whose essence is: `5 instance (: strange place for a comment :) of item()`. :) (:*******************************************************:) 5 instance (: strange place for a comment :) of item()
(:*******************************************************:) (: Test: K-XQueryComment-6                               :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: A test whose essence is: `1 (: simple comment :) eq 1`. :) (:*******************************************************:) 1 (: simple comment :) eq 1
(:*******************************************************:) (: Test: K-XQueryComment-7                               :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: A test whose essence is: `1 (: comment (: inside :) NEW LINE comment :) eq 1`. :) (:*******************************************************:) 1 (: comment (: inside :) NEW LINE comment :) eq 1
(:*******************************************************:) (: Test: K-XQueryComment-8                               :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: A test whose essence is: `(: "recursive comments must be balanced, this one is not :)" :)`. :) (:*******************************************************:) (: "recursive comments must be  balanced, this one is not :)" :)
(:*******************************************************:) (: Test: K-XQueryComment-9                               :) (: Written by: Frans Englich                             :) (: Date: 2007-11-22T11:31:22+01:00                       :) (: Purpose: An empty comment inbetween the 'eq' operator and a number literal. :) (:*******************************************************:) 1 eq (::)1
text {., .}
text(*)
text{}
text(1)
text {1,'',2}
text {1,<a/>,2}
text {1,'string',3.14,xs:float('1.2345e-2'),xs:dateTime('2002-04-02T12:00:00-01:00')}
text {<elem>123</elem>, (<elem attr='456'/>)/@attr, (<elem>789</elem>)/text()}
text{ "He said, ""I don't like it.""" }
text{ 'He said, "I don''t like it."' }
text {"name"} {"content"}
text name {"content"}
text {/root}
text {text {'one', text {'two'}}, 'three', text {'four'}}
"the cat sat on the mat"=>tokenize("\s+")=>count()
(:      This query opens a C++ GCC-XML output file, and outputs a report describing the use     of globals variables. :) declare variable $inputDocument := (/); (: Determines whether the type by ID @p typeId is a complex type such as QString. :) declare function local:isComplexType($typeID as xs:string) as xs:boolean {     (: We're being a bit crude here and only checks whether it's a class. We        actually should check whether it has non-synthesized,         constructors, I believe. :)          exists($inputDocument/xml/Class[@id = $typeID])     or     (: We also want const-qualified variables. :)     exists($inputDocument/xml/Class[@id = $inputDocument/xml/CvQualifiedType[@id = $typeID]/@type]) }; declare function local:isPrimitive($typeId as xs:string) as xs:boolean {     exists($inputDocument/xml/FundamentalType[@id = $typeId]) }; (: Returns a string for human consumption that describes    the location of @p block. :) declare function local:location($block as element()) as xs:string {     concat($inputDocument/xml/File[@id = $block/@file]/@name, " at line ", $block/@line) }; declare function local:report() as element()+ {             let $complexVariables as element(Variable)* := $inputDocument/xml/Variable[local:isComplexType(@type)]             return if(exists($complexVariables)) (: Is the length larger than zero? :)                    then (<p xmlns="http://www.w3.org/1999/xhtml/">The following global, complex variables were found:</p>,                          <ol xmlns="http://www.w3.org/1999/xhtml/">                             {                                 (: For each Variable in $complexVariables... :)                                 for $v in $complexVariables                                 return $v/<li><span class="variableName">{string(@name)}</span> in {local:location(.)}</li>                             }                          </ol>)                    else <p xmlns="http://www.w3.org/1999/xhtml/">No global variables that are of complex types were found.</p>             ,             (: List primitive, mutable types. :)             let $primitiveVariables as element(Variable)+ := $inputDocument/xml/Variable[local:isPrimitive(@type)]             return if(exists($primitiveVariables))                    then (<p xmlns="http://www.w3.org/1999/xhtml/">The following mutable primitives were found:</p>,                          <ol xmlns="http://www.w3.org/1999/xhtml/">                             {                                 (: For each Variable in $complexVariables... :)                                 for $v in $primitiveVariables                                 return $v/<li><span class="variableName">{string(@name)}</span> in {local:location(.)}</li>                             }                          </ol>)                    else <p xmlns="http://www.w3.org/1999/xhtml/">No global variables that are of complex types were found.</p> }; <html xmlns="http://www.w3.org/1999/xhtml/" xml:lang="en" lang="en">     <head>         <title>Global variables report for {"Globals.cpp"}</title>     </head>     <style type="text/css">         .details         {{             text-align: center;             font-size: 80%;             color: gray         }}         .variableName         {{             font-family: courier         }}     </style>     <body>         {             (: We don't want simple types that are const, but all other types.                One could frown upon const integers and say enums should be used instead, but                let's be gentle. :)             local:report()         }         <p class="details">This report was generated on</p>     </body> </html>
"this, that and the other"=>contains("the")
('Thy ' ||  () ||  'old ' ||  "groans" ||  "" ||  ' ring' ||  ' yet' ||  ' in' ||  ' my' ||  ' ancient' || ' ears.')
timezone-from-date()
timezone-from-date(()) instance of xs:dayTimeDuration?
timezone-from-dateTime()
timezone-from-dateTime(()) instance of xs:dayTimeDuration?
timezone-from-dateTime((), "Wrong param")
timezone-from-dateTime(xs:dateTime("2004-10-12T23:43:12-08:23")) eq xs:dayTimeDuration("-PT8H23M")
timezone-from-dateTime(xs:dateTime("2004-10-12T23:43:12Z")) eq xs:dayTimeDuration("PT0S")
(timezone-from-dateTime( xs:dateTime('2006-08-15T10:30:23')))
(timezone-from-dateTime( xs:dateTime('2006-08-15T10:30:23-05:00')))
(timezone-from-dateTime( xs:dateTime('2006-08-15T10:30:23-05:00')), timezone-from-dateTime( xs:dateTime('2006-08-15T10:30:23')))
timezone-from-date((), "Wrong param")
timezone-from-date(xs:date("2004-10-12-08:23")) eq xs:dayTimeDuration("-PT8H23M")
timezone-from-date(xs:date("2004-10-12Z")) eq xs:dayTimeDuration("PT0S")
(timezone-from-date( xs:date('2006-08-15')))
(timezone-from-date( xs:date('2006-08-15-05:00')))
(timezone-from-date( xs:date('2006-08-15-05:00')), timezone-from-date( xs:date('2006-08-15')))
timezone-from-time()
timezone-from-time(()) instance of xs:dayTimeDuration?
timezone-from-time((), "Wrong param")
(timezone-from-time( xs:time('09:54:00')))
(timezone-from-time( xs:time('09:54:00+05:00')))
(timezone-from-time( xs:time('09:54:00-05:00')))
(timezone-from-time( xs:time('09:54:00-05:00')), timezone-from-time( xs:time('09:54:00+05:00')), timezone-from-time( xs:time('09:54:00Z')), timezone-from-time( xs:time('09:54:00')))
(timezone-from-time( xs:time('09:54:00Z')))
timezone-from-time(xs:time("23:43:12.765-08:23")) eq xs:dayTimeDuration("-PT8H23M")
timezone-from-time(xs:time("23:43:12.765Z")) eq xs:dayTimeDuration("PT0S")
(tokenize( '2006-12-25T12:15:00', '[\-T:]'))
(tokenize( ' a b c '))
(tokenize( 'a b c'))
(tokenize( 'a,b,,c', ','))
(tokenize( 'a,b,c', ','))
(tokenize( 'a b c', '\s'))
(tokenize( 'a b c', '\s+'))
(tokenize( 'a, b, c', '[,\s]+'))
(tokenize( 'abc', '\s'))
(tokenize( 'a b c', '\s'), tokenize( 'a b c', '\s'), tokenize( 'a b c', '\s+'), tokenize( ' b c', '\s'), tokenize( 'a,b,c', ','), tokenize( 'a,b,,c', ','), tokenize( 'a, b, c', '[,\s]+'), tokenize( '2006-12-25T12:15:00', '[\-T:]'), tokenize( 'Hello, there.', '\W+'), tokenize( (), '\s+'), tokenize( 'abc', '\s'), tokenize( 'a,xb,xc', ',|,x'))
(tokenize( 'a,xb,xc', ',|,x'))
(tokenize( ' b c', '\s'))
(tokenize( 'Hello, there.', '\W+'))
(tokenize( (), '\s+'))
<top_section_count> { count(/book/section) } </top_section_count>
translate()
(translate('1999/01/02', '/', '-'))
(translate('1999/01/02', '/', '-'), translate('xml query', 'qlmx', 'QLMX'), translate('xml query', 'qlmx ', 'Q'), translate('xml query', 'qlmx ', ''), translate('xml query', 'abcd', 'ABCD'), translate('', 'qlmx ', 'Q'), translate((), 'qlmx ', 'Q'))
translate(1,'-','x')
translate("--aaa--","abc-","ABC") eq "AAA"
translate("--aaa--","bbb++","") eq "--aaa--"
translate("--aaa--","-","") eq "aaa"
translate('abc')
translate('abc',1,'x')
translate('---abcABCxyz---','-abcABCxyz','1ABCabcXYZ')
translate("abcdabc", "abc", "AB") eq "ABdAB"
translate("abcdef", "", "#")
translate("abcdef", "de", "#DE")
translate("abcdef", "def", "EF")
translate("abcd", "xa", "y")
translate("abcd", "a", "xy")
translate("abcde", "ae", "XYZ")
translate("abcde", "ae", "YZ")
translate('abc','x',1)
translate("abc&#x1D156;def", "def", "&#x1D156;EF")
translate("abc&#x1D156;def", "&#x1D156;", "#")
translate("abc&#x1D156;def", "&#x1D156;de", "#DE")
translate("arg", "map string", "transString", "wrong param")
translate("argstr", "", "matrs") eq "argstr"
translate("bar","abc","ABC") eq "BAr"
translate(codepoints-to-string(65536 to 65537),codepoints-to-string(65536 to 65537),"l")
translate((), "map", "trans") eq ""
translate('newline tab space ','  ','123')
(translate('', 'qlmx ', 'Q'))
(translate((), 'qlmx ', 'Q'))
translate("string", "map string")
translate('','-','x')
translate((),'-','x')
(translate('xml query', 'abcd', 'ABCD'))
(translate('xml query', 'qlmx ', ''))
(translate('xml query', 'qlmx ', 'Q'))
(translate('xml query', 'qlmx', 'QLMX'))
(true())
true()
true(1)
true() and count((1, 2, 3, timezone-from-time(current-time()), 4))
true() and false()
true() and true()
'true' castable as xs:boolean
'true' cast as xs:boolean eq true()
true() cast as xs:string eq "true"
true() cast as xs:untypedAtomic eq xs:untypedAtomic("true")
true() cast as xs:untypedAtomic instance of xs:untypedAtomic
true() eq (every $a in 1 satisfies $a)
true() eq (every $fn:name in (1, 2) satisfies $fn:name)
true() eq (every $xs:name in (1, 2) satisfies $xs:name)
true() eq (some $a in 1 satisfies $a)
true() eq (some $fn:name in (1, 2) satisfies $fn:name)
true() eq (some $xs:name in (1, 2) satisfies $xs:name)
true() eq true()
((true() eq true()) eq true()) eq true()
true() eq true() eq true() eq true()
true() ge false()
true() ge true()
true() gt false()
true() le true()
true() ne false()
true() or false()
true() or true()
(true() < true()) < true()
true() < true() < true()
((true() = true()) = true()) = true()
true() = true() = true() = true()
true() > xs:untypedAtomic("false")
true() >= xs:untypedAtomic("false")
(true() = xs:untypedAtomic("true"))
true() <= xs:untypedAtomic("true")
()("two")
typeswitch()
typeswitch (10)  case $i as xs:integer return 1  default $v return 0
typeswitch (1, 2, 3) case $i as node() return <e/> case xs:integer* return $i default return true()
typeswitch(123)          case $i as xs:string return <wrap>test failed</wrap>          case $i as xs:double return <wrap>test failed</wrap>          case $i as xs:anyURI return <wrap>test failed</wrap>          default return <wrap>test passed - 123 is an integer (not an option on any cases)</wrap>
typeswitch(123)          case $i as xs:string return <wrap>test failed</wrap>          case $i as xs:double return <wrap>test failed</wrap>          case $i as xs:integer return <wrap>test passed - If a dynamic error is generated, then test failed.</wrap>          default return 12 div 0
typeswitch (1, 2, 3) case node() return $i case $i as xs:integer return 1 default return true()
typeswitch (1, 2, 3) case node() return <e/> case $i as xs:integer return 1 default return $i
typeswitch (1, 2, 3) case node() return <e/> case $i as xs:integer return 3 default return 1, $i
typeswitch (1, 2, 3) case node() return <e/> case xs:integer* return $i default $i return 1
typeswitch (1, 2, 3) case node() return <e/> case xs:integer return 3 default $i as item() return 1
typeswitch (1, 2, 3) case node() return <e/> case xs:integer return 3 default $i return 1, $i
typeswitch (1, 2, 3) case node() return <e/> default $i return 1 , typeswitch (1, 2, 3) case xs:integer* return $i default return 1
(typeswitch(1, 2, 3) case xs:string+ return -1 case xs:integer+ return 1 default return -2) eq 1
typeswitch (1267.43233E12)          case $i as xs:string return <wrap>test failed</wrap>          case $i as xs:integer return <wrap>test failed</wrap>          case $i as xs:double return <wrap>test passed - 1267.43233E12 is a double type</wrap>          default return <wrap>test failed</wrap>
typeswitch(1 > 2) case $i as xs:string return <wrap>test failed</wrap>          case $i as xs:integer return <wrap>test failed</wrap>          case $i as xs:boolean return <wrap>test passed - 1 > 2 is a boolean type</wrap>          default return <wrap>test failed</wrap>
(typeswitch((1, 2)) case xs:integer return -1 case xs:integer+ return 1 default return -2) eq 1
(typeswitch(1, 2, current-time()) case element() return -1 case document-node() return -2 default return 1) eq 1
(typeswitch((1, "a string")) case xs:integer return -1 case xs:string return -2 case xs:anyAtomicType+ return 1 default return -3) eq 1
typeswitch (1)          case $i as xs:double return <wrap>test failed</wrap>          case $i as xs:integer return 10 div 2          case $i as xs:string return <wrap>test failed</wrap>          default return <wrap>test failed</wrap>
typeswitch (1)          case $i as xs:double return <wrap>test failed</wrap>          case $i as xs:integer return 10 idiv 2          case $i as xs:string return <wrap>test failed</wrap>          default return <wrap>test failed</wrap>
typeswitch (1)          case $i as xs:double return <wrap>test failed</wrap>          case $i as xs:integer return 5 * 2          case $i as xs:string return <wrap>test failed</wrap>          default return <wrap>test failed</wrap>
typeswitch (1)          case $i as xs:double return <wrap>test failed</wrap>          case $i as xs:integer return 5 - 3          case $i as xs:string return <wrap>test failed</wrap>          default return <wrap>test failed</wrap>
typeswitch (1)          case $i as xs:double return <wrap>test failed</wrap>          case $i as xs:integer return fn:count((1, 2, 3))          case $i as xs:string return <wrap>test failed</wrap>          default return <wrap>test failed</wrap>
typeswitch 1 case node() return 0 case xs:integer return 3 default return true()
(typeswitch(((1, current-time())[1])) case element() return -1 case xs:integer return 1 default return -2) eq 1
typeswitch ((1 to 10)[. mod 2 = 0]) case xs:integer+ return false() default return true()
typeswitch ((1 to 10)[. mod 2 = 0]) case xs:integer+ return true() default return true()
typeswitch (5.1)          case $i as xs:decimal return <wrap>test passed - 5.1 is a decimal type</wrap>          case $i as xs:float return <wrap>test failed</wrap>          case $i as xs:integer return <wrap>test failed</wrap>          case $i as xs:double return <wrap>test failed</wrap>          default return <wrap>test failed</wrap>
typeswitch (5.1)          case $i as xs:decimal return xs:decimal(1.1 + 3.1)          case $i as xs:float return <wrap>test failed</wrap>          case $i as xs:integer return <wrap>test failed</wrap>          case $i as xs:double return <wrap>test failed</wrap>          default return <wrap>test failed</wrap>
typeswitch (5.1E2)          case $i as xs:integer return <wrap>test failed2</wrap>          case $i as xs:double return <wrap>test passed - 5.1E2 is a double type</wrap>          default return <wrap>test failed</wrap>
typeswitch (5.1E2)          case $i as xs:integer return <wrap>test failed2</wrap>          case $i as xs:double return xs:double(5.1E2 + 1.1E2)          default return <wrap>test failed</wrap>
typeswitch (5)          case $i as xs:integer return <wrap>test passed - integer data type</wrap>          case $i as xs:date return <wrap>test failed</wrap>          case $i as xs:time return <wrap>test failed</wrap>          case $i as xs:string return <wrap>test failed</wrap>          default return <wrap>test failed</wrap>
typeswitch (5)          case $i as xs:integer return xs:integer(1 + 1)          case $i as xs:date return <wrap>test failed</wrap>          case $i as xs:time return <wrap>test failed</wrap>          case $i as xs:string return <wrap>test failed</wrap>          default return <wrap>test failed</wrap>
typeswitch ("A String")          case $i as xs:decimal return <wrap>test failed</wrap>          case $i as xs:integer return <wrap>test failed</wrap>          case $i as xs:string return <wrap>test passed - "A String" is a string type</wrap>          default return <wrap>test failed</wrap>
(typeswitch("a string") case xs:anyURI return -1 case xs:string return 1 default return -2) eq 1
(typeswitch("a string") case xs:untypedAtomic return -1 case xs:string return 1 default return -2) eq 1
typeswitch(current-time()) case node() return 0 case xs:integer return 3 case xs:anyAtomicType return true()
typeswitch (<e/>)   case xs:integer | xs:string return 1  default $v return 0
typeswitch(fn:true() and fn:true())          case $i as xs:string return <wrap>test failed</wrap>          case $i as xs:double return <wrap>test failed</wrap>          case $i as xs:boolean return <wrap>test passed - "fn:true() and fn:true()" should evaluate to boolean type</wrap>          default return <wrap>test failed</wrap>
typeswitch(fn:true() or fn:false())          case $i as xs:string return <wrap>test failed</wrap>          case $i as xs:double return <wrap>test failed</wrap>          case $i as xs:boolean return <wrap>test passed - "fn:true() or fn:false()" should evaluate to boolean type</wrap>          default return <wrap>test failed</wrap>
typeswitch(if (1 lt 2) then 3 else 4.5E4)          case $i as xs:string return <wrap>test failed</wrap>          case $i as xs:double return <wrap>test failed</wrap>          case $i as xs:integer return <wrap>test passed - "(1 lt 2) then 3 else 4.5E4" should evaluate to an integer</wrap>          default return <wrap>test failed</wrap>
typeswitch(xs:anyURI("http://example.com"))          case $i as xs:string return <wrap>test failed</wrap>          case $i as xs:integer return <wrap>test failed</wrap>          case $i as xs:anyURI return <wrap>test passed - xs:anyURI("http://www.example.com")is of anyURI type</wrap>          default return <wrap>test failed</wrap>
typeswitch(xs:date("1999-05-31"))          case $i as xs:string return <wrap>test failed</wrap>          case $i as xs:integer return <wrap>test failed</wrap>          case $i as xs:date return <wrap>test passed - xs:date("1999-05-31")is of date type</wrap>          default return <wrap>test failed</wrap>
typeswitch(xs:dateTime("1999-12-31T19:20:00"))          case $i as xs:string return <wrap>test failed</wrap>          case $i as xs:integer return <wrap>test failed</wrap>          case $i as xs:dateTime return <wrap>test passed - xs:dateTime("1999-12-31T19:20:00")is of dateTime type</wrap>          default return <wrap>test failed</wrap>
typeswitch (xs:error(1))              case xs:error return fn:true()             default return false()
typeswitch(xs:time("12:00:00"))          case $i as xs:string return <wrap>test failed</wrap>          case $i as xs:integer return <wrap>test failed</wrap>          case $i as xs:time return <wrap>test passed - xs:time("12:00:00")is of time type</wrap>          default return <wrap>test failed</wrap>
('un' ||  'grateful')
@unknownprefix:*
unknownprefix:*
unordered()
unordered(1, 2)
unordered(1) eq 1
unparsed-entity-public-id("entity")
unparsed-entity-public-id("str")
unparsed-entity-uri("example.com/file.ext")
unparsed-entity-uri("str")
"untyped a " cast as xs:untypedAtomic eq xs:untypedAtomic("untyped a ")
upper-case()
upper-case("abCd0") eq "ABCD0"
upper-case(()) eq ""
(upper-case('query'))
(upper-case('Query'))
(upper-case('QUERY'))
(upper-case('query-123'))
(upper-case('query'), upper-case('QUERY'), upper-case('Query'), upper-case('query-123'))
upper-case("string", "wrong param")
upper-case(typeswitch ((1 to 10)[. div 2 = 0]) case xs:integer+ return "int" default return "false")
upper-case(typeswitch ((1 to 10)[. mod 2 = 0]) case xs:integer+ return "int" default return "false")
validate { }
validate lax { }
validate strict { }
<?validchar content a b c asdada dad ?> eq "content a b c asdada dad "
<?validchar content ?> eq "content "
<?validchar ???<<???? <? >?hm???> eq "???<<???? <? >?hm??"
variable lt variable
" white space left alone" cast as xs:string eq xs:string(" white space left alone")
(/works[1]/employee[11]/following::employee[1]) << (/works[1]/employee[13])
(/works[1]/employee[12]/following::employee) and fn:false()
(/works[1]/employee[12]/following::employee) and fn:true()
(/works[1]/employee[12]/following::employee) or fn:false()
(/works[1]/employee[12]/following::employee) or fn:true()
(/works[1]/employee[12]/following-sibling::employee) and fn:false()
(/works[1]/employee[12]/following-sibling::employee) and fn:true()
(/works[1]/employee[12]/following-sibling::employee) or fn:false()
(/works[1]/employee[12]/following-sibling::employee) or fn:true()
(/works[1]/employee[12]/overtime[1]/day[1]/following::day) intersect (/works[1]/employee[12]/overtime[1]/day[1]/following::day)
(/works[1]/employee[12]/overtime[1]/day[1]/following-sibling::day) intersect (/works[1]/employee[12]/overtime[1]/day[1]/following-sibling::day)
(/works[1]/employee[12]/overtime[1]/day[2]/preceding::day) intersect (/works[1]/employee[12]/overtime[1]/day[2]/preceding::day)
(/works[1]/employee[12]/overtime[1]/day[2]/preceding-sibling::day) intersect (/works[1]/employee[12]/overtime[1]/day[2]/preceding-sibling::day)
(/works[1]/employee[12]/overtime/day) except (/works[1]/employee[12]/overtime/day[1]/following::day)
(/works[1]/employee[12]/overtime/day) except (/works[1]/employee[12]/overtime/day[1]/following-sibling::day)
(/works[1]/employee[12]/overtime/day) except (/works[1]/employee[12]/overtime/day[2]/preceding::day)
(/works[1]/employee[12]/overtime/day) except (/works[1]/employee[12]/overtime/day[2]/preceding-sibling::day)
(/works[1]/employee[12]/preceding::employee) and fn:false()
(/works[1]/employee[12]/preceding::employee) and fn:true()
(/works[1]/employee[12]/preceding::employee) or fn:false()
(/works[1]/employee[12]/preceding::employee) or fn:true()
(/works[1]/employee[12]/preceding-sibling::employee) and fn:false()
(/works[1]/employee[12]/preceding-sibling::employee) and fn:true()
(/works[1]/employee[12]/preceding-sibling::employee) or fn:false()
(/works[1]/employee[12]/preceding-sibling::employee) or fn:true()
/works[1]/employee[1]/empnum[1] << <a>50000</a>
/works[1]/employee[1]/empnum[1] >> <a>50000</a>
/works[1]/employee[1]/empnum[1] is <a>50000</a>
/works[1]/employee[1]/empnum[1] is /works[1]/employee[1]/empnum[1]
/works[1]/employee[1]/empnum[1] << /works[1]/employee[1]/empnum[1]
/works[1]/employee[1]/empnum[1] >> /works[1]/employee[1]/empnum[1]
/works[1]/employee[2]/preceding::employee
(/works[1]//employee[empnum != "E1" and empnum != "E4"])
(/works//day[xs:string(.) ne "Monday"])
./works/employee[1]
works/employee[1]
((/works/employee[12]/*/day[1]/ancestor-or-self::overtime) | (/works/employee[12]/*/day[2]/ancestor-or-self::overtime))/count(*)
(/works/employee[12]/*/day[1]/ancestor::overtime) | (/works/employee[12]/*/day[2]/ancestor::overtime)
(/works/employee[12]/*/day[1]/following::day) | (/works/employee[12]/*/day[1])
(/works/employee[12]/*/day[1]/following::day) | (/works/employee[12]/*/day[1]/following::day)
(/works/employee[12]/*/day[1]/following-sibling::day) | (/works/employee[12]/*/day[1])
(/works/employee[12]/*/day[1]/following-sibling::day) | (/works/employee[12]/*/day[1]/following-sibling::day)
(/works/employee[12]/*/day[2]/preceding::day) | (/works/employee[12]/*/day[2])
(/works/employee[12]/*/day[2]/preceding::day) | (/works/employee[12]/*/day[2]/preceding::day)
(/works/employee[12]/*/day[2]/preceding-sibling::day) | (/works/employee[12]/*/day[2])
(/works/employee[12]/*/day[2]/preceding-sibling::day) | (/works/employee[12]/*/day[2]/preceding-sibling::day)
((/works/employee[12]/*/day/ancestor-or-self::overtime) | (/works/employee[12]/*/day/ancestor-or-self::overtime))/count(*)
(/works/employee[12]/*/day/ancestor::overtime) | (/works/employee[12]/*/day/ancestor::overtime)
(/works/employee[12]/overtime/day/ancestor::employee) intersect (/works/employee[12]/overtime/day/ancestor::employee)
((/works/employee[12]/overtime/day/ancestor-or-self::employee) intersect (/works/employee[12]/overtime/day/ancestor-or-self::employee))/@name
(/works/employee[12]/overtime/day[ancestor-or-self::overtime]) and fn:false()
(/works/employee[12]/overtime/day[ancestor-or-self::overtime]) and fn:true()
(/works/employee[12]/overtime/day[ancestor-or-self::overtime]) except (/works/employee[12]/overtime/day[1])
(/works/employee[12]/overtime/day[ancestor-or-self::overtime]) or fn:false()
(/works/employee[12]/overtime/day[ancestor-or-self::overtime]) or fn:true()
(/works/employee[12]/overtime/day[ancestor::overtime]) and fn:false()
(/works/employee[12]/overtime/day[ancestor::overtime]) and fn:true()
(/works/employee[12]/overtime/day[ancestor::overtime]) except (/works/employee[12]/overtime/day[1])
(/works/employee[12]/overtime/day[ancestor::overtime]) or fn:false()
(/works/employee[12]/overtime/day[ancestor::overtime]) or fn:true()
() != (/works/employee[1]/hours[1])
() < (/works/employee[1]/hours[1])
() <= (/works/employee[1]/hours[1])
() = (/works/employee[1]/hours[1])
() > (/works/employee[1]/hours[1])
() >= (/works/employee[1]/hours[1])
(/works/employee[1]/hours[1]) != ()
(/works/employee[1]/hours[1]) < ()
(/works/employee[1]/hours[1]) <= ()
(/works/employee[1]/hours[1]) = ()
(/works/employee[1]/hours[1]) > ()
(/works/employee[1]/hours[1]) >= ()
(/works/employee[1]/hours[1]) != 10000
(/works/employee[1]/hours[1]) < 10000
(/works/employee[1]/hours[1]) <= 10000
(/works/employee[1]/hours[1]) = 10000
(/works/employee[1]/hours[1]) > 10000
(/works/employee[1]/hours[1]) >= 10000
(/works/employee[1]/hours[1]) != (10000,50000)
(/works/employee[1]/hours[1]) < (10000,50000)
(/works/employee[1]/hours[1]) <= (10000,50000)
(/works/employee[1]/hours[1]) = (10000,50000)
(/works/employee[1]/hours[1]) > (10000,50000)
(/works/employee[1]/hours[1]) >= (10000,50000)
(/works/employee[1]/hours[1]) != (50000)
(/works/employee[1]/hours[1]) < (50000)
(/works/employee[1]/hours[1]) <= (50000)
(/works/employee[1]/hours[1]) = (50000)
(/works/employee[1]/hours[1]) > (50000)
(/works/employee[1]/hours[1]) >= (50000)
(/works/employee[1]/hours[1]) != (<a>10000</a>)
(/works/employee[1]/hours[1]) != <a>10000</a>
(/works/employee[1]/hours[1]) < (<a>10000</a>)
(/works/employee[1]/hours[1]) < <a>10000</a>
(/works/employee[1]/hours[1]) <= (<a>10000</a>)
(/works/employee[1]/hours[1]) <= <a>10000</a>
(/works/employee[1]/hours[1]) = (<a>10000</a>)
(/works/employee[1]/hours[1]) = <a>10000</a>
(/works/employee[1]/hours[1]) > (<a>10000</a>)
(/works/employee[1]/hours[1]) > <a>10000</a>
(/works/employee[1]/hours[1]) >= (<a>10000</a>)
(/works/employee[1]/hours[1]) >= <a>10000</a>
(/works/employee[1]/hours[1]) != (<a>10000</a>,<b>50000</b>)
(/works/employee[1]/hours[1]) < (<a>10000</a>,<b>50000</b>)
(/works/employee[1]/hours[1]) <= (<a>10000</a>,<b>50000</b>)
(/works/employee[1]/hours[1]) = (<a>10000</a>,<b>50000</b>)
(/works/employee[1]/hours[1]) > (<a>10000</a>,<b>50000</b>)
(/works/employee[1]/hours[1]) >= (<a>10000</a>,<b>50000</b>)
(/works/employee[1]/hours[1]) != (/works/employee[1]/hours[1])
(/works/employee[1]/hours[1]) < (/works/employee[1]/hours[1])
(/works/employee[1]/hours[1]) <= (/works/employee[1]/hours[1])
(/works/employee[1]/hours[1]) = (/works/employee[1]/hours[1])
(/works/employee[1]/hours[1]) > (/works/employee[1]/hours[1])
(/works/employee[1]/hours[1]) >= (/works/employee[1]/hours[1])
(/works/employee[1]/hours[1]) != (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(/works/employee[1]/hours[1]) < (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(/works/employee[1]/hours[1]) <= (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(/works/employee[1]/hours[1]) = (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(/works/employee[1]/hours[1]) > (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(/works/employee[1]/hours[1]) >= (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
() != (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
() < (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
() <= (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
() = (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
() > (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
() >= (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) != ()
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) < ()
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) <= ()
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) = ()
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) > ()
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) >= ()
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) != 10000
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) < 10000
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) <= 10000
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) = 10000
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) > 10000
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) >= 10000
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) != (10000,50000)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) < (10000,50000)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) <= (10000,50000)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) = (10000,50000)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) > (10000,50000)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) >= (10000,50000)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) != (50000)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) < (50000)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) <= (50000)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) = (50000)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) > (50000)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) >= (50000)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) != (<a>10000</a>)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) != <a>10000</a>
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) < (<a>10000</a>)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) < <a>10000</a>
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) <= (<a>10000</a>)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) <= <a>10000</a>
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) = (<a>10000</a>)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) = <a>10000</a>
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) > (<a>10000</a>)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) > <a>10000</a>
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) >= (<a>10000</a>)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) >= <a>10000</a>
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) != (<a>10000</a>,<b>50000</b>)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) < (<a>10000</a>,<b>50000</b>)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) <= (<a>10000</a>,<b>50000</b>)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) = (<a>10000</a>,<b>50000</b>)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) > (<a>10000</a>,<b>50000</b>)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) >= (<a>10000</a>,<b>50000</b>)
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) != (/works/employee[1]/hours[1])
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) < (/works/employee[1]/hours[1])
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) <= (/works/employee[1]/hours[1])
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) = (/works/employee[1]/hours[1])
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) > (/works/employee[1]/hours[1])
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) >= (/works/employee[1]/hours[1])
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) != (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) < (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) <= (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) = (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) > (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
(/works/employee[1]/hours[1],/works/employee[6]/hours[1]) >= (/works/employee[1]/hours[1],/works/employee[6]/hours[1])
/ works ! employee[2] ! hours[2] ! number()
(/works/employee[2], /works/employee[1], /works/employee[2]) ! @name ! string()
/ works ! employee[4] ! preceding-sibling::*[1] ! string(@name)
/works/employee[5]/hours[2]
/works/employee/*/last()
(/works/employee[@name="Jane Doe 11"])
/works/employee[@name=/works/employee[1]/@name]/@name/string()
/works/employee/*/position()
(/works/employee[xs:integer(hours[1]) gt 20])
(/works//hours[xs:integer(.) <= 12])
(/works//hours[xs:integer(.) = 12])
(/works//hours[xs:integer(.) < 13])
(/works//hours[xs:integer(.) > 79])
(/works//hours[xs:integer(.) >= 80])
(/works//hours[xs:integer(.) ge 80])
(/works//hours[xs:integer(.) gt 79])
(/works//hours[xs:integer(.) le 12])
(/works//hours[xs:integer(.) lt 13])
works/@id eq "abc"
works/@id ne "abc"
'&#x;'
'&#x0;'
"&#x00;"
'&#x100000000'
'&#x100000000x'
"&#x+20;"
"&#x-20;"
"&#X4A;"
"&#x9;" castable as xs:normalizedString
"&#x9;" castable as xs:token
"&#xD;&#xA;&#x9; foobar &#xA;&#xD;&#x9;" castable as xs:NMTOKEN
<XMark-result-Q15> {              let $auction := (/) return              for $a in $auction/site/closed_auctions/closed_auction/annotation/description/parlist/                 listitem/ parlist/ listitem/ text/ emph/ keyword/ text()              return <text>{$a}</text> } </XMark-result-Q15>
<XMark-result-Q17> {              let $auction := (/)              return for $p in $auction/site/people/person              where empty($p/homepage/text())              return <person name="{$p/name/text()}"/> } </XMark-result-Q17>
<XMark-result-Q1> {              let $auction := (/)             return for $b in $auction/site/people/person[@id = "person0"]              return $b/name/text() } </XMark-result-Q1>
<XMark-result-Q20> {              let $auction := (/) return                 <result>                    <preferred> {count($auction/site/people/person/profile[@income >= 100000.0])} </preferred>                   <standard> { count( $auction/site/people/person/ profile[@income < 100000.0 and @income >= 30000.0] ) } </standard>                   <challenge> {count($auction/site/people/person/profile[@income < 30000.0])} </challenge>                   <na> { count( for $p in $auction/site/people/person where empty($p/profile/@income) return $p ) } </na>                </result> } </XMark-result-Q20>
<XMark-result-Q2> {              let $auction := (/)              return for $b in $auction/site/open_auctions/open_auction              return <increase>{$b/bidder[1]/increase/text()}</increase> } </XMark-result-Q2>
<XMark-result-Q5> {            let $auction := (/) return count(             for $i in $auction/site/closed_auctions/closed_auction              where $i/price/text() >= 40.0 return $i/price) }          </XMark-result-Q5>
<XMark-result-Q6> {              let $auction := (/) return for $b in $auction//site/regions return count($b//item) }          </XMark-result-Q6>
<XMark-result-Q7> { let $auction := (/) return for $p in $auction/site return count($p//description) + count($p//annotation) + count($p//emailaddress) } </XMark-result-Q7>
<?xml ?>
<?xml?>
<?xMl?>
<?XmL ?>
<?XmL?>
<?XML ?>
<?XML?>
<?xml:char ?>
<xml:new/>
@xmlns:*
xmlns:*
@xmlns:ncname
xmlns:ncname
xquery encoding "utf-8"; 1 eq 1
xquery encoding "utf-8" version "3.0"; 1
xquery gt xquery
xquery version; 1
xquery version "1.0"; <bib/>
"xquery version '1.0' encoding 'UTF-8|#%';" eq "xquery version '1.0' encoding 'UTF-8|#%';"
'xquery version "1.0" encoding "UTF-8|#%";' eq 'xquery version "1.0" encoding "UTF-8|#%";'
xquery version "1.0" (:encoding "utf-8xx":); 1,2
xquery version '1.0' encoding 'UTF&#x2d;8'; true()
xquery version '1&#x2e;0' encoding 'UTF-8'; true()
xquery version "2.0"; 1.2
xquery version "3.0"; 1,2
xquery version "3.0" ; 1 eq 1
xquery version "3.0"; <bib/>
xquery version "3.0";        declare function local:square($i as xs:integer) as xs:integer { $i*$i };         function-lookup(QName("http://www.w3.org/2005/xquery-local-functions", "square"), 1)(13)
xquery version "3.0";        declare %private function local:square($i as xs:integer) as xs:integer { $i*$i };         function-lookup(QName("http://www.w3.org/2005/xquery-local-functions", "square"), 1)(13)
xquery version "3.0";        declare %private function local:square($i as xs:integer) as xs:integer { $i*$i };         function-lookup(QName("http://www.w3.org/2005/xquery-local-functions", "square"), 1)(13, 12)
xquery version "3.0";        declare %private function local:square($i as xs:integer) as xs:integer { $i*$i };         function-lookup(QName("http://www.w3.org/2005/xquery-local-functions", "square"), 1)("banana")
xquery version "3.0" default; 1
xquery version "3.0" encoding "US-ASCII"; 1,2
xquery version "3.0" encoding "utf-8"; 1,2
xquery version "3.1"; 1,2
xquery version "3.1" ; 1 eq 1
xquery version "3.1"; <bib/>
xquery, version, encoding, default, declare, function, option, collation, schema, import
xs:anyAtomic("1")
xs:anyURI("")
xs:anyURI(())
xs:anyURI()
xs:anyURI("0") < 1
xs:anyURI("2") > 1
xs:anyURI("") eq xs:anyURI("")
(xs:anyURI("example.com/"), 1, QName("example.com", "ncname"), false(), xs:hexBinary("FF")) = (xs:anyURI("example.com/NOT"), 0, QName("example.com", "p:ncname"), true(), xs:hexBinary("EF"))
xs:anyURI("example.com/") and xs:anyURI("example.com/")
xs:anyURI("example.com/") cast as xs:anyURI eq xs:anyURI('example.com/')
xs:anyURI("example.com/") eq xs:anyURI("example.com/")
xs:anyURI("example.com/") eq xs:string("example.com/")
xs:anyURI("example.com/") eq xs:untypedAtomic("example.com/")
xs:anyURI("example.com/") != false()
xs:anyURI("example.com/") = false()
xs:anyURI("example.com/") ne xs:anyURI("example.com/No")
xs:anyURI("example.com/") ne xs:string("example.com/No")
xs:anyURI("example.com/") ne xs:untypedAtomic("example.com/No")
xs:anyURI("example.com/") or 0
xs:anyURI("foo://")
xs:anyURI("http://!$&'()*+,;=/")
xs:anyURI("http://!$&amp;'()*+,;=/")
xs:anyURI("http://%0Ad%E2%9C%90%F0%98%9A%A0/")
xs:anyURI("http://example.com/A") eq xs:anyURI("http://example.com/A")
xs:anyURI("http://example.com/A") eq xs:string("http://example.com/A")
xs:anyURI("http://example.com/A") le xs:anyURI("http://example.com/A")
xs:anyURI("http://example.com/A") le xs:anyURI("http://example.com/B")
xs:anyURI("http://example.com/A") lt xs:anyURI("http://example.com/B")
xs:anyURI("http://example.com/A") ne xs:anyURI("http://example.com/B")
xs:anyURI("http://example.com/A") ne xs:string("http://example.com/B")
xs:anyURI("http://example.com/B") ge xs:anyURI("http://example.com/A")
xs:anyURI("http://example.com/B") gt xs:anyURI("http://example.com/A")
xs:anyURI("http://example.com/B") gt xs:string("http://example.com/A")
xs:anyURI(" http://example.com/ foo.xml ")
xs:anyURI("http:\\invalid>URI\someURI")
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:anyURI
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:string
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") castable as xs:untypedAtomic
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:anyURI eq xs:anyURI("http://www.example.com/an/arbitrary/URI.ext")
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:base64Binary
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:boolean
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:date
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:dateTime
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:dayTimeDuration
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:decimal
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:double
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:duration
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:float
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:gDay
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:gMonth
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:gMonthDay
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:gYear
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:gYearMonth
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:hexBinary
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:integer
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:string ne xs:string("an arbitrary string")
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:time
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:untypedAtomic       ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:anyURI("http://www.example.com/an/arbitrary/URI.ext") cast as xs:yearMonthDuration
xs:anyURI(" http://www.example.com/an/arbitrary/URI.ext ") eq xs:anyURI(" http://www.example.com/an/arbitrary/URI.ext ")
xs:anyURI( "http://www.example.com/an/arbitrary/URI.ext" , "http://www.example.com/an/arbitrary/URI.ext" )
xs:anyURI("http://www.example.com") instance of xs:anyURI
xs:anyURI("http://www.example.com/") instance of xs:anyURI
xs:anyURI("http://www.example.com") instance of xs:boolean
xs:anyURI("http://www.example.com") instance of xs:date
xs:anyURI("http://www.example.com") instance of xs:dateTime
xs:anyURI("http://www.example.com") instance of xs:decimal
xs:anyURI("http://www.example.com") instance of xs:double
xs:anyURI("http://www.example.com") instance of xs:float
xs:anyURI("http://www.example.com") instance of xs:int
xs:anyURI("http://www.example.com") instance of xs:integer
xs:anyURI("http://www.example.com") instance of xs:string
xs:anyURI("http://www.example.com") instance of xs:time
(xs:anyURI("http://www.example.com"),xs:anyURI("http://www.example1.com"))
(xs:anyURI("http://www.example/com")) < (xs:anyURI("http://www.example/com"))
(xs:anyURI("http://www.example/com")) <= (xs:anyURI("http://www.example/com"))
(xs:anyURI("http://www.example/com")) > (xs:anyURI("http://www.example/com"))
(xs:anyURI("http://www.example/com")) >= (xs:anyURI("http://www.example/com"))
xs:anyURI("http://www.example.org/#:@")
xs:anyURI("http://www.example.org/:/@/")
xs:anyURI("http://www.example.org/?:@")
xs:anyURI("http://www.example.org/!/$/&/'/(/)/*/+/,/;/=/")
xs:anyURI("http://www.example.org/#!$&'()*+,;=")
xs:anyURI("http://www.example.org/?!$&'()*+,;=")
xs:anyURI("http://www.example.org/#!$&amp;'()*+,;=")
xs:anyURI("http://www.example.org/?!$&amp;'()*+,;=")
xs:anyURI("http://www.example.org/!/$/&amp;/'/(/)/*/+/,/;/=/")
xs:anyURI("http://www.example.org/#%0Ad%E2%9C%90%F0%98%9A%A0/")
xs:anyURI("http://www.example.org/%0Ad%E2%9C%90%F0%98%9A%A0/")
xs:anyURI("http://www.example.org/?%0Ad%E2%9C%90%F0%98%9A%A0/")
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:anyURI
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:base64Binary
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:boolean
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:date
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:dateTime
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:dayTimeDuration
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:decimal
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:double
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:duration
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:float
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:gDay
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:gMonth
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:gMonthDay
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:gYear
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:gYearMonth
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:hexBinary
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:integer
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:string
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:time
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:untypedAtomic
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:yearMonthDuration
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:anyURI
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:base64Binary
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:boolean
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:date
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:dateTime
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:dayTimeDuration
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:decimal
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:double
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:duration
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:float
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:gDay
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:gMonth
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:gMonthDay
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:gYear
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:gYearMonth
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:hexBinary
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:integer
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:string
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:time
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:untypedAtomic
xs:anyURI("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:yearMonthDuration
xs:anyURI("odd-scheme+1.://www.example.org/")
xs:anyURI("//server/share/dir1")
xs:anyURI("www.example.com") , xs:decimal("1.01")
xs:anyURI(xs:untypedAtomic( "http://www.example.com/an/arbitrary/URI.ext" ))        eq xs:anyURI("http://www.example.com/an/arbitrary/URI.ext")
xs:base64Binary("")
xs:base64Binary()
xs:base64Binary("00000000") castable as xs:hexBinary
xs:base64Binary("00000000") cast as xs:hexBinary
xs:base64Binary("01001010") castable as xs:base64Binary
xs:base64Binary("01001010") castable as xs:string
xs:base64Binary("01001010") castable as xs:untypedAtomic
xs:base64Binary("01001010") cast as xs:base64Binary
xs:base64Binary("01001010") cast as xs:string
xs:base64Binary("01001010") cast as xs:untypedAtomic
xs:base64Binary("0FB7") castable as xs:base64Binary
xs:base64Binary("0FB7") castable as xs:hexBinary
xs:base64Binary("0FB7") castable as xs:string
xs:base64Binary("0FB7") castable as xs:untypedAtomic
xs:base64Binary("0FB7") cast as xs:base64Binary
xs:base64Binary("0FB7") cast as xs:hexBinary
xs:base64Binary("0FB7") cast as xs:string
xs:base64Binary("0FB7") cast as xs:untypedAtomic
xs:base64Binary("10010101") castable as xs:anyURI
xs:base64Binary("10010101") castable as xs:boolean
xs:base64Binary("10010101") castable as xs:date
xs:base64Binary("10010101") castable as xs:dateTime
xs:base64Binary("10010101") castable as xs:dayTimeDuration
xs:base64Binary("10010101") castable as xs:decimal
xs:base64Binary("10010101") castable as xs:double
xs:base64Binary("10010101") castable as xs:duration
xs:base64Binary("10010101") castable as xs:float
xs:base64Binary("10010101") castable as xs:gDay
xs:base64Binary("10010101") castable as xs:gMonth
xs:base64Binary("10010101") castable as xs:gMonthDay
xs:base64Binary("10010101") castable as xs:gYear
xs:base64Binary("10010101") castable as xs:gYearMonth
xs:base64Binary("10010101") castable as xs:hexBinary
xs:base64Binary("10010101") castable as xs:integer
xs:base64Binary("10010101") castable as xs:time
xs:base64Binary("10010101") castable as xs:yearMonthDuration
xs:base64Binary("10010101") cast as xs:anyURI
xs:base64Binary("10010101") cast as xs:boolean
xs:base64Binary("10010101") cast as xs:date
xs:base64Binary("10010101") cast as xs:dateTime
xs:base64Binary("10010101") cast as xs:dayTimeDuration
xs:base64Binary("10010101") cast as xs:decimal
xs:base64Binary("10010101") cast as xs:double
xs:base64Binary("10010101") cast as xs:duration
xs:base64Binary("10010101") cast as xs:float
xs:base64Binary("10010101") cast as xs:gDay
xs:base64Binary("10010101") cast as xs:gMonth
xs:base64Binary("10010101") cast as xs:gMonthDay
xs:base64Binary("10010101") cast as xs:gYear
xs:base64Binary("10010101") cast as xs:gYearMonth
xs:base64Binary("10010101") cast as xs:hexBinary
xs:base64Binary("10010101") cast as xs:integer
xs:base64Binary("10010101") cast as xs:time
xs:base64Binary("10010101") cast as xs:yearMonthDuration
xs:base64Binary( "aaaa" , "aaaa" )
xs:base64Binary("aaaa") castable as xs:base64Binary
xs:base64Binary("aaaa") castable as xs:hexBinary
xs:base64Binary("aaaa") castable as xs:string
xs:base64Binary("aaaa") castable as xs:untypedAtomic
xs:base64Binary("aaaa") cast as xs:anyURI
xs:base64Binary("aaaa") cast as xs:base64Binary eq xs:base64Binary("aaaa")
xs:base64Binary("aaaa") cast as xs:boolean
xs:base64Binary("aaaa") cast as xs:date
xs:base64Binary("aaaa") cast as xs:dateTime
xs:base64Binary("aaaa") cast as xs:dayTimeDuration
xs:base64Binary("aaaa") cast as xs:decimal
xs:base64Binary("aaaa") cast as xs:double
xs:base64Binary("aaaa") cast as xs:duration
xs:base64Binary("aaaa") cast as xs:float
xs:base64Binary("aaaa") cast as xs:gDay
xs:base64Binary("aaaa") cast as xs:gMonth
xs:base64Binary("aaaa") cast as xs:gMonthDay
xs:base64Binary("aaaa") cast as xs:gYear
xs:base64Binary("aaaa") cast as xs:gYearMonth
xs:base64Binary("aaaa") cast as xs:hexBinary ne xs:hexBinary("0FB7")
xs:base64Binary("aaaa") cast as xs:integer
xs:base64Binary("aaaa") cast as xs:string ne xs:string("an arbitrary string")
xs:base64Binary("aaaa") cast as xs:time
xs:base64Binary("aaaa") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:base64Binary("aaaa") cast as xs:yearMonthDuration
xs:base64Binary(" aaaa ") eq xs:base64Binary(" aaaa ")
xs:base64Binary("aA+zZ/09") castable as xs:hexBinary
xs:base64Binary("AP9=")
xs:base64Binary("=AQI")
xs:base64Binary("AQ=I")
xs:base64Binary("AQI")
xs:base64Binary("Ay==")
xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") eq xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q")
xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") eq xs:base64Binary("cW9kanZzY3ZlaWthYXVreGxibm11dW91ZmllZGplbXZza2FqcGlwdWlxcG5xbHR4dmFjcWFjbGN1Z3BqYmVuZWhsdHhzeHZs")
xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") eq xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp")
(xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") eq xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp")) and fn:false()
(xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") eq xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp")) and fn:true()
(xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") eq xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp")) and (xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") eq xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp"))
(xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") eq xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp")) or fn:false()
(xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") eq xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp")) or fn:true()
xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") eq xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp") or xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") eq xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp")
xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") ne xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q")
xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") ne xs:base64Binary("cW9kanZzY3ZlaWthYXVreGxibm11dW91ZmllZGplbXZza2FqcGlwdWlxcG5xbHR4dmFjcWFjbGN1Z3BqYmVuZWhsdHhzeHZs")
xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") ne xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp")
(xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") ne xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp")) and fn:false()
(xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") ne xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp")) and fn:true()
(xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") ne xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp")) or fn:false()
(xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") ne xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp")) or fn:true()
(xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") ne xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp")) or (xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q") ne xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp"))
xs:base64Binary(codepoints-to-string((119070, 119070, 119070, 119070) (:treble clef:)))
xs:base64Binary("cW9kanZzY3ZlaWthYXVreGxibm11dW91ZmllZGplbXZza2FqcGlwdWlxcG5xbHR4dmFjcWFjbGN1Z3BqYmVuZWhsdHhzeHZs") eq xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q")
xs:base64Binary("cW9kanZzY3ZlaWthYXVreGxibm11dW91ZmllZGplbXZza2FqcGlwdWlxcG5xbHR4dmFjcWFjbGN1Z3BqYmVuZWhsdHhzeHZs") ne xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q")
xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp") eq xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q")
xs:base64Binary("d2J1bnB0Y3lucWtvYXdpb2xoZWNwZXlkdG90eHB3ZXJqcnliZXFubmJjZXBmbGx3aGN3cmNndG9xb2hvdHdlY2pzZ3h5bnlp") ne xs:base64Binary("cmxjZ3R4c3JidnllcmVuZG91aWpsbXV5Z2NhamxpcmJkaWFhbmFob2VsYXVwZmJ1Z2dmanl2eHlzYmhheXFtZXR0anV2dG1q")
xs:base64Binary("") eq xs:base64Binary("")
xs:base64Binary("frfhforlksid745323==")
xs:base64Binary("gMA-")
xs:base64Binary("qrvM====")
xs:base64Binary(xs:hexBinary(""))
xs:base64Binary(xs:hexBinary("00"))
xs:base64Binary(xs:hexBinary("0000"))
xs:base64Binary(xs:hexBinary("00ff"))
xs:base64Binary(xs:hexBinary("01"))
xs:base64Binary(xs:hexBinary("010203"))
xs:base64Binary(xs:hexBinary("01020304"))
xs:base64Binary(xs:hexBinary("0102030405"))
xs:base64Binary(xs:hexBinary("010203040506"))
xs:base64Binary(xs:hexBinary("01020304050607"))
xs:base64Binary(xs:hexBinary("0102030405060708090A0B0C0D0E0F10111213131415161718191A1B1C1D1F202122232425262728292A2B2C2D2E2F"))
xs:base64Binary(xs:hexBinary("03")) eq xs:base64Binary(xs:hexBinary("03"))
xs:base64Binary(xs:hexBinary("03")) ne xs:base64Binary(xs:hexBinary("13"))
xs:base64Binary(xs:hexBinary("80c0"))
xs:base64Binary(xs:hexBinary("aabbcc"))
xs:base64Binary(xs:hexBinary("ff"))
xs:base64Binary(xs:untypedAtomic( "aaaa" )) eq xs:base64Binary("aaaa")
xs:boolean("")
xs:boolean()
xs:boolean(0.0E0) eq false()
xs:boolean('0') cast as xs:string eq 'false'
xs:boolean(+0) eq false()
xs:boolean(-0) eq false()
xs:boolean("0") eq xs:boolean("false")
xs:boolean("0") eq xs:boolean("true")
xs:boolean("0") ge xs:boolean("false")
xs:boolean("0") ge xs:boolean("true")
xs:boolean("0") gt xs:boolean("false")
xs:boolean("0") gt xs:boolean("true")
xs:boolean("0") le xs:boolean("false")
xs:boolean("0") le xs:boolean("true")
xs:boolean("0") lt xs:boolean("false")
xs:boolean("0") lt xs:boolean("true")
xs:boolean("1") eq xs:boolean("false")
xs:boolean("1") eq xs:boolean("true")
xs:boolean("1") ge xs:boolean("false")
xs:boolean("1") ge xs:boolean("true")
xs:boolean("1") gt xs:boolean("false")
xs:boolean("1") gt xs:boolean("true")
xs:boolean("1") le xs:boolean("false")
xs:boolean("1") le xs:boolean("true")
xs:boolean("1") lt xs:boolean("false")
xs:boolean("1") lt xs:boolean("true")
xs:boolean(<a>0</a>)
xs:boolean("false") castable as xs:boolean
xs:boolean("false") castable as xs:decimal
xs:boolean("false") castable as xs:double
xs:boolean("false") castable as xs:float
xs:boolean("false") castable as xs:integer
xs:boolean("false") cast as xs:boolean
xs:boolean("false") cast as xs:decimal
xs:boolean("false") cast as xs:double
xs:boolean("false") cast as xs:float
xs:boolean("false") cast as xs:integer
xs:boolean("false") eq false()
xs:boolean("false") eq true()
xs:boolean("false") eq xs:boolean("0")
xs:boolean("false") eq xs:boolean('0')
xs:boolean('false') eq xs:boolean('0')
xs:boolean("false") eq xs:boolean("1")
xs:boolean('false') eq xs:boolean('1')
xs:boolean("false") eq xs:boolean("false")
xs:boolean("false") eq xs:boolean("true")
xs:boolean("false") ge xs:boolean("0")
xs:boolean("false") ge xs:boolean("1")
xs:boolean("false") ge xs:boolean("false")
xs:boolean("false") ge xs:boolean("true")
xs:boolean("false") gt xs:boolean("0")
xs:boolean("false") gt xs:boolean("1")
xs:boolean("false") gt xs:boolean("false")
xs:boolean("false") gt xs:boolean("true")
xs:boolean("false") le xs:boolean("0")
xs:boolean("false") le xs:boolean("1")
xs:boolean("false") le xs:boolean("false")
xs:boolean("false") le xs:boolean("true")
xs:boolean("false") lt xs:boolean("0")
xs:boolean("false") lt xs:boolean("1")
xs:boolean("false") lt xs:boolean("false")
xs:boolean("false") lt xs:boolean("true")
xs:boolean("false"), xs:boolean("1")
xs:boolean(fn:codepoint-equal("aa","aa"))
xs:boolean(fn:false())
xs:boolean(fn:not("true"))
xs:boolean(fn:true())
(xs:boolean(fn:true()), fn:false(), fn:true())
(xs:boolean("true") and xs:boolean("true")) eq (xs:boolean("false") and xs:boolean("false"))
xs:boolean("true") castable as xs:anyURI
xs:boolean("true") castable as xs:base64Binary
xs:boolean("true") castable as xs:boolean
xs:boolean("true") castable as xs:date
xs:boolean("true") castable as xs:dateTime
xs:boolean("true") castable as xs:dayTimeDuration
xs:boolean("true") castable as xs:decimal
xs:boolean("true") castable as xs:double
xs:boolean("true") castable as xs:duration
xs:boolean("true") castable as xs:float
xs:boolean("true") castable as xs:gDay
xs:boolean("true") castable as xs:gMonth
xs:boolean("true") castable as xs:gMonthDay
xs:boolean("true") castable as xs:gYear
xs:boolean("true") castable as xs:gYearMonth
xs:boolean("true") castable as xs:hexBinary
xs:boolean("true") castable as xs:integer
xs:boolean("true") castable as xs:string
xs:boolean("true") castable as xs:time
xs:boolean("true") castable as xs:untypedAtomic
xs:boolean("true") castable as xs:yearMonthDuration
xs:boolean("true") cast as xs:anyURI
xs:boolean("true") cast as xs:base64Binary
xs:boolean("true") cast as xs:boolean
xs:boolean("true") cast as xs:boolean eq xs:boolean("true")
xs:boolean("true") cast as xs:date
xs:boolean("true") cast as xs:dateTime
xs:boolean("true") cast as xs:dayTimeDuration
xs:boolean("true") cast as xs:decimal
xs:boolean("true") cast as xs:decimal ne xs:decimal("10.01")
xs:boolean("true") cast as xs:double
xs:boolean("true") cast as xs:double ne xs:double("3.3e3")
xs:boolean("true") cast as xs:duration
xs:boolean("true") cast as xs:float
xs:boolean("true") cast as xs:float ne xs:float("3.4e5")
xs:boolean("true") cast as xs:gDay
xs:boolean("true") cast as xs:gMonth
xs:boolean("true") cast as xs:gMonthDay
xs:boolean("true") cast as xs:gYear
xs:boolean("true") cast as xs:gYearMonth
xs:boolean("true") cast as xs:hexBinary
xs:boolean("true") cast as xs:integer
xs:boolean("true") cast as xs:integer ne xs:integer("6789")
xs:boolean("true") cast as xs:string
xs:boolean("true") cast as xs:string ne xs:string("an arbitrary string")
xs:boolean("true") cast as xs:time
xs:boolean("true") cast as xs:untypedAtomic
xs:boolean("true") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:boolean("true") cast as xs:yearMonthDuration
xs:boolean("true") eq false()
xs:boolean("true") eq true()
xs:boolean("true") eq xs:boolean("0")
xs:boolean('true') eq xs:boolean('0')
xs:boolean("true") eq xs:boolean("1")
xs:boolean("true") eq xs:boolean('1')
xs:boolean('true') eq xs:boolean('1')
xs:boolean("true") eq xs:boolean("false")
xs:boolean(" true ") eq xs:boolean(" true ")
xs:boolean("true") eq xs:boolean("true")
xs:boolean("true") ge xs:boolean("0")
xs:boolean("true") ge xs:boolean("1")
xs:boolean("true") ge xs:boolean("false")
xs:boolean("true") ge xs:boolean("true")
xs:boolean("true") gt xs:boolean("0")
xs:boolean("true") gt xs:boolean("1")
xs:boolean("true") gt xs:boolean("false")
xs:boolean("true") gt xs:boolean("true")
xs:boolean("true") instance of xs:anyURI
xs:boolean("true") instance of xs:boolean
xs:boolean("true") instance of xs:date
xs:boolean("true") instance of xs:dateTime
xs:boolean("true") instance of xs:decimal
xs:boolean("true") instance of xs:double
xs:boolean("true") instance of xs:float
xs:boolean("true") instance of xs:int
xs:boolean("true") instance of xs:integer
xs:boolean("true") instance of xs:string
xs:boolean("true") instance of xs:time
xs:boolean("true") le xs:boolean("0")
xs:boolean("true") le xs:boolean("1")
xs:boolean("true") le xs:boolean("false")
xs:boolean("true") le xs:boolean("true")
xs:boolean("true") lt xs:boolean("0")
xs:boolean("true") lt xs:boolean("1")
xs:boolean("true") lt xs:boolean("false")
xs:boolean("true") lt xs:boolean("true")
xs:boolean( "true" , "true" )
xs:boolean("true") , xs:boolean("0"), xs:integer("0")
xs:boolean(xs:decimal(0.0)) eq false()
xs:boolean(xs:decimal(0)) eq false()
xs:boolean(xs:decimal(3)) eq true()
xs:boolean(xs:double(+0)) eq false()
xs:boolean(xs:double(-0)) eq false()
xs:boolean(xs:double(0)) eq false()
xs:boolean(xs:double(3)) eq true()
xs:boolean(xs:double("NaN")) eq false()
xs:boolean(xs:duration("P36D") eq xs:duration("P36D"))
xs:boolean(xs:duration("P36D") ne xs:duration("P36D"))
xs:boolean(xs:float("NaN")) eq false()
xs:boolean(xs:integer(0)) eq false()
xs:boolean(xs:integer(3)) eq true()
xs:boolean(xs:string(0)) eq false()
xs:boolean(xs:string(1)) eq true()
xs:boolean(xs:untypedAtomic( "true" )) eq xs:boolean("true")
xs:byte("")
xs:byte("000000001")
xs:byte(0) and xs:byte(0)
xs:byte(0) and xs:byte(1)
xs:byte(0) instance of xs:byte
xs:byte("0") instance of xs:short
xs:byte(0) or xs:byte(0)
xs:byte(0) or xs:byte(1)
xs:byte("-0x128")
xs:byte("127")
xs:byte(127) and xs:byte(0)
xs:byte(127) and xs:byte(-1)
xs:byte(127) and xs:byte(-128)
xs:byte(127) or xs:byte(0)
xs:byte(127) or xs:byte(-1)
xs:byte(127) or xs:byte(-128)
xs:byte("-128")
xs:byte("128")
xs:byte(128)
xs:byte(-128) and xs:byte(0)
xs:byte(-128) and xs:byte(1)
xs:byte(-128) or xs:byte(0)
xs:byte(-128) or xs:byte(1)
xs:byte("-129")
xs:byte(-129)
xs:byte(-1) and xs:byte(0)
xs:byte(1) and xs:byte(-1)
xs:byte(-1) or xs:byte(0)
xs:byte(1) or xs:byte(-1)
xs:byte("3.0")
xs:byte("+ 5")
xs:byte("- 5")
xs:byte(false())
xs:byte(true())
xs:byte(xs:double("1")) instance of xs:byte
xs:byte(xs:double("-INF"))
xs:byte(xs:double("INF"))
xs:byte(xs:double("NaN"))
xs:byte(xs:float("1")) instance of xs:byte
xs:byte(xs:float("-INF"))
xs:byte(xs:float("INF"))
xs:byte(xs:float("NaN"))
xs:date("")
xs:date()
xs:date("00004-08-01")
xs:date("-0012-12-03-05:00") castable as xs:date
xs:date("-0012-12-03-05:00") castable as xs:gMonth
xs:date("-0012-12-03-05:00") castable as xs:gMonthDay
xs:date("-0012-12-03-05:00") castable as xs:gYear
xs:date("-0012-12-03-05:00") castable as xs:string
xs:date("-0012-12-03-05:00") castable as xs:untypedAtomic
xs:date("-0012-12-03-05:00") cast as xs:date
xs:date("-0012-12-03-05:00") cast as xs:gMonth
xs:date("-0012-12-03-05:00") cast as xs:gMonthDay
xs:date("-0012-12-03-05:00") cast as xs:gYear
xs:date("-0012-12-03-05:00") cast as xs:string
xs:date("-0012-12-03-05:00") cast as xs:untypedAtomic
xs:date("02004-08-01")
xs:date("0x10-11-11")
xs:date(1)
xs:date(" +11-11-11")
xs:date(" 111-11-11")
xs:date("+111-11-11")
xs:date("-111-11-11")
xs:date("111 -11-11")
xs:date("1111- 1-11")
xs:date("1111-+1-11")
xs:date("1111--1-11")
xs:date("1111-1 -11")
xs:date("1111-11- 1")
xs:date("1111-11-+1")
xs:date("1111-11--1")
xs:date("1111-11-1 ")
xs:date("1111-11-1F")
xs:date("1970-01-01Z") eq xs:date("1970-01-01Z")
xs:date("1970-01-01Z") eq xs:date("1983-11-17Z")
xs:date("1970-01-01Z") eq xs:date("2030-12-31Z")
xs:date("1970-01-01Z") ge xs:date("1970-01-01Z")
xs:date("1970-01-01Z") ge xs:date("1983-11-17Z")
xs:date("1970-01-01Z") ge xs:date("2030-12-31Z")
xs:date("1970-01-01Z") gt xs:date("1970-01-01Z")
xs:date("1970-01-01Z") gt xs:date("1983-11-17Z")
xs:date("1970-01-01Z") gt xs:date("2030-12-31Z")
xs:date("1970-01-01Z") le xs:date("1970-01-01Z")
xs:date("1970-01-01Z") le xs:date("1983-11-17Z")
xs:date("1970-01-01Z") le xs:date("2030-12-31Z")
xs:date("1970-01-01Z") lt xs:date("1970-01-01Z")
xs:date("1970-01-01Z") lt xs:date("1983-11-17Z")
xs:date("1970-01-01Z") lt xs:date("2030-12-31Z")
xs:date("1970-01-01Z") ne xs:date("1970-01-01Z")
xs:date("1970-01-01Z") ne xs:date("1983-11-17Z")
xs:date("1970-01-01Z") ne xs:date("2030-12-31Z")
(xs:date("1976-10-25Z") ge xs:date("1976-10-28Z")) or (xs:date("1980-08-11Z") ge xs:date("1980-08-10Z"))
(xs:date("1976-10-25Z") le xs:date("1976-10-28Z")) or (xs:date("1980-08-11Z") le xs:date("1980-08-10Z"))
(xs:date("1978-12-12Z") - xs:date("1978-12-12Z")) div xs:dayTimeDuration("P17DT10H02M")
(xs:date("1980-01-01Z") gt xs:date("1980-10-01Z")) or (fn:false())
(xs:date("1980-01-01Z") lt xs:date("1980-10-01Z")) or (fn:false())
(xs:date("1980-05-18Z") gt xs:date("1980-05-17Z")) or (fn:true())
(xs:date("1980-05-18Z") lt xs:date("1980-05-17Z")) or (fn:true())
(xs:date("1980-10-25Z") ge xs:date("1980-10-26Z")) or (fn:false())
(xs:date("1980-10-25Z") le xs:date("1980-10-26Z")) or (fn:false())
xs:date("1983-11-17Z") eq xs:date("1970-01-01Z")
xs:date("1983-11-17Z") ge xs:date("1970-01-01Z")
xs:date("1983-11-17Z") gt xs:date("1970-01-01Z")
xs:date("1983-11-17Z") le xs:date("1970-01-01Z")
xs:date("1983-11-17Z") lt xs:date("1970-01-01Z")
xs:date("1983-11-17Z") ne xs:date("1970-01-01Z")
xs:date("1993-03-31") , xs:boolean("true"), xs:string("abc")
xs:date("1999-05-31") castable as xs:anyURI
xs:date("1999-05-31") castable as xs:base64Binary
xs:date("1999-05-31") castable as xs:boolean
xs:date("1999-05-31") castable as xs:date
xs:date("1999-05-31") castable as xs:dateTime
xs:date("1999-05-31") castable as xs:dayTimeDuration
xs:date("1999-05-31") castable as xs:double
xs:date("1999-05-31") castable as xs:duration
xs:date("1999-05-31") castable as xs:float
xs:date("1999-05-31") castable as xs:gMonthDay
xs:date("1999-05-31") castable as xs:gYear
xs:date("1999-05-31") castable as xs:gYearMonth
xs:date("1999-05-31") castable as xs:hexBinary
xs:date("1999-05-31") castable as xs:integer
xs:date("1999-05-31") castable as xs:string
xs:date("1999-05-31") castable as xs:time
xs:date("1999-05-31") castable as xs:untypedAtomic
xs:date("1999-05-31") castable as xs:yearMonthDuration
xs:date("1999-05-31") cast as xs:anyURI
xs:date("1999-05-31") cast as xs:base64Binary
xs:date("1999-05-31") cast as xs:boolean
xs:date("1999-05-31") cast as xs:date
xs:date("1999-05-31") cast as xs:dateTime
xs:date("1999-05-31") cast as xs:dayTimeDuration
xs:date("1999-05-31") cast as xs:double
xs:date("1999-05-31") cast as xs:duration
xs:date("1999-05-31") cast as xs:float
xs:date("1999-05-31") cast as xs:gMonthDay
xs:date("1999-05-31") cast as xs:gYear
xs:date("1999-05-31") cast as xs:gYearMonth
xs:date("1999-05-31") cast as xs:hexBinary
xs:date("1999-05-31") cast as xs:integer
xs:date("1999-05-31") cast as xs:string
xs:date("1999-05-31") cast as xs:time
xs:date("1999-05-31") cast as xs:untypedAtomic
xs:date("1999-05-31") cast as xs:yearMonthDuration
xs:date("1999-05-31Z") castable as xs:date
xs:date("1999-05-31Z") castable as xs:double
xs:date("1999-05-31Z") castable as xs:gDay
xs:date("1999-05-31Z") castable as xs:gMonth
xs:date("1999-05-31Z") castable as xs:gMonthDay
xs:date("1999-05-31Z") castable as xs:gYear
xs:date("1999-05-31Z") cast as xs:date
xs:date("1999-05-31Z") cast as xs:double
xs:date("1999-05-31Z") cast as xs:gDay
xs:date("1999-05-31Z") cast as xs:gMonth
xs:date("1999-05-31Z") cast as xs:gMonthDay
xs:date("1999-05-31Z") cast as xs:gYear
xs:date("1999-07-19") - xs:date("1969-11-30") eq xs:dayTimeDuration("P10823D")
xs:date("1999-07-19") - xs:date("1999-07-19") eq xs:dayTimeDuration("PT0S")
xs:date("1999-10-12") div xs:date("1999-10-12")
xs:date("1999-10-12") mod xs:date("1999-10-12")
xs:date("1999-10-12") * xs:date("1999-10-12")
xs:date("1999-10-12") + xs:date("1999-10-12")
(xs:date("1999-10-23Z") - xs:date("1998-09-09Z")) + xs:dayTimeDuration("P17DT10H02M")
(xs:date("1999-10-23Z") - xs:date("1998-09-09Z")) * xs:decimal(2.0)
xs:date("1999-12-01+10:60")
xs:date("1999-12-01-10:60")
xs:date("1999-12-01+15:00")
xs:date("1999-12-01-15:00")
xs:date("1999-12-04-00:00") eq xs:date("1999-12-04+00:00")
xs:date("1999-12-04+00:00") eq xs:date("1999-12-04Z")
xs:date("1999-12-04-00:00") eq xs:date("1999-12-04Z")
xs:date("1999-12-04") eq xs:dateTime("1999-12-04T12:12:23")
xs:date("1999-12-04") ge xs:dateTime("1999-12-04T12:12:23")
xs:date("1999-12-04") gt xs:dateTime("1999-12-04T12:12:23")
xs:date("1999-12-04") le xs:dateTime("1999-12-04T12:12:23")
xs:date("1999-12-04") lt xs:dateTime("1999-12-04T12:12:23")
xs:date("1999-12-04") ne xs:dateTime("1999-12-04T12:12:23")
xs:date("1999-12-04Z") eq xs:date("1999-12-04Z")
xs:date("2000-01-01+05:00") instance of xs:anyURI
xs:date("2000-01-01+05:00") instance of xs:boolean
xs:date("2000-01-01+05:00") instance of xs:date
xs:date("2000-01-01+05:00") instance of xs:dateTime
xs:date("2000-01-01+05:00") instance of xs:decimal
xs:date("2000-01-01+05:00") instance of xs:double
xs:date("2000-01-01+05:00") instance of xs:float
xs:date("2000-01-01+05:00") instance of xs:int
xs:date("2000-01-01+05:00") instance of xs:integer
xs:date("2000-01-01+05:00") instance of xs:string
xs:date("2000-01-01+05:00") instance of xs:time
(xs:date("2000-01-01Z") gt xs:date("2000-01-01Z")) and (xs:date("2001-02-02Z") gt xs:date("2001-03-02Z"))
(xs:date("2000-01-01Z") lt xs:date("2000-01-01Z")) and (xs:date("2001-02-02Z") lt xs:date("2001-03-02Z"))
(xs:date("2000-01-25Z") ge xs:date("2000-10-26Z")) and (xs:date("1975-10-26Z") ge xs:date("1975-10-28Z"))
(xs:date("2000-01-25Z") le xs:date("2000-10-26Z")) and (xs:date("1975-10-26Z") le xs:date("1975-10-28Z"))
xs:date("2000-10-15-05:00") - xs:date("2000-10-10+02:00")
(xs:date("2000-10-25Z") ge xs:date("2000-10-26Z")) or (fn:true())
(xs:date("2000-10-25Z") le xs:date("2000-10-26Z")) or (fn:true())
(xs:date("2000-10-26Z") gt xs:date("2000-10-28Z")) or (xs:date("1976-10-28Z") gt xs:date("1976-10-28Z"))
(xs:date("2000-10-26Z") lt xs:date("2000-10-28Z")) or (xs:date("1976-10-28Z") lt xs:date("1976-10-28Z"))
xs:date("2000-10-30+05:00") - xs:date("1999-11-28Z")
xs:date("2000-10-30") - xs:date("1999-11-28")
xs:date("2002-002-15")
xs:date("--2002-02-15")
xs:date("2002-02-150")
xs:date("2002-02-15T08:12:12")
xs:date("+2002-12-11")
xs:date("2002-12-31+01:00") - xs:date("2008-12-31") - implicit-timezone()
xs:date("2004-07-12") ge xs:date("2004-07-12")
xs:date("2004-07-12") le xs:date("2004-07-12")
xs:date("2004-07-12") lt xs:date("2004-07-13")
xs:date("2004-07-13") ge xs:date("2004-07-12")
xs:date("2004-07-13") gt xs:date("2004-07-12")
xs:date("+2004-08-01")
xs:date("2004-08-12") eq xs:date("2004-08-12")
xs:date("2004-08-12") ne xs:date("2004-07-12")
xs:date( "2004-10-13" , "2004-10-13" )
xs:date("2004-10-13") castable as xs:date
xs:date("2004-10-13") castable as xs:dateTime
xs:date("2004-10-13") castable as xs:gDay
xs:date("2004-10-13") castable as xs:gMonth
xs:date("2004-10-13") castable as xs:gMonthDay
xs:date("2004-10-13") castable as xs:gYear
xs:date("2004-10-13") castable as xs:gYearMonth
xs:date("2004-10-13") castable as xs:string
xs:date("2004-10-13") castable as xs:untypedAtomic
xs:date("2004-10-13") cast as xs:anyURI
xs:date("2004-10-13") cast as xs:base64Binary
xs:date("2004-10-13") cast as xs:boolean
xs:date("2004-10-13") cast as xs:date eq xs:date("2004-10-13")
xs:date("2004-10-13") cast as xs:dateTime ne xs:dateTime("2002-10-10T12:00:00-05:00")
xs:date("2004-10-13") cast as xs:dayTimeDuration
xs:date("2004-10-13") cast as xs:decimal
xs:date("2004-10-13") cast as xs:double
xs:date("2004-10-13") cast as xs:duration
xs:date("2004-10-13") cast as xs:float
xs:date("2004-10-13") cast as xs:gDay ne xs:gDay("---03")
xs:date("2004-10-13") cast as xs:gMonthDay ne xs:gMonthDay("--11-13")
xs:date("2004-10-13") cast as xs:gMonth ne xs:gMonth("--11")
xs:date("2004-10-13") cast as xs:gYearMonth ne xs:gYearMonth("1999-11")
xs:date("2004-10-13") cast as xs:gYear ne xs:gYear("1999")
xs:date("2004-10-13") cast as xs:hexBinary
xs:date("2004-10-13") cast as xs:integer
xs:date("2004-10-13") cast as xs:string ne xs:string("an arbitrary string")
xs:date("2004-10-13") cast as xs:time
xs:date("2004-10-13") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:date("2004-10-13") cast as xs:yearMonthDuration
xs:date(" 2004-10-13 ") eq xs:date(" 2004-10-13 ")
(xs:date("2004-12-25-12:00") gt xs:date("2004-12-26+12:00"))
(xs:date("2004-12-25-12:00") le xs:date("2004-12-26+12:00"))
(xs:date("2004-12-25Z") gt xs:date("2004-12-25+07:00"))
(xs:date("2004-12-25Z") lt xs:date("2004-12-25-05:00"))
(xs:date("2004-12-25Z"),xs:date("2004-12-26Z"))
xs:date("2004-32-01")
xs:date("2008-01-30") eq xs:date("2008-01-31+09:00")
xs:date("2008-01-30") ge xs:date("2008-01-31+09:00")
xs:date("2008-01-30") le xs:date("2008-01-31+09:00")
xs:date("2008-01-30") lt xs:date("2008-01-31+09:00")
xs:date("2008-01-30") ne xs:date("2008-01-31+09:00")
xs:date("2008-01-31+09:00") eq xs:date("2008-01-30")
xs:date("2008-01-31+09:00") eq xs:date("2008-01-31")
xs:date("2008-01-31+09:00") ge xs:date("2008-01-30")
xs:date("2008-01-31+09:00") ge xs:date("2008-01-31")
xs:date("2008-01-31+09:00") le xs:date("2008-01-30")
xs:date("2008-01-31+09:00") le xs:date("2008-01-31")
xs:date("2008-01-31+09:00") lt xs:date("2008-01-30")
xs:date("2008-01-31+09:00") lt xs:date("2008-01-31")
xs:date("2008-01-31+09:00") ne xs:date("2008-01-30")
xs:date("2008-01-31+09:00") ne xs:date("2008-01-31")
xs:date("2008-01-31") eq xs:date("2008-01-31+09:00")
xs:date("2008-01-31") ge xs:date("2008-01-31+09:00")
xs:date("2008-01-31") le xs:date("2008-01-31+09:00")
xs:date("2008-01-31") lt xs:date("2008-01-31+09:00")
xs:date("2008-01-31") ne xs:date("2008-01-31+09:00")
xs:date("2008-12-31") - xs:date("2002-12-31+01:00") + implicit-timezone()
xs:date('2017-07-19-00:30')
xs:date("2030-12-31Z") eq xs:date("1970-01-01Z")
xs:date("2030-12-31Z") ge xs:date("1970-01-01Z")
xs:date("2030-12-31Z") gt xs:date("1970-01-01Z")
xs:date("2030-12-31Z") le xs:date("1970-01-01Z")
xs:date("2030-12-31Z") lt xs:date("1970-01-01Z")
xs:date("2030-12-31Z") ne xs:date("1970-01-01Z")
xs:date("-25252734927766554-12-31") - xs:date("25252734927766554-12-31")
xs:date("-25252734927766554-12-31") - xs:date("25252734927766554-12-31+01:00")
xs:date("-25252734927766555-06-07+02:00") < xs:date("25252734927766555-07-28")
xs:date("-25252734927766555-06-07+02:00") <= xs:date("25252734927766555-07-28")
xs:date("-25252734927766555-06-07+02:00") = xs:date("25252734927766555-07-28")
xs:date("25252734927766555-07-28-14:00") - xs:date("-25252734927766555-07-28-14:00")
xs:date("25252734927766555-07-28-14:00") + xs:dayTimeDuration("PT24H")
xs:date("25252734927766555-07-28-14:00") - xs:dayTimeDuration("-PT24H")
xs:date("25252734927766555-07-28-14:00") + xs:yearMonthDuration("P1Y0M")
xs:date("25252734927766555-07-28-14:00") - xs:yearMonthDuration("-P1Y0M")
xs:date("25252734927766555-07-28") != xs:date("-25252734927766555-06-07+02:00")
xs:date("25252734927766555-07-28") > xs:date("-25252734927766555-06-07+02:00")
xs:date("25252734927766555-07-28") >= xs:date("-25252734927766555-06-07+02:00")
xs:dateTime("")
xs:dateTime()
xs:dateTime("00004-08-01T12:44:05")
xs:dateTime("02004-08-01T12:44:05")
xs:dateTime("1970-01-01T00:00:00Z") eq xs:dateTime("1970-01-01T00:00:00Z")
xs:dateTime("1970-01-01T00:00:00Z") eq xs:dateTime("1996-04-07T01:40:52Z")
xs:dateTime("1970-01-01T00:00:00Z") eq xs:dateTime("2030-12-31T23:59:59Z")
xs:dateTime("1970-01-01T00:00:00Z") ge xs:dateTime("1970-01-01T00:00:00Z")
xs:dateTime("1970-01-01T00:00:00Z") ge xs:dateTime("1996-04-07T01:40:52Z")
xs:dateTime("1970-01-01T00:00:00Z") ge xs:dateTime("2030-12-31T23:59:59Z")
xs:dateTime("1970-01-01T00:00:00Z") gt xs:dateTime("1970-01-01T00:00:00Z")
xs:dateTime("1970-01-01T00:00:00Z") gt xs:dateTime("1996-04-07T01:40:52Z")
xs:dateTime("1970-01-01T00:00:00Z") gt xs:dateTime("2030-12-31T23:59:59Z")
xs:dateTime("1970-01-01T00:00:00Z") le xs:dateTime("1970-01-01T00:00:00Z")
xs:dateTime("1970-01-01T00:00:00Z") le xs:dateTime("1996-04-07T01:40:52Z")
xs:dateTime("1970-01-01T00:00:00Z") le xs:dateTime("2030-12-31T23:59:59Z")
xs:dateTime("1970-01-01T00:00:00Z") lt xs:dateTime("1970-01-01T00:00:00Z")
xs:dateTime("1970-01-01T00:00:00Z") lt xs:dateTime("1996-04-07T01:40:52Z")
xs:dateTime("1970-01-01T00:00:00Z") lt xs:dateTime("2030-12-31T23:59:59Z")
xs:dateTime("1970-01-01T00:00:00Z") ne xs:dateTime("1970-01-01T00:00:00Z")
xs:dateTime("1970-01-01T00:00:00Z") ne xs:dateTime("1996-04-07T01:40:52Z")
xs:dateTime("1970-01-01T00:00:00Z") ne xs:dateTime("2030-12-31T23:59:59Z")
(xs:dateTime("1970-04-02T12:00:20Z") ge xs:dateTime("1980-04-02T12:00:20Z")) or (fn:true())
(xs:dateTime("1970-04-02T12:00:20Z") le xs:dateTime("1980-04-02T12:00:20Z")) or (fn:true())
xs:dateTime("1972-12-15T00:00:00+12:00") eq xs:dateTime("1972-12-15T00:00:01")
xs:dateTime("1972-12-15T00:00:00+12:00") ne xs:dateTime("1972-12-15T00:00:01")
xs:dateTime("1972-12-31T00:00:00Z") , (())
(xs:dateTime("1976-04-03T12:00:00Z") ge xs:dateTime("2002-07-02T12:00:30Z")) or (fn:false())
(xs:dateTime("1976-04-03T12:00:00Z") le xs:dateTime("2002-07-02T12:00:30Z")) or (fn:false())
(xs:dateTime("1981-04-02T12:00:00Z") gt xs:dateTime("2003-04-02T12:10:00Z")) or (fn:false())
(xs:dateTime("1981-04-02T12:00:00Z") lt xs:dateTime("2003-04-02T12:10:00Z")) or (fn:false())
(xs:dateTime("1985-07-05T07:07:07Z") - xs:dateTime("1985-07-05T07:07:07Z")) div xs:dayTimeDuration("P05DT08H11M")
(xs:dateTime("1990-04-02T12:00:10Z") gt xs:dateTime("2006-06-02T12:10:00Z")) or (fn:true())
(xs:dateTime("1990-04-02T12:00:10Z") lt xs:dateTime("2006-06-02T12:10:00Z")) or (fn:true())
xs:dateTime("1996-04-07T01:40:52Z") eq xs:dateTime("1970-01-01T00:00:00Z")
xs:dateTime("1996-04-07T01:40:52Z") ge xs:dateTime("1970-01-01T00:00:00Z")
xs:dateTime("1996-04-07T01:40:52Z") gt xs:dateTime("1970-01-01T00:00:00Z")
xs:dateTime("1996-04-07T01:40:52Z") le xs:dateTime("1970-01-01T00:00:00Z")
xs:dateTime("1996-04-07T01:40:52Z") lt xs:dateTime("1970-01-01T00:00:00Z")
xs:dateTime("1996-04-07T01:40:52Z") ne xs:dateTime("1970-01-01T00:00:00Z")
xs:dateTime("1999-05-31T13:20:00-05:00") cast as xs:date
xs:dateTime("1999-05-31T13:20:00-05:00") cast as xs:dateTime
xs:dateTime("1999-05-31T13:20:00-05:00") cast as xs:string
xs:dateTime("1999-05-31T13:20:00-05:00") cast as xs:time
xs:dateTime("-1999-05-31T13:20:00+14:00") castable as xs:date
xs:dateTime("-1999-05-31T13:20:00+14:00") castable as xs:gDay
xs:dateTime("-1999-05-31T13:20:00+14:00") castable as xs:gMonth
xs:dateTime("-1999-05-31T13:20:00+14:00") castable as xs:gMonthDay
xs:dateTime("-1999-05-31T13:20:00+14:00") castable as xs:gYear
xs:dateTime("-1999-05-31T13:20:00+14:00") castable as xs:gYearMonth
xs:dateTime("-1999-05-31T13:20:00+14:00") castable as xs:string
xs:dateTime("-1999-05-31T13:20:00+14:00") castable as xs:time
xs:dateTime("-1999-05-31T13:20:00+14:00") castable as xs:untypedAtomic
xs:dateTime("-1999-05-31T13:20:00+14:00") cast as xs:date
xs:dateTime("-1999-05-31T13:20:00+14:00") cast as xs:gDay
xs:dateTime("-1999-05-31T13:20:00+14:00") cast as xs:gMonth
xs:dateTime("-1999-05-31T13:20:00+14:00") cast as xs:gMonthDay
xs:dateTime("-1999-05-31T13:20:00+14:00") cast as xs:gYear
xs:dateTime("-1999-05-31T13:20:00+14:00") cast as xs:gYearMonth
xs:dateTime("-1999-05-31T13:20:00+14:00") cast as xs:string
xs:dateTime("-1999-05-31T13:20:00+14:00") cast as xs:time
xs:dateTime("-1999-05-31T13:20:00+14:00") cast as xs:untypedAtomic
xs:dateTime("1999-05-31T13:20:00") castable as xs:anyURI
xs:dateTime("1999-05-31T13:20:00") castable as xs:base64Binary
xs:dateTime("1999-05-31T13:20:00") castable as xs:boolean
xs:dateTime("1999-05-31T13:20:00") castable as xs:date
xs:dateTime("1999-05-31T13:20:00") castable as xs:dateTime
xs:dateTime("1999-05-31T13:20:00") castable as xs:dayTimeDuration
xs:dateTime("1999-05-31T13:20:00") castable as xs:decimal
xs:dateTime("1999-05-31T13:20:00") castable as xs:duration
xs:dateTime("1999-05-31T13:20:00") castable as xs:float
xs:dateTime("1999-05-31T13:20:00") castable as xs:gDay
xs:dateTime("1999-05-31T13:20:00") castable as xs:gMonth
xs:dateTime("1999-05-31T13:20:00") castable as xs:gMonthDay
xs:dateTime("1999-05-31T13:20:00") castable as xs:gYear
xs:dateTime("1999-05-31T13:20:00") castable as xs:gYearMonth
xs:dateTime("1999-05-31T13:20:00") castable as xs:hexBinary
xs:dateTime("1999-05-31T13:20:00") castable as xs:integer
xs:dateTime("1999-05-31T13:20:00") castable as xs:string
xs:dateTime("1999-05-31T13:20:00") castable as xs:time
xs:dateTime("1999-05-31T13:20:00") castable as xs:untypedAtomic
xs:dateTime("1999-05-31T13:20:00") castable as xs:yearMonthDuration
xs:dateTime("1999-05-31T13:20:00") cast as xs:anyURI
xs:dateTime("1999-05-31T13:20:00") cast as xs:base64Binary
xs:dateTime("1999-05-31T13:20:00") cast as xs:boolean
xs:dateTime("1999-05-31T13:20:00") cast as xs:date
xs:dateTime("1999-05-31T13:20:00") cast as xs:dateTime
xs:dateTime("1999-05-31T13:20:00") cast as xs:dayTimeDuration
xs:dateTime("1999-05-31T13:20:00") cast as xs:decimal
xs:dateTime("1999-05-31T13:20:00") cast as xs:duration
xs:dateTime("1999-05-31T13:20:00") cast as xs:float
xs:dateTime("1999-05-31T13:20:00") cast as xs:gDay
xs:dateTime("1999-05-31T13:20:00") cast as xs:gMonth
xs:dateTime("1999-05-31T13:20:00") cast as xs:gMonthDay
xs:dateTime("1999-05-31T13:20:00") cast as xs:gYear
xs:dateTime("1999-05-31T13:20:00") cast as xs:gYearMonth
xs:dateTime("1999-05-31T13:20:00") cast as xs:hexBinary
xs:dateTime("1999-05-31T13:20:00") cast as xs:integer
xs:dateTime("1999-05-31T13:20:00") cast as xs:string
xs:dateTime("1999-05-31T13:20:00") cast as xs:time
xs:dateTime("1999-05-31T13:20:00") cast as xs:untypedAtomic
xs:dateTime("1999-05-31T13:20:00") cast as xs:yearMonthDuration
xs:dateTime("1999-07-19T08:23:12.765") - xs:dateTime("1999-07-19T08:23:12.765") eq xs:dayTimeDuration("PT0S")
xs:dateTime("1999-10-12T08:01:23") div xs:dateTime("1999-10-12T08:01:23")
xs:dateTime("1999-10-12T08:01:23") mod xs:dateTime("1999-10-12T08:01:23")
xs:dateTime("1999-10-12T08:01:23") * xs:dateTime("1999-10-12T08:01:23")
xs:dateTime("1999-10-12T08:01:23") + xs:dateTime("1999-10-12T08:01:23")
(xs:dateTime("1999-10-23T01:01:01Z") - xs:dateTime("1998-09-09T02:02:02Z")) * xs:decimal(2.0)
(xs:dateTime("1999-10-23T09:08:07Z") - xs:dateTime("1998-09-09T04:03:02Z")) + xs:dayTimeDuration("P17DT10H02M")
(xs:dateTime("1999-11-28T09:00:00Z"),xs:dateTime("1998-11-28T09:00:00Z"))
xs:dateTime("1999-12-01-03")
xs:dateTime("1999-12-01T23:59:12.432+10:60")
xs:dateTime("1999-12-01T23:59:12.432-10:60")
xs:dateTime("1999-12-01T23:59:12.432+15:00")
xs:dateTime("1999-12-01T23:59:12.432-15:00")
xs:dateTime("1999-12-01T23:59:12.999-00")
xs:dateTime("1999-12-04T12:12:23") eq xs:date("1999-12-04")
xs:dateTime("1999-12-04T12:12:23") eq xs:time("22:12:04")
xs:dateTime("1999-12-04T12:12:23") ge xs:date("1999-12-04")
xs:dateTime("1999-12-04T12:12:23") ge xs:time("22:12:04")
xs:dateTime("1999-12-04T12:12:23") gt xs:date("1999-12-04")
xs:dateTime("1999-12-04T12:12:23") gt xs:time("22:12:04")
xs:dateTime("1999-12-04T12:12:23") le xs:date("1999-12-04")
xs:dateTime("1999-12-04T12:12:23") le xs:time("22:12:04")
xs:dateTime("1999-12-04T12:12:23") lt xs:date("1999-12-04")
xs:dateTime("1999-12-04T12:12:23") lt xs:time("22:12:04")
xs:dateTime("1999-12-04T12:12:23") ne xs:date("1999-12-04")
xs:dateTime("1999-12-04T12:12:23") ne xs:time("22:12:04")
xs:dateTime("1999-12-04T16:00:12.345-00:00") eq xs:dateTime("1999-12-04T16:00:12.345+00:00")
xs:dateTime("1999-12-04T16:00:12.345+00:00") eq xs:dateTime("1999-12-04T16:00:12.345Z")
xs:dateTime("1999-12-04T16:00:12.345-00:00") eq xs:dateTime("1999-12-04T16:00:12.345Z")
xs:dateTime("1999-12-04T16:00:12.345Z") eq xs:dateTime("1999-12-04T16:00:12.345Z")
xs:dateTime("2000-01-16T00:00:00Z") castable as xs:float
xs:dateTime("2000-01-16T00:00:00Z") cast as xs:float
xs:dateTime("2000-02-03T02:09:07-06:00") - xs:dateTime("1998-02-03T02:09:07-06:00")
xs:dateTime("2000-10-30T06:12:00-05:00") - xs:dateTime("1999-11-28T09:00:00Z")
xs:dateTime("2000-12-12T09:08:07+05:00") - xs:dateTime("1999-12-12T09:08:07+05:00")
xs:dateTime("2002-002-15T12:44:05")
xs:dateTime("2002-02-150T12:44:05")
xs:dateTime("--2002-02-15T21:01:23")
xs:dateTime("2002-02-15T21:01:60")
xs:dateTime("2002-02-15T21:60:00")
xs:dateTime("2002-02-15T24:00:00.001")
xs:dateTime("2002-02-15T24:01:00")
xs:dateTime("2002-02-15T25:01:00")
xs:dateTime("2002-03-06T00:00:00Z") ne xs:dateTime("2002-03-05T00:00:00+03:00")
(xs:dateTime("2002-04-02T12:00:00Z") ge xs:dateTime("2005-04-02T12:00:20Z")) and (xs:dateTime("2002-04-02T12:10:00Z") ge xs:dateTime("2002-04-03T12:00:00Z"))
(xs:dateTime("2002-04-02T12:00:00Z") gt xs:dateTime("2002-04-02T12:01:00Z")) and (xs:dateTime("2003-04-02T12:00:00Z") gt xs:dateTime("2002-04-02T12:00:00Z"))
xs:dateTime("2002-04-02T12:00:00Z") instance of xs:anyURI
xs:dateTime("2002-04-02T12:00:00Z") instance of xs:boolean
xs:dateTime("2002-04-02T12:00:00Z") instance of xs:date
xs:dateTime("2002-04-02T12:00:00Z") instance of xs:dateTime
xs:dateTime("2002-04-02T12:00:00Z") instance of xs:decimal
xs:dateTime("2002-04-02T12:00:00Z") instance of xs:double
xs:dateTime("2002-04-02T12:00:00Z") instance of xs:float
xs:dateTime("2002-04-02T12:00:00Z") instance of xs:int
xs:dateTime("2002-04-02T12:00:00Z") instance of xs:integer
xs:dateTime("2002-04-02T12:00:00Z") instance of xs:string
xs:dateTime("2002-04-02T12:00:00Z") instance of xs:time
(xs:dateTime("2002-04-02T12:00:00Z") le xs:dateTime("2005-04-02T12:00:20Z")) and (xs:dateTime("2002-04-02T12:10:00Z") le xs:dateTime("2002-04-03T12:00:00Z"))
(xs:dateTime("2002-04-02T12:00:00Z") lt xs:dateTime("2002-04-02T12:01:00Z")) and (xs:dateTime("2003-04-02T12:00:00Z") lt xs:dateTime("2002-04-02T12:00:00Z"))
(xs:dateTime("2002-04-03T12:00:10Z") ge xs:dateTime("1990-04-02T12:10:00Z")) or (xs:dateTime("1975-04-03T12:10:00Z") ge xs:dateTime("2000-02-02T12:00:09Z"))
(xs:dateTime("2002-04-03T12:00:10Z") le xs:dateTime("1990-04-02T12:10:00Z")) or (xs:dateTime("1975-04-03T12:10:00Z") le xs:dateTime("2000-02-02T12:00:09Z"))
(xs:dateTime("2002-06-02T12:00:10Z") gt xs:dateTime("2000-04-04T12:00:00Z")) or (xs:dateTime("2002-04-02T13:00:10Z") gt xs:dateTime("2001-04-02T10:00:00Z"))
(xs:dateTime("2002-06-02T12:00:10Z") lt xs:dateTime("2000-04-04T12:00:00Z")) or (xs:dateTime("2002-04-02T13:00:10Z") lt xs:dateTime("2001-04-02T10:00:00Z"))
xs:dateTime( "2002-10-10T12:00:00-05:00" , "2002-10-10T12:00:00-05:00" )
xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:date
xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:dateTime
xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:gDay
xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:gMonth
xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:gMonthDay
xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:gYear
xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:gYearMonth
xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:string
xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:time
xs:dateTime("2002-10-10T12:00:00-05:00") castable as xs:untypedAtomic
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:anyURI
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:base64Binary
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:boolean
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:date ne xs:date("2004-10-13")
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:dateTime eq xs:dateTime("2002-10-10T12:00:00-05:00")
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:dayTimeDuration
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:decimal
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:double
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:duration
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:float
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:gDay ne xs:gDay("---03")
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:gMonthDay ne xs:gMonthDay("--11-13")
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:gMonth ne xs:gMonth("--11")
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:gYearMonth ne xs:gYearMonth("1999-11")
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:gYear ne xs:gYear("1999")
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:hexBinary
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:integer
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:string ne xs:string("an arbitrary string")
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:time ne xs:time("03:20:00-05:00")
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:dateTime("2002-10-10T12:00:00-05:00") cast as xs:yearMonthDuration
xs:dateTime(" 2002-10-10T12:00:00-05:00 ") eq xs:dateTime(" 2002-10-10T12:00:00-05:00 ")
xs:dateTime("2002-11-23")
xs:dateTime("2002-12-31T12:00:00+01:00") - xs:dateTime("2008-12-31T12:00:00") - implicit-timezone()
xs:dateTime("2004-07-12T23:01:04.12") ge xs:dateTime("2004-07-12T23:01:04.12")
xs:dateTime("2004-07-12T23:01:04.12") le xs:dateTime("2004-07-12T23:01:04.12")
xs:dateTime("2004-07-12T23:01:04.12") lt xs:dateTime("2004-07-13T23:01:04.12")
xs:dateTime("2004-07-13T23:01:04.12") ge xs:dateTime("2004-07-12T23:01:04.12")
xs:dateTime("2004-07-13T23:01:04.12") gt xs:dateTime("2004-07-12T23:01:04.12")
xs:dateTime("+2004-08-01T12:44:05")
xs:dateTime("2004-08-12T23:01:04.12") eq xs:dateTime("2004-08-12T23:01:04.12")
xs:dateTime("2004-08-12T23:01:05.12") ne xs:dateTime("2004-08-12T23:01:04.12")
xs:dateTime("2004-32-01T12:44:05")
xs:dateTime("2008-01-30T00:01:00") eq xs:dateTime("2008-01-31T01:00:00+09:00")
xs:dateTime("2008-01-30T00:01:00") ge xs:dateTime("2008-01-31T00:01:00+09:00")
xs:dateTime("2008-01-30T00:01:00") gt xs:dateTime("2008-01-31T01:00:00+09:00")
xs:dateTime("2008-01-30T00:01:00") le xs:dateTime("2008-01-31T00:01:00+09:00")
xs:dateTime("2008-01-30T00:01:00") lt xs:dateTime("2008-01-31T01:00:00+09:00")
xs:dateTime("2008-01-30T00:01:00") ne xs:dateTime("2008-01-31T00:01:00+09:00")
xs:dateTime("2008-01-31T00:01:00+09:00") eq xs:dateTime("2008-01-30T00:01:00")
xs:dateTime("2008-01-31T00:01:00+09:00") eq xs:dateTime("2008-01-31T00:01:00")
xs:dateTime("2008-01-31T00:01:00+09:00") ge xs:dateTime("2008-01-30T00:01:00")
xs:dateTime("2008-01-31T00:01:00+09:00") ge xs:dateTime("2008-01-31T00:01:00")
xs:dateTime("2008-01-31T00:01:00+09:00") gt xs:dateTime("2008-01-30T00:01:00")
xs:dateTime("2008-01-31T00:01:00+09:00") gt xs:dateTime("2008-01-31T00:01:00")
xs:dateTime("2008-01-31T00:01:00+09:00") le xs:dateTime("2008-01-30T00:01:00")
xs:dateTime("2008-01-31T00:01:00+09:00") le xs:dateTime("2008-01-31T00:01:00")
xs:dateTime("2008-01-31T00:01:00+09:00") lt xs:dateTime("2008-01-30T00:01:00")
xs:dateTime("2008-01-31T00:01:00+09:00") lt xs:dateTime("2008-01-31T00:01:00")
xs:dateTime("2008-01-31T00:01:00+09:00") ne xs:dateTime("2008-01-30T00:01:00")
xs:dateTime("2008-01-31T00:01:00+09:00") ne xs:dateTime("2008-01-31T00:01:00")
xs:dateTime("2008-01-31T00:01:00") eq xs:dateTime("2008-01-31T00:01:00+09:00")
xs:dateTime("2008-01-31T00:01:00") ge xs:dateTime("2008-01-31T00:01:00+09:00")
xs:dateTime("2008-01-31T00:01:00") gt xs:dateTime("2008-01-31T00:01:00+09:00")
xs:dateTime("2008-01-31T00:01:00") le xs:dateTime("2008-01-31T00:01:00+09:00")
xs:dateTime("2008-01-31T00:01:00") lt xs:dateTime("2008-01-31T00:01:00+09:00")
xs:dateTime("2008-01-31T00:01:00") ne xs:dateTime("2008-01-31T00:01:00+09:00")
xs:dateTime("2008-12-31T12:00:00") - xs:dateTime("2002-12-31T12:00:00+01:00") + implicit-timezone()
xs:dateTime('2017-07-19T12:00:00-00:30')
xs:dateTime("2030-12-31T23:59:59Z") eq xs:dateTime("1970-01-01T00:00:00Z")
xs:dateTime("2030-12-31T23:59:59Z") ge xs:dateTime("1970-01-01T00:00:00Z")
xs:dateTime("2030-12-31T23:59:59Z") gt xs:dateTime("1970-01-01T00:00:00Z")
xs:dateTime("2030-12-31T23:59:59Z") le xs:dateTime("1970-01-01T00:00:00Z")
xs:dateTime("2030-12-31T23:59:59Z") lt xs:dateTime("1970-01-01T00:00:00Z")
xs:dateTime("2030-12-31T23:59:59Z") ne xs:dateTime("1970-01-01T00:00:00Z")
xs:dateTime("-25252734927766554-12-31T12:00:00") - xs:dateTime("25252734927766554-12-31T12:00:00")
xs:dateTime("-25252734927766554-12-31T12:00:00") - xs:dateTime("25252734927766554-12-31T12:00:00+01:00")
xs:dateTime("25252734927766555-07-28T23:59:59-14:00") - xs:dateTime("-25252734927766555-07-28T23:59:59-14:00")
xs:dateTime("25252734927766555-07-28T23:59:59-14:00") + xs:dayTimeDuration("PT14H")
xs:dateTime("25252734927766555-07-28T23:59:59-14:00") - xs:dayTimeDuration("-PT14H")
xs:dateTime("25252734927766555-07-28T23:59:59-14:00") + xs:yearMonthDuration("P1Y0M")
xs:dateTime("25252734927766555-07-28T23:59:59-14:00") - xs:yearMonthDuration("-P1Y0M")
xs:dateTime("9999-12-31T23:59:59.9999999") cast as xs:string
xs:dateTimeStamp("2011-07-28T12:34:56")
xs:dateTime("T23:59:12.999-03")
xs:dateTime(xs:date("2002-11-23-00:00")) eq xs:dateTime("2002-11-23T00:00:00.000Z")
xs:dateTime(xs:date("2002-11-23-13:37")) eq xs:dateTime("2002-11-23T00:00:00.000-13:37")
xs:dateTime(xs:untypedAtomic( "2002-10-10T12:00:00-05:00" )) eq xs:dateTime("2002-10-10T12:00:00-05:00")
xs:date(xs:dateTime("2002-11-23T22:12:23.867-00:00")) eq xs:date("2002-11-23Z")
xs:date(xs:dateTime("2002-11-23T22:12:23.867-13:37")) eq xs:date("2002-11-23-13:37")
xs:date(xs:untypedAtomic( "2004-10-13" )) eq xs:date("2004-10-13")
xs:dayTimeDuration("")
xs:dayTimeDuration()
xs:dayTimeDuration("3DT10H")
(xs:dayTimeDuration("P01DT02H01M") div xs:dayTimeDuration("P02DT09H02M")) and (xs:dayTimeDuration("P01DT02H01M") div xs:dayTimeDuration("P02DT09H02M"))
(xs:dayTimeDuration("P05DT09H02M") div xs:dayTimeDuration("P03DT01H04M")) or (xs:dayTimeDuration("P05DT05H03M") div xs:dayTimeDuration("P01DT01H03M"))
xs:dayTimeDuration("P0DT0H0M0S") div xs:dayTimeDuration("P0DT0H0M01S")
xs:dayTimeDuration("P0DT0H0M0S") div xs:dayTimeDuration("P15DT11H59M59S")
xs:dayTimeDuration("P0DT0H0M0S") div xs:dayTimeDuration("P31DT23H59M59S")
xs:dayTimeDuration("P0DT0H0M0S") div xs:double("0.1")
xs:dayTimeDuration("P0DT0H0M0S") div xs:double("-1.7976931348623157E308")
xs:dayTimeDuration("P0DT0H0M0S") div xs:double("1.7976931348623157E308")
xs:dayTimeDuration("P0DT0H0M0S") eq xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P0DT0H0M0S") eq xs:dayTimeDuration("P15DT11H59M59S")
xs:dayTimeDuration("P0DT0H0M0S") eq xs:dayTimeDuration("P31DT23H59M59S")
xs:dayTimeDuration("P0DT0H0M0S") ge xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P0DT0H0M0S") ge xs:dayTimeDuration("P15DT11H59M59S")
xs:dayTimeDuration("P0DT0H0M0S") ge xs:dayTimeDuration("P31DT23H59M59S")
xs:dayTimeDuration("P0DT0H0M0S") gt xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P0DT0H0M0S") gt xs:dayTimeDuration("P15DT11H59M59S")
xs:dayTimeDuration("P0DT0H0M0S") gt xs:dayTimeDuration("P31DT23H59M59S")
xs:dayTimeDuration("P0DT0H0M0S") le xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P0DT0H0M0S") le xs:dayTimeDuration("P15DT11H59M59S")
xs:dayTimeDuration("P0DT0H0M0S") le xs:dayTimeDuration("P31DT23H59M59S")
xs:dayTimeDuration("P0DT0H0M0S") lt xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P0DT0H0M0S") lt xs:dayTimeDuration("P15DT11H59M59S")
xs:dayTimeDuration("P0DT0H0M0S") lt xs:dayTimeDuration("P31DT23H59M59S")
xs:dayTimeDuration("P0DT0H0M0S") ne xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P0DT0H0M0S") ne xs:dayTimeDuration("P15DT11H59M59S")
xs:dayTimeDuration("P0DT0H0M0S") ne xs:dayTimeDuration("P31DT23H59M59S")
xs:dayTimeDuration("P0DT0H0M0S") + xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P0DT0H0M0S") - xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P0DT0H0M0S") + xs:dayTimeDuration("P15DT11H59M59S")
xs:dayTimeDuration("P0DT0H0M0S") - xs:dayTimeDuration("P15DT11H59M59S")
xs:dayTimeDuration("P0DT0H0M0S") + xs:dayTimeDuration("P31DT23H59M59S")
xs:dayTimeDuration("P0DT0H0M0S") - xs:dayTimeDuration("P31DT23H59M59S")
xs:dayTimeDuration("P0DT0H0M0S") * xs:double("0")
xs:dayTimeDuration("P0DT0H0M0S") * xs:double("-1.7976931348623157E308")
xs:dayTimeDuration("P0DT0H0M0S") * xs:double("1.7976931348623157E308")
(xs:dayTimeDuration("P10DT01H01M") * -2.0)
(xs:dayTimeDuration("P10DT01H01M") div -2.0)
(xs:dayTimeDuration("P10DT01H01M") div xs:dayTimeDuration("-P10DT01H01M"))
(xs:dayTimeDuration("P10DT01H01M") + xs:dayTimeDuration("-P11DT02H02M"))
(xs:dayTimeDuration("P10DT01H01M") - xs:dayTimeDuration("P11DT02H02M"))
(xs:dayTimeDuration("P10DT01H") ge xs:dayTimeDuration("P09DT05H")) or (fn:true())
(xs:dayTimeDuration("P10DT01H") ge xs:dayTimeDuration("P09DT06H")) or (xs:dayTimeDuration("P15DT01H") ge xs:dayTimeDuration("P02DT04H"))
(xs:dayTimeDuration("P10DT01H") le xs:dayTimeDuration("P09DT05H")) or (fn:true())
(xs:dayTimeDuration("P10DT01H") le xs:dayTimeDuration("P09DT06H")) or (xs:dayTimeDuration("P15DT01H") le xs:dayTimeDuration("P02DT04H"))
(xs:dayTimeDuration("P10DT02H") gt xs:dayTimeDuration("P01DT10H")) or (fn:true())
(xs:dayTimeDuration("P10DT02H") lt xs:dayTimeDuration("P01DT10H")) or (fn:true())
(xs:dayTimeDuration("P10DT05H") ge xs:dayTimeDuration("P20DT10H")) or (fn:false())
(xs:dayTimeDuration("P10DT05H") le xs:dayTimeDuration("P20DT10H")) or (fn:false())
(xs:dayTimeDuration("P10DT08H11M") div xs:dayTimeDuration("P05DT08H11M")) and (fn:true())
(xs:dayTimeDuration("P10DT08H") gt xs:dayTimeDuration("P10DT07H")) or (xs:dayTimeDuration("P10DT09H") gt xs:dayTimeDuration("P10DT09H"))
(xs:dayTimeDuration("P10DT08H") lt xs:dayTimeDuration("P10DT07H")) or (xs:dayTimeDuration("P10DT09H") lt xs:dayTimeDuration("P10DT09H"))
(xs:dayTimeDuration("P10DT09H") ge xs:dayTimeDuration("P10DT01H")) and (xs:dayTimeDuration("P02DT04H") ge xs:dayTimeDuration("P09DT07H"))
(xs:dayTimeDuration("P10DT09H") gt xs:dayTimeDuration("P09DT10H")) and (xs:dayTimeDuration("P10DT01H") gt xs:dayTimeDuration("P08DT06H"))
(xs:dayTimeDuration("P10DT09H") le xs:dayTimeDuration("P10DT01H")) and (xs:dayTimeDuration("P02DT04H") le xs:dayTimeDuration("P09DT07H"))
(xs:dayTimeDuration("P10DT09H") lt xs:dayTimeDuration("P09DT10H")) and (xs:dayTimeDuration("P10DT01H") lt xs:dayTimeDuration("P08DT06H"))
(xs:dayTimeDuration("P10DT10H01M") * 2.0) le xs:dayTimeDuration("P17DT10H02M")
(xs:dayTimeDuration("P10DT10H01M") div 2.0) le xs:dayTimeDuration("P17DT10H02M")
(xs:dayTimeDuration("P10DT10H01M") div xs:dayTimeDuration("P17DT10H02M")) le xs:decimal(2.0)
(xs:dayTimeDuration("P10DT10H01M") + xs:dayTimeDuration("P17DT10H02M")) le xs:dayTimeDuration("P17DT10H02M")
(xs:dayTimeDuration("P10DT10H01M") - xs:dayTimeDuration("P17DT10H02M")) le xs:dayTimeDuration("P17DT10H02M")
xs:dayTimeDuration("P10DT10H11M") div xs:dayTimeDuration("P12DT10H07M") and fn:false()
(xs:dayTimeDuration("P13DT09H09M") * 2.0) ge xs:dayTimeDuration("P18DT02H02M")
(xs:dayTimeDuration("P13DT09H09M") div 2.0) ge xs:dayTimeDuration("P18DT02H02M")
(xs:dayTimeDuration("P13DT09H09M") div xs:dayTimeDuration("P18DT02H02M")) ge xs:decimal(2.0)
(xs:dayTimeDuration("P13DT09H09M") + xs:dayTimeDuration("P18DT02H02M")) ge xs:dayTimeDuration("P18DT02H02M")
(xs:dayTimeDuration("P13DT09H09M") - xs:dayTimeDuration("P18DT02H02M")) ge xs:dayTimeDuration("P18DT02H02M")
xs:dayTimeDuration("P14D") castable as xs:dayTimeDuration
xs:dayTimeDuration("P14D") cast as xs:dayTimeDuration
xs:dayTimeDuration("P15DT11H59M59S") div xs:dayTimeDuration("P0DT0H0M01S")
xs:dayTimeDuration("P15DT11H59M59S") eq xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P15DT11H59M59S") ge xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P15DT11H59M59S") gt xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P15DT11H59M59S") le xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P15DT11H59M59S") lt xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P15DT11H59M59S") ne xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P15DT11H59M59S") + xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P15DT11H59M59S") - xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P15DT11H59M59S") * xs:double("0")
xs:dayTimeDuration("P1DT2H") eq xs:duration("P1DT2H")
xs:dayTimeDuration("P1DT2H") ne xs:duration("P1M1DT2H")
xs:dayTimeDuration("P1Y12M1D")
xs:dayTimeDuration("P20DT20H10M") div xs:dayTimeDuration("P19DT13H10M") or fn:false()
(xs:dayTimeDuration("P21DT08H12M") * 2.0) ne xs:dayTimeDuration("P08DT08H05M")
(xs:dayTimeDuration("P21DT08H12M") div 2.0) ne xs:dayTimeDuration("P08DT08H05M")
(xs:dayTimeDuration("P21DT08H12M") div xs:dayTimeDuration("P08DT08H05M")) ne xs:decimal(2.0)
(xs:dayTimeDuration("P21DT08H12M") + xs:dayTimeDuration("P08DT08H05M")) ne xs:dayTimeDuration("P08DT08H05M")
(xs:dayTimeDuration("P21DT08H12M") - xs:dayTimeDuration("P08DT08H05M")) ne xs:dayTimeDuration("P08DT08H05M")
(xs:dayTimeDuration("P23DT11H11M") * 2.0) eq xs:dayTimeDuration("P23DT11H11M")
(xs:dayTimeDuration("P23DT11H11M") div 2.0) eq xs:dayTimeDuration("P23DT11H11M")
(xs:dayTimeDuration("P23DT11H11M") div xs:dayTimeDuration("P23DT11H11M")) eq xs:decimal(2.0)
(xs:dayTimeDuration("P23DT11H11M") + xs:dayTimeDuration("P23DT11H11M")) eq xs:dayTimeDuration("P23DT11H11M")
(xs:dayTimeDuration("P23DT11H11M") - xs:dayTimeDuration("P23DT11H11M")) eq xs:dayTimeDuration("P23DT11H11M")
xs:dayTimeDuration("P24M1D")
xs:dayTimeDuration("P2DT12H5M") + xs:dayTimeDuration("P5DT12H")
xs:dayTimeDuration("P2DT12H") - xs:dayTimeDuration("P1DT10H30M")
xs:dayTimeDuration("-P2DT5H") ne xs:dayTimeDuration("P2DT5H")
(xs:dayTimeDuration("P30DT10H") gt xs:dayTimeDuration("P01DT02H")) or (fn:false())
(xs:dayTimeDuration("P30DT10H") lt xs:dayTimeDuration("P01DT02H")) or (fn:false())
xs:dayTimeDuration("P31D") ne xs:yearMonthDuration("P1M")
xs:dayTimeDuration("P31DT23H59M59S") div xs:dayTimeDuration("P0DT0H0M01S")
xs:dayTimeDuration("P31DT23H59M59S") eq xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P31DT23H59M59S") ge xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P31DT23H59M59S") gt xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P31DT23H59M59S") le xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P31DT23H59M59S") lt xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P31DT23H59M59S") ne xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P31DT23H59M59S") + xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P31DT23H59M59S") - xs:dayTimeDuration("P0DT0H0M0S")
xs:dayTimeDuration("P31DT23H59M59S") * xs:double("0")
xs:dayTimeDuration("P3D") div xs:double("-0")
xs:dayTimeDuration("P3D") div xs:double("-INF") eq xs:dayTimeDuration("PT0S")
xs:dayTimeDuration("P3D") div xs:double("INF") eq xs:dayTimeDuration("PT0S")
xs:dayTimeDuration("P3D") div xs:duration("P3Y3M")
xs:dayTimeDuration("P3D") div xs:yearMonthDuration("P3Y3M")
xs:dayTimeDuration("P3DT08H34M12.142S") lt xs:dayTimeDuration("P3DT08H34M12.143S")
xs:dayTimeDuration("P3DT08H34M12.143S") eq xs:dayTimeDuration("P3DT08H34M12.143S")
xs:dayTimeDuration("P3DT08H34M12.143S") ge xs:dayTimeDuration("P3DT08H34M12.143S")
xs:dayTimeDuration("P3DT08H34M12.143S") ge xs:duration("P1999Y10M3DT08H34M12.143S")
xs:dayTimeDuration("P3DT08H34M12.143S") ge xs:yearMonthDuration("P1999Y10M")
xs:dayTimeDuration("P3DT08H34M12.143S") gt xs:duration("P1999Y10M3DT08H34M12.143S")
xs:dayTimeDuration("P3DT08H34M12.143S") gt xs:yearMonthDuration("P1999Y10M")
xs:dayTimeDuration("P3DT08H34M12.143S") le xs:dayTimeDuration("P3DT08H34M12.143S")
xs:dayTimeDuration("P3DT08H34M12.143S") le xs:duration("P1999Y10M3DT08H34M12.143S")
xs:dayTimeDuration("P3DT08H34M12.143S") le xs:yearMonthDuration("P1999Y10M")
xs:dayTimeDuration("P3DT08H34M12.143S") lt xs:duration("P1999Y10M3DT08H34M12.143S")
xs:dayTimeDuration("P3DT08H34M12.143S") lt xs:yearMonthDuration("P1999Y10M")
xs:dayTimeDuration("P3DT08H34M12.143S") = xs:untypedAtomic("P3DT08H34M12.143S")
xs:dayTimeDuration("P3DT08H34M12.144S") ge xs:dayTimeDuration("P3DT08H34M12.143S")
xs:dayTimeDuration("P3DT08H34M12.144S") gt xs:dayTimeDuration("P3DT08H34M12.143S")
xs:dayTimeDuration("+P3DT10H")
xs:dayTimeDuration("P3DT10H+08:00")
xs:dayTimeDuration("P3DT10H30M") castable as xs:anyURI
xs:dayTimeDuration("P3DT10H30M") castable as xs:base64Binary
xs:dayTimeDuration("P3DT10H30M") castable as xs:boolean
xs:dayTimeDuration("P3DT10H30M") castable as xs:date
xs:dayTimeDuration("P3DT10H30M") castable as xs:dateTime
xs:dayTimeDuration("P3DT10H30M") castable as xs:dayTimeDuration
xs:dayTimeDuration("P3DT10H30M") castable as xs:decimal
xs:dayTimeDuration("P3DT10H30M") castable as xs:double
xs:dayTimeDuration("P3DT10H30M") castable as xs:duration
xs:dayTimeDuration("P3DT10H30M") castable as xs:float
xs:dayTimeDuration("P3DT10H30M") castable as xs:gDay
xs:dayTimeDuration("P3DT10H30M") castable as xs:gMonth
xs:dayTimeDuration("P3DT10H30M") castable as xs:gMonthDay
xs:dayTimeDuration("P3DT10H30M") castable as xs:gYear
xs:dayTimeDuration("P3DT10H30M") castable as xs:gYearMonth
xs:dayTimeDuration("P3DT10H30M") castable as xs:hexBinary
xs:dayTimeDuration("P3DT10H30M") castable as xs:integer
xs:dayTimeDuration("P3DT10H30M") castable as xs:string
xs:dayTimeDuration("P3DT10H30M") castable as xs:time
xs:dayTimeDuration("P3DT10H30M") castable as xs:untypedAtomic
xs:dayTimeDuration("P3DT10H30M") castable as xs:yearMonthDuration
xs:dayTimeDuration("P3DT10H30M") cast as xs:anyURI
xs:dayTimeDuration("P3DT10H30M") cast as xs:base64Binary
xs:dayTimeDuration("P3DT10H30M") cast as xs:boolean
xs:dayTimeDuration("P3DT10H30M") cast as xs:date
xs:dayTimeDuration("P3DT10H30M") cast as xs:dateTime
xs:dayTimeDuration("P3DT10H30M") cast as xs:dayTimeDuration
xs:dayTimeDuration("P3DT10H30M") cast as xs:decimal
xs:dayTimeDuration("P3DT10H30M") cast as xs:double
xs:dayTimeDuration("P3DT10H30M") cast as xs:duration
xs:dayTimeDuration("P3DT10H30M") cast as xs:float
xs:dayTimeDuration("P3DT10H30M") cast as xs:gDay
xs:dayTimeDuration("P3DT10H30M") cast as xs:gMonth
xs:dayTimeDuration("P3DT10H30M") cast as xs:gMonthDay
xs:dayTimeDuration("P3DT10H30M") cast as xs:gYear
xs:dayTimeDuration("P3DT10H30M") cast as xs:gYearMonth
xs:dayTimeDuration("P3DT10H30M") cast as xs:hexBinary
xs:dayTimeDuration("P3DT10H30M") cast as xs:integer
xs:dayTimeDuration("P3DT10H30M") cast as xs:string
xs:dayTimeDuration("P3DT10H30M") cast as xs:time
xs:dayTimeDuration("P3DT10H30M") cast as xs:untypedAtomic
xs:dayTimeDuration("P3DT10H30M") cast as xs:yearMonthDuration
xs:dayTimeDuration('P3DT10H30M') div xs:double('NaN')
xs:dayTimeDuration('P3DT10H30M') * xs:double('NaN')
xs:dayTimeDuration("P3DT2H") castable as xs:dayTimeDuration
xs:dayTimeDuration("P3DT2H") castable as xs:duration
xs:dayTimeDuration("P3DT2H") castable as xs:string
xs:dayTimeDuration("P3DT2H") castable as xs:untypedAtomic
xs:dayTimeDuration("P3DT2H") castable as xs:yearMonthDuration
xs:dayTimeDuration("P3DT2H") cast as xs:anyURI
xs:dayTimeDuration("P3DT2H") cast as xs:base64Binary
xs:dayTimeDuration("P3DT2H") cast as xs:boolean
xs:dayTimeDuration("P3DT2H") cast as xs:date
xs:dayTimeDuration("P3DT2H") cast as xs:dateTime
xs:dayTimeDuration("P3DT2H") cast as xs:dayTimeDuration eq xs:dayTimeDuration("P3DT2H")
xs:dayTimeDuration("P3DT2H") cast as xs:decimal
xs:dayTimeDuration("P3DT2H") cast as xs:double
xs:dayTimeDuration("P3DT2H") cast as xs:duration ne xs:duration("P1Y2M3DT10H30M")
xs:dayTimeDuration("P3DT2H") cast as xs:float
xs:dayTimeDuration("P3DT2H") cast as xs:gDay
xs:dayTimeDuration("P3DT2H") cast as xs:gMonth
xs:dayTimeDuration("P3DT2H") cast as xs:gMonthDay
xs:dayTimeDuration("P3DT2H") cast as xs:gYear
xs:dayTimeDuration("P3DT2H") cast as xs:gYearMonth
xs:dayTimeDuration("P3DT2H") cast as xs:hexBinary
xs:dayTimeDuration("P3DT2H") cast as xs:integer
xs:dayTimeDuration("P3DT2H") cast as xs:string ne xs:string("an arbitrary string")
xs:dayTimeDuration("P3DT2H") cast as xs:time
xs:dayTimeDuration("P3DT2H") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:dayTimeDuration("P3DT2H") cast as xs:yearMonthDuration ne xs:yearMonthDuration("P1Y12M")
xs:dayTimeDuration(" P3DT2H ") eq xs:dayTimeDuration(" P3DT2H ")
xs:dayTimeDuration( "P3DT2H" , "P3DT2H" )
xs:dayTimeDuration("P3DT4H3M3.100S") * 0 eq xs:dayTimeDuration("PT0S")
xs:dayTimeDuration("P3DT4H3M3.100S") div 0
xs:dayTimeDuration("P3DT4H3M3.100S") div xs:double("NaN")
xs:dayTimeDuration("P3DT4H3M3.100S") + xs:dayTimeDuration("PT0S") eq xs:dayTimeDuration("P3DT4H3M3.100S")
xs:dayTimeDuration("P3DT4H3M3.100S") - xs:dayTimeDuration("PT0S") eq xs:dayTimeDuration("P3DT4H3M3.100S")
xs:dayTimeDuration("P3DT4H3M3.100S") * xs:double("-0") eq xs:dayTimeDuration("PT0S")
xs:dayTimeDuration("P3DT4H3M3.100S") * xs:double("-INF")
xs:dayTimeDuration("P3DT4H3M3.100S") * xs:double("INF")
xs:dayTimeDuration("P3DT4H3M3.100S") * xs:double("NaN")
xs:dayTimeDuration("P3D") - xs:date("1999-08-12")
xs:dayTimeDuration("P3D") - xs:dateTime("1999-08-12T08:01:23")
xs:dayTimeDuration("P3D") * xs:dayTimeDuration("P3D")
xs:dayTimeDuration("P3D") + xs:duration("P3Y3M")
xs:dayTimeDuration("P3D") - xs:duration("P3Y3M")
xs:dayTimeDuration("P3D") - xs:time("08:01:23")
xs:dayTimeDuration("P3D") * xs:yearMonthDuration("P3Y3M")
xs:dayTimeDuration("P3D") + xs:yearMonthDuration("P3Y3M")
xs:dayTimeDuration("P3D") - xs:yearMonthDuration("P3Y3M")
(xs:dayTimeDuration("P42DT10H10M") * 2.0) div (xs:dayTimeDuration("P42DT10H10M") * 2.0)
(xs:dayTimeDuration("P42DT10H10M") div 2.0) div (xs:dayTimeDuration("P42DT10H10M") div 2.0)
(xs:dayTimeDuration("P42DT10H10M") - xs:dayTimeDuration("P10DT10H10M")) div (xs:dayTimeDuration("P20DT10H10M") - xs:dayTimeDuration("P18DT10H10M"))
(xs:dayTimeDuration("P42DT10H10M") + xs:dayTimeDuration("P10DT10H10M")) div (xs:dayTimeDuration("P42DT10H10M") + xs:dayTimeDuration("P10DT10H10M"))
xs:dayTimeDuration('P5999999999999999999DT00H00M01S') * 2
xs:dayTimeDuration('P5999999999999999999DT00H00M01S') div 0.5
xs:dayTimeDuration('P5999999999999999999DT00H00M01S') div xs:dayTimeDuration('P0DT00H00M0.000001S')
xs:dayTimeDuration('P5999999999999999999DT00H00M01S') + xs:dayTimeDuration('P4999999999999999999DT00H00M01S')
xs:dayTimeDuration('P5999999999999999999DT00H00M01S') - xs:dayTimeDuration('-P5999999999999999999DT00H00M01S')
xs:dayTimeDuration("P6DT16H34M59.613999S") eq xs:dayTimeDuration("P6DT16H34M59.613999S")
xs:dayTimeDuration("P8DT4H4M4.400S") div 4 eq xs:dayTimeDuration("P2DT1H1M1.1S")
xs:dayTimeDuration("P9223372036854775806D") div xs:dayTimeDuration("P4611686018427387903D")
xs:dayTimeDuration("P9223372036854775807D") div 0.5
xs:dayTimeDuration("P9223372036854775807D") div xs:dayTimeDuration("P0D")
xs:dayTimeDuration("P9223372036854775807D") div xs:dayTimeDuration("P0DT0H0M0.000000001S")
xs:dayTimeDuration("PDT3H2M10.001S")
xs:dayTimeDuration("PT08H34M12.143S") ne xs:dayTimeDuration("P3DT08H34M12.143S")
xs:dayTimeDuration("-PT0S") eq xs:dayTimeDuration("PT0S")
xs:dayTimeDuration("PT0S") eq xs:dayTimeDuration("PT0S")
xs:dayTimeDuration("PT0S") eq xs:duration("PT0S")
xs:dayTimeDuration("PT0S") eq xs:yearMonthDuration("P0M")
xs:dayTimeDuration("PT0S") + xs:dayTimeDuration("P3DT4H3M3.100S") eq xs:dayTimeDuration("P3DT4H3M3.100S")
xs:dayTimeDuration("PT0S") - xs:dayTimeDuration("P3DT4H3M3.100S") eq xs:dayTimeDuration("-P3DT4H3M3.100S")
xs:dayTimeDuration("-PT100M") castable as xs:dayTimeDuration
xs:dayTimeDuration("-PT100M") castable as xs:duration
xs:dayTimeDuration("-PT100M") castable as xs:string
xs:dayTimeDuration("-PT100M") castable as xs:untypedAtomic
xs:dayTimeDuration("-PT100M") cast as xs:dayTimeDuration
xs:dayTimeDuration("-PT100M") cast as xs:duration
xs:dayTimeDuration("-PT100M") cast as xs:string
xs:dayTimeDuration("-PT100M") cast as xs:untypedAtomic
xs:dayTimeDuration("PT24H") castable as xs:duration
xs:dayTimeDuration("PT24H") cast as xs:duration
xs:dayTimeDuration("PT2H10M") * 2.1
(xs:dayTimeDuration("PT8M") div xs:dayTimeDuration("PT2M")) eq 4
xs:dayTimeDuration(xs:untypedAtomic( "P3DT2H" )) eq xs:dayTimeDuration("P3DT2H")
xs:decimal("")
xs:decimal()
-xs:decimal(0)
xs:decimal(0) and xs:decimal(0)
xs:decimal(0) and xs:decimal(1)
xs:decimal(0) or xs:decimal(0)
xs:decimal(0) or xs:decimal(1)
xs:decimal("0") * xs:decimal("617375191608514839")
xs:decimal("0") - xs:decimal("-999999999999999999")
xs:decimal("0") - xs:decimal("999999999999999999")
xs:decimal("-1.0000000000") * xs:decimal("-999999999999999999")
xs:decimal("-1.0000000000") * xs:decimal("999999999999999999")
xs:decimal( "10.01" , "10.01" )
xs:decimal("10.01") castable as xs:boolean
xs:decimal("10.01") castable as xs:decimal
xs:decimal("10.01") castable as xs:double
xs:decimal("10.01") castable as xs:float
xs:decimal("10.01") castable as xs:integer
xs:decimal("10.01") castable as xs:string
xs:decimal("10.01") castable as xs:untypedAtomic
xs:decimal("10.01") cast as xs:anyURI
xs:decimal("10.01") cast as xs:base64Binary
xs:decimal("10.01") cast as xs:boolean eq xs:boolean("true")
xs:decimal("10.01") cast as xs:date
xs:decimal("10.01") cast as xs:dateTime
xs:decimal("10.01") cast as xs:dayTimeDuration
xs:decimal("10.01") cast as xs:decimal eq xs:decimal("10.01")
xs:decimal("10.01") cast as xs:double ne xs:double("3.3e3")
xs:decimal("10.01") cast as xs:duration
xs:decimal("10.01") cast as xs:float ne xs:float("3.4e5")
xs:decimal("10.01") cast as xs:gDay
xs:decimal("10.01") cast as xs:gMonth
xs:decimal("10.01") cast as xs:gMonthDay
xs:decimal("10.01") cast as xs:gYear
xs:decimal("10.01") cast as xs:gYearMonth
xs:decimal("10.01") cast as xs:hexBinary
xs:decimal("10.01") cast as xs:integer ne xs:integer("6789")
xs:decimal("10.01") cast as xs:string ne xs:string("an arbitrary string")
xs:decimal("10.01") cast as xs:time
xs:decimal("10.01") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:decimal("10.01") cast as xs:yearMonthDuration
xs:decimal(" 10.01 ") eq xs:decimal(" 10.01 ")
xs:decimal("-1.1234") castable as xs:anyURI
xs:decimal("-1.1234") castable as xs:base64Binary
xs:decimal("-1.1234") castable as xs:boolean
xs:decimal("-1.1234") castable as xs:date
xs:decimal("-1.1234") castable as xs:dateTime
xs:decimal("-1.1234") castable as xs:dayTimeDuration
xs:decimal("-1.1234") castable as xs:decimal
xs:decimal("-1.1234") castable as xs:double
xs:decimal("-1.1234") castable as xs:duration
xs:decimal("-1.1234") castable as xs:float
xs:decimal("-1.1234") castable as xs:gDay
xs:decimal("-1.1234") castable as xs:gMonth
xs:decimal("-1.1234") castable as xs:gMonthDay
xs:decimal("-1.1234") castable as xs:gYear
xs:decimal("-1.1234") castable as xs:gYearMonth
xs:decimal("-1.1234") castable as xs:hexBinary
xs:decimal("-1.1234") castable as xs:integer
xs:decimal("-1.1234") castable as xs:string
xs:decimal("-1.1234") castable as xs:time
xs:decimal("-1.1234") castable as xs:untypedAtomic
xs:decimal("-1.1234") castable as xs:yearMonthDuration
xs:decimal("-1.1234") cast as xs:anyURI
xs:decimal("-1.1234") cast as xs:base64Binary
xs:decimal("-1.1234") cast as xs:boolean
xs:decimal("-1.1234") cast as xs:date
xs:decimal("-1.1234") cast as xs:dateTime
xs:decimal("-1.1234") cast as xs:dayTimeDuration
xs:decimal("-1.1234") cast as xs:decimal
xs:decimal("-1.1234") cast as xs:double
xs:decimal("-1.1234") cast as xs:duration
xs:decimal("-1.1234") cast as xs:float
xs:decimal("-1.1234") cast as xs:gDay
xs:decimal("-1.1234") cast as xs:gMonth
xs:decimal("-1.1234") cast as xs:gMonthDay
xs:decimal("-1.1234") cast as xs:gYear
xs:decimal("-1.1234") cast as xs:gYearMonth
xs:decimal("-1.1234") cast as xs:hexBinary
xs:decimal("-1.1234") cast as xs:integer
xs:decimal("-1.1234") cast as xs:string
xs:decimal("-1.1234") cast as xs:time
xs:decimal("-1.1234") cast as xs:untypedAtomic
xs:decimal("-1.1234") cast as xs:yearMonthDuration
xs:decimal(-1.1) eq xs:decimal(-1.1)
xs:decimal(1.1) eq xs:decimal(1.1)
xs:decimal(1.1) ne xs:decimal(2.1)
(xs:decimal(1), 2, 3)
xs:decimal(-123456789.123456789123456789) and xs:decimal(1)
xs:decimal(-123456789.123456789123456789) or xs:decimal(1)
xs:decimal(12678967.543233) cast as xs:boolean
xs:decimal(12678967.543233) cast as xs:decimal
xs:decimal(12678967.543233) cast as xs:integer
xs:decimal(12678967.543233) cast as xs:string
xs:decimal(-1) and xs:decimal(0)
xs:decimal(1) and xs:decimal(-1)
xs:decimal(1) ge xs:decimal(1)
xs:decimal(1) gt xs:decimal(-1)
xs:decimal(-1) le xs:decimal(1)
xs:decimal(-1) lt xs:decimal(1)
xs:decimal(-1) or xs:decimal(0)
xs:decimal(1) or xs:decimal(-1)
xs:decimal(3.1) eq 3.1
xs:decimal("-382624808391485160") - xs:decimal("617375191608514839")
xs:decimal(3) eq 3
xs:decimal("5.5432") castable as xs:integer
xs:decimal("5.5432") cast as xs:integer
xs:decimal(5) div xs:decimal(2) eq 2.5
xs:decimal(5) div xs:decimal(2) ne 2.6
(xs:decimal(5) mod xs:untypedAtomic("3")) eq 2
+(xs:decimal("617375191608514839"))
-(xs:decimal("617375191608514839"))
xs:decimal("617375191608514839") eq xs:decimal("-999999999999999999")
xs:decimal("617375191608514839") ge xs:decimal("-999999999999999999")
xs:decimal("617375191608514839") gt xs:decimal("-999999999999999999")
xs:decimal("617375191608514839") idiv xs:decimal("-999999999999999999")
xs:decimal("617375191608514839") lt xs:decimal("-999999999999999999")
xs:decimal("617375191608514839") ne xs:decimal("-999999999999999999")
xs:decimal("617375191608514839") * xs:decimal("0")
xs:decimal("617375191608514839") + xs:decimal("-999999999999999999")
xs:decimal(6.1) + xs:decimal(2.1) eq 8.2
xs:decimal(6) div xs:decimal(2) eq 3
(xs:decimal(6) div xs:decimal(2)) instance of xs:decimal
(xs:decimal(6) div xs:double(2)) instance of xs:double
(xs:decimal(6) div xs:integer(2)) instance of xs:decimal
(xs:decimal(6) idiv xs:decimal(2)) instance of xs:integer
(xs:decimal(6) idiv xs:double(2)) instance of xs:integer
(xs:decimal(6) idiv xs:float(2)) instance of xs:integer
(xs:decimal(6) idiv xs:integer(2)) instance of xs:integer
xs:decimal(6) instance of xs:decimal
(xs:decimal(6) mod xs:decimal(2)) instance of xs:decimal
(xs:decimal(6) mod xs:double(2)) instance of xs:double
(xs:decimal(6) mod xs:integer(2)) instance of xs:decimal
xs:decimal(6) * xs:decimal(2) eq 12
xs:decimal(6) - xs:decimal(2) eq 4
xs:decimal(6) + xs:decimal(2) eq 8
(xs:decimal(6) * xs:decimal(2)) instance of xs:decimal
(xs:decimal(6) + xs:decimal(2)) instance of xs:decimal
(xs:decimal(6) - xs:decimal(2)) instance of xs:decimal
(xs:decimal(6) * xs:double(2)) instance of xs:double
(xs:decimal(6) + xs:double(2)) instance of xs:double
(xs:decimal(6) - xs:double(2)) instance of xs:double
(xs:decimal(6) * xs:integer(2)) instance of xs:decimal
(xs:decimal(6) + xs:integer(2)) instance of xs:decimal
(xs:decimal(6) - xs:integer(2)) instance of xs:decimal
+(xs:decimal("-999999999999999999"))
+(xs:decimal("999999999999999999"))
-(xs:decimal("-999999999999999999"))
-(xs:decimal("999999999999999999"))
xs:decimal(9.99999999999999999999999999) and xs:decimal(0)
xs:decimal(9.99999999999999999999999999) and xs:decimal(-123456789.123456789123456789)
xs:decimal(9.99999999999999999999999999) or xs:decimal(0)
xs:decimal(9.99999999999999999999999999) or xs:decimal(-123456789.123456789123456789)
xs:decimal("-999999999999999999") div xs:decimal("-999999999999999999")
xs:decimal("-999999999999999999") div xs:decimal("999999999999999999")
xs:decimal("999999999999999999") div xs:decimal("-999999999999999999")
xs:decimal("-999999999999999999") eq xs:decimal("617375191608514839")
xs:decimal("-999999999999999999") eq xs:decimal("-999999999999999999")
xs:decimal("-999999999999999999") eq xs:decimal("999999999999999999")
xs:decimal("999999999999999999") eq xs:decimal("-999999999999999999")
xs:decimal("-999999999999999999") ge xs:decimal("617375191608514839")
xs:decimal("-999999999999999999") ge xs:decimal("-999999999999999999")
xs:decimal("-999999999999999999") ge xs:decimal("999999999999999999")
xs:decimal("999999999999999999") ge xs:decimal("-999999999999999999")
xs:decimal("-999999999999999999") gt xs:decimal("617375191608514839")
xs:decimal("-999999999999999999") gt xs:decimal("-999999999999999999")
xs:decimal("-999999999999999999") gt xs:decimal("999999999999999999")
xs:decimal("999999999999999999") gt xs:decimal("-999999999999999999")
xs:decimal("-999999999999999999") idiv xs:decimal("617375191608514839")
xs:decimal("-999999999999999999") idiv xs:decimal("-999999999999999999")
xs:decimal("-999999999999999999") idiv xs:decimal("999999999999999999")
xs:decimal("999999999999999999") idiv xs:decimal("-999999999999999999")
xs:decimal("-999999999999999999") lt xs:decimal("617375191608514839")
xs:decimal("-999999999999999999") lt xs:decimal("-999999999999999999")
xs:decimal("-999999999999999999") lt xs:decimal("999999999999999999")
xs:decimal("999999999999999999") lt xs:decimal("-999999999999999999")
xs:decimal("-999999999999999999") mod xs:decimal("617375191608514839")
xs:decimal("-999999999999999999") mod xs:decimal("999999999999999999")
xs:decimal("-999999999999999999") ne xs:decimal("617375191608514839")
xs:decimal("-999999999999999999") ne xs:decimal("-999999999999999999")
xs:decimal("-999999999999999999") ne xs:decimal("999999999999999999")
xs:decimal("999999999999999999") ne xs:decimal("-999999999999999999")
xs:decimal("999999999999999999") * xs:decimal("-1.0000000000")
xs:decimal("-999999999999999999") + xs:decimal("617375191608514839")
xs:decimal("-999999999999999999") + xs:decimal("999999999999999999")
xs:decimal("-999999999999999999") - xs:decimal("-999999999999999999")
xs:decimal("999999999999999999") + xs:decimal("-999999999999999999")
xs:decimal(99e100)
xs:decimal(fn:translate("123","123","123"))
xs:decimal("inf")
xs:decimal("inF")
xs:decimal("+Inf")
xs:decimal("-Inf")
xs:decimal("Inf")
xs:decimal("+InF")
xs:decimal("-InF")
xs:decimal("InF")
xs:decimal("+ INF")
xs:decimal("+INF")
xs:decimal("- INF")
xs:decimal("INF")
xs:decimal("nan")
xs:decimal("naN")
xs:decimal("NaN")
xs:decimal(remove((1, 2, 3), 1))
(xs:decimal(remove((3e3, 1.1), 1))) eq 1.1
xs:decimal(xs:byte(3))
xs:decimal(xs:double("-INF"))
xs:decimal(xs:double("INF"))
xs:decimal(xs:double("NaN"))
xs:decimal(xs:float("-INF"))
xs:decimal(xs:float("INF"))
xs:decimal(xs:float("NaN"))
xs:decimal(xs:int(3))
xs:decimal(xs:long(3))
xs:decimal(xs:negativeInteger(-3))
xs:decimal(xs:nonNegativeInteger(3))
xs:decimal(xs:nonPositiveInteger(0))
xs:decimal(xs:short(3))
xs:decimal(xs:unsignedByte(3))
xs:decimal(xs:unsignedInt(3))
xs:decimal(xs:unsignedLong(3))
xs:decimal(xs:unsignedShort(3))
xs:decimal(xs:untypedAtomic( "10.01" )) eq xs:decimal("10.01")
xs:double("")
xs:double()
+(xs:double("0"))
-(xs:double("0"))
-xs:double(0)
xs:double(-0.0)
xs:double("-0.0E0") castable as xs:decimal
xs:double("-0.0E0") castable as xs:float
xs:double("-0.0E0") castable as xs:integer
xs:double("-0.0E0") cast as xs:decimal
xs:double("-0.0E0") cast as xs:float
xs:double("-0.0E0") cast as xs:integer
xs:double(0) and xs:double(0)
xs:double(0) and xs:double(1)
xs:double("0") div xs:double("-1.7976931348623157E308")
xs:double("0") eq xs:double("-1.7976931348623157E308")
xs:double("0") ge xs:double("-1.7976931348623157E308")
xs:double("0") gt xs:double("-1.7976931348623157E308")
xs:double("0") lt xs:double("-1.7976931348623157E308")
xs:double("-0") mod 3
xs:double("0") mod 3
xs:double("-0") mod xs:double("-0")
xs:double("-0") mod xs:double("4")
xs:double("0") mod xs:double("4")
xs:double("-0") mod xs:double("-INF")
xs:double("-0") mod xs:double("INF")
xs:double("0") mod xs:double("-INF")
xs:double("0") mod xs:double("INF")
xs:double("0") ne xs:double("-1.7976931348623157E308")
xs:double("0") ne xs:double("-INF")
xs:double("0") ne xs:double("INF")
xs:double(0) ne xs:double("NaN")
xs:double(0) or xs:double(0)
xs:double(0) or xs:double(1)
xs:double("-0") * xs:dayTimeDuration("P3DT4H3M3.100S") eq xs:dayTimeDuration("PT0S")
(xs:double("0")||xs:double("-1.7976931348623157E308"))
xs:double("0") * xs:double("-1.7976931348623157E308")
xs:double("0") + xs:double("-1.7976931348623157E308")
xs:double("0") - xs:double("-1.7976931348623157E308")
xs:double("0") - xs:double("1.7976931348623157E308")
xs:double("-1.0000000000") * xs:double("-1.7976931348623157E308")
xs:double("-1.0000000000") * xs:double("1.7976931348623157E308")
xs:double("-10000000") mod xs:double("-10000000")
xs:double("-10000000") mod xs:double("10000000")
xs:double("10000000") mod xs:double("-10000000")
xs:double("10000000") mod xs:double("10000000")
xs:double(-1.1) eq xs:double(-1.1)
xs:double(1.1) eq xs:double(1.1)
(xs:double(1.1) idiv 1.1) instance of xs:integer
xs:double(1.1) ne xs:double(2.1)
xs:double(1.1) + xs:double(2.2) ne 3.3
xs:double(1267.43233E12) cast as xs:boolean
(xs:double(1267.43233E12) cast as xs:float) eq xs:float(1267.43233E12)
xs:double("12.78e-2") idiv xs:double("3")
(xs:double(1.2E2), 2.2E2, 3.3E2)
xs:double(1.5) idiv xs:decimal(1)
xs:double("-1.75e-3") castable as xs:decimal
xs:double("-1.75e-3") castable as xs:float
xs:double("-1.75e-3") castable as xs:integer
xs:double("-1.75e-3") cast as xs:float
xs:double("-1.75e-3") cast as xs:integer
+(xs:double("-1.7976931348623157E308"))
+(xs:double("1.7976931348623157E308"))
-(xs:double("-1.7976931348623157E308"))
-(xs:double("1.7976931348623157E308"))
xs:double("-1.7976931348623157E308") div xs:double("-1.7976931348623157E308")
xs:double("-1.7976931348623157E308") div xs:double("1.7976931348623157E308")
xs:double("1.7976931348623157E308") div xs:double("-1.7976931348623157E308")
xs:double("-1.7976931348623157E308") eq xs:double("0")
xs:double("-1.7976931348623157E308") eq xs:double("-1.7976931348623157E308")
xs:double("-1.7976931348623157E308") eq xs:double("1.7976931348623157E308")
xs:double("1.7976931348623157E308") eq xs:double("-1.7976931348623157E308")
xs:double("-1.7976931348623157E308") ge xs:double("0")
xs:double("-1.7976931348623157E308") ge xs:double("-1.7976931348623157E308")
xs:double("-1.7976931348623157E308") ge xs:double("1.7976931348623157E308")
xs:double("1.7976931348623157E308") ge xs:double("-1.7976931348623157E308")
xs:double("-1.7976931348623157E308") gt xs:double("0")
xs:double("-1.7976931348623157E308") gt xs:double("-1.7976931348623157E308")
xs:double("-1.7976931348623157E308") gt xs:double("1.7976931348623157E308")
xs:double("1.7976931348623157E308") gt xs:double("-1.7976931348623157E308")
xs:double("-1.7976931348623157E308") lt xs:double("0")
xs:double("-1.7976931348623157E308") lt xs:double("-1.7976931348623157E308")
xs:double("-1.7976931348623157E308") lt xs:double("1.7976931348623157E308")
xs:double("1.7976931348623157E308") lt xs:double("-1.7976931348623157E308")
xs:double("-1.7976931348623157E308") mod xs:double("1.7976931348623157E308")
xs:double("-1.7976931348623157E308") ne xs:double("0")
xs:double("-1.7976931348623157E308") ne xs:double("-1.7976931348623157E308")
xs:double("-1.7976931348623157E308") ne xs:double("1.7976931348623157E308")
xs:double("1.7976931348623157E308") ne xs:double("-1.7976931348623157E308")
(xs:double("-1.7976931348623157E308") || xs:double("0"))
xs:double("-1.7976931348623157E308") * xs:double("0")
xs:double("-1.7976931348623157E308") + xs:double("0")
xs:double("-1.7976931348623157E308") - xs:double("0")
xs:double("1.7976931348623157E308") * xs:double("-1.0000000000")
(xs:double("-1.7976931348623157E308") || xs:double("1.7976931348623157E308"))
(xs:double("-1.7976931348623157E308")||xs:double("-1.7976931348623157E308"))
(xs:double("1.7976931348623157E308")||xs:double("-1.7976931348623157E308"))
xs:double("-1.7976931348623157E308") + xs:double("1.7976931348623157E308")
xs:double("-1.7976931348623157E308") - xs:double("-1.7976931348623157E308")
xs:double("1.7976931348623157E308") + xs:double("-1.7976931348623157E308")
xs:double(-1) and xs:double(0)
xs:double(1) and xs:double(-1)
xs:double("1e5") castable as xs:anyURI
xs:double("1e5") castable as xs:base64Binary
xs:double("1e5") castable as xs:boolean
xs:double("1e5") castable as xs:date
xs:double("1e5") castable as xs:dateTime
xs:double("1e5") castable as xs:dayTimeDuration
xs:double("1e5") castable as xs:double
xs:double("1e5") castable as xs:duration
xs:double("1e5") castable as xs:float
xs:double("1e5") castable as xs:gDay
xs:double("1e5") castable as xs:gMonth
xs:double("1e5") castable as xs:gMonthDay
xs:double("1e5") castable as xs:gYear
xs:double("1e5") castable as xs:gYearMonth
xs:double("1e5") castable as xs:hexBinary
xs:double("1e5") castable as xs:integer
xs:double("1e5") castable as xs:time
xs:double("1e5") castable as xs:untypedAtomic
xs:double("1e5") castable as xs:yearMonthDuration
xs:double("1e5") cast as xs:anyURI
xs:double("1e5") cast as xs:base64Binary
xs:double("1e5") cast as xs:boolean
xs:double("1e5") cast as xs:date
xs:double("1e5") cast as xs:dateTime
xs:double("1e5") cast as xs:dayTimeDuration
xs:double("1e5") cast as xs:double
xs:double("1e5") cast as xs:duration
xs:double("1e5") cast as xs:float
xs:double("1e5") cast as xs:gDay
xs:double("1e5") cast as xs:gMonth
xs:double("1e5") cast as xs:gMonthDay
xs:double("1e5") cast as xs:gYear
xs:double("1e5") cast as xs:gYearMonth
xs:double("1e5") cast as xs:hexBinary
xs:double("1e5") cast as xs:integer
xs:double("1e5") cast as xs:time
xs:double("1e5") cast as xs:untypedAtomic
xs:double("1e5") cast as xs:yearMonthDuration
xs:double("1e8") castable as xs:string
xs:double(1) ge xs:double(1)
xs:double(1) gt xs:double(-1)
xs:double("1") idiv xs:double("0.0E0")
xs:double("1") idiv xs:double("NaN")
xs:double(-1) le xs:double(1)
xs:double(-1) lt xs:double(1)
xs:double(-1) ne xs:double(1)
xs:double(-1) or xs:double(0)
xs:double(1) or xs:double(-1)
(xs:double(1), xs:double(2), xs:double(3)) castable as xs:double*
xs:double("2.2250738585072012e-308")
xs:double(3.1) eq 3.1
xs:double( "3.3e3" , "3.3e3" )
xs:double("3.3e3") castable as xs:boolean
xs:double("3.3e3") castable as xs:double
xs:double("3.3e3") castable as xs:float
xs:double("3.3e3") castable as xs:string
xs:double("3.3e3") castable as xs:untypedAtomic
xs:double("3.3e3") cast as xs:anyURI
xs:double("3.3e3") cast as xs:base64Binary
xs:double("3.3e3") cast as xs:boolean eq xs:boolean("true")
xs:double("3.3e3") cast as xs:date
xs:double("3.3e3") cast as xs:dateTime
xs:double("3.3e3") cast as xs:dayTimeDuration
xs:double("3.3e3") cast as xs:double eq xs:double("3.3e3")
xs:double("3.3e3") cast as xs:duration
xs:double("3.3e3") cast as xs:float ne xs:float("3.4e5")
xs:double("3.3e3") cast as xs:gDay
xs:double("3.3e3") cast as xs:gMonth
xs:double("3.3e3") cast as xs:gMonthDay
xs:double("3.3e3") cast as xs:gYear
xs:double("3.3e3") cast as xs:gYearMonth
xs:double("3.3e3") cast as xs:hexBinary
xs:double("3.3e3") cast as xs:string ne xs:string("an arbitrary string")
xs:double("3.3e3") cast as xs:time
xs:double("3.3e3") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:double("3.3e3") cast as xs:yearMonthDuration
xs:double(" 3.3e3 ") eq xs:double(" 3.3e3 ")
xs:double(3) div "3"
(xs:double(3) div xs:untypedAtomic("3")) eq 1
xs:double(3) eq 3
xs:double("3") gt xs:double("NaN")
xs:double("3") idiv xs:double("-INF") eq xs:double(0)
xs:double("3") idiv xs:double("INF") eq xs:double(0)
xs:double("5.4321E-1001") castable as xs:decimal
xs:double("5.4321E-1001") castable as xs:float
xs:double("5.4321E-1001") cast as xs:decimal
xs:double("5.4321E-1001") cast as xs:float
xs:double(5) div xs:double(2) eq 2.5
xs:double(5) div xs:double(2) ne 2.6
(xs:double(6) div xs:decimal(2)) instance of xs:double
xs:double(6) div xs:double(2) eq 3
(xs:double(6) div xs:double(2)) instance of xs:double
(xs:double(6) div xs:float(2)) instance of xs:double
(xs:double(6) div xs:integer(2)) instance of xs:double
(xs:double(6) idiv xs:decimal(2)) instance of xs:integer
(xs:double(6) idiv xs:double(2)) instance of xs:integer
(xs:double(6) idiv xs:float(2)) instance of xs:integer
(xs:double(6) idiv xs:integer(2)) instance of xs:integer
xs:double(6) instance of xs:double
(xs:double(6) mod xs:decimal(2)) instance of xs:double
(xs:double(6) mod xs:double(2)) instance of xs:double
(xs:double(6) mod xs:float(2)) instance of xs:double
(xs:double(6) mod xs:integer(2)) instance of xs:double
(xs:double(6) * xs:decimal(2)) instance of xs:double
(xs:double(6) + xs:decimal(2)) instance of xs:double
(xs:double(6) - xs:decimal(2)) instance of xs:double
xs:double(6) * xs:double(2) eq 12
xs:double(6) - xs:double(2) eq 4
xs:double(6) + xs:double(2) eq 8
(xs:double(6) * xs:double(2)) instance of xs:double
(xs:double(6) + xs:double(2)) instance of xs:double
(xs:double(6) - xs:double(2)) instance of xs:double
(xs:double(6) * xs:float(2)) instance of xs:double
(xs:double(6) + xs:float(2)) instance of xs:double
(xs:double(6) - xs:float(2)) instance of xs:double
(xs:double(6) * xs:integer(2)) instance of xs:double
(xs:double(6) + xs:integer(2)) instance of xs:double
(xs:double(6) - xs:integer(2)) instance of xs:double
xs:double(fn:translate("123","123","123"))
xs:double("inf")
xs:double("inF")
xs:double("+Inf")
xs:double("-Inf")
xs:double("Inf")
xs:double("+InF")
xs:double("-InF")
xs:double("InF")
xs:double(" INF ")
xs:double("+ INF")
xs:double("+INF")
xs:double("- INF")
xs:double('-INF') and xs:double(0)
xs:double('INF') and xs:double(0)
xs:double('-INF') and xs:double(1)
xs:double('INF') and xs:double(1)
xs:double('-INF') and xs:double('INF')
xs:double('-INF') and xs:double('NaN')
xs:double('INF') and xs:double('NaN')
xs:double("INF") castable as xs:decimal
xs:double('-INF') castable as xs:decimal
xs:double('INF') castable as xs:decimal
xs:double("INF") castable as xs:double
xs:double("INF") castable as xs:integer
xs:double("INF") castable as xs:string
xs:double("INF") castable as xs:untypedAtomic
xs:double("INF") cast as xs:decimal
xs:double("INF") cast as xs:double
xs:double("INF") cast as xs:integer
xs:double("INF") cast as xs:string
xs:double("INF") cast as xs:untypedAtomic
xs:double("-INF") eq xs:double("-INF")
xs:double("INF") eq xs:double("INF")
xs:double("INF") gt 0
xs:double("INF") idiv xs:double("0")
xs:double("-INF") idiv xs:double("1")
xs:double("-INF") idiv xs:double(3)
xs:double("INF") idiv xs:double(3)
xs:double('INF') idiv xs:integer(2)
xs:double("-INF") lt 0
xs:double("-INF") mod 3
xs:double("INF") mod 3
xs:double("-INF") mod xs:double("-INF")
xs:double("INF") mod xs:double("INF")
xs:double("-INF") ne xs:double("0")
xs:double("INF") ne xs:double("0")
xs:double("-INF") ne xs:double("INF")
xs:double("INF") ne xs:double("-INF")
xs:double('-INF') or xs:double(0)
xs:double('INF') or xs:double(0)
xs:double('-INF') or xs:double(1)
xs:double('INF') or xs:double(1)
xs:double('-INF') or xs:double('INF')
xs:double('-INF') or xs:double('NaN')
xs:double('INF') or xs:double('NaN')
xs:double('-INF')[string() = '-INF']
xs:double("INF"), xs:double("-INF"), xs:float("-INF")
xs:double("nan")
xs:double("naN")
xs:double(" NaN ")
xs:double('NaN') and xs:double(0)
xs:double('NaN') and xs:double(1)
xs:double('NaN') and xs:double('NaN')
xs:double('NaN') castable as xs:decimal
xs:double("NaN") castable as xs:float
xs:double("NaN") castable as xs:integer
xs:double("NaN") cast as xs:float
xs:double("NaN") cast as xs:integer
xs:double("NaN") idiv 1
xs:double("NaN") mod 3
xs:double("NaN") mod xs:double("NaN")
xs:double("NaN") ne xs:double(0)
xs:double("NaN") ne xs:double("NaN")
xs:double('NaN') or xs:double(0)
xs:double('NaN') or xs:double(1)
xs:double('NaN') or xs:double('NaN')
xs:double('NaN') * xs:yearMonthDuration("P2Y")
xs:double(xs:byte(3))
xs:double(xs:int(3))
xs:double(xs:long(3))
xs:double(xs:negativeInteger(-3))
xs:double(xs:nonNegativeInteger(3))
xs:double(xs:nonPositiveInteger(0))
xs:double(xs:positiveInteger("52"))
xs:double(xs:short(3))
xs:double(xs:unsignedByte(3))
xs:double(xs:unsignedInt(3))
xs:double(xs:unsignedLong(3))
xs:double(xs:unsignedShort(3))
xs:double(xs:untypedAtomic( "3.3e3" )) eq xs:double("3.3e3")
xs:duration("")
xs:duration()
xs:duration("1Y2M123DT10H30M99S")
xs:duration("P12M") eq xs:duration("P12M")
xs:duration("P12M") ne xs:duration("P12M")
xs:duration("P1999Y01M3DT08H34M12.143S") ne xs:duration("P1999Y10M3DT08H34M12.143S")
xs:duration("P1999Y10M3DT08H34M12.142S") lt xs:duration("P1999Y10M3DT08H34M12.143S")
xs:duration("P1999Y10M3DT08H34M12.143S") eq xs:duration("P1999Y10M3DT08H34M12.143S")
xs:duration("P1999Y10M3DT08H34M12.143S") ge xs:dayTimeDuration("P3DT08H34M12.143S")
xs:duration("P1999Y10M3DT08H34M12.143S") ge xs:duration("P1999Y10M3DT08H34M12.143S")
xs:duration("P1999Y10M3DT08H34M12.143S") gt xs:dayTimeDuration("P3DT08H34M12.143S")
xs:duration("P1999Y10M3DT08H34M12.143S") le xs:dayTimeDuration("P3DT08H34M12.143S")
xs:duration("P1999Y10M3DT08H34M12.143S") le xs:duration("P1999Y10M3DT08H34M12.143S")
xs:duration("P1999Y10M3DT08H34M12.143S") lt xs:dayTimeDuration("P3DT08H34M12.143S")
xs:duration("P1999Y10M3DT08H34M12.144S") gt xs:duration("P1999Y10M3DT08H34M12.143S")
xs:duration("P1DT2H") eq xs:dayTimeDuration("P1DT2H")
xs:duration("P1M1DT2H") ne xs:dayTimeDuration("P1DT2H")
xs:duration("P1M") ne xs:duration("P31D")
xs:duration("P1Y12M0D") eq xs:yearMonthDuration("P1Y12M")
xs:duration("+P1Y2M123DT10H30M99S")
xs:duration("P1Y2M123DT10H30M99S+08:00")
xs:duration("P1Y2M3DT10H30M23S") castable as xs:anyURI
xs:duration("P1Y2M3DT10H30M23S") castable as xs:base64Binary
xs:duration("P1Y2M3DT10H30M23S") castable as xs:boolean
xs:duration("P1Y2M3DT10H30M23S") castable as xs:date
xs:duration("P1Y2M3DT10H30M23S") castable as xs:dateTime
xs:duration("P1Y2M3DT10H30M23S") castable as xs:dayTimeDuration
xs:duration("P1Y2M3DT10H30M23S") castable as xs:decimal
xs:duration("P1Y2M3DT10H30M23S") castable as xs:double
xs:duration("P1Y2M3DT10H30M23S") castable as xs:duration
xs:duration("P1Y2M3DT10H30M23S") castable as xs:float
xs:duration("P1Y2M3DT10H30M23S") castable as xs:gDay
xs:duration("P1Y2M3DT10H30M23S") castable as xs:gMonth
xs:duration("P1Y2M3DT10H30M23S") castable as xs:gMonthDay
xs:duration("P1Y2M3DT10H30M23S") castable as xs:gYear
xs:duration("P1Y2M3DT10H30M23S") castable as xs:gYearMonth
xs:duration("P1Y2M3DT10H30M23S") castable as xs:hexBinary
xs:duration("P1Y2M3DT10H30M23S") castable as xs:integer
xs:duration("P1Y2M3DT10H30M23S") castable as xs:string
xs:duration("P1Y2M3DT10H30M23S") castable as xs:time
xs:duration("P1Y2M3DT10H30M23S") castable as xs:untypedAtomic
xs:duration("P1Y2M3DT10H30M23S") castable as xs:yearMonthDuration
xs:duration("P1Y2M3DT10H30M23S") cast as xs:anyURI
xs:duration("P1Y2M3DT10H30M23S") cast as xs:base64Binary
xs:duration("P1Y2M3DT10H30M23S") cast as xs:boolean
xs:duration("P1Y2M3DT10H30M23S") cast as xs:date
xs:duration("P1Y2M3DT10H30M23S") cast as xs:dateTime
xs:duration("P1Y2M3DT10H30M23S") cast as xs:dayTimeDuration
xs:duration("P1Y2M3DT10H30M23S") cast as xs:decimal
xs:duration("P1Y2M3DT10H30M23S") cast as xs:double
xs:duration("P1Y2M3DT10H30M23S") cast as xs:duration
xs:duration("P1Y2M3DT10H30M23S") cast as xs:float
xs:duration("P1Y2M3DT10H30M23S") cast as xs:gDay
xs:duration("P1Y2M3DT10H30M23S") cast as xs:gMonth
xs:duration("P1Y2M3DT10H30M23S") cast as xs:gMonthDay
xs:duration("P1Y2M3DT10H30M23S") cast as xs:gYear
xs:duration("P1Y2M3DT10H30M23S") cast as xs:gYearMonth
xs:duration("P1Y2M3DT10H30M23S") cast as xs:hexBinary
xs:duration("P1Y2M3DT10H30M23S") cast as xs:integer
xs:duration("P1Y2M3DT10H30M23S") cast as xs:string
xs:duration("P1Y2M3DT10H30M23S") cast as xs:time
xs:duration("P1Y2M3DT10H30M23S") cast as xs:untypedAtomic
xs:duration("P1Y2M3DT10H30M23S") cast as xs:yearMonthDuration
xs:duration("P1Y2M3DT10H30M") castable as xs:dayTimeDuration
xs:duration("P1Y2M3DT10H30M") castable as xs:duration
xs:duration("P1Y2M3DT10H30M") castable as xs:string
xs:duration("P1Y2M3DT10H30M") castable as xs:untypedAtomic
xs:duration("P1Y2M3DT10H30M") castable as xs:yearMonthDuration
xs:duration("P1Y2M3DT10H30M") cast as xs:anyURI
xs:duration("P1Y2M3DT10H30M") cast as xs:base64Binary
xs:duration("P1Y2M3DT10H30M") cast as xs:boolean
xs:duration("P1Y2M3DT10H30M") cast as xs:date
xs:duration("P1Y2M3DT10H30M") cast as xs:dateTime
xs:duration("P1Y2M3DT10H30M") cast as xs:dayTimeDuration ne xs:dayTimeDuration("P3DT2H")
xs:duration("P1Y2M3DT10H30M") cast as xs:decimal
xs:duration("P1Y2M3DT10H30M") cast as xs:double
xs:duration("P1Y2M3DT10H30M") cast as xs:duration eq xs:duration("P1Y2M3DT10H30M")
xs:duration("P1Y2M3DT10H30M") cast as xs:float
xs:duration("P1Y2M3DT10H30M") cast as xs:gDay
xs:duration("P1Y2M3DT10H30M") cast as xs:gMonth
xs:duration("P1Y2M3DT10H30M") cast as xs:gMonthDay
xs:duration("P1Y2M3DT10H30M") cast as xs:gYear
xs:duration("P1Y2M3DT10H30M") cast as xs:gYearMonth
xs:duration("P1Y2M3DT10H30M") cast as xs:hexBinary
xs:duration("P1Y2M3DT10H30M") cast as xs:integer
xs:duration("P1Y2M3DT10H30M") cast as xs:string ne xs:string("an arbitrary string")
xs:duration("P1Y2M3DT10H30M") cast as xs:time
xs:duration("P1Y2M3DT10H30M") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:duration("P1Y2M3DT10H30M") cast as xs:yearMonthDuration ne xs:yearMonthDuration("P1Y12M")
xs:duration(" P1Y2M3DT10H30M ") eq xs:duration(" P1Y2M3DT10H30M ")
xs:duration( "P1Y2M3DT10H30M" , "P1Y2M3DT10H30M" )
xs:duration("P1Y3M") * 3
xs:duration("-P1Y3M4DT08H4M33S") ne xs:duration("P1Y3M4DT08H4M33S")
xs:duration("P1Y3M") div 3
xs:duration("P1Y") eq xs:duration("P12M")
xs:duration("P1Y") eq xs:duration("P1Y")
xs:duration("P1Y") eq xs:duration("P365D")
xs:duration("P1Y") ne xs:duration("P1Y")
xs:duration("P1Y") ne xs:duration("P365D")
xs:duration("P24H")
xs:duration("P24M") castable as xs:dayTimeDuration
xs:duration("P24M") castable as xs:yearMonthDuration
xs:duration("P24M") cast as xs:dayTimeDuration
xs:duration("P24M") cast as xs:yearMonthDuration
xs:duration("P31D") ne xs:yearMonthDuration("P1M")
xs:duration("P365D") eq xs:duration("P365D")
xs:duration("P365D") ne xs:duration("P365D")
(xs:duration("P36D") eq xs:duration("P36D")) and fn:false()
(xs:duration("P36D") eq xs:duration("P36D")) and fn:true()
(xs:duration("P36D") eq xs:duration("P36D")) or fn:false()
(xs:duration("P36D") eq xs:duration("P36D")) or fn:true()
xs:duration("P36D") eq xs:duration("P39D")
(xs:duration("P36D") ne xs:duration("P36D")) and fn:false()
(xs:duration("P36D") ne xs:duration("P36D")) and fn:true()
(xs:duration("P36D") ne xs:duration("P36D")) or fn:false()
(xs:duration("P36D") ne xs:duration("P36D")) or fn:true()
xs:duration("P36D") ne xs:duration("P39D")
xs:duration("P3D") div xs:yearMonthDuration("P3Y3M")
xs:duration("P3DT08H34M12.143S") ge xs:yearMonthDuration("P1999Y10M")
xs:duration("P3DT08H34M12.143S") gt xs:yearMonthDuration("P1999Y10M")
xs:duration("P3DT08H34M12.143S") le xs:yearMonthDuration("P1999Y10M")
xs:duration("P3DT08H34M12.143S") lt xs:yearMonthDuration("P1999Y10M")
xs:duration("P3D") + xs:yearMonthDuration("P3Y3M")
xs:duration("P3D") - xs:yearMonthDuration("P3Y3M")
xs:duration("P3Y3M") div xs:dayTimeDuration("P3D")
xs:duration("P3Y3M") + xs:dayTimeDuration("P3D")
xs:duration("P3Y3M") - xs:dayTimeDuration("P3D")
xs:duration("PT0S") eq xs:dayTimeDuration("PT0S")
xs:duration("-PT0S") eq xs:duration("PT0S")
xs:duration("PT0S") eq xs:duration("PT0S")
xs:duration("PT0S") eq xs:yearMonthDuration("P0M")
xs:duration("PT10H") castable as xs:dayTimeDuration
xs:duration("PT10H") castable as xs:duration
xs:duration("PT10H") castable as xs:yearMonthDuration
xs:duration("PT10H") cast as xs:dayTimeDuration
xs:duration("PT10H") cast as xs:duration
xs:duration("PT10H") cast as xs:yearMonthDuration
xs:duration("PT24H") eq xs:duration("P1D")
xs:duration("PT24H") eq xs:duration("PT24H")
xs:duration("PT24H") ne xs:duration("PT24H")
xs:duration(xs:untypedAtomic( "P1Y2M3DT10H30M" )) eq xs:duration("P1Y2M3DT10H30M")
xs:ENTITY("")
xs:ENTITY("NCName") instance of xs:ENTITY
xs:ENTITY("ncname") instance of xs:IDREF
xs:ENTITY("ncname") instance of xs:NCName
xs:error( () )
xs:error( (), () )
xs:error("")
xs:error()
xs:error#0
xs:error(1)
xs:error(1.0)
xs:error(1) castable as xs:error
xs:error(1) castable as xs:integer
xs:error(1) cast as xs:error
xs:error(1) cast as xs:integer
xs:error(1e0)
xs:error(1) instance of xs:error
xs:error#2
xs:error(()) castable as xs:error
xs:error(()) castable as xs:error?
xs:error(()) cast as xs:error
xs:error(()) cast as xs:error?
xs:error(xs:untypedAtomic(""))
xs:float("")
xs:float()
+(xs:float("0"))
-(xs:float("0"))
-xs:float(0)
xs:float(-0.0)
xs:float("-0.0E0") castable as xs:boolean
xs:float("-0.0E0") castable as xs:decimal
xs:float("-0.0E0") castable as xs:double
xs:float("-0.0E0") castable as xs:integer
xs:float("-0.0E0") castable as xs:string
xs:float("-0.0E0") cast as xs:boolean
xs:float("-0.0E0") cast as xs:decimal
xs:float("-0.0E0") cast as xs:double
xs:float("-0.0E0") cast as xs:integer
xs:float("-0.0E0") cast as xs:string
xs:float(0) and xs:float(0)
xs:float(0) and xs:float(1)
xs:float("0") div xs:float("-3.4028235E38")
xs:float("0") eq xs:float("-3.4028235E38")
xs:float("0") ge xs:float("-3.4028235E38")
xs:float("0") gt xs:float("-3.4028235E38")
xs:float("0") lt xs:float("-3.4028235E38")
xs:float("-0") mod 3
xs:float("0") mod 3
xs:float("-0") mod xs:float("-0")
xs:float("-0") mod xs:float("4")
xs:float("0") mod xs:float("4")
xs:float("-0") mod xs:float("-INF")
xs:float("-0") mod xs:float("INF")
xs:float("0") mod xs:float("-INF")
xs:float("0") mod xs:float("INF")
xs:float("0") ne xs:float("-3.4028235E38")
xs:float("0") ne xs:float("-INF")
xs:float("0") ne xs:float("INF")
xs:float(0) ne xs:float("NaN")
xs:float(0) or xs:float(0)
xs:float(0) or xs:float(1)
(xs:float("0") || xs:float("-3.4028235E38"))
xs:float("0") * xs:float("-3.4028235E38")
xs:float("0") + xs:float("-3.4028235E38")
xs:float("0") - xs:float("-3.4028235E38")
xs:float("0") - xs:float("3.4028235E38")
xs:float("-1.0000000000") * xs:float("-3.4028235E38")
xs:float("-1.0000000000") * xs:float("3.4028235E38")
xs:float("-10000000") mod xs:float("-10000000")
xs:float("-10000000") mod xs:float("10000000")
xs:float("10000000") mod xs:float("-10000000")
xs:float("10000000") mod xs:float("10000000")
xs:float("1.01"), xs:float("NaN")
xs:float(1.0e0) idiv xs:float(0.0e0)
xs:float(-1.0e0) mod xs:float(-9223372036854775808)
(xs:float(1.1), 2.2, 3.3)
xs:float(-1.1) eq xs:float(-1.1)
xs:float(1.1) eq xs:float(1.1)
xs:float(1.1) ne xs:float(2.1)
xs:float(1.1) + xs:float(2.2) ne 3.3
xs:float(1.5) idiv xs:decimal(1)
xs:float("-1.75e-3") castable as xs:decimal
xs:float("-1.75e-3") castable as xs:duration
xs:float("-1.75e-3") castable as xs:float
xs:float("-1.75e-3") cast as xs:duration
xs:float("-1.75e-3") cast as xs:float
xs:float(-1) and xs:float(0)
xs:float(1) and xs:float(-1)
xs:float(1) castable as xs:float
xs:float(1) castable as xs:string
xs:float(1) castable as xs:untypedAtomic
xs:float("1e5") castable as xs:boolean
xs:float("1e5") castable as xs:decimal
xs:float("1e5") castable as xs:integer
xs:float("1e5") castable as xs:untypedAtomic
xs:float("1e5") cast as xs:boolean
xs:float("1e5") cast as xs:decimal
xs:float("1e5") cast as xs:integer
xs:float("1e5") cast as xs:untypedAtomic
xs:float(1) ge xs:float(1)
xs:float(1) gt xs:float(-1)
xs:float("1") idiv xs:float("0")
xs:float("1") idiv xs:float("NaN")
xs:float(-1) le xs:float(1)
xs:float(-1) lt xs:float(1)
xs:float(-1) or xs:float(0)
xs:float(1) or xs:float(-1)
xs:float(2.1E3) cast as xs:boolean
xs:float(2.1E3) cast as xs:double
xs:float(2.1E3) cast as xs:float
xs:float(2.1E3) cast as xs:string
xs:float(3.1) eq 3.1
+(xs:float("-3.4028235E38"))
+(xs:float("3.4028235E38"))
-(xs:float("-3.4028235E38"))
-(xs:float("3.4028235E38"))
xs:float("-3.4028235E38") div xs:float("-3.4028235E38")
xs:float("-3.4028235E38") div xs:float("3.4028235E38")
xs:float("3.4028235E38") div xs:float("-3.4028235E38")
xs:float("-3.4028235E38") eq xs:float("0")
xs:float("-3.4028235E38") eq xs:float("-3.4028235E38")
xs:float("-3.4028235E38") eq xs:float("3.4028235E38")
xs:float("3.4028235E38") eq xs:float("-3.4028235E38")
xs:float("-3.4028235E38") ge xs:float("0")
xs:float("-3.4028235E38") ge xs:float("-3.4028235E38")
xs:float("-3.4028235E38") ge xs:float("3.4028235E38")
xs:float("3.4028235E38") ge xs:float("-3.4028235E38")
xs:float("-3.4028235E38") gt xs:float("0")
xs:float("-3.4028235E38") gt xs:float("-3.4028235E38")
xs:float("-3.4028235E38") gt xs:float("3.4028235E38")
xs:float("3.4028235E38") gt xs:float("-3.4028235E38")
xs:float("-3.4028235E38") lt xs:float("0")
xs:float("-3.4028235E38") lt xs:float("-3.4028235E38")
xs:float("-3.4028235E38") lt xs:float("3.4028235E38")
xs:float("3.4028235E38") lt xs:float("-3.4028235E38")
xs:float("-3.4028235E38") mod xs:float("3.4028235E38")
xs:float("-3.4028235E38") ne xs:float("0")
xs:float("-3.4028235E38") ne xs:float("-3.4028235E38")
xs:float("-3.4028235E38") ne xs:float("3.4028235E38")
xs:float("3.4028235E38") ne xs:float("-3.4028235E38")
(xs:float("-3.4028235E38") || xs:float("0"))
xs:float("-3.4028235E38") * xs:float("0")
xs:float("-3.4028235E38") + xs:float("0")
xs:float("-3.4028235E38") - xs:float("0")
xs:float("3.4028235E38") * xs:float("-1.0000000000")
(xs:float("-3.4028235E38") || xs:float("-3.4028235E38"))
(xs:float("-3.4028235E38") || xs:float("3.4028235E38"))
(xs:float("3.4028235E38") || xs:float("-3.4028235E38"))
xs:float("-3.4028235E38") + xs:float("3.4028235E38")
xs:float("-3.4028235E38") - xs:float("-3.4028235E38")
xs:float("3.4028235E38") + xs:float("-3.4028235E38")
xs:float('-3.402823e38') castable as xs:decimal
xs:float('3.402823e38') castable as xs:decimal
xs:float('-3.402823e38') castable as xs:integer
xs:float('3.402823e38') castable as xs:integer
xs:float( "3.4e5" , "3.4e5" )
xs:float("3.4e5") castable as xs:boolean
xs:float("3.4e5") castable as xs:double
xs:float("3.4e5") castable as xs:float
xs:float("3.4e5") castable as xs:string
xs:float("3.4e5") castable as xs:untypedAtomic
xs:float("3.4e5") cast as xs:anyURI
xs:float("3.4e5") cast as xs:base64Binary
xs:float("3.4e5") cast as xs:boolean eq xs:boolean("true")
xs:float("3.4e5") cast as xs:date
xs:float("3.4e5") cast as xs:dateTime
xs:float("3.4e5") cast as xs:dayTimeDuration
xs:float("3.4e5") cast as xs:double ne xs:double("3.3e3")
xs:float("3.4e5") cast as xs:duration
xs:float("3.4e5") cast as xs:float eq xs:float("3.4e5")
xs:float("3.4e5") cast as xs:gDay
xs:float("3.4e5") cast as xs:gMonth
xs:float("3.4e5") cast as xs:gMonthDay
xs:float("3.4e5") cast as xs:gYear
xs:float("3.4e5") cast as xs:gYearMonth
xs:float("3.4e5") cast as xs:hexBinary
xs:float("3.4e5") cast as xs:string ne xs:string("an arbitrary string")
xs:float("3.4e5") cast as xs:time
xs:float("3.4e5") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:float("3.4e5") cast as xs:yearMonthDuration
xs:float(" 3.4e5 ") eq xs:float(" 3.4e5 ")
xs:float("-3.5") idiv xs:float("3")
xs:float(3e3) < <e>1.1</e>
xs:float(3) eq 3
xs:float("3") idiv xs:float("-INF") eq xs:float(0)
xs:float("3") idiv xs:float("INF") eq xs:float(0)
xs:float("3") lt xs:float("NaN")
xs:float("5.4321E-100") castable as xs:anyURI
xs:float("5.4321E-100") castable as xs:base64Binary
xs:float("5.4321E-100") castable as xs:date
xs:float("5.4321E-100") castable as xs:dateTime
xs:float("5.4321E-100") castable as xs:dayTimeDuration
xs:float("5.4321E-100") castable as xs:decimal
xs:float("5.4321E-100") castable as xs:float
xs:float("5.4321E-100") castable as xs:gDay
xs:float("5.4321E-100") castable as xs:gMonth
xs:float("5.4321E-100") castable as xs:gMonthDay
xs:float("5.4321E-100") castable as xs:gYear
xs:float("5.4321E-100") castable as xs:gYearMonth
xs:float("5.4321E-100") castable as xs:hexBinary
xs:float("5.4321E-100") castable as xs:time
xs:float("5.4321E-100") castable as xs:yearMonthDuration
xs:float("5.4321E-100") cast as xs:anyURI
xs:float("5.4321E-100") cast as xs:base64Binary
xs:float("5.4321E-100") cast as xs:date
xs:float("5.4321E-100") cast as xs:dateTime
xs:float("5.4321E-100") cast as xs:dayTimeDuration
xs:float("5.4321E-100") cast as xs:gDay
xs:float("5.4321E-100") cast as xs:gMonth
xs:float("5.4321E-100") cast as xs:gMonthDay
xs:float("5.4321E-100") cast as xs:gYear
xs:float("5.4321E-100") cast as xs:gYearMonth
xs:float("5.4321E-100") cast as xs:hexBinary
xs:float("5.4321E-100") cast as xs:time
xs:float("5.4321E-100") cast as xs:yearMonthDuration
xs:float(5) div xs:float(2) eq 2.5
xs:float(5) div xs:float(2) ne 2.6
xs:float(5) - xs:float(1) eq 4
(xs:float(6) div xs:double(2)) instance of xs:double
xs:float(6) div xs:float(2) eq 3
(xs:float(6) div xs:float(2)) instance of xs:float
(xs:float(6) idiv xs:decimal(2)) instance of xs:integer
(xs:float(6) idiv xs:double(2)) instance of xs:integer
(xs:float(6) idiv xs:float(2)) instance of xs:integer
(xs:float(6) idiv xs:integer(2)) instance of xs:integer
xs:float(6) instance of xs:float
(xs:float(6) mod xs:double(2)) instance of xs:double
(xs:float(6) mod xs:float(2)) instance of xs:float
(xs:float(6) * xs:double(2)) instance of xs:double
(xs:float(6) + xs:double(2)) instance of xs:double
(xs:float(6) - xs:double(2)) instance of xs:double
xs:float(6) * xs:float(2) eq 12
xs:float(6) + xs:float(2) eq 8
(xs:float(6) * xs:float(2)) instance of xs:float
(xs:float(6) + xs:float(2)) instance of xs:float
(xs:float(6) - xs:float(2)) instance of xs:float
(xs:float(9) idiv xs:untypedAtomic("5")) eq 1
(xs:float(9) idiv xs:untypedAtomic("five")) eq 1
xs:float(fn:translate("123","123","123"))
xs:float("inf")
xs:float("inF")
xs:float("+Inf")
xs:float("-Inf")
xs:float("Inf")
xs:float("+InF")
xs:float("-InF")
xs:float("InF")
xs:float(" INF ")
xs:float("+ INF")
xs:float("+INF")
xs:float("- INF")
xs:float('-INF') and xs:float(0)
xs:float('INF') and xs:float(0)
xs:float('-INF') and xs:float(1)
xs:float('INF') and xs:float(1)
xs:float('-INF') and xs:float('INF')
xs:float('-INF') and xs:float('NaN')
xs:float('INF') and xs:float('NaN')
xs:float("-INF") castable as xs:boolean
xs:float('-INF') castable as xs:decimal
xs:float('INF') castable as xs:decimal
xs:float("-INF") castable as xs:double
xs:float("INF") castable as xs:float
xs:float("INF") castable as xs:integer
xs:float("-INF") castable as xs:untypedAtomic
xs:float("-INF") cast as xs:boolean
xs:float("-INF") cast as xs:double
xs:float("INF") cast as xs:float
xs:float("INF") cast as xs:integer
xs:float('INF') cast as xs:integer
xs:float("-INF") cast as xs:untypedAtomic
xs:float("-INF") eq xs:float("-INF")
xs:float("INF") eq xs:float("INF")
xs:float("INF") gt 0
xs:float("INF") idiv xs:float("0")
xs:float("-INF") idiv xs:float("1")
xs:float("-INF") idiv xs:float(3)
xs:float("INF") idiv xs:float(3)
xs:float("-INF") lt 0
xs:float("-INF") mod 3
xs:float("INF") mod 3
xs:float("-INF") mod xs:float("-INF")
xs:float("INF") mod xs:float("INF")
xs:float("-INF") ne xs:float("0")
xs:float("INF") ne xs:float("0")
xs:float("-INF") ne xs:float("INF")
xs:float("INF") ne xs:float("-INF")
xs:float('-INF') or xs:float(0)
xs:float('INF') or xs:float(0)
xs:float('-INF') or xs:float(1)
xs:float('INF') or xs:float(1)
xs:float('-INF') or xs:float('INF')
xs:float('-INF') or xs:float('NaN')
xs:float('INF') or xs:float('NaN')
xs:float("INF") , xs:double("NaN")
xs:float("nan")
xs:float("naN")
xs:float(" NaN ")
xs:float('NaN') and xs:float(0)
xs:float('NaN') and xs:float(1)
xs:float('NaN') and xs:float('NaN')
xs:float("NaN") castable as xs:boolean
xs:float('NaN') castable as xs:decimal
xs:float("NaN") castable as xs:string
xs:float("NaN") cast as xs:boolean
xs:float("NaN") cast as xs:string
xs:float("NaN") idiv 1
xs:float("NaN") instance of xs:float
xs:float("NaN") mod 3
xs:float("NaN") mod xs:float("NaN")
xs:float("NaN") ne xs:float(0)
xs:float("NaN") ne xs:float("NaN")
xs:float('NaN') or xs:float(0)
xs:float('NaN') or xs:float(1)
xs:float('NaN') or xs:float('NaN')
xs:float(xs:byte(3))
xs:float(xs:double('-INF')),xs:float(xs:double('INF'))
xs:float(xs:int(3))
xs:float(xs:long(3))
xs:float(xs:negativeInteger(-3))
xs:float(xs:nonNegativeInteger(3))
xs:float(xs:nonPositiveInteger(0))
xs:float(xs:short(3))
xs:float(xs:unsignedByte(3))
xs:float(xs:unsignedInt(3))
xs:float(xs:unsignedLong(3))
xs:float(xs:unsignedShort(3))
xs:float(xs:untypedAtomic( "3.4e5" )) eq xs:float("3.4e5")
xs:func-does-not-exist(1, 2, 3)
xs:gDay("")
xs:gDay()
xs:gDay("---00")
xs:gDay("---001")
xs:gDay("---01-")
xs:gDay("--01")
xs:gDay("-01")
xs:gDay("---01-00:00") eq xs:gDay("---01+00:00")
xs:gDay("---01+00:00") eq xs:gDay("---01Z")
xs:gDay("---01-00:00") eq xs:gDay("---01Z")
xs:gDay("---01E")
xs:gDay("---01") ne xs:gDay("---10")
xs:gDay("---01Z") eq xs:gDay("---01Z")
xs:gDay("---01Z") eq xs:gDay("---14Z")
xs:gDay("---01Z") eq xs:gDay("---31Z")
xs:gDay("---01Z") ne xs:gDay("---01Z")
xs:gDay("---01Z") ne xs:gDay("---14Z")
xs:gDay("---01Z") ne xs:gDay("---31Z")
(xs:gDay("---02Z") eq xs:gDay("---02Z")) or (xs:gDay("---06Z") eq xs:gDay("---06Z"))
xs:gDay( "---03" , "---03" )
xs:gDay("---03-05:00") castable as xs:gDay
xs:gDay("---03-05:00") cast as xs:gDay
xs:gDay("---03") castable as xs:gDay
xs:gDay("---03") castable as xs:string
xs:gDay("---03") castable as xs:untypedAtomic
xs:gDay("---03") cast as xs:anyURI
xs:gDay("---03") cast as xs:base64Binary
xs:gDay("---03") cast as xs:boolean
xs:gDay("---03") cast as xs:date
xs:gDay("---03") cast as xs:dateTime
xs:gDay("---03") cast as xs:dayTimeDuration
xs:gDay("---03") cast as xs:decimal
xs:gDay("---03") cast as xs:double
xs:gDay("---03") cast as xs:duration
xs:gDay("---03") cast as xs:float
xs:gDay("---03") cast as xs:gDay eq xs:gDay("---03")
xs:gDay("---03") cast as xs:gMonth
xs:gDay("---03") cast as xs:gMonthDay
xs:gDay("---03") cast as xs:gYear
xs:gDay("---03") cast as xs:gYearMonth
xs:gDay("---03") cast as xs:hexBinary
xs:gDay("---03") cast as xs:integer
xs:gDay("---03") cast as xs:string ne xs:string("an arbitrary string")
xs:gDay("---03") cast as xs:time
xs:gDay("---03") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:gDay("---03") cast as xs:yearMonthDuration
xs:gDay(" ---03 ") eq xs:gDay(" ---03 ")
(xs:gDay("---03Z") eq xs:gDay("---01Z")) or (fn:true())
(xs:gDay("---04Z") eq xs:gDay("---02Z")) and (xs:gDay("---01Z") eq xs:gDay("---12Z"))
(xs:gDay("---05Z") eq xs:gDay("---05Z")) or (fn:false())
(xs:gDay("---06Z") ne xs:gDay("---06Z")) or (xs:gDay("---08Z") ne xs:gDay("---09Z"))
xs:gDay("+---08")
xs:gDay("+--08")
xs:gDay("---08-10")
xs:gDay("---08+10:60")
xs:gDay("---08-10:60")
xs:gDay("---08+15:00")
xs:gDay("---08-15:00")
xs:gDay("---08 Z")
(xs:gDay("---08Z") ne xs:gDay("---07Z")) or (fn:true())
(xs:gDay("---09Z") ne xs:gDay("---09Z")) or (fn:false())
xs:gDay("10")
xs:gDay('---12-00:30')
(xs:gDay("---12-05:00") eq xs:gDay("---12Z"))
(xs:gDay("---12Z") ne xs:gDay("---03Z")) and (xs:gDay("---05Z") ne xs:gDay("---08Z"))
xs:gDay("---14Z") eq xs:gDay("---01Z")
xs:gDay("---14Z") ne xs:gDay("---01Z")
xs:gDay("---30-12:00") eq xs:gDay("---31+12:00")
xs:gDay("---30-12:00") ne xs:gDay("---31+12:00")
xs:gDay("---31+12:00") eq xs:gDay("---30-12:00")
xs:gDay("---31+12:00") ne xs:gDay("---30-12:00")
xs:gDay("---31") castable as xs:anyURI
xs:gDay("---31") castable as xs:base64Binary
xs:gDay("---31") castable as xs:boolean
xs:gDay("---31") castable as xs:date
xs:gDay("---31") castable as xs:dateTime
xs:gDay("---31") castable as xs:dayTimeDuration
xs:gDay("---31") castable as xs:decimal
xs:gDay("---31") castable as xs:double
xs:gDay("---31") castable as xs:duration
xs:gDay("---31") castable as xs:float
xs:gDay("---31") castable as xs:gDay
xs:gDay("---31") castable as xs:gMonth
xs:gDay("---31") castable as xs:gMonthDay
xs:gDay("---31") castable as xs:gYear
xs:gDay("---31") castable as xs:gYearMonth
xs:gDay("---31") castable as xs:hexBinary
xs:gDay("---31") castable as xs:integer
xs:gDay("---31") castable as xs:string
xs:gDay("---31") castable as xs:time
xs:gDay("---31") castable as xs:untypedAtomic
xs:gDay("---31") castable as xs:yearMonthDuration
xs:gDay("---31") cast as xs:anyURI
xs:gDay("---31") cast as xs:base64Binary
xs:gDay("---31") cast as xs:boolean
xs:gDay("---31") cast as xs:date
xs:gDay("---31") cast as xs:dateTime
xs:gDay("---31") cast as xs:dayTimeDuration
xs:gDay("---31") cast as xs:decimal
xs:gDay("---31") cast as xs:double
xs:gDay("---31") cast as xs:duration
xs:gDay("---31") cast as xs:float
xs:gDay("---31") cast as xs:gDay
xs:gDay("---31") cast as xs:gMonth
xs:gDay("---31") cast as xs:gMonthDay
xs:gDay("---31") cast as xs:gYear
xs:gDay("---31") cast as xs:gYearMonth
xs:gDay("---31") cast as xs:hexBinary
xs:gDay("---31") cast as xs:integer
xs:gDay("---31") cast as xs:string
xs:gDay("---31") cast as xs:time
xs:gDay("---31") cast as xs:untypedAtomic
xs:gDay("---31") cast as xs:yearMonthDuration
xs:gDay(" ---31 ") eq xs:gDay("---31")
xs:gDay("---31Z") castable as xs:gDay
xs:gDay("---31Z") cast as xs:gDay
xs:gDay("---31Z") eq xs:gDay("---01Z")
xs:gDay("---31Z") ne xs:gDay("---01Z")
xs:gDay("---32")
xs:gDay("---321")
xs:gDay("E---01")
xs:gDay(xs:date("2002-11-23-00:00")) eq xs:gDay("---23Z")
xs:gDay(xs:date("2002-11-23-13:37")) eq xs:gDay("---23-13:37")
xs:gDay(xs:dateTime("2002-11-23T22:12:23.867-00:00")) eq xs:gDay("---23Z")
xs:gDay(xs:dateTime("2002-11-23T22:12:23.867-13:37")) eq xs:gDay("---23-13:37")
xs:gDay(xs:untypedAtomic( "---03" )) eq xs:gDay("---03")
xs:gMonth("")
xs:gMonth()
xs:gMonth("--00")
xs:gMonth("+--01")
xs:gMonth("---01")
xs:gMonth("-01")
xs:gMonth("--01-00:00") eq xs:gMonth("--01+00:00")
xs:gMonth("--01+00:00") eq xs:gMonth("--01Z")
xs:gMonth("--01-00:00") eq xs:gMonth("--01Z")
xs:gMonth("--01Z") eq xs:gMonth("--01Z")
xs:gMonth("--01Z") eq xs:gMonth("--07Z")
xs:gMonth("--01Z") eq xs:gMonth("--12Z")
xs:gMonth("--01Z") ne xs:gMonth("--01Z")
xs:gMonth("--01Z") ne xs:gMonth("--07Z")
xs:gMonth("--01Z") ne xs:gMonth("--12Z")
xs:gMonth("--02--")
(xs:gMonth("--02Z") eq xs:gMonth("--02Z")) or (xs:gMonth("--06Z") eq xs:gMonth("--06Z"))
(xs:gMonth("--03Z") eq xs:gMonth("--01Z")) or (fn:true())
(xs:gMonth("--04Z") eq xs:gMonth("--02Z")) and (xs:gMonth("--01Z") eq xs:gMonth("--12Z"))
xs:gMonth("--05") castable as xs:anyURI
xs:gMonth("--05") castable as xs:base64Binary
xs:gMonth("--05") castable as xs:boolean
xs:gMonth("--05") castable as xs:date
xs:gMonth("--05") castable as xs:dateTime
xs:gMonth("--05") castable as xs:dayTimeDuration
xs:gMonth("--05") castable as xs:decimal
xs:gMonth("--05") castable as xs:double
xs:gMonth("--05") castable as xs:duration
xs:gMonth("--05") castable as xs:float
xs:gMonth("--05") castable as xs:gDay
xs:gMonth("--05") castable as xs:gMonth
xs:gMonth("--05") castable as xs:gMonthDay
xs:gMonth("--05") castable as xs:gYear
xs:gMonth("--05") castable as xs:gYearMonth
xs:gMonth("--05") castable as xs:hexBinary
xs:gMonth("--05") castable as xs:integer
xs:gMonth("--05") castable as xs:string
xs:gMonth("--05") castable as xs:time
xs:gMonth("--05") castable as xs:untypedAtomic
xs:gMonth("--05") castable as xs:yearMonthDuration
xs:gMonth("--05") cast as xs:anyURI
xs:gMonth("--05") cast as xs:base64Binary
xs:gMonth("--05") cast as xs:boolean
xs:gMonth("--05") cast as xs:date
xs:gMonth("--05") cast as xs:dateTime
xs:gMonth("--05") cast as xs:dayTimeDuration
xs:gMonth("--05") cast as xs:decimal
xs:gMonth("--05") cast as xs:double
xs:gMonth("--05") cast as xs:duration
xs:gMonth("--05") cast as xs:float
xs:gMonth("--05") cast as xs:gDay
xs:gMonth("--05") cast as xs:gMonth
xs:gMonth("--05") cast as xs:gMonthDay
xs:gMonth("--05") cast as xs:gYear
xs:gMonth("--05") cast as xs:gYearMonth
xs:gMonth("--05") cast as xs:hexBinary
xs:gMonth("--05") cast as xs:integer
xs:gMonth("--05") cast as xs:string
xs:gMonth("--05") cast as xs:time
xs:gMonth("--05") cast as xs:untypedAtomic
xs:gMonth("--05") cast as xs:yearMonthDuration
xs:gMonth("--05Z") castable as xs:gMonth
xs:gMonth("--05Z") cast as xs:gMonth
(xs:gMonth("--05Z") eq xs:gMonth("--05Z")) or (fn:false())
(xs:gMonth("--06Z") ne xs:gMonth("--06Z")) or (xs:gMonth("--08Z") ne xs:gMonth("--09Z"))
xs:gMonth('--07-00:30')
xs:gMonth("--07Z") eq xs:gMonth("--01Z")
xs:gMonth("--07Z") ne xs:gMonth("--01Z")
xs:gMonth("--08-10")
xs:gMonth("--08+10:60")
xs:gMonth("--08-10:60")
xs:gMonth("--08+15:00")
xs:gMonth("--08-15:00")
(xs:gMonth("--08Z") ne xs:gMonth("--07Z")) or (fn:true())
(xs:gMonth("--09Z") ne xs:gMonth("--09Z")) or (fn:false())
xs:gMonth("--11-")
xs:gMonth( "--11" , "--11" )
xs:gMonth("--11") castable as xs:gMonth
xs:gMonth("--11") castable as xs:string
xs:gMonth("--11") castable as xs:untypedAtomic
xs:gMonth("--11") cast as xs:anyURI
xs:gMonth("--11") cast as xs:base64Binary
xs:gMonth("--11") cast as xs:boolean
xs:gMonth("--11") cast as xs:date
xs:gMonth("--11") cast as xs:dateTime
xs:gMonth("--11") cast as xs:dayTimeDuration
xs:gMonth("--11") cast as xs:decimal
xs:gMonth("--11") cast as xs:double
xs:gMonth("--11") cast as xs:duration
xs:gMonth("--11") cast as xs:float
xs:gMonth("--11") cast as xs:gDay
xs:gMonth("--11") cast as xs:gMonthDay
xs:gMonth("--11") cast as xs:gMonth eq xs:gMonth("--11")
xs:gMonth("--11") cast as xs:gYear
xs:gMonth("--11") cast as xs:gYearMonth
xs:gMonth("--11") cast as xs:hexBinary
xs:gMonth("--11") cast as xs:integer
xs:gMonth("--11") cast as xs:string ne xs:string("an arbitrary string")
xs:gMonth("--11") cast as xs:time
xs:gMonth("--11") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:gMonth("--11") cast as xs:yearMonthDuration
xs:gMonth(" --11 ") eq xs:gMonth(" --11 ")
xs:gMonth("--11 ") eq xs:gMonth("--11")
xs:gMonth("--12-05:00") castable as xs:gMonth
xs:gMonth("--12-05:00") cast as xs:gMonth
(xs:gMonth("--12-05:00") eq xs:gMonth("--12Z"))
xs:gMonth("--12") ne xs:gMonth("--10")
xs:gMonth("--12Z") eq xs:gMonth("--01Z")
xs:gMonth("--12Z") ne xs:gMonth("--01Z")
(xs:gMonth("--12Z") ne xs:gMonth("--03Z")) and (xs:gMonth("--05Z") ne xs:gMonth("--08Z"))
xs:gMonth("--13")
xs:gMonth("--431")
xs:gMonthDay("")
xs:gMonthDay()
xs:gMonthDay("--00-01")
xs:gMonthDay("--01-00")
xs:gMonthDay("--01-01+10:60")
xs:gMonthDay("--01-01-10:60")
xs:gMonthDay("--01-01+15:00")
xs:gMonthDay("--01-01-15:00")
xs:gMonthDay("--01-01Z") eq xs:gMonthDay("--01-01Z")
xs:gMonthDay("--01-01Z") eq xs:gMonthDay("--04-10Z")
xs:gMonthDay("--01-01Z") eq xs:gMonthDay("--12-31Z")
xs:gMonthDay("--01-01Z") ne xs:gMonthDay("--01-01Z")
xs:gMonthDay("--01-01Z") ne xs:gMonthDay("--04-10Z")
xs:gMonthDay("--01-01Z") ne xs:gMonthDay("--12-31Z")
xs:gMonthDay("+--01-12")
xs:gMonthDay("--01--12")
xs:gMonthDay("-01-12")
xs:gMonthDay("01-12-")
xs:gMonthDay("--01-30-12:00") eq xs:gMonthDay("--01-31+12:00")
xs:gMonthDay("--01-30-12:00") ne xs:gMonthDay("--01-31+12:00")
xs:gMonthDay("--01-31+12:00") eq xs:gMonthDay("--01-30-12:00")
xs:gMonthDay("--01-31+12:00") ne xs:gMonthDay("--01-30-12:00")
(xs:gMonthDay("--02-01Z") eq xs:gMonthDay("--02-10Z")) or (xs:gMonthDay("--06-02Z") eq xs:gMonthDay("--06-03Z"))
xs:gMonthDay("--02-29+00:00") eq xs:gMonthDay("--02-29+00:00")
xs:gMonthDay("--03-01-00:00") eq xs:gMonthDay("--03-01+00:00")
xs:gMonthDay("--03-01+00:00") eq xs:gMonthDay("--03-01Z")
xs:gMonthDay("--03-01-00:00") eq xs:gMonthDay("--03-01Z")
xs:gMonthDay("--03-01Z") eq xs:gMonthDay("--03-01Z")
(xs:gMonthDay("--03-04Z") eq xs:gMonthDay("--01-07Z")) or (fn:true())
xs:gMonthDay("--04-01 ") eq xs:gMonthDay("--04-01")
(xs:gMonthDay("--04-02Z") eq xs:gMonthDay("--02-03Z")) and (xs:gMonthDay("--01-07Z") eq xs:gMonthDay("--12-10Z"))
xs:gMonthDay("--04-10Z") eq xs:gMonthDay("--01-01Z")
xs:gMonthDay("--04-10Z") ne xs:gMonthDay("--01-01Z")
xs:gMonthDay("--04-12") ne xs:gMonthDay("--04-11")
(xs:gMonthDay("--05-05Z") eq xs:gMonthDay("--05-05Z")) or (fn:false())
xs:gMonthDay("--05-31") castable as xs:anyURI
xs:gMonthDay("--05-31") castable as xs:base64Binary
xs:gMonthDay("--05-31") castable as xs:boolean
xs:gMonthDay("--05-31") castable as xs:date
xs:gMonthDay("--05-31") castable as xs:dateTime
xs:gMonthDay("--05-31") castable as xs:dayTimeDuration
xs:gMonthDay("--05-31") castable as xs:decimal
xs:gMonthDay("--05-31") castable as xs:double
xs:gMonthDay("--05-31") castable as xs:duration
xs:gMonthDay("--05-31") castable as xs:float
xs:gMonthDay("--05-31") castable as xs:gDay
xs:gMonthDay("--05-31") castable as xs:gMonth
xs:gMonthDay("--05-31") castable as xs:gMonthDay
xs:gMonthDay("--05-31") castable as xs:gYear
xs:gMonthDay("--05-31") castable as xs:gYearMonth
xs:gMonthDay("--05-31") castable as xs:hexBinary
xs:gMonthDay("--05-31") castable as xs:integer
xs:gMonthDay("--05-31") castable as xs:string
xs:gMonthDay("--05-31") castable as xs:time
xs:gMonthDay("--05-31") castable as xs:untypedAtomic
xs:gMonthDay("--05-31") castable as xs:yearMonthDuration
xs:gMonthDay("--05-31") cast as xs:anyURI
xs:gMonthDay("--05-31") cast as xs:base64Binary
xs:gMonthDay("--05-31") cast as xs:boolean
xs:gMonthDay("--05-31") cast as xs:date
xs:gMonthDay("--05-31") cast as xs:dateTime
xs:gMonthDay("--05-31") cast as xs:dayTimeDuration
xs:gMonthDay("--05-31") cast as xs:decimal
xs:gMonthDay("--05-31") cast as xs:double
xs:gMonthDay("--05-31") cast as xs:duration
xs:gMonthDay("--05-31") cast as xs:float
xs:gMonthDay("--05-31") cast as xs:gDay
xs:gMonthDay("--05-31") cast as xs:gMonth
xs:gMonthDay("--05-31") cast as xs:gMonthDay
xs:gMonthDay("--05-31") cast as xs:gYear
xs:gMonthDay("--05-31") cast as xs:gYearMonth
xs:gMonthDay("--05-31") cast as xs:hexBinary
xs:gMonthDay("--05-31") cast as xs:integer
xs:gMonthDay("--05-31") cast as xs:string
xs:gMonthDay("--05-31") cast as xs:time
xs:gMonthDay("--05-31") cast as xs:untypedAtomic
xs:gMonthDay("--05-31") cast as xs:yearMonthDuration
xs:gMonthDay("--05-31Z") castable as xs:gMonthDay
xs:gMonthDay("--05-31Z") cast as xs:gMonthDay
(xs:gMonthDay("--06-02Z") ne xs:gMonthDay("--06-09Z")) or (xs:gMonthDay("--08-06Z") ne xs:gMonthDay("--09-01Z"))
xs:gMonthDay('--07-12-00:30')
(xs:gMonthDay("--08-04Z") ne xs:gMonthDay("--07-12Z")) or (fn:true())
(xs:gMonthDay("--09-09Z") ne xs:gMonthDay("--09-10Z")) or (fn:false())
xs:gMonthDay("--11-08-10")
xs:gMonthDay("--111-01")
xs:gMonthDay( "--11-13" , "--11-13" )
xs:gMonthDay("--11-13") castable as xs:gMonthDay
xs:gMonthDay("--11-13") castable as xs:string
xs:gMonthDay("--11-13") castable as xs:untypedAtomic
xs:gMonthDay("--11-13") cast as xs:anyURI
xs:gMonthDay("--11-13") cast as xs:base64Binary
xs:gMonthDay("--11-13") cast as xs:boolean
xs:gMonthDay("--11-13") cast as xs:date
xs:gMonthDay("--11-13") cast as xs:dateTime
xs:gMonthDay("--11-13") cast as xs:dayTimeDuration
xs:gMonthDay("--11-13") cast as xs:decimal
xs:gMonthDay("--11-13") cast as xs:double
xs:gMonthDay("--11-13") cast as xs:duration
xs:gMonthDay("--11-13") cast as xs:float
xs:gMonthDay("--11-13") cast as xs:gDay
xs:gMonthDay("--11-13") cast as xs:gMonth
xs:gMonthDay("--11-13") cast as xs:gMonthDay eq xs:gMonthDay("--11-13")
xs:gMonthDay("--11-13") cast as xs:gYear
xs:gMonthDay("--11-13") cast as xs:gYearMonth
xs:gMonthDay("--11-13") cast as xs:hexBinary
xs:gMonthDay("--11-13") cast as xs:integer
xs:gMonthDay("--11-13") cast as xs:string ne xs:string("an arbitrary string")
xs:gMonthDay("--11-13") cast as xs:time
xs:gMonthDay("--11-13") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:gMonthDay("--11-13") cast as xs:yearMonthDuration
xs:gMonthDay(" --11-13 ") eq xs:gMonthDay(" --11-13 ")
xs:gMonthDay("--12-03-05:00") castable as xs:gMonthDay
xs:gMonthDay("--12-03-05:00") cast as xs:gMonthDay
(xs:gMonthDay("--12-10Z") ne xs:gMonthDay("--03-11Z")) and (xs:gMonthDay("--05-12Z") ne xs:gMonthDay("--08-08Z"))
(xs:gMonthDay("--12-25Z") eq xs:gMonthDay("--12-26Z"))
xs:gMonthDay("--12-31Z") eq xs:gMonthDay("--01-01Z")
xs:gMonthDay("--12-31Z") ne xs:gMonthDay("--01-01Z")
xs:gMonthDay("--13-01")
xs:gMonthDay("--1967-01")
xs:gMonthDay(xs:date("2002-11-23-00:00")) eq xs:gMonthDay("--11-23Z")
xs:gMonthDay(xs:date("2002-11-23-13:37")) eq xs:gMonthDay("--11-23-13:37")
xs:gMonthDay(xs:dateTime("2002-11-23T22:12:23.867-00:00")) eq xs:gMonthDay("--11-23Z")
xs:gMonthDay(xs:dateTime("2002-11-23T22:12:23.867-13:37")) eq xs:gMonthDay("--11-23-13:37")
xs:gMonthDay(xs:untypedAtomic( "--11-13" )) eq xs:gMonthDay("--11-13")
xs:gMonth(xs:date("2002-11-23-00:00")) eq xs:gMonth("--11Z")
xs:gMonth(xs:date("2002-11-23-13:37")) eq xs:gMonth("--11-13:37")
xs:gMonth(xs:dateTime("2002-11-23T22:12:23.867-00:00")) eq xs:gMonth("--11Z")
xs:gMonth(xs:dateTime("2002-11-23T22:12:23.867-13:37")) eq xs:gMonth("--11-13:37")
xs:gMonth(xs:untypedAtomic( "--11" )) eq xs:gMonth("--11")
xs:gYear("")
xs:gYear()
xs:gYear("+0000")
xs:gYear("-0012-05:00") castable as xs:gYear
xs:gYear("-0012-05:00") cast as xs:gYear
xs:gYear("0040")
xs:gYear("02004")
xs:gYear("1")
xs:gYear("1 111")
xs:gYear("1111-")
xs:gYear("1111a")
xs:gYear("1111 Z")
xs:gYear("12")
xs:gYear("1956-00:00") eq xs:gYear("1956+00:00")
xs:gYear("1956+00:00") eq xs:gYear("1956Z")
xs:gYear("1956-00:00") eq xs:gYear("1956Z")
xs:gYear("1956-10")
xs:gYear("1956+10:60")
xs:gYear("1956-10:60")
xs:gYear("1956+15:00")
xs:gYear("1956-15:00")
xs:gYear(" 1956 ") eq xs:gYear("1956")
xs:gYear("1956") ne xs:gYear("1958")
xs:gYear("1956Z") eq xs:gYear("1956Z")
xs:gYear("1970Z") eq xs:gYear("1970Z")
xs:gYear("1970Z") eq xs:gYear("2012Z")
xs:gYear("1970Z") eq xs:gYear("2030Z")
xs:gYear("1970Z") ne xs:gYear("1970Z")
xs:gYear("1970Z") ne xs:gYear("2012Z")
xs:gYear("1970Z") ne xs:gYear("2030Z")
(xs:gYear("1976-05:00") eq xs:gYear("1976-05:00"))
(xs:gYear("1976Z") ne xs:gYear("1976Z")) or (xs:gYear("1980Z") ne xs:gYear("1980Z"))
(xs:gYear("1980Z") eq xs:gYear("1980Z")) or (fn:false())
(xs:gYear("1980Z") eq xs:gYear("1980Z")) or (fn:true())
(xs:gYear("1980Z") ne xs:gYear("1980Z")) or (fn:false())
xs:gYear("+1999")
xs:gYear( "1999" , "1999" )
xs:gYear("1999") castable as xs:anyURI
xs:gYear("1999") castable as xs:base64Binary
xs:gYear("1999") castable as xs:boolean
xs:gYear("1999") castable as xs:date
xs:gYear("1999") castable as xs:dateTime
xs:gYear("1999") castable as xs:decimal
xs:gYear("1999") castable as xs:double
xs:gYear("1999") castable as xs:duration
xs:gYear("1999") castable as xs:float
xs:gYear("1999") castable as xs:gDay
xs:gYear("1999") castable as xs:gMonth
xs:gYear("1999") castable as xs:gMonthDay
xs:gYear("1999") castable as xs:gYear
xs:gYear("1999") castable as xs:gYearMonth
xs:gYear("1999") castable as xs:hexBinary
xs:gYear("1999") castable as xs:integer
xs:gYear("1999") castable as xs:string
xs:gYear("1999") castable as xs:time
xs:gYear("1999") castable as xs:untypedAtomic
xs:gYear("1999") castable as xs:yearMonthDuration
xs:gYear("1999") cast as xs:anyURI
xs:gYear("1999") cast as xs:base64Binary
xs:gYear("1999") cast as xs:boolean
xs:gYear("1999") cast as xs:date
xs:gYear("1999") cast as xs:dateTime
xs:gYear("1999") cast as xs:dayTimeDuration
xs:gYear("1999") cast as xs:decimal
xs:gYear("1999") cast as xs:double
xs:gYear("1999") cast as xs:duration
xs:gYear("1999") cast as xs:float
xs:gYear("1999") cast as xs:gDay
xs:gYear("1999") cast as xs:gMonth
xs:gYear("1999") cast as xs:gMonthDay
xs:gYear("1999") cast as xs:gYear
xs:gYear("1999") cast as xs:gYear eq xs:gYear("1999")
xs:gYear("1999") cast as xs:gYearMonth
xs:gYear("1999") cast as xs:hexBinary
xs:gYear("1999") cast as xs:integer
xs:gYear("1999") cast as xs:string
xs:gYear("1999") cast as xs:string ne xs:string("an arbitrary string")
xs:gYear("1999") cast as xs:time
xs:gYear("1999") cast as xs:untypedAtomic
xs:gYear("1999") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:gYear("1999") cast as xs:yearMonthDuration
xs:gYear(" 1999 ") eq xs:gYear(" 1999 ")
xs:gYear("1999Z") castable as xs:gYear
xs:gYear("1999Z") cast as xs:gYear
(xs:gYear("2000Z") eq xs:gYear("2000Z")) and (xs:gYear("2001Z") eq xs:gYear("2001Z"))
(xs:gYear("2000Z") eq xs:gYear("2000Z")) or (xs:gYear("1976Z") eq xs:gYear("1976Z"))
(xs:gYear("2000Z") ne xs:gYear("2000Z")) and (xs:gYear("1975Z") ne xs:gYear("1975Z"))
(xs:gYear("2000Z") ne xs:gYear("2000Z")) or (fn:true())
(xs:gYear("2005-12:00") eq xs:gYear("2005+12:00"))
xs:gYear("2012Z") eq xs:gYear("1970Z")
xs:gYear("2012Z") ne xs:gYear("1970Z")
xs:gYear('2017-00:30')
xs:gYear("2030Z") eq xs:gYear("1970Z")
xs:gYear("2030Z") ne xs:gYear("1970Z")
xs:gYear("867")
xs:gYear("a1111")
xs:gYearMonth("")
xs:gYearMonth()
xs:gYearMonth("-0012-12-05:00") castable as xs:gYearMonth
xs:gYearMonth("-0012-12-05:00") cast as xs:gYearMonth
xs:gYearMonth("0040-01")
xs:gYearMonth("02004-08")
xs:gYearMonth("1970-01Z") eq xs:gYearMonth("1970-01Z")
xs:gYearMonth("1970-01Z") eq xs:gYearMonth("1984-12Z")
xs:gYearMonth("1970-01Z") eq xs:gYearMonth("2030-12Z")
xs:gYearMonth("1970-01Z") ne xs:gYearMonth("1970-01Z")
xs:gYearMonth("1970-01Z") ne xs:gYearMonth("1984-12Z")
xs:gYearMonth("1970-01Z") ne xs:gYearMonth("2030-12Z")
(xs:gYearMonth("1976-01Z") ne xs:gYearMonth("1976-02Z")) or (xs:gYearMonth("1980-03Z") ne xs:gYearMonth("1980-04Z"))
(xs:gYearMonth("1976-02-05:00") eq xs:gYearMonth("1976-03Z"))
(xs:gYearMonth("1976-03-05:00") eq xs:gYearMonth("1976-03Z"))
(xs:gYearMonth("1980-03Z") ne xs:gYearMonth("1980-03Z")) or (fn:false())
(xs:gYearMonth("1980-05Z") eq xs:gYearMonth("1980-05Z")) or (fn:true())
(xs:gYearMonth("1980-09Z") eq xs:gYearMonth("1980-09Z")) or (fn:false())
xs:gYearMonth("1984-12Z") eq xs:gYearMonth("1970-01Z")
xs:gYearMonth("1984-12Z") ne xs:gYearMonth("1970-01Z")
xs:gYearMonth("1999-00")
xs:gYearMonth("1999-01-00:00") eq xs:gYearMonth("1999-01+00:00")
xs:gYearMonth("1999-01+00:00") eq xs:gYearMonth("1999-01Z")
xs:gYearMonth("1999-01-00:00") eq xs:gYearMonth("1999-01Z")
xs:gYearMonth("1999-01+10:60")
xs:gYearMonth("1999-01-10:60")
xs:gYearMonth("1999-01+15:00")
xs:gYearMonth("1999-01-15:00")
xs:gYearMonth("1999-01Z") eq xs:gYearMonth("1999-01Z")
xs:gYearMonth("1999-05") castable as xs:double
xs:gYearMonth("1999-05") castable as xs:float
xs:gYearMonth("1999-05") castable as xs:gYearMonth
xs:gYearMonth("1999-05") castable as xs:string
xs:gYearMonth("1999-05") castable as xs:untypedAtomic
xs:gYearMonth("1999-05") cast as xs:double
xs:gYearMonth("1999-05") cast as xs:float
xs:gYearMonth("1999-05") cast as xs:gYearMonth
xs:gYearMonth("1999-05") cast as xs:string
xs:gYearMonth("1999-05") cast as xs:untypedAtomic
xs:gYearMonth("1999-05Z") castable as xs:anyURI
xs:gYearMonth("1999-05Z") castable as xs:base64Binary
xs:gYearMonth("1999-05Z") castable as xs:boolean
xs:gYearMonth("1999-05Z") castable as xs:date
xs:gYearMonth("1999-05Z") castable as xs:dateTime
xs:gYearMonth("1999-05Z") castable as xs:dayTimeDuration
xs:gYearMonth("1999-05Z") castable as xs:decimal
xs:gYearMonth("1999-05Z") castable as xs:double
xs:gYearMonth("1999-05Z") castable as xs:duration
xs:gYearMonth("1999-05Z") castable as xs:gDay
xs:gYearMonth("1999-05Z") castable as xs:gMonth
xs:gYearMonth("1999-05Z") castable as xs:gMonthDay
xs:gYearMonth("1999-05Z") castable as xs:gYear
xs:gYearMonth("1999-05Z") castable as xs:gYearMonth
xs:gYearMonth("1999-05Z") castable as xs:hexBinary
xs:gYearMonth("1999-05Z") castable as xs:integer
xs:gYearMonth("1999-05Z") castable as xs:time
xs:gYearMonth("1999-05Z") castable as xs:yearMonthDuration
xs:gYearMonth("1999-05Z") cast as xs:anyURI
xs:gYearMonth("1999-05Z") cast as xs:base64Binary
xs:gYearMonth("1999-05Z") cast as xs:boolean
xs:gYearMonth("1999-05Z") cast as xs:date
xs:gYearMonth("1999-05Z") cast as xs:dateTime
xs:gYearMonth("1999-05Z") cast as xs:dayTimeDuration
xs:gYearMonth("1999-05Z") cast as xs:decimal
xs:gYearMonth("1999-05Z") cast as xs:double
xs:gYearMonth("1999-05Z") cast as xs:duration
xs:gYearMonth("1999-05Z") cast as xs:gDay
xs:gYearMonth("1999-05Z") cast as xs:gMonth
xs:gYearMonth("1999-05Z") cast as xs:gMonthDay
xs:gYearMonth("1999-05Z") cast as xs:gYear
xs:gYearMonth("1999-05Z") cast as xs:gYearMonth
xs:gYearMonth("1999-05Z") cast as xs:hexBinary
xs:gYearMonth("1999-05Z") cast as xs:integer
xs:gYearMonth("1999-05Z") cast as xs:time
xs:gYearMonth("1999-05Z") cast as xs:yearMonthDuration
xs:gYearMonth("1999-08-10")
xs:gYearMonth( "1999-11" , "1999-11" )
xs:gYearMonth("1999-11") castable as xs:gYearMonth
xs:gYearMonth("1999-11") castable as xs:string
xs:gYearMonth("1999-11") castable as xs:untypedAtomic
xs:gYearMonth("1999-11") cast as xs:anyURI
xs:gYearMonth("1999-11") cast as xs:base64Binary
xs:gYearMonth("1999-11") cast as xs:boolean
xs:gYearMonth("1999-11") cast as xs:date
xs:gYearMonth("1999-11") cast as xs:dateTime
xs:gYearMonth("1999-11") cast as xs:dayTimeDuration
xs:gYearMonth("1999-11") cast as xs:decimal
xs:gYearMonth("1999-11") cast as xs:double
xs:gYearMonth("1999-11") cast as xs:duration
xs:gYearMonth("1999-11") cast as xs:float
xs:gYearMonth("1999-11") cast as xs:gDay
xs:gYearMonth("1999-11") cast as xs:gMonth
xs:gYearMonth("1999-11") cast as xs:gMonthDay
xs:gYearMonth("1999-11") cast as xs:gYear
xs:gYearMonth("1999-11") cast as xs:gYearMonth eq xs:gYearMonth("1999-11")
xs:gYearMonth("1999-11") cast as xs:hexBinary
xs:gYearMonth("1999-11") cast as xs:integer
xs:gYearMonth("1999-11") cast as xs:string ne xs:string("an arbitrary string")
xs:gYearMonth("1999-11") cast as xs:time
xs:gYearMonth("1999-11") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:gYearMonth("1999-11") cast as xs:yearMonthDuration
xs:gYearMonth(" 1999-11 ") eq xs:gYearMonth(" 1999-11 ")
xs:gYearMonth("+1999-12")
xs:gYearMonth("--1999-12")
xs:gYearMonth("1999--12")
xs:gYearMonth("1999-12-")
xs:gYearMonth("1999-13")
(xs:gYearMonth("2000-01Z") eq xs:gYearMonth("2000-03Z")) or (xs:gYearMonth("1976-06Z") eq xs:gYearMonth("1976-06Z"))
(xs:gYearMonth("2000-01Z") ne xs:gYearMonth("2000-01Z")) and (xs:gYearMonth("1975-01Z") ne xs:gYearMonth("1975-03Z"))
(xs:gYearMonth("2000-02Z") eq xs:gYearMonth("2000-03Z")) and (xs:gYearMonth("2001-01Z") eq xs:gYearMonth("2001-01Z"))
(xs:gYearMonth("2000-06Z") ne xs:gYearMonth("2000-07Z")) or (fn:true())
xs:gYearMonth("2001-01 ") eq xs:gYearMonth("2001-01")
xs:gYearMonth("2001-12") ne xs:gYearMonth("2001-11")
xs:gYearMonth('2017-07-00:30')
xs:gYearMonth("2030-12Z") eq xs:gYearMonth("1970-01Z")
xs:gYearMonth("2030-12Z") ne xs:gYearMonth("1970-01Z")
xs:gYearMonth(xs:date("2002-11-23-13:37")) eq xs:gYearMonth("2002-11-13:37")
xs:gYearMonth(xs:date("2002-11-23Z")) eq xs:gYearMonth("2002-11Z")
xs:gYearMonth(xs:dateTime("2002-11-23T23:12:23.867-00:00")) eq xs:gYearMonth("2002-11Z")
xs:gYearMonth(xs:dateTime("2002-11-23T23:12:23.867-13:37")) eq xs:gYearMonth("2002-11-13:37")
xs:gYearMonth(xs:untypedAtomic( "1999-11" )) eq xs:gYearMonth("1999-11")
xs:gYear(xs:date("2002-11-23-13:37")) eq xs:gYear("2002-13:37")
xs:gYear(xs:date("2002-11-23Z")) eq xs:gYear("2002Z")
xs:gYear(xs:dateTime("2002-11-23T23:12:23.867-00:00")) eq xs:gYear("2002Z")
xs:gYear(xs:dateTime("2002-11-23T23:12:23.867-13:37")) eq xs:gYear("2002-13:37")
xs:gYear(xs:untypedAtomic( "1999" )) eq xs:gYear("1999")
xs:hexBinary()
xs:hexBinary("00") eq xs:hexBinary("")
xs:hexBinary( "0FB7" , "0FB7" )
xs:hexBinary("0fb7") castable as xs:base64Binary
xs:hexBinary("0FB7") castable as xs:base64Binary
xs:hexBinary("0FB7") castable as xs:hexBinary
xs:hexBinary("0FB7") castable as xs:string
xs:hexBinary("0FB7") castable as xs:untypedAtomic
xs:hexBinary("0FB7") cast as xs:anyURI
xs:hexBinary("0fb7") cast as xs:base64Binary
xs:hexBinary("0FB7") cast as xs:base64Binary ne xs:base64Binary("aaaa")
xs:hexBinary("0FB7") cast as xs:boolean
xs:hexBinary("0FB7") cast as xs:date
xs:hexBinary("0FB7") cast as xs:dateTime
xs:hexBinary("0FB7") cast as xs:dayTimeDuration
xs:hexBinary("0FB7") cast as xs:decimal
xs:hexBinary("0FB7") cast as xs:double
xs:hexBinary("0FB7") cast as xs:duration
xs:hexBinary("0FB7") cast as xs:float
xs:hexBinary("0FB7") cast as xs:gDay
xs:hexBinary("0FB7") cast as xs:gMonth
xs:hexBinary("0FB7") cast as xs:gMonthDay
xs:hexBinary("0FB7") cast as xs:gYear
xs:hexBinary("0FB7") cast as xs:gYearMonth
xs:hexBinary("0FB7") cast as xs:hexBinary eq xs:hexBinary("0FB7")
xs:hexBinary("0FB7") cast as xs:integer
xs:hexBinary("0FB7") cast as xs:string ne xs:string("an arbitrary string")
xs:hexBinary("0FB7") cast as xs:time
xs:hexBinary("0FB7") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:hexBinary("0FB7") cast as xs:yearMonthDuration
xs:hexBinary(" 0FB7 ") eq xs:hexBinary(" 0FB7 ")
xs:hexBinary("0xFF")
xs:hexBinary("6e7875626264756366") eq xs:hexBinary("767479716c6a647663")
xs:hexBinary("6e7875626264756366") ne xs:hexBinary("767479716c6a647663")
xs:hexBinary("767479716c6a647663") eq xs:hexBinary("6e7875626264756366")
xs:hexBinary("767479716c6a647663") eq xs:hexBinary("767479716c6a647663")
xs:hexBinary("767479716c6a647663") eq xs:hexBinary("786174616d61616772")
xs:hexBinary("767479716c6a647663") ne xs:hexBinary("6e7875626264756366")
xs:hexBinary("767479716c6a647663") ne xs:hexBinary("767479716c6a647663")
xs:hexBinary("767479716c6a647663") ne xs:hexBinary("786174616d61616772")
xs:hexBinary("786174616d61616772") eq xs:hexBinary("767479716c6a647663")
(xs:hexBinary("786174616d61616772") eq xs:hexBinary("767479716c6a647663")) and fn:false()
(xs:hexBinary("786174616d61616772") eq xs:hexBinary("767479716c6a647663")) and fn:true()
(xs:hexBinary("786174616d61616772") eq xs:hexBinary("767479716c6a647663")) and (xs:hexBinary("786174616d61616772") eq xs:hexBinary("767479716c6a647663"))
(xs:hexBinary("786174616d61616772") eq xs:hexBinary("767479716c6a647663")) or fn:false()
(xs:hexBinary("786174616d61616772") eq xs:hexBinary("767479716c6a647663")) or fn:true()
(xs:hexBinary("786174616d61616772") eq xs:hexBinary("767479716c6a647663")) or (xs:hexBinary("786174616d61616772") eq xs:hexBinary("767479716c6a647663"))
xs:hexBinary("786174616d61616772") ne xs:hexBinary("767479716c6a647663")
(xs:hexBinary("786174616d61616772") ne xs:hexBinary("767479716c6a647663")) and fn:false()
(xs:hexBinary("786174616d61616772") ne xs:hexBinary("767479716c6a647663")) and fn:true()
(xs:hexBinary("786174616d61616772") ne xs:hexBinary("767479716c6a647663")) and (xs:hexBinary("786174616d61616772") ne xs:hexBinary("767479716c6a647663"))
(xs:hexBinary("786174616d61616772") ne xs:hexBinary("767479716c6a647663")) or fn:false()
(xs:hexBinary("786174616d61616772") ne xs:hexBinary("767479716c6a647663")) or fn:true()
(xs:hexBinary("786174616d61616772") ne xs:hexBinary("767479716c6a647663")) or (xs:hexBinary("786174616d61616772") ne xs:hexBinary("767479716c6a647663"))
xs:hexBinary("D74D35D35D35") castable as xs:anyURI
xs:hexBinary("D74D35D35D35") castable as xs:base64Binary
xs:hexBinary("D74D35D35D35") castable as xs:boolean
xs:hexBinary("D74D35D35D35") castable as xs:date
xs:hexBinary("D74D35D35D35") castable as xs:dateTime
xs:hexBinary("D74D35D35D35") castable as xs:dayTimeDuration
xs:hexBinary("D74D35D35D35") castable as xs:decimal
xs:hexBinary("D74D35D35D35") castable as xs:double
xs:hexBinary("D74D35D35D35") castable as xs:duration
xs:hexBinary("D74D35D35D35") castable as xs:float
xs:hexBinary("D74D35D35D35") castable as xs:gDay
xs:hexBinary("D74D35D35D35") castable as xs:gMonth
xs:hexBinary("D74D35D35D35") castable as xs:gMonthDay
xs:hexBinary("D74D35D35D35") castable as xs:gYear
xs:hexBinary("D74D35D35D35") castable as xs:gYearMonth
xs:hexBinary("d74d35d35d35") castable as xs:hexBinary
xs:hexBinary("D74D35D35D35") castable as xs:hexBinary
xs:hexBinary("D74D35D35D35") castable as xs:integer
xs:hexBinary("D74D35D35D35") castable as xs:string
xs:hexBinary("D74D35D35D35") castable as xs:time
xs:hexBinary("D74D35D35D35") castable as xs:untypedAtomic
xs:hexBinary("D74D35D35D35") castable as xs:yearMonthDuration
xs:hexBinary("D74D35D35D35") cast as xs:anyURI
xs:hexBinary("D74D35D35D35") cast as xs:base64Binary
xs:hexBinary("D74D35D35D35") cast as xs:boolean
xs:hexBinary("D74D35D35D35") cast as xs:date
xs:hexBinary("D74D35D35D35") cast as xs:dateTime
xs:hexBinary("D74D35D35D35") cast as xs:dayTimeDuration
xs:hexBinary("D74D35D35D35") cast as xs:decimal
xs:hexBinary("D74D35D35D35") cast as xs:double
xs:hexBinary("D74D35D35D35") cast as xs:duration
xs:hexBinary("D74D35D35D35") cast as xs:float
xs:hexBinary("D74D35D35D35") cast as xs:gDay
xs:hexBinary("D74D35D35D35") cast as xs:gMonth
xs:hexBinary("D74D35D35D35") cast as xs:gMonthDay
xs:hexBinary("D74D35D35D35") cast as xs:gYear
xs:hexBinary("D74D35D35D35") cast as xs:gYearMonth
xs:hexBinary("d74d35d35d35") cast as xs:hexBinary
xs:hexBinary("D74D35D35D35") cast as xs:hexBinary
xs:hexBinary("D74D35D35D35") cast as xs:integer
xs:hexBinary("D74D35D35D35") cast as xs:string
xs:hexBinary("D74D35D35D35") cast as xs:time
xs:hexBinary("D74D35D35D35") cast as xs:untypedAtomic
xs:hexBinary("D74D35D35D35") cast as xs:yearMonthDuration
xs:hexBinary("") eq xs:hexBinary("")
xs:hexBinary("") eq xs:hexBinary("01")
xs:hexBinary("F")
xs:hexBinary("FFF")
xs:hexBinary("FF") ne xs:hexBinary("aa")
xs:hexBinary("FFxF")
xs:hexBinary("x")
xs:hexBinary(xs:base64Binary("gMA="))
xs:hexBinary(xs:base64Binary("qrvM"))
xs:hexBinary(xs:base64Binary("/w=="))
xs:hexBinary(xs:base64Binary("/w==")) eq xs:hexBinary("FF")
xs:hexBinary(xs:base64Binary(xs:hexBinary("03"))) ne xs:hexBinary("13")
xs:hexBinary(xs:untypedAtomic( "0FB7" )) eq xs:hexBinary("0FB7")
xs:ID("")
xs:ID('id') castable as xs:NCName
xs:ID('id') cast as xs:NCName
xs:ID("NCName") instance of xs:ID
xs:ID("ncname") instance of xs:IDREF
xs:ID("ncname") instance of xs:NCName
xs:IDREF("")
xs:IDREF("NCName") instance of xs:IDREF
xs:IDREF("ncname") instance of xs:NCName
xs:int("")
xs:int("000000001")
xs:int(0) and xs:int(0)
xs:int(0) and xs:int(1)
xs:int(0) instance of xs:int
xs:int("0") instance of xs:long
xs:int(0) or xs:int(0)
xs:int(0) or xs:int(1)
xs:int("0x2147483647")
+(xs:int("-1873914410"))
-(xs:int("-1873914410"))
xs:int("-1873914410") eq xs:int("-2147483648")
xs:int("-1873914410") ge xs:int("-2147483648")
xs:int("-1873914410") gt xs:int("-2147483648")
xs:int("-1873914410") idiv xs:int("-2147483648")
xs:int("-1873914410") lt xs:int("-2147483648")
xs:int("-1873914410") ne xs:int("-2147483648")
xs:int("-1873914410") - xs:int("-2147483648")
xs:int("-1873914410")||xs:int("-2147483648")
xs:int("-1873914410") + xs:int("-273569238")
xs:int(-1) and xs:int(0)
xs:int(1) and xs:int(-1)
xs:int(-1) or xs:int(0)
xs:int(1) or xs:int(-1)
xs:int("-1") - xs:int("2147483647")
xs:int("-1") - xs:int("-2147483648")
+(xs:int("2147483647"))
-(xs:int("-2147483647"))
-(xs:int("2147483647"))
xs:int("2147483647")
xs:int(2147483647) and xs:int(0)
xs:int(2147483647) and xs:int(-1)
xs:int(2147483647) and xs:int(-2147483648)
xs:int("2147483647") eq xs:int("-2147483648")
xs:int("2147483647") ge xs:int("-2147483648")
xs:int("2147483647") gt xs:int("-2147483648")
xs:int("2147483647") idiv xs:int("-2147483648")
xs:int("2147483647") lt xs:int("-2147483648")
xs:int("2147483647") ne xs:int("-2147483648")
xs:int(2147483647) or xs:int(0)
xs:int(2147483647) or xs:int(-1)
xs:int(2147483647) or xs:int(-2147483648)
xs:int("2147483647") + xs:int("-2147483648")
xs:int("2147483647")||xs:int("-2147483648")
+(xs:int("-2147483648"))
xs:int("-2147483648")
xs:int("2147483648")
xs:int(2147483648)
xs:int(-2147483648) and xs:int(0)
xs:int(-2147483648) and xs:int(1)
xs:int("-2147483648") div xs:int("-2147483648")
xs:int("-2147483648") eq xs:int("-1873914410")
xs:int("-2147483648") eq xs:int("2147483647")
xs:int("-2147483648") eq xs:int("-2147483648")
xs:int("-2147483648") ge xs:int("-1873914410")
xs:int("-2147483648") ge xs:int("2147483647")
xs:int("-2147483648") ge xs:int("-2147483648")
xs:int("-2147483648") gt xs:int("-1873914410")
xs:int("-2147483648") gt xs:int("2147483647")
xs:int("-2147483648") gt xs:int("-2147483648")
xs:int("-2147483648") idiv xs:int("-1873914410")
xs:int("-2147483648") idiv xs:int("2147483647")
xs:int("-2147483648") idiv xs:int("-2147483648")
xs:int("-2147483648") lt xs:int("-1873914410")
xs:int("-2147483648") lt xs:int("2147483647")
xs:int("-2147483648") lt xs:int("-2147483648")
xs:int("-2147483648") mod xs:int("2147483647")
xs:int("-2147483648") ne xs:int("-1873914410")
xs:int("-2147483648") ne xs:int("2147483647")
xs:int("-2147483648") ne xs:int("-2147483648")
xs:int(-2147483648) or xs:int(0)
xs:int(-2147483648) or xs:int(1)
(xs:int("-2147483648")||xs:int("-1873914410"))
xs:int("-2147483648") - xs:int("-1873914410")
(xs:int("-2147483648")||xs:int("2147483647"))
xs:int("-2147483648") + xs:int("2147483647")
xs:int("-2147483648") - xs:int("-2147483648")
xs:int("-2147483648")||xs:int("-2147483648")
xs:int("-2147483649")
xs:int(-2147483649)
xs:int("-273569238") + xs:int("-1873914410")
xs:int("3.0")
xs:int("+ 5")
xs:int("- 5")
xs:integer("")
xs:integer()
-xs:integer(0)
xs:integer(0) and xs:integer(0)
xs:integer(0) and xs:integer(1)
xs:integer(0) or xs:integer(0)
xs:integer(0) or xs:integer(1)
xs:integer("-100") castable as xs:anyURI
xs:integer("-100") castable as xs:base64Binary
xs:integer("-100") castable as xs:boolean
xs:integer("-100") castable as xs:date
xs:integer("-100") castable as xs:dateTime
xs:integer("-100") castable as xs:dayTimeDuration
xs:integer("-100") castable as xs:decimal
xs:integer("-100") castable as xs:double
xs:integer("-100") castable as xs:duration
xs:integer("-100") castable as xs:float
xs:integer("-100") castable as xs:gDay
xs:integer("-100") castable as xs:gMonth
xs:integer("-100") castable as xs:gMonthDay
xs:integer("-100") castable as xs:gYear
xs:integer("-100") castable as xs:gYearMonth
xs:integer("-100") castable as xs:hexBinary
xs:integer("-100") castable as xs:integer
xs:integer("-100") castable as xs:string
xs:integer("-100") castable as xs:time
xs:integer("-100") castable as xs:yearMonthDuration
xs:integer("-100") cast as xs:anyURI
xs:integer("-100") cast as xs:base64Binary
xs:integer("-100") cast as xs:boolean
xs:integer("-100") cast as xs:date
xs:integer("-100") cast as xs:dateTime
xs:integer("-100") cast as xs:dayTimeDuration
xs:integer("-100") cast as xs:decimal
xs:integer("-100") cast as xs:double
xs:integer("-100") cast as xs:duration
xs:integer("-100") cast as xs:float
xs:integer("-100") cast as xs:gDay
xs:integer("-100") cast as xs:gMonth
xs:integer("-100") cast as xs:gMonthDay
xs:integer("-100") cast as xs:gYear
xs:integer("-100") cast as xs:gYearMonth
xs:integer("-100") cast as xs:hexBinary
xs:integer("-100") cast as xs:integer
xs:integer("-100") cast as xs:string
xs:integer("-100") cast as xs:time
xs:integer("-100") cast as xs:yearMonthDuration
(xs:integer(1), 2, 3)
xs:integer(12678967543233) cast as xs:boolean
xs:integer(12678967543233) cast as xs:decimal
(xs:integer(12678967543233) cast as xs:float) eq xs:float(12678967543233)
xs:integer(12678967543233) cast as xs:integer
xs:integer(12678967543233) cast as xs:string
xs:integer(-1) and xs:integer(0)
xs:integer(1) and xs:integer(-1)
xs:integer("1") castable as xs:untypedAtomic
xs:integer("1") cast as xs:untypedAtomic
xs:integer(-1) eq xs:integer(-1)
xs:integer(1) eq xs:integer(1)
xs:integer(1) ge xs:integer(1)
xs:integer(1) gt xs:integer(-1)
xs:integer(-1) le xs:integer(1)
xs:integer(-1) lt xs:integer(1)
xs:integer(1) ne xs:integer(2)
xs:integer(-1) or xs:integer(0)
xs:integer(1) or xs:integer(-1)
(xs:integer(1) to 5)
(xs:integer(1) to xs:integer(5))
xs:integer(2) idiv xs:decimal(1)
xs:integer(2) ne xs:decimal(2.6)
xs:integer(3.1) eq 3
xs:integer(3) eq 3
xs:integer(5) div xs:integer(2) eq 2.5
xs:integer(5) div xs:integer(2) ne 2.6
xs:integer( "6789" , "6789" )
xs:integer("6789") castable as xs:boolean
xs:integer("6789") castable as xs:decimal
xs:integer("6789") castable as xs:double
xs:integer("6789") castable as xs:float
xs:integer("6789") castable as xs:integer
xs:integer("6789") castable as xs:string
xs:integer("6789") castable as xs:untypedAtomic
xs:integer("6789") cast as xs:anyURI
xs:integer("6789") cast as xs:base64Binary
xs:integer("6789") cast as xs:boolean eq xs:boolean("true")
xs:integer("6789") cast as xs:date
xs:integer("6789") cast as xs:dateTime
xs:integer("6789") cast as xs:dayTimeDuration
xs:integer("6789") cast as xs:decimal ne xs:decimal("10.01")
xs:integer("6789") cast as xs:double ne xs:double("3.3e3")
xs:integer("6789") cast as xs:duration
xs:integer("6789") cast as xs:float ne xs:float("3.4e5")
xs:integer("6789") cast as xs:gDay
xs:integer("6789") cast as xs:gMonth
xs:integer("6789") cast as xs:gMonthDay
xs:integer("6789") cast as xs:gYear
xs:integer("6789") cast as xs:gYearMonth
xs:integer("6789") cast as xs:hexBinary
xs:integer("6789") cast as xs:integer eq xs:integer("6789")
xs:integer("6789") cast as xs:string ne xs:string("an arbitrary string")
xs:integer("6789") cast as xs:time
xs:integer("6789") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:integer("6789") cast as xs:yearMonthDuration
xs:integer(" 6789 ") eq xs:integer(" 6789 ")
(xs:integer(6) div xs:decimal(2)) instance of xs:decimal
(xs:integer(6) div xs:double(2)) instance of xs:double
xs:integer(6) div xs:integer(2) eq 3
(xs:integer(6) div xs:integer(2)) instance of xs:decimal
(xs:integer(6) idiv xs:decimal(2)) instance of xs:integer
(xs:integer(6) idiv xs:double(2)) instance of xs:integer
(xs:integer(6) idiv xs:float(2)) instance of xs:integer
(xs:integer(6) idiv xs:integer(2)) instance of xs:integer
xs:integer(6) instance of xs:decimal
xs:integer(6) instance of xs:integer
(xs:integer(6) mod xs:decimal(2)) instance of xs:decimal
(xs:integer(6) mod xs:double(2)) instance of xs:double
(xs:integer(6) mod xs:integer(2)) instance of xs:integer
(xs:integer(6) * xs:decimal(2)) instance of xs:decimal
(xs:integer(6) + xs:decimal(2)) instance of xs:decimal
(xs:integer(6) - xs:decimal(2)) instance of xs:decimal
(xs:integer(6) * xs:double(2)) instance of xs:double
(xs:integer(6) + xs:double(2)) instance of xs:double
(xs:integer(6) - xs:double(2)) instance of xs:double
xs:integer(6) * xs:integer(2) eq 12
xs:integer(6) - xs:integer(2) eq 4
xs:integer(6) + xs:integer(2) eq 8
(xs:integer(6) * xs:integer(2)) instance of xs:integer
(xs:integer(6) + xs:integer(2)) instance of xs:integer
(xs:integer(6) - xs:integer(2)) instance of xs:integer
xs:integer(99999999999999999) and xs:integer(0)
xs:integer(-99999999999999999) and xs:integer(1)
xs:integer(99999999999999999) and xs:integer(-99999999999999999)
xs:integer(99999999999999999) or xs:integer(0)
xs:integer(-99999999999999999) or xs:integer(1)
xs:integer(99999999999999999) or xs:integer(-99999999999999999)
xs:integer(fn:translate("123","123","123"))
xs:integer('INF')
xs:integer(/works/employee[830]/hours) eq 40
xs:integer(/works/employee[830]/hours) eq 40e0
xs:integer(xs:double("-INF"))
xs:integer(xs:double("INF"))
xs:integer(xs:double("NaN"))
xs:integer(xs:float("-INF"))
xs:integer(xs:float("INF"))
xs:integer(xs:float("NaN"))
xs:integer(xs:untypedAtomic( "6789" )) eq xs:integer("6789")
xs:int(false())
xs:int(true())
xs:int(xs:double("-4")) instance of xs:int
xs:int(xs:double("-INF"))
xs:int(xs:double("INF"))
xs:int(xs:double("NaN"))
xs:int(xs:float("-4")) instance of xs:int
xs:int(xs:float("-INF"))
xs:int(xs:float("INF"))
xs:int(xs:float("NaN"))
xs:language("")
xs:language("1")
xs:language(1)
xs:language("a")
xs:language("a1a")
xs:language("a*a")
xs:language("a.a")
xs:language("ab")
xs:language("abc")
xs:language("abc-")
xs:language("abc-a-1-1b01efil")
xs:language("abc-a-1-1b1efil")
xs:language("abc-a-1b1efikl")
xs:language("abc--ab")
xs:language("abc-ab-")
xs:language("abc-ab1efikl")
xs:language("abc-abcdefikl")
xs:language("abc-abcdef.k")
xs:language("abcd")
xs:language("abcde")
xs:language("abcdef")
xs:language("abcdefg")
xs:language("abcdefgh")
xs:language("abcdefgh-abcdefgh")
xs:language("abcdefjhl")
xs:language(current-date())
xs:language(current-dateTime())
xs:language(current-time())
xs:language('en-gb') castable as xs:language
xs:language('en-gb') cast as xs:language
xs:language(false())
xs:language("NCName") instance of xs:language
xs:language("ncname") instance of xs:NMTOKEN
xs:language("ncname") instance of xs:token
xs:language(QName("http://example.com/", "p:localName"))
xs:language(true())
xs:language(xs:base64Binary("1111"))
xs:language(xs:dayTimeDuration("P1DT4H"))
xs:language(xs:decimal("543"))
xs:language(xs:double("543"))
xs:language(xs:duration("P1M"))
xs:language(xs:float("543"))
xs:language(xs:gDay("---11"))
xs:language(xs:gMonth("--10"))
xs:language(xs:gMonthDay("--10-15"))
xs:language(xs:gYear("4004"))
xs:language(xs:hexBinary("11"))
xs:language(xs:integer("543"))
xs:language(xs:short("1"))
xs:language(xs:yearMonthDuration("P4Y5M"))
xs:long("")
xs:long("000000001")
xs:long(0) and xs:long(0)
xs:long(0) and xs:long(1)
xs:long("0") instance of xs:integer
xs:long(0) instance of xs:long
xs:long(0) or xs:long(0)
xs:long(0) or xs:long(1)
xs:long("0x9223372036854775807")
xs:long(10) + xs:unsignedLong(35)
xs:long(-1) and xs:long(0)
xs:long(1) and xs:long(-1)
xs:long("1") instance of xs:negativeInteger
xs:long("1") instance of xs:nonNegativeInteger
xs:long("1") instance of xs:nonPositiveInteger
xs:long("1") instance of xs:positiveInteger
xs:long(-1) or xs:long(0)
xs:long(1) or xs:long(-1)
xs:long("3.0")
xs:long("+ 5")
xs:long("- 5")
xs:long(9223372036854775808)
xs:long(-9223372036854775809)
xs:long(-99999999999999999) and xs:long(0)
xs:long(-99999999999999999) and xs:long(1)
xs:long(99999999999999999) and xs:long(-99999999999999999)
xs:long(-99999999999999999) or xs:long(0)
xs:long(-99999999999999999) or xs:long(1)
xs:long(99999999999999999) or xs:long(-99999999999999999)
xs:long(false())
xs:long(true())
xs:long(xs:double("-4")) instance of xs:long
xs:long(xs:double("-INF"))
xs:long(xs:double("INF"))
xs:long(xs:double("NaN"))
xs:long(xs:float("-4")) instance of xs:long
xs:long(xs:float("-INF"))
xs:long(xs:float("INF"))
xs:long(xs:float("NaN"))
xs:Name("")
xs:Name(":")
xs:Name("::::")
xs:Name("_")
xs:Name("1abc")
xs:Name(" a ")
xs:Name("a")
xs:Name("a1123-_--__-__--....-.--.-..12309asd")
xs:Name("ab|")
xs:Name("ab\c")
xs:Name("a c")
xs:name("input")
xs:Name("ncname") instance of xs:language
xs:Name("NCName") instance of xs:Name
xs:Name("ncname") instance of xs:token
xs:NCName("")
xs:NCName('entity') cast as xs:ENTITY
xs:NCName('id') cast as xs:ID
xs:NCName('idref') cast as xs:IDREF
xs:NCName('NCName') castable as xs:Name
xs:NCName('NCName') cast as xs:Name
xs:NCName("ncname") instance of xs:Name
xs:NCName("NCName") instance of xs:NCName
xs:negativeInteger("")
xs:negativeInteger("+0")
xs:negativeInteger("-0")
xs:negativeInteger("0")
xs:negativeInteger(0)
xs:negativeInteger("-000000001")
xs:negativeInteger("-0x1")
+(xs:negativeInteger("-1"))
-(xs:negativeInteger("-1"))
xs:negativeInteger("--1")
xs:negativeInteger("-1")
xs:negativeInteger(-1) and xs:negativeInteger(-1)
xs:negativeInteger(-1) instance of xs:negativeInteger
xs:negativeInteger("-1") instance of xs:nonPositiveInteger
xs:negativeInteger(-1) or xs:negativeInteger(-1)
xs:negativeInteger("- 3")
xs:negativeInteger("-3.0")
xs:negativeInteger(-99999999999999999) and xs:negativeInteger(-1)
xs:negativeInteger(-99999999999999999) and xs:negativeInteger(-99999999999999999)
xs:negativeInteger(-99999999999999999) or xs:negativeInteger(-1)
xs:negativeInteger(-99999999999999999) or xs:negativeInteger(-99999999999999999)
xs:negativeInteger(false())
xs:negativeInteger(true())
xs:negativeInteger(xs:double("-4")) instance of xs:negativeInteger
xs:negativeInteger(xs:double("-INF"))
xs:negativeInteger(xs:double("INF"))
xs:negativeInteger(xs:double("NaN"))
xs:negativeInteger(xs:float("-4")) instance of xs:negativeInteger
xs:negativeInteger(xs:float("-INF"))
xs:negativeInteger(xs:float("INF"))
xs:negativeInteger(xs:float("NaN"))
xs:NMTOKEN(" ")
xs:NMTOKEN("")
xs:NMTOKEN(";")
xs:NMTOKEN(" f f")
xs:NMTOKEN("NCName") instance of xs:NMTOKEN
xs:NMTOKEN("ncname") instance of xs:token
xs:NMTOKEN('NMTOKEN') castable as xs:NMTOKEN
xs:NMTOKEN('NMTOKEN') cast as xs:NMTOKEN
xs:NMTOKEN(" ::::...:SDA21455313 ")
xs:nonNegativeInteger("")
+(xs:nonNegativeInteger("0"))
-(xs:nonNegativeInteger("0"))
xs:nonNegativeInteger("+ 0")
xs:nonNegativeInteger("- 0")
xs:nonNegativeInteger("--0")
xs:nonNegativeInteger("-0")
xs:nonNegativeInteger("0")
xs:nonNegativeInteger("-00")
xs:nonNegativeInteger("000000001")
xs:nonNegativeInteger(0) and xs:nonNegativeInteger(0)
xs:nonNegativeInteger(0) and xs:nonNegativeInteger(1)
xs:nonNegativeInteger("0") eq xs:nonNegativeInteger("0")
xs:nonNegativeInteger("0") ge xs:nonNegativeInteger("0")
xs:nonNegativeInteger("0") gt xs:nonNegativeInteger("0")
xs:nonNegativeInteger("0") instance of xs:integer
xs:nonNegativeInteger(0) instance of xs:nonNegativeInteger
xs:nonNegativeInteger("0") lt xs:nonNegativeInteger("0")
xs:nonNegativeInteger("0") ne xs:nonNegativeInteger("0")
xs:nonNegativeInteger(0) or xs:nonNegativeInteger(0)
xs:nonNegativeInteger(0) or xs:nonNegativeInteger(1)
xs:nonNegativeInteger("0x0")
(xs:nonNegativeInteger("0") || xs:nonNegativeInteger("0"))
xs:nonNegativeInteger("0") * xs:nonNegativeInteger("0")
xs:nonNegativeInteger("0") + xs:nonNegativeInteger("0")
xs:nonNegativeInteger("0") - xs:nonNegativeInteger("0")
xs:nonNegativeInteger("++1")
xs:nonNegativeInteger("+1")
xs:nonNegativeInteger("-1")
xs:nonNegativeInteger(-1)
xs:nonNegativeInteger(10) + xs:short(15)
xs:nonNegativeInteger(1) and xs:nonNegativeInteger(0)
xs:nonNegativeInteger(1) and xs:nonNegativeInteger(1)
xs:nonNegativeInteger(1) and xs:nonNegativeInteger(99999999999999999)
xs:nonNegativeInteger("1") instance of xs:negativeInteger
xs:nonNegativeInteger("1") instance of xs:nonPositiveInteger
xs:nonNegativeInteger(1) or xs:nonNegativeInteger(0)
xs:nonNegativeInteger(1) or xs:nonNegativeInteger(1)
xs:nonNegativeInteger(1) or xs:nonNegativeInteger(99999999999999999)
xs:nonNegativeInteger("3.0")
xs:nonNegativeInteger(99999999999999999) and xs:nonNegativeInteger(99999999999999999)
xs:nonNegativeInteger(99999999999999999) or xs:nonNegativeInteger(0)
xs:nonNegativeInteger(99999999999999999) or xs:nonNegativeInteger(99999999999999999)
xs:nonNegativeInteger(9999999999) and xs:nonNegativeInteger(0)
xs:nonNegativeInteger(false())
xs:nonNegativeInteger(true())
xs:nonNegativeInteger(xs:double("4")) instance of xs:nonNegativeInteger
xs:nonNegativeInteger(xs:double("-INF"))
xs:nonNegativeInteger(xs:double("INF"))
xs:nonNegativeInteger(xs:double("NaN"))
xs:nonNegativeInteger(xs:float("4")) instance of xs:nonNegativeInteger
xs:nonNegativeInteger(xs:float("-INF"))
xs:nonNegativeInteger(xs:float("INF"))
xs:nonNegativeInteger(xs:float("NaN"))
xs:nonPositiveInteger("")
+(xs:nonPositiveInteger("0"))
-(xs:nonPositiveInteger("0"))
xs:nonPositiveInteger("+ 0")
xs:nonPositiveInteger("++0")
xs:nonPositiveInteger("+0")
xs:nonPositiveInteger("- 0")
xs:nonPositiveInteger("--0")
xs:nonPositiveInteger("-0")
xs:nonPositiveInteger("0")
xs:nonPositiveInteger("+00")
xs:nonPositiveInteger("-000000000")
xs:nonPositiveInteger("-000000001")
xs:nonPositiveInteger(0) and xs:nonPositiveInteger(0)
xs:nonPositiveInteger(0) and xs:nonPositiveInteger(-1)
xs:nonPositiveInteger("0") instance of xs:integer
xs:nonPositiveInteger(0) instance of xs:nonPositiveInteger
xs:nonPositiveInteger(0) or xs:nonPositiveInteger(0)
xs:nonPositiveInteger(0) or xs:nonPositiveInteger(-1)
xs:nonPositiveInteger("0x0")
xs:nonPositiveInteger("+1")
xs:nonPositiveInteger("--1")
xs:nonPositiveInteger("-1")
xs:nonPositiveInteger("1")
xs:nonPositiveInteger(1)
xs:nonPositiveInteger(-1) and xs:nonPositiveInteger(0)
xs:nonPositiveInteger(-1) and xs:nonPositiveInteger(-1)
xs:nonPositiveInteger(-1) and xs:nonPositiveInteger(-9999999999)
xs:nonPositiveInteger(-1) or xs:nonPositiveInteger(0)
xs:nonPositiveInteger(-1) or xs:nonPositiveInteger(-1)
xs:nonPositiveInteger(-1) or xs:nonPositiveInteger(-99999999999999999)
xs:nonPositiveInteger("-3.0")
xs:nonPositiveInteger(-99999999999999999) and xs:nonPositiveInteger(0)
xs:nonPositiveInteger(-99999999999999999) and xs:nonPositiveInteger(-99999999999999999)
xs:nonPositiveInteger(-99999999999999999) or xs:nonPositiveInteger(0)
xs:nonPositiveInteger(-99999999999999999) or xs:nonPositiveInteger(-99999999999999999)
xs:nonPositiveInteger(false())
xs:nonPositiveInteger(true())
xs:nonPositiveInteger(xs:double("0")) instance of xs:nonPositiveInteger
xs:nonPositiveInteger(xs:double("-INF"))
xs:nonPositiveInteger(xs:double("INF"))
xs:nonPositiveInteger(xs:double("NaN"))
xs:nonPositiveInteger(xs:float("0")) instance of xs:nonPositiveInteger
xs:nonPositiveInteger(xs:float("-INF"))
xs:nonPositiveInteger(xs:float("INF"))
xs:nonPositiveInteger(xs:float("NaN"))
xs:normalizedString("")
xs:normalizedString(' ')
xs:normalizedString(5)
xs:normalizedString("NCName") instance of xs:normalizedString
xs:normalizedString("ncname") instance of xs:string
xs:normalizedString("ncname") instance of xs:token
xs:normalizedString("test") castable as xs:normalizedString
xs:normalizedString('&#x9;')
xs:normalizedString(xs:normalizedString("test"))
xs:NOTATION()
xs:NOTATION( "prefix:local" , "prefix:local" )
xs:NOTATION(QName('example.com', 'p:foo'))
xs:NOTATION(xs:anyURI('example.com/'))
xs:positiveInteger("")
xs:positiveInteger("-0")
xs:positiveInteger("0")
xs:positiveInteger(0)
xs:positiveInteger("000000001")
xs:positiveInteger("0x1")
+(xs:positiveInteger("1"))
-(xs:positiveInteger("1"))
xs:positiveInteger("++1")
xs:positiveInteger("+1")
xs:positiveInteger("-1")
xs:positiveInteger("1")
xs:positiveInteger(10) + xs:negativeInteger(-5)
xs:positiveInteger(10) + xs:nonPositiveInteger(-15)
xs:positiveInteger(1) and xs:positiveInteger(1)
xs:positiveInteger("1") div xs:positiveInteger("1")
xs:positiveInteger("1") eq xs:positiveInteger("1")
xs:positiveInteger("1") ge xs:positiveInteger("1")
xs:positiveInteger("1") gt xs:positiveInteger("1")
xs:positiveInteger("1") idiv xs:positiveInteger("1")
xs:positiveInteger("1") instance of xs:negativeInteger
xs:positiveInteger("1") instance of xs:nonNegativeInteger
xs:positiveInteger("1") instance of xs:nonPositiveInteger
xs:positiveInteger(1) instance of xs:positiveInteger
xs:positiveInteger("1") lt xs:positiveInteger("1")
xs:positiveInteger("1") mod xs:positiveInteger("1")
xs:positiveInteger("1") ne xs:positiveInteger("1")
xs:positiveInteger(1) or xs:positiveInteger(1)
(xs:positiveInteger("1") || xs:positiveInteger("1"))
xs:positiveInteger("1") * xs:positiveInteger("1")
xs:positiveInteger("1") + xs:positiveInteger("1")
xs:positiveInteger("+ 3")
xs:positiveInteger("3.0")
xs:positiveInteger("52") castable as xs:double
xs:positiveInteger(99999999999999999) and xs:positiveInteger(1)
xs:positiveInteger(99999999999999999) and xs:positiveInteger(99999999999999999)
xs:positiveInteger(99999999999999999) or xs:positiveInteger(1)
xs:positiveInteger(99999999999999999) or xs:positiveInteger(99999999999999999)
xs:positiveInteger(false())
xs:positiveInteger(true())
xs:positiveInteger(xs:double("4")) instance of xs:positiveInteger
xs:positiveInteger(xs:float("4")) instance of xs:positiveInteger
xs:QName("")
xs:QName()
xs:QName(20)
(xs:QName("fn:local-name") cast as xs:string) eq "fn:local-name"
(xs:QName("fn:local-name") cast as xs:untypedAtomic) eq xs:untypedAtomic("fn:local-name")
(xs:QName("local-name") cast as xs:QName) eq xs:QName("local-name")
(xs:QName("local-name") cast as xs:string) eq "local-name"
(xs:QName("local-name") cast as xs:untypedAtomic) eq xs:untypedAtomic("local-name")
xs:QName("ncname") castable as xs:QName
xs:QName("ncname") castable as xs:string
xs:QName("ncname") castable as xs:untypedAtomic
xs:QName("ncname") cast as xs:anyURI
xs:QName("ncname") cast as xs:base64Binary
xs:QName("ncname") cast as xs:boolean
xs:QName("ncname") cast as xs:date
xs:QName("ncname") cast as xs:dateTime
xs:QName("ncname") cast as xs:dayTimeDuration
xs:QName("ncname") cast as xs:decimal
xs:QName("ncname") cast as xs:double
xs:QName("ncname") cast as xs:duration
xs:QName("ncname") cast as xs:float
xs:QName("ncname") cast as xs:gDay
xs:QName("ncname") cast as xs:gMonth
xs:QName("ncname") cast as xs:gMonthDay
xs:QName("ncname") cast as xs:gYear
xs:QName("ncname") cast as xs:gYearMonth
xs:QName("ncname") cast as xs:hexBinary
xs:QName("ncname") cast as xs:integer
xs:QName("ncname") cast as xs:string ne xs:string("an arbitrary string")
xs:QName("ncname") cast as xs:time
xs:QName("ncname") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:QName("ncname") cast as xs:yearMonthDuration
xs:QName(" ncname ") eq xs:QName(" ncname ")
xs:QName( "ncname" , "ncname" )
xs:QName('prefix:localName')
xs:short("")
xs:short("000000001")
xs:short(0) and xs:short(0)
xs:short(0) and xs:short(1)
xs:short("0") instance of xs:int
xs:short(0) instance of xs:short
xs:short(0) or xs:short(0)
xs:short(0) or xs:short(1)
xs:short("-0x32768")
xs:short(10) + xs:long(145)
xs:short(-1) and xs:short(0)
xs:short(1) and xs:short(-1)
xs:short(-1) or xs:short(0)
xs:short(1) or xs:short(-1)
xs:short("-1") - xs:short("32767")
xs:short("-1") - xs:short("-32768")
xs:short("-27444") + xs:short("-5324")
xs:short("3.0")
+(xs:short("32767"))
-(xs:short("32767"))
xs:short("32767")
xs:short(32767) and xs:short(0)
xs:short(32767) and xs:short(-1)
xs:short(32767) and xs:short(-32768)
xs:short("32767") div xs:short("-32768")
xs:short("32767") eq xs:short("-32768")
xs:short("32767") ge xs:short("-32768")
xs:short("32767") gt xs:short("-32768")
xs:short("32767") idiv xs:short("-32768")
xs:short("32767") lt xs:short("-32768")
xs:short("32767") ne xs:short("-32768")
xs:short(32767) or xs:short(0)
xs:short(32767) or xs:short(-1)
xs:short(32767) or xs:short(-32768)
(xs:short("32767") || xs:short("-32768"))
xs:short("32767") + xs:short("-32768")
+(xs:short("-32768"))
-(xs:short("-32768"))
xs:short("-32768")
xs:short("32768")
xs:short(32768)
xs:short(-32768) and xs:short(0)
xs:short(-32768) and xs:short(1)
xs:short("-32768") div xs:short("32767")
xs:short("-32768") div xs:short("-32768")
xs:short("-32768") eq xs:short("32767")
xs:short("-32768") eq xs:short("-32768")
xs:short("-32768") eq xs:short("-5324")
xs:short("-32768") ge xs:short("32767")
xs:short("-32768") ge xs:short("-32768")
xs:short("-32768") ge xs:short("-5324")
xs:short("-32768") gt xs:short("32767")
xs:short("-32768") gt xs:short("-32768")
xs:short("-32768") gt xs:short("-5324")
xs:short("-32768") idiv xs:short("32767")
xs:short("-32768") idiv xs:short("-32768")
xs:short("-32768") idiv xs:short("-5324")
xs:short("-32768") lt xs:short("32767")
xs:short("-32768") lt xs:short("-32768")
xs:short("-32768") lt xs:short("-5324")
xs:short("-32768") mod xs:short("32767")
xs:short("-32768") ne xs:short("32767")
xs:short("-32768") ne xs:short("-32768")
xs:short("-32768") ne xs:short("-5324")
xs:short(-32768) or xs:short(0)
xs:short(-32768) or xs:short(1)
(xs:short("-32768") || xs:short("32767"))
xs:short("-32768") + xs:short("32767")
(xs:short("-32768") || xs:short("-32768"))
xs:short("-32768") - xs:short("-32768")
(xs:short("-32768") || xs:short("-5324"))
xs:short("-32768") - xs:short("-5324")
xs:short("-32769")
xs:short(-32769)
xs:short("+ 5")
xs:short("- 5")
+(xs:short("-5324"))
-(xs:short("-5324"))
xs:short("-5324") eq xs:short("-32768")
xs:short("-5324") ge xs:short("-32768")
xs:short("-5324") gt xs:short("-32768")
xs:short("-5324") idiv xs:short("-32768")
xs:short("-5324") lt xs:short("-32768")
xs:short("-5324") ne xs:short("-32768")
xs:short("-5324") + xs:short("-27444")
(xs:short("-5324") || xs:short("-32768"))
xs:short("-5324") - xs:short("-32768")
xs:short(false())
xs:short(true())
xs:short(xs:double("-4")) instance of xs:short
xs:short(xs:double("-INF"))
xs:short(xs:double("INF"))
xs:short(xs:double("NaN"))
xs:short(xs:float("-4")) instance of xs:short
xs:short(xs:float("-INF"))
xs:short(xs:float("INF"))
xs:short(xs:float("NaN"))
xs:string()
xs:string("00000000") castable as xs:base64Binary
xs:string("00000000") cast as xs:base64Binary
xs:string("-0012-05:00") castable as xs:gYear
xs:string("-0012-05:00") cast as xs:gYear
xs:string("-0012-12-03-05:00") castable as xs:date
xs:string("-0012-12-03-05:00") cast as xs:date
xs:string("-0012-12-05:00") castable as xs:gYearMonth
xs:string("-0012-12-05:00") cast as xs:gYearMonth
xs:string("0.0") castable as xs:boolean
xs:string("0.0") cast as xs:boolean
xs:string("-0.0E0") castable as xs:decimal
xs:string("-0.0E0") castable as xs:double
xs:string("-0.0E0") castable as xs:float
xs:string("-0.0E0") castable as xs:integer
xs:string("0.0E0") castable as xs:string
xs:string("0.0E0") castable as xs:untypedAtomic
xs:string("-0.0E0") cast as xs:decimal
xs:string("-0.0E0") cast as xs:double
xs:string("-0.0E0") cast as xs:float
xs:string("-0.0E0") cast as xs:integer
xs:string("0.0E0") cast as xs:string
xs:string("0.0E0") cast as xs:untypedAtomic
xs:string("010010101") castable as xs:hexBinary
xs:string("010010101") cast as xs:hexBinary
xs:string("---03-05:00") castable as xs:gDay
xs:string("---03-05:00") cast as xs:gDay
xs:string("--05-31+14:00") castable as xs:gMonthDay
xs:string("--05-31+14:00") cast as xs:gMonthDay
xs:string("--05-31") castable as xs:gMonthDay
xs:string("--05-31") cast as xs:gMonthDay
xs:string("--05-31Z") castable as xs:gMonthDay
xs:string("--05-31Z") cast as xs:gMonthDay
xs:string("--05") castable as xs:gMonth
xs:string("--05") cast as xs:gMonth
xs:string("--05Z") castable as xs:gMonth
xs:string("--05Z") cast as xs:gMonth
xs:string("0") and xs:string('abc')
xs:string("0") castable as xs:boolean
xs:string("0") cast as xs:boolean
xs:string("0fb7") castable as xs:hexBinary
xs:string("0fb7") cast as xs:hexBinary
xs:string("0") or xs:string('abc')
xs:string("-10000000") castable as xs:double
xs:string("-10000000") castable as xs:float
xs:string("-1.1234") castable as xs:integer
xs:string("-1.1234") cast as xs:integer
xs:string("--12-05:00") castable as xs:gMonth
xs:string("--12-05:00") cast as xs:gMonth
xs:string(120) cast as xs:byte
xs:string(12) cast as xs:unsignedByte
xs:string(12) cast as xs:unsignedShort
xs:string("13:20:00-05:00") castable as xs:time
xs:string("13:20:00-05:00") cast as xs:time
xs:string("13:20:00Z") castable as xs:time
xs:string("13:20:00Z") cast as xs:time
xs:string("13:20:02.123") castable as xs:time
xs:string("13:20:02.123") cast as xs:time
xs:string("1999-05-31") castable as xs:date
xs:string("1999-05-31") cast as xs:date
xs:string("-1999-05-31T13:20:00+14:00") castable as xs:dateTime
xs:string("-1999-05-31T13:20:00+14:00") cast as xs:dateTime
xs:string("1999-05-31T13:20:00") castable as xs:dateTime
xs:string("1999-05-31T13:20:00") cast as xs:dateTime
xs:string("1999-05-31Z") castable as xs:date
xs:string("1999-05-31Z") cast as xs:date
xs:string("1999-05") castable as xs:gYearMonth
xs:string("1999-05") cast as xs:gYearMonth
xs:string("1999-05Z") castable as xs:gYearMonth
xs:string("1999-05Z") cast as xs:gYearMonth
xs:string("1999") castable as xs:gYear
xs:string("1999") cast as xs:gYear
xs:string("1999Z") castable as xs:gYear
xs:string("1999Z") cast as xs:gYear
xs:string("1e-5") castable as xs:decimal
xs:string("1e-5") castable as xs:double
xs:string("1e-5") castable as xs:float
xs:string("1e-5") castable as xs:integer
xs:string("1e-5") cast as xs:decimal
xs:string("1e-5") cast as xs:double
xs:string("1e-5") cast as xs:float
xs:string("1e-5") cast as xs:integer
xs:string((1 to 10)[. mod 2 = 0] instance of xs:integer+)
xs:string("2000-01-16T00:00:00Z") castable as xs:dateTime
xs:string("2000-01-16T00:00:00Z") cast as xs:dateTime
xs:string(200) cast as xs:nonNegativeInteger
xs:string(-201) cast as xs:negativeInteger
xs:string(20) cast as xs:int
xs:string(20) cast as xs:long
xs:string(-20) cast as xs:nonPositiveInteger
xs:string(20) cast as xs:unsignedLong
xs:string(300) cast as xs:positiveInteger
xs:string(300) cast as xs:unsignedInt
xs:string(30) cast as xs:short
xs:string("---31") castable as xs:gDay
xs:string("---31") cast as xs:gDay
xs:string("---31Z") castable as xs:gDay
xs:string("---31Z") cast as xs:gDay
xs:string("5.5432") castable as xs:decimal
xs:string("5.5432") cast as xs:decimal
xs:string("abc") and xs:string('')
(xs:string("ABC"), "D", "E")
xs:string("abc") or xs:string('')
xs:string( "an arbitrary string" , "an arbitrary string" )
xs:string("an arbitrary string") castable as xs:string
xs:string("an arbitrary string") castable as xs:untypedAtomic
xs:string("an arbitrary string") cast as xs:string eq xs:string("an arbitrary string")
xs:string("an arbitrary string") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:string(" an arbitrary string ") eq xs:string(" an arbitrary string ")
xs:string("") and xs:string('')
xs:string("") and xs:string('abc')
xs:string("A String") cast as xs:NOTATION
xs:string("a") , xs:anyURI("www.example.com")
xs:string("a") , xs:string("b")
xs:string("a") , (), "xyz"
xs:string("D74D35D35D35") castable as xs:base64Binary
xs:string("D74D35D35D35") castable as xs:hexBinary
xs:string("D74D35D35D35") cast as xs:base64Binary
xs:string("D74D35D35D35") cast as xs:hexBinary
xs:string(dateTime(xs:date("1999-12-31"), xs:time("24:00:00"))) eq "1999-12-31T00:00:00"
xs:string("") eq xs:string("")
xs:string("example.com/") eq xs:anyURI("example.com/")
xs:string("example.com/") ne xs:anyURI("example.com/No")
xs:string("example.org/") eq xs:anyURI("example.org/")
xs:string("example.org/") ne xs:anyURI("example.org/")
xs:string("false") != false()
xs:string("false") = false()
xs:string(fn:codepoints-to-string((65,32,83,116,114,105,110,103)))
xs:string(fn:current-date())
xs:string(fn:current-dateTime())
xs:string(fn:current-time())
xs:string(fn:prefix-from-QName(xs:QName("foo:name")))
xs:string("hello") , xs:integer("100"), xs:anyURI("www.example.com")
xs:string("http://example.com/A") eq xs:anyURI("http://example.com/A")
xs:string("http://example.com/A") le xs:anyURI("http://example.com/A")
xs:string("http://example.com/A") lt xs:anyURI("http://example.com/B")
xs:string("http://example.com/A") ne xs:anyURI("http://example.com/B")
xs:string("http://example.com/B") gt xs:anyURI("http://example.com/A")
xs:string("http://www.example.com/~b%C3%A9b%C3%A9") castable as xs:anyURI
xs:string("http://www.example.com/~b%C3%A9b%C3%A9") cast as xs:anyURI
xs:string("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:anyURI
xs:string("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:anyURI
xs:string("INF") castable as xs:string
xs:string("INF") castable as xs:untypedAtomic
xs:string("INF") cast as xs:string
xs:string("INF") cast as xs:untypedAtomic
((), "xs:string") instance of xs:string
xs:string("NaN") castable as xs:decimal
xs:string("NaN") castable as xs:double
xs:string("NaN") castable as xs:float
xs:string("NaN") castable as xs:integer
xs:string("NaN") cast as xs:decimal
xs:string("NaN") cast as xs:double
xs:string("NaN") cast as xs:float
xs:string("NaN") cast as xs:integer
xs:string("") or xs:string('')
xs:string("") or xs:string('abc')
xs:string("-P1Y1M1DT1H1M1.123S") castable as xs:dayTimeDuration
xs:string("-P1Y1M1DT1H1M1.123S") castable as xs:duration
xs:string("-P1Y1M1DT1H1M1.123S") castable as xs:yearMonthDuration
xs:string("-P1Y1M1DT1H1M1.123S") cast as xs:dayTimeDuration
xs:string("-P1Y1M1DT1H1M1.123S") cast as xs:yearMonthDuration
xs:string("P1Y2M3DT10H30M23S") castable as xs:duration
xs:string("P1Y2M3DT10H30M23S") cast as xs:duration
xs:string("-P21M") castable as xs:yearMonthDuration
xs:string("-P21M") cast as xs:yearMonthDuration
xs:string("P24M") castable as xs:yearMonthDuration
xs:string("P24M") cast as xs:yearMonthDuration
xs:string("P3DT10H30M") castable as xs:dayTimeDuration
xs:string("P3DT10H30M") cast as xs:dayTimeDuration
xs:string("-PT100M") castable as xs:dayTimeDuration
xs:string("-PT100M") cast as xs:dayTimeDuration
xs:string("true") castable as xs:anyURI
xs:string("true") castable as xs:base64Binary
xs:string("true") castable as xs:boolean
xs:string("true") castable as xs:date
xs:string("true") castable as xs:dateTime
xs:string("true") castable as xs:dayTimeDuration
xs:string("true") castable as xs:decimal
xs:string("true") castable as xs:double
xs:string("true") castable as xs:duration
xs:string("true") castable as xs:float
xs:string("true") castable as xs:gDay
xs:string("true") castable as xs:gMonth
xs:string("true") castable as xs:gMonthDay
xs:string("true") castable as xs:gYear
xs:string("true") castable as xs:gYearMonth
xs:string("true") castable as xs:hexBinary
xs:string("true") castable as xs:integer
xs:string("true") castable as xs:string
xs:string("true") castable as xs:time
xs:string("true") castable as xs:untypedAtomic
xs:string("true") castable as xs:yearMonthDuration
xs:string("true") cast as xs:anyURI
xs:string("true") cast as xs:base64Binary
xs:string("true") cast as xs:boolean
xs:string("true") cast as xs:date
xs:string("true") cast as xs:dateTime
xs:string("true") cast as xs:dayTimeDuration
xs:string("true") cast as xs:decimal
xs:string("true") cast as xs:double
xs:string("true") cast as xs:duration
xs:string("true") cast as xs:float
xs:string("true") cast as xs:gDay
xs:string("true") cast as xs:gMonth
xs:string("true") cast as xs:gMonthDay
xs:string("true") cast as xs:gYear
xs:string("true") cast as xs:gYearMonth
xs:string("true") cast as xs:hexBinary
xs:string("true") cast as xs:integer
xs:string("true") cast as xs:string
xs:string("true") cast as xs:time
xs:string("true") cast as xs:untypedAtomic
xs:string("true") cast as xs:yearMonthDuration
xs:string(/works/@id) eq "abc"
xs:string(/works/@id) ne "abc"
xs:string(xs:anyURI('example.com/')) eq 'example.com/'
xs:string(xs:base64Binary("0w==")) eq "0w=="
xs:string(xs:base64Binary("a"))
xs:string(xs:base64Binary("aaaa===="))
xs:string(xs:base64Binary("aaaaa======="))
xs:string(xs:base64Binary("aaaa=bcd"))
xs:string(xs:base64Binary("aaaabcd"))
xs:string(xs:base64Binary("aaaabcd|"))
xs:string(xs:base64Binary("=aaabbcd"))
xs:string(xs:base64Binary("aabbcd=a"))
xs:string(xs:base64Binary("aabb=d=="))
xs:string(xs:base64Binary("abcdefghi"))
xs:string(xs:base64Binary("")) eq ""
xs:string(xs:base64Binary("F==="))
xs:string(xs:base64Binary("frfhforlksid7453")) eq "frfhforlksid7453"
xs:string(xs:base64Binary(xs:hexBinary("03"))) eq "Aw=="
xs:string(xs:base64Binary(xs:hexBinary("0f3c"))) eq "Dzw="
xs:string(xs:base64Binary(xs:hexBinary("12"))) eq "Eg=="
xs:string(xs:base64Binary(xs:hexBinary("3B"))) eq "Ow=="
xs:string(xs:base64Binary(xs:hexBinary("69A69A"))) eq "aaaa"
xs:string(xs:base64Binary(xs:hexBinary("f0"))) eq "8A=="
xs:string(xs:base64Binary(xs:hexBinary("F43D1234ce8f"))) eq "9D0SNM6P"
xs:string(xs:base64Binary(xs:hexBinary("ffaabbddcceeff0134f001d8ca9bc77899c83e6f7d"))) eq "/6q73czu/wE08AHYypvHeJnIPm99"
xs:string(xs:base64Binary(xs:hexBinary("ffff34564321deac9876"))) eq "//80VkMh3qyYdg=="
xs:string(xs:base64Binary(xs:hexBinary("ffff"))) eq "//8="
xs:string(xs:byte(3))
xs:string(xs:date("1999-12-01+00:00")) eq "1999-12-01Z"
xs:string(xs:date("1999-12-01-00:00")) eq "1999-12-01Z"
xs:string(xs:date("2002-02-15")) eq "2002-02-15"
xs:string(xs:dateTime("1999-12-01T23:59:12.432+00:00")) eq "1999-12-01T23:59:12.432Z"
xs:string(xs:dateTime("1999-12-01T23:59:12.999-00:00")) eq "1999-12-01T23:59:12.999Z"
xs:string(xs:dateTime("2002-02-15T21:01:23.000")) eq "2002-02-15T21:01:23"
xs:string(xs:dateTime("2002-02-15T21:01:23.001")) eq "2002-02-15T21:01:23.001"
xs:string(xs:dateTime("2002-02-15T21:01:23.010")) eq "2002-02-15T21:01:23.01"
xs:string(xs:dateTime("2002-02-15T21:01:23.100")) eq "2002-02-15T21:01:23.1"
xs:string(xs:dateTime("2002-02-15T21:01:23.110")) eq "2002-02-15T21:01:23.11"
xs:string(xs:dateTime("2002-02-15T21:01:23.11")) eq "2002-02-15T21:01:23.11"
xs:string(xs:dateTime("2002-02-15T21:01:23.435")) eq "2002-02-15T21:01:23.435"
xs:string(xs:dayTimeDuration("-P0010DT0010H0010M0010S")) eq "-P10DT10H10M10S"
xs:string(xs:dayTimeDuration("P0010DT0010H0010M0010S")) eq "P10DT10H10M10S"
xs:string(xs:dayTimeDuration("P0DT00H00M00.000S")) eq "PT0S"
xs:string(xs:dayTimeDuration("P3D")) eq "P3D"
xs:string(xs:dayTimeDuration("-P5DT0H0M0.000S")) eq "-P5D"
xs:string(xs:dayTimeDuration("P9876DT1M")) eq "P9876DT1M"
xs:string(xs:dayTimeDuration("-PT0S")) eq "PT0S"
xs:string(xs:dayTimeDuration("PT6000M")) eq "P4DT4H"
xs:string(xs:dayTimeDuration("-PT8H23M0S")) eq "-PT8H23M"
xs:string(xs:dayTimeDuration("PT9876H1M")) eq "P411DT12H1M"
xs:string(xs:dayTimeDuration(xs:yearMonthDuration("-P543Y456M"))) eq "PT0S"
xs:string(xs:dayTimeDuration(xs:yearMonthDuration("P543Y456M"))) eq "PT0S"
() , xs:string(" ") , xs:decimal("2.000000000000002")
xs:string(xs:decimal(3)) eq '3'
xs:string(xs:double(3)) eq '3'
xs:string(xs:double("-INF")) eq "-INF"
xs:string(xs:double("INF")) eq "INF"
xs:string(xs:duration("-P0010DT0010H0010M0010S")) eq "-P10DT10H10M10S"
xs:string(xs:duration("P0010Y0010M0010DT0010H0010M0010S")) eq "P10Y10M10DT10H10M10S"
xs:string(xs:duration("P0Y0M0DT00H00M00.000S")) eq "PT0S"
xs:string(xs:duration("P12M")) eq "P1Y"
xs:string(xs:duration("-P2000Y11M5DT0H0M0.000S")) eq "-P2000Y11M5D"
xs:string(xs:duration("P31D")) eq "P31D"
xs:string(xs:duration("P365D")) eq "P365D"
xs:string(xs:duration("-PT0S")) eq "PT0S"
xs:string(xs:duration("-PT8H23M0S")) eq "-PT8H23M"
xs:string(xs:duration(xs:yearMonthDuration("-P543Y456M"))) eq "-P581Y"
xs:string(xs:duration(xs:yearMonthDuration("P543Y456M"))) eq "P581Y"
xs:string(xs:ENTITY("foo"))
xs:string(xs:float("-INF")) eq "-INF"
xs:string(xs:float("INF")) eq "INF"
xs:string(xs:gDay("---01+00:00")) eq "---01Z"
xs:string(xs:gDay("---01-00:00")) eq "---01Z"
xs:string(xs:gDay("---01Z")) eq "---01Z"
xs:string(xs:gMonth("--01+00:00")) eq "--01Z"
xs:string(xs:gMonth("--01-00:00")) eq "--01Z"
xs:string(xs:gMonth("--01Z")) eq "--01Z"
xs:string(xs:gMonthDay("--01-01+00:00")) eq "--01-01Z"
xs:string(xs:gMonthDay("--01-01-00:00")) eq "--01-01Z"
xs:string(xs:gMonthDay("--01-01Z")) eq "--01-01Z"
xs:string(xs:gYear("1999+00:00")) eq "1999Z"
xs:string(xs:gYear("1999-00:00")) eq "1999Z"
xs:string(xs:gYear("1999Z")) eq "1999Z"
xs:string(xs:gYearMonth("1999-01+00:00")) eq "1999-01Z"
xs:string(xs:gYearMonth("1999-01-00:00")) eq "1999-01Z"
xs:string(xs:gYearMonth("1999-01Z")) eq "1999-01Z"
xs:string(xs:hexBinary("031a34123b")) eq "031A34123B"
xs:string(xs:hexBinary("03")) eq "03"
xs:string(xs:hexBinary("0a")) eq "0A"
xs:string(xs:hexBinary("0b")) eq "0B"
xs:string(xs:hexBinary("0c")) eq "0C"
xs:string(xs:hexBinary("10")) eq "10"
xs:string(xs:hexBinary("3a")) eq "3A"
xs:string(xs:hexBinary("a0")) eq "A0"
xs:string(xs:hexBinary("a4")) eq "A4"
xs:string(xs:hexBinary("aa")) eq "AA"
xs:string(xs:hexBinary("c0")) eq "C0"
xs:string(xs:hexBinary("")) eq ""
xs:string(xs:hexBinary("fA")) eq "FA"
xs:string(xs:hexBinary(xs:base64Binary("aaa a"))) eq "69A69A"
xs:string(xs:hexBinary(xs:base64Binary("Ow=="))) eq "3B"
xs:string(xs:ID("foo"))
xs:string(xs:IDREF("foo"))
xs:string(xs:int(3))
xs:string(xs:integer(3)) eq '3'
xs:string(xs:language("foo"))
xs:string(xs:long(3))
xs:string(xs:Name("foo"))
xs:string(xs:NCName("foo"))
xs:string(xs:negativeInteger(-3))
xs:string(xs:NMTOKEN("foo"))
xs:string(xs:nonNegativeInteger(3))
xs:string(xs:nonPositiveInteger(0))
xs:string(xs:normalizedString("foo"))
xs:string(xs:short(3))
xs:string(xs:string(3)) eq '3'
("xs:string", (), "xs:string") instance of xs:string+
xs:string(xs:time("21:01:23.000")) eq "21:01:23"
xs:string(xs:time("21:01:23.001")) eq "21:01:23.001"
xs:string(xs:time("21:01:23.010")) eq "21:01:23.01"
xs:string(xs:time("21:01:23.100")) eq "21:01:23.1"
xs:string(xs:time("21:01:23.110")) eq "21:01:23.11"
xs:string(xs:time("21:01:23.11")) eq "21:01:23.11"
xs:string(xs:time("21:01:23.435")) eq "21:01:23.435"
xs:string(xs:time("23:59:12.432+00:00")) eq "23:59:12.432Z"
xs:string(xs:time("23:59:12.999-00:00")) eq "23:59:12.999Z"
xs:string(xs:token("foo"))
xs:string(xs:unsignedByte(3))
xs:string(xs:unsignedInt(3))
xs:string(xs:unsignedLong(3))
xs:string(xs:unsignedShort(3))
xs:string(xs:untypedAtomic( "an arbitrary string" )) eq xs:string("an arbitrary string")
xs:string(xs:yearMonthDuration("-P0010Y0010M")) eq "-P10Y10M"
xs:string(xs:yearMonthDuration("P0010Y0010M")) eq "P10Y10M"
xs:string(xs:yearMonthDuration("-P0M")) eq "P0M"
xs:string(xs:yearMonthDuration("P0Y0M")) eq "P0M"
xs:string(xs:yearMonthDuration("P2Y323M")) eq "P28Y11M"
xs:string(xs:yearMonthDuration("P3Y0M")) eq "P3Y"
xs:string(xs:yearMonthDuration("-P543Y456M")) eq "-P581Y"
xs:string(xs:yearMonthDuration(xs:dayTimeDuration("-P31DT3H2M10.001S"))) eq "P0M"
xs:string(xs:yearMonthDuration(xs:dayTimeDuration("P31DT3H2M10.001S"))) eq "P0M"
xs:string(xs:yearMonthDuration(xs:duration("-P3Y0M31DT3H2M10.001S"))) eq "-P3Y"
xs:string(xs:yearMonthDuration(xs:duration("P3Y0M31DT3H2M10.001S"))) eq "P3Y"
xs:time("")
xs:time()
xs:time("00:00:00Z") - xs:time("00:00:00Z")
xs:time("00:00:00Z") - xs:time("08:03:35Z")
xs:time("00:00:00Z") - xs:time("23:59:59Z")
xs:time("01:01:01-03:00") ne xs:time("01:01:01+03:00")
xs:time( "03:20:00-05:00" , "03:20:00-05:00" )
xs:time("03:20:00-05:00") castable as xs:string
xs:time("03:20:00-05:00") castable as xs:time
xs:time("03:20:00-05:00") castable as xs:untypedAtomic
xs:time("03:20:00-05:00") cast as xs:anyURI
xs:time("03:20:00-05:00") cast as xs:base64Binary
xs:time("03:20:00-05:00") cast as xs:boolean
xs:time("03:20:00-05:00") cast as xs:date
xs:time("03:20:00-05:00") cast as xs:dateTime
xs:time("03:20:00-05:00") cast as xs:dayTimeDuration
xs:time("03:20:00-05:00") cast as xs:decimal
xs:time("03:20:00-05:00") cast as xs:double
xs:time("03:20:00-05:00") cast as xs:duration
xs:time("03:20:00-05:00") cast as xs:float
xs:time("03:20:00-05:00") cast as xs:gDay
xs:time("03:20:00-05:00") cast as xs:gMonth
xs:time("03:20:00-05:00") cast as xs:gMonthDay
xs:time("03:20:00-05:00") cast as xs:gYear
xs:time("03:20:00-05:00") cast as xs:gYearMonth
xs:time("03:20:00-05:00") cast as xs:hexBinary
xs:time("03:20:00-05:00") cast as xs:integer
xs:time("03:20:00-05:00") cast as xs:string ne xs:string("an arbitrary string")
xs:time("03:20:00-05:00") cast as xs:time eq xs:time("03:20:00-05:00")
xs:time("03:20:00-05:00") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:time("03:20:00-05:00") cast as xs:yearMonthDuration
xs:time(" 03:20:00-05:00 ") eq xs:time(" 03:20:00-05:00 ")
(xs:time("08:00:00+09:00"),xs:time("08:00:00+10:00"))
xs:time("08:01:23") div xs:time("08:01:23")
xs:time("08:01:23") mod xs:time("08:01:23")
xs:time("08:01:23") * xs:time("08:01:23")
xs:time("08:01:23") + xs:time("08:01:23")
xs:time("08:03:35Z") - xs:time("00:00:00Z")
xs:time("08:12:32") - xs:time("08:12:32") eq xs:dayTimeDuration("PT0S")
xs:time("08:12:32") - xs:time("18:12:32") eq xs:dayTimeDuration("-PT10H")
xs:time("11")
xs:time("11:00:00-05:00") - xs:time("21:30:00+05:30")
xs:time("+1:11:11")
xs:time("-1:11:11")
xs:time("1 :11:11")
xs:time("11: 1:11")
xs:time("11:+1:11")
xs:time("11:-1:11")
xs:time("11:11: 1")
xs:time("11:11:+1")
xs:time("11:11:-1")
xs:time("11:11:1 ")
xs:time("11:11: 10")
xs:time("11:11:111")
xs:time("11:11:11. 11")
xs:time("11:11:11.+11")
xs:time("11:11:11.-11")
xs:time("11:11:11+ 1:11")
xs:time("11:11:11++1:11")
xs:time("11:11:11+-1:11")
xs:time("11:11:11+11: 1")
xs:time("11:11:11+11:+1")
xs:time("11:11:11+11:-1")
xs:time("11:11:11b33")
xs:time("11:11:1b0")
xs:time("11:11:1e0")
xs:time("11:11:1E0")
xs:time("11:12:00Z") - xs:time("04:00:00Z")
xs:time('12:00:00-00:30')
xs:time("12:00:00+01:00") - xs:time("12:00:00") - implicit-timezone()
xs:time("12:00:00") cast as xs:string
xs:time("12:00:00") cast as xs:time
xs:time("12:00:00") - xs:time("12:00:00+01:00") + implicit-timezone()
xs:time("12:30:00Z") , xs:string(" ") , xs:decimal("2.000000000000002")
(xs:time("13:00:00Z") - xs:time("17:00:00Z"))
(xs:time("13:00:00Z") - xs:time("17:00:00Z")) eq xs:dayTimeDuration("P20DT01H02M")
(xs:time("13:00:00Z") - xs:time("17:00:00Z")) ge xs:dayTimeDuration("P17DT10H02M")
(xs:time("13:00:00Z") - xs:time("17:00:00Z")) le xs:dayTimeDuration("P10DT02H10M")
(xs:time("13:00:00Z") - xs:time("17:00:00Z")) ne xs:dayTimeDuration("P10DT01H01M")
xs:time("13:20:00-05:00") castable as xs:anyURI
xs:time("13:20:00-05:00") castable as xs:base64Binary
xs:time("13:20:00-05:00") castable as xs:boolean
xs:time("13:20:00-05:00") castable as xs:date
xs:time("13:20:00-05:00") castable as xs:dateTime
xs:time("13:20:00-05:00") castable as xs:dayTimeDuration
xs:time("13:20:00-05:00") castable as xs:decimal
xs:time("13:20:00-05:00") castable as xs:double
xs:time("13:20:00-05:00") castable as xs:duration
xs:time("13:20:00-05:00") castable as xs:float
xs:time("13:20:00-05:00") castable as xs:gDay
xs:time("13:20:00-05:00") castable as xs:gMonth
xs:time("13:20:00-05:00") castable as xs:gMonthDay
xs:time("13:20:00-05:00") castable as xs:gYear
xs:time("13:20:00-05:00") castable as xs:gYearMonth
xs:time("13:20:00-05:00") castable as xs:hexBinary
xs:time("13:20:00-05:00") castable as xs:integer
xs:time("13:20:00-05:00") castable as xs:string
xs:time("13:20:00-05:00") castable as xs:time
xs:time("13:20:00-05:00") castable as xs:untypedAtomic
xs:time("13:20:00-05:00") castable as xs:yearMonthDuration
xs:time("13:20:00-05:00") cast as xs:anyURI
xs:time("13:20:00-05:00") cast as xs:base64Binary
xs:time("13:20:00-05:00") cast as xs:boolean
xs:time("13:20:00-05:00") cast as xs:date
xs:time("13:20:00-05:00") cast as xs:dateTime
xs:time("13:20:00-05:00") cast as xs:dayTimeDuration
xs:time("13:20:00-05:00") cast as xs:decimal
xs:time("13:20:00-05:00") cast as xs:double
xs:time("13:20:00-05:00") cast as xs:duration
xs:time("13:20:00-05:00") cast as xs:float
xs:time("13:20:00-05:00") cast as xs:gDay
xs:time("13:20:00-05:00") cast as xs:gMonth
xs:time("13:20:00-05:00") cast as xs:gMonthDay
xs:time("13:20:00-05:00") cast as xs:gYear
xs:time("13:20:00-05:00") cast as xs:gYearMonth
xs:time("13:20:00-05:00") cast as xs:hexBinary
xs:time("13:20:00-05:00") cast as xs:integer
xs:time("13:20:00-05:00") cast as xs:string
xs:time("13:20:00-05:00") cast as xs:time
xs:time("13:20:00-05:00") cast as xs:untypedAtomic
xs:time("13:20:00-05:00") cast as xs:yearMonthDuration
xs:time("13:20:00Z") castable as xs:time
xs:time("13:20:00Z") cast as xs:time
xs:time("13:20:02.123") castable as xs:time
xs:time("13:20:02.123") cast as xs:time
xs:time("13:20:10.5Z") instance of xs:anyURI
xs:time("13:20:10.5Z") instance of xs:boolean
xs:time("13:20:10.5Z") instance of xs:date
xs:time("13:20:10.5Z") instance of xs:dateTime
xs:time("13:20:10.5Z") instance of xs:decimal
xs:time("13:20:10.5Z") instance of xs:double
xs:time("13:20:10.5Z") instance of xs:float
xs:time("13:20:10.5Z") instance of xs:int
xs:time("13:20:10.5Z") instance of xs:integer
xs:time("13:20:10.5Z") instance of xs:string
xs:time("13:20:10.5Z") instance of xs:time
xs:time("17:00:00-06:00") - xs:time("08:00:00+09:00")
xs:time("2002-02-15T08:12:12")
xs:time("+21:01:50")
xs:time("-21:01:50")
xs:time("21:01:60")
xs:time("21:60:00")
xs:time("22:12:04") eq xs:dateTime("1999-12-04T12:12:23")
xs:time("22:12:04") ge xs:dateTime("1999-12-04T12:12:23")
xs:time("22:12:04") gt xs:dateTime("1999-12-04T12:12:23")
xs:time("22:12:04") le xs:dateTime("1999-12-04T12:12:23")
xs:time("22:12:04") lt xs:dateTime("1999-12-04T12:12:23")
xs:time("22:12:04") ne xs:dateTime("1999-12-04T12:12:23")
(xs:time("23:00:00Z") - xs:time("17:00:00Z")) div (xs:time("13:00:00Z") - xs:time("10:00:00Z"))
xs:time("23:59:12.432+10:60")
xs:time("23:59:12.432-10:60")
xs:time("23:59:12.432+15:00")
xs:time("23:59:12.432-15:00")
xs:time("23:59:59Z") - xs:time("00:00:00Z")
xs:time("24:00:00.001")
xs:time("24:00:00.1")
xs:time("24:00:01")
xs:time("24:01:00")
xs:time("25:01:00")
xs:time(xs:dateTime("2002-11-23T22:12:23.867-00:00")) eq xs:time("22:12:23.867Z")
xs:time(xs:dateTime("2002-11-23T22:12:23.867-13:37")) eq xs:time("22:12:23.867-13:37")
xs:time(xs:untypedAtomic( "03:20:00-05:00" )) eq xs:time("03:20:00-05:00")
xs:token("")
xs:token(5)
xs:token("ncname") instance of xs:NCName
xs:token("ncname") instance of xs:normalizedString
xs:token("NCName") instance of xs:token
xs:token("test") castable as xs:token
xs:token(xs:token("test"))
xs:unsignedByte("")
xs:unsignedByte("+0")
xs:unsignedByte("-0")
xs:unsignedByte("0")
xs:unsignedByte("-00")
xs:unsignedByte("000000001")
xs:unsignedByte(0) and xs:unsignedByte(0)
xs:unsignedByte(0) and xs:unsignedByte(1)
xs:unsignedByte(0) instance of xs:unsignedByte
xs:unsignedByte("0") instance of xs:unsignedShort
xs:unsignedByte(0) or xs:unsignedByte(0)
xs:unsignedByte(0) or xs:unsignedByte(1)
xs:unsignedByte("0x0")
xs:unsignedByte("-1")
xs:unsignedByte(-1)
xs:unsignedByte(1) and xs:unsignedByte(0)
xs:unsignedByte(1) and xs:unsignedByte(1)
xs:unsignedByte(1) or xs:unsignedByte(0)
xs:unsignedByte(1) or xs:unsignedByte(1)
xs:unsignedByte("255")
xs:unsignedByte(255) and xs:unsignedByte(0)
xs:unsignedByte(255) and xs:unsignedByte(1)
xs:unsignedByte(255) and xs:unsignedByte(255)
xs:unsignedByte(255) or xs:unsignedByte(0)
xs:unsignedByte(255) or xs:unsignedByte(1)
xs:unsignedByte(255) or xs:unsignedByte(255)
xs:unsignedByte("256")
xs:unsignedByte(256)
xs:unsignedByte("3.0")
xs:unsignedByte(false())
xs:unsignedByte(true())
xs:unsignedByte(xs:double("4")) instance of xs:unsignedByte
xs:unsignedByte(xs:double("-INF"))
xs:unsignedByte(xs:double("INF"))
xs:unsignedByte(xs:double("NaN"))
xs:unsignedByte(xs:float("4")) instance of xs:unsignedByte
xs:unsignedByte(xs:float("-INF"))
xs:unsignedByte(xs:float("INF"))
xs:unsignedByte(xs:float("NaN"))
xs:unsignedInt("")
xs:unsignedInt("+0")
xs:unsignedInt("-0")
xs:unsignedInt("0")
xs:unsignedInt("-00")
xs:unsignedInt("000000001")
xs:unsignedInt(0) and xs:unsignedInt(0)
xs:unsignedInt(0) and xs:unsignedInt(1)
xs:unsignedInt(0) instance of xs:unsignedInt
xs:unsignedInt("0") instance of xs:unsignedLong
xs:unsignedInt(0) or xs:unsignedInt(0)
xs:unsignedInt(0) or xs:unsignedInt(1)
xs:unsignedInt("0x0")
xs:unsignedInt("-1")
xs:unsignedInt(-1)
xs:unsignedInt(1) and xs:unsignedInt(0)
xs:unsignedInt(1) and xs:unsignedInt(1)
xs:unsignedInt(1) or xs:unsignedInt(0)
xs:unsignedInt(1) or xs:unsignedInt(1)
xs:unsignedInt("3.0")
xs:unsignedInt("4294967295")
xs:unsignedInt(4294967295) and xs:unsignedInt(0)
xs:unsignedInt(4294967295) and xs:unsignedInt(1)
xs:unsignedInt(4294967295) and xs:unsignedInt(4294967295)
xs:unsignedInt(4294967295) or xs:unsignedInt(0)
xs:unsignedInt(4294967295) or xs:unsignedInt(1)
xs:unsignedInt(4294967295) or xs:unsignedInt(4294967295)
xs:unsignedInt("4294967296")
xs:unsignedInt(4294967296)
xs:unsignedInteger(1)
xs:unsignedInt(false())
xs:unsignedInt(true())
xs:unsignedInt(xs:double("4")) instance of xs:unsignedInt
xs:unsignedInt(xs:double("-INF"))
xs:unsignedInt(xs:double("INF"))
xs:unsignedInt(xs:double("NaN"))
xs:unsignedInt(xs:float("4")) instance of xs:unsignedInt
xs:unsignedInt(xs:float("-INF"))
xs:unsignedInt(xs:float("INF"))
xs:unsignedInt(xs:float("NaN"))
xs:unsignedLong("")
+(xs:unsignedLong("0"))
-(xs:unsignedLong("0"))
xs:unsignedLong("+0")
xs:unsignedLong("-0")
xs:unsignedLong("0")
xs:unsignedLong("-00")
xs:unsignedLong("000000001")
xs:unsignedLong(0) and xs:unsignedLong(0)
xs:unsignedLong(0) and xs:unsignedLong(1)
xs:unsignedLong("0") eq xs:unsignedLong("0")
xs:unsignedLong("0") ge xs:unsignedLong("0")
xs:unsignedLong("0") gt xs:unsignedLong("0")
xs:unsignedLong("0") instance of xs:nonNegativeInteger
xs:unsignedLong(0) instance of xs:unsignedLong
xs:unsignedLong("0") lt xs:unsignedLong("0")
xs:unsignedLong("0") ne xs:unsignedLong("0")
xs:unsignedLong(0) or xs:unsignedLong(0)
xs:unsignedLong(0) or xs:unsignedLong(1)
xs:unsignedLong("0x0")
(xs:unsignedLong("0") || xs:unsignedLong("0"))
xs:unsignedLong("0") * xs:unsignedLong("0")
xs:unsignedLong("0") + xs:unsignedLong("0")
xs:unsignedLong("0") - xs:unsignedLong("0")
xs:unsignedLong("-1")
xs:unsignedLong(-1)
xs:unsignedLong(18446744073709551616)
xs:unsignedLong(1) and xs:unsignedLong(0)
xs:unsignedLong(1) and xs:unsignedLong(1)
xs:unsignedLong(1) or xs:unsignedLong(0)
xs:unsignedLong(1) or xs:unsignedLong(1)
xs:unsignedLong("3.0")
xs:unsignedLong(9223372036854775807) and xs:unsignedLong(0)
xs:unsignedLong(9223372036854775807) and xs:unsignedLong(1)
xs:unsignedLong(9223372036854775807) or xs:unsignedLong(0)
xs:unsignedLong(9223372036854775807) or xs:unsignedLong(1)
xs:unsignedLong("-9876")
xs:unsignedLong(99999999999999999) and xs:unsignedLong(99999999999999999)
xs:unsignedLong(99999999999999999) or xs:unsignedLong(99999999999999999)
xs:unsignedLong(false())
xs:unsignedLong(true())
xs:unsignedLong(xs:double("4")) instance of xs:unsignedLong
xs:unsignedLong(xs:double("-INF"))
xs:unsignedLong(xs:double("INF"))
xs:unsignedLong(xs:double("NaN"))
xs:unsignedLong(xs:float("4")) instance of xs:unsignedLong
xs:unsignedLong(xs:float("-INF"))
xs:unsignedLong(xs:float("INF"))
xs:unsignedLong(xs:float("NaN"))
xs:unsignedShort("")
+(xs:unsignedShort("0"))
-(xs:unsignedShort("0"))
xs:unsignedShort("+0")
xs:unsignedShort("-0")
xs:unsignedShort("0")
xs:unsignedShort("-00")
xs:unsignedShort("000000001")
xs:unsignedShort(0) and xs:unsignedShort(0)
xs:unsignedShort(0) and xs:unsignedShort(1)
xs:unsignedShort("0") div xs:unsignedShort("44633")
xs:unsignedShort("0") div xs:unsignedShort("65535")
xs:unsignedShort("0") eq xs:unsignedShort("0")
xs:unsignedShort("0") eq xs:unsignedShort("44633")
xs:unsignedShort("0") eq xs:unsignedShort("65535")
xs:unsignedShort("0") ge xs:unsignedShort("0")
xs:unsignedShort("0") ge xs:unsignedShort("44633")
xs:unsignedShort("0") ge xs:unsignedShort("65535")
xs:unsignedShort("0") gt xs:unsignedShort("0")
xs:unsignedShort("0") gt xs:unsignedShort("44633")
xs:unsignedShort("0") gt xs:unsignedShort("65535")
xs:unsignedShort("0") idiv xs:unsignedShort("44633")
xs:unsignedShort("0") idiv xs:unsignedShort("65535")
xs:unsignedShort("0") instance of xs:unsignedInt
xs:unsignedShort(0) instance of xs:unsignedShort
xs:unsignedShort("0") lt xs:unsignedShort("0")
xs:unsignedShort("0") lt xs:unsignedShort("44633")
xs:unsignedShort("0") lt xs:unsignedShort("65535")
xs:unsignedShort("0") mod xs:unsignedShort("44633")
xs:unsignedShort("0") mod xs:unsignedShort("65535")
xs:unsignedShort("0") ne xs:unsignedShort("0")
xs:unsignedShort("0") ne xs:unsignedShort("44633")
xs:unsignedShort("0") ne xs:unsignedShort("65535")
xs:unsignedShort(0) or xs:unsignedShort(0)
xs:unsignedShort(0) or xs:unsignedShort(1)
xs:unsignedShort("0x0")
(xs:unsignedShort("0") || xs:unsignedShort("0"))
xs:unsignedShort("0") * xs:unsignedShort("0")
xs:unsignedShort("0") + xs:unsignedShort("0")
xs:unsignedShort("0") - xs:unsignedShort("0")
(xs:unsignedShort("0") || xs:unsignedShort("44633"))
xs:unsignedShort("0") * xs:unsignedShort("44633")
xs:unsignedShort("0") + xs:unsignedShort("44633")
(xs:unsignedShort("0") || xs:unsignedShort("65535"))
xs:unsignedShort("0") * xs:unsignedShort("65535")
xs:unsignedShort("0") + xs:unsignedShort("65535")
xs:unsignedShort("-1")
xs:unsignedShort(-1)
xs:unsignedShort(1) and xs:unsignedShort(0)
xs:unsignedShort(1) and xs:unsignedShort(1)
xs:unsignedShort(1) or xs:unsignedShort(0)
xs:unsignedShort(1) or xs:unsignedShort(1)
xs:unsignedShort("3.0")
+(xs:unsignedShort("44633"))
-(xs:unsignedShort("44633"))
xs:unsignedShort("44633") eq xs:unsignedShort("0")
xs:unsignedShort("44633") ge xs:unsignedShort("0")
xs:unsignedShort("44633") gt xs:unsignedShort("0")
xs:unsignedShort("44633") lt xs:unsignedShort("0")
xs:unsignedShort("44633") ne xs:unsignedShort("0")
(xs:unsignedShort("44633") || xs:unsignedShort("0"))
xs:unsignedShort("44633") * xs:unsignedShort("0")
xs:unsignedShort("44633") + xs:unsignedShort("0")
xs:unsignedShort("44633") - xs:unsignedShort("0")
xs:unsignedShort("44633") - xs:unsignedShort("44633")
+(xs:unsignedShort("65535"))
-(xs:unsignedShort("65535"))
xs:unsignedShort("65535")
xs:unsignedShort(65535) and xs:unsignedShort(0)
xs:unsignedShort(65535) and xs:unsignedShort(1)
xs:unsignedShort(65535) and xs:unsignedShort(65535)
xs:unsignedShort("65535") eq xs:unsignedShort("0")
xs:unsignedShort("65535") ge xs:unsignedShort("0")
xs:unsignedShort("65535") gt xs:unsignedShort("0")
xs:unsignedShort("65535") lt xs:unsignedShort("0")
xs:unsignedShort("65535") ne xs:unsignedShort("0")
xs:unsignedShort(65535) or xs:unsignedShort(0)
xs:unsignedShort(65535) or xs:unsignedShort(1)
xs:unsignedShort(65535) or xs:unsignedShort(65535)
(xs:unsignedShort("65535") || xs:unsignedShort("0"))
xs:unsignedShort("65535") * xs:unsignedShort("0")
xs:unsignedShort("65535") + xs:unsignedShort("0")
xs:unsignedShort("65535") - xs:unsignedShort("0")
xs:unsignedShort("65535") - xs:unsignedShort("65535")
xs:unsignedShort("65536")
xs:unsignedShort(65536)
xs:unsignedShort(false())
xs:unsignedShort(true())
xs:unsignedShort(xs:double("4")) instance of xs:unsignedShort
xs:unsignedShort(xs:double("-INF"))
xs:unsignedShort(xs:double("INF"))
xs:unsignedShort(xs:double("NaN"))
xs:unsignedShort(xs:float("4")) instance of xs:unsignedShort
xs:unsignedShort(xs:float("-INF"))
xs:unsignedShort(xs:float("INF"))
xs:unsignedShort(xs:float("NaN"))
xs:untypedAtomic()
xs:untypedAtomic("00000000") castable as xs:base64Binary
xs:untypedAtomic("00000000") cast as xs:base64Binary
xs:untypedAtomic("-0012-05:00") castable as xs:gYear
xs:untypedAtomic("-0012-05:00") cast as xs:gYear
xs:untypedAtomic("-0012-12-03-05:00") castable as xs:date
xs:untypedAtomic("-0012-12-03-05:00") cast as xs:date
xs:untypedAtomic("-0012-12-05:00") castable as xs:gYearMonth
xs:untypedAtomic("-0012-12-05:00") cast as xs:gYearMonth
xs:untypedAtomic("0.0") castable as xs:boolean
xs:untypedAtomic("0.0") cast as xs:boolean
xs:untypedAtomic("-0.0E0") castable as xs:decimal
xs:untypedAtomic("-0.0E0") castable as xs:double
xs:untypedAtomic("-0.0E0") castable as xs:float
xs:untypedAtomic("-0.0E0") castable as xs:integer
xs:untypedAtomic("0.0E0") castable as xs:string
xs:untypedAtomic("0.0E0") castable as xs:untypedAtomic
xs:untypedAtomic("-0.0E0") cast as xs:decimal
xs:untypedAtomic("-0.0E0") cast as xs:double
xs:untypedAtomic("-0.0E0") cast as xs:float
xs:untypedAtomic("-0.0E0") cast as xs:integer
xs:untypedAtomic("0.0E0") cast as xs:string
xs:untypedAtomic("0.0E0") cast as xs:untypedAtomic
xs:untypedAtomic("010010101") castable as xs:hexBinary
xs:untypedAtomic("010010101") cast as xs:hexBinary
xs:untypedAtomic("---03-05:00") castable as xs:gDay
xs:untypedAtomic("---03-05:00") cast as xs:gDay
xs:untypedAtomic("--05-31+14:00") castable as xs:gMonthDay
xs:untypedAtomic("--05-31+14:00") cast as xs:gMonthDay
xs:untypedAtomic("--05-31") castable as xs:gMonthDay
xs:untypedAtomic("--05-31") cast as xs:gMonthDay
xs:untypedAtomic("--05-31Z") castable as xs:gMonthDay
xs:untypedAtomic("--05-31Z") cast as xs:gMonthDay
xs:untypedAtomic("--05") castable as xs:gMonth
xs:untypedAtomic("--05") cast as xs:gMonth
xs:untypedAtomic("--05Z") castable as xs:gMonth
xs:untypedAtomic("--05Z") cast as xs:gMonth
xs:untypedAtomic("0") castable as xs:boolean
xs:untypedAtomic("0") cast as xs:boolean
xs:untypedAtomic("0fb7") castable as xs:hexBinary
xs:untypedAtomic("0fb7") cast as xs:hexBinary
xs:untypedAtomic("0") = xs:dayTimeDuration("PT0S")
xs:untypedAtomic("-10000000") castable as xs:double
xs:untypedAtomic("-10000000") castable as xs:float
xs:untypedAtomic("1") = 1
xs:untypedAtomic("-1.1234") castable as xs:integer
xs:untypedAtomic("-1.1234") cast as xs:integer
xs:untypedAtomic("--12-05:00") castable as xs:gMonth
xs:untypedAtomic("--12-05:00") cast as xs:gMonth
xs:untypedAtomic("13:20:00-05:00") castable as xs:time
xs:untypedAtomic("13:20:00-05:00") cast as xs:time
xs:untypedAtomic("13:20:00Z") castable as xs:time
xs:untypedAtomic("13:20:00Z") cast as xs:time
xs:untypedAtomic("13:20:02.123") castable as xs:time
xs:untypedAtomic("13:20:02.123") cast as xs:time
xs:untypedAtomic("1999-05-31") castable as xs:date
xs:untypedAtomic("1999-05-31") cast as xs:date
xs:untypedAtomic("-1999-05-31T13:20:00+14:00") castable as xs:dateTime
xs:untypedAtomic("-1999-05-31T13:20:00+14:00") cast as xs:dateTime
xs:untypedAtomic("1999-05-31T13:20:00") castable as xs:dateTime
xs:untypedAtomic("1999-05-31T13:20:00") cast as xs:dateTime
xs:untypedAtomic("1999-05-31Z") castable as xs:date
xs:untypedAtomic("1999-05-31Z") cast as xs:date
xs:untypedAtomic("1999-05") castable as xs:gYearMonth
xs:untypedAtomic("1999-05") cast as xs:gYearMonth
xs:untypedAtomic("1999-05Z") castable as xs:gYearMonth
xs:untypedAtomic("1999-05Z") cast as xs:gYearMonth
xs:untypedAtomic("1999") castable as xs:gYear
xs:untypedAtomic("1999") cast as xs:gYear
xs:untypedAtomic("1999Z") castable as xs:gYear
xs:untypedAtomic("1999Z") cast as xs:gYear
xs:untypedAtomic("1e-5") castable as xs:decimal
xs:untypedAtomic("1e-5") castable as xs:double
xs:untypedAtomic("1e-5") castable as xs:float
xs:untypedAtomic("1e-5") castable as xs:integer
xs:untypedAtomic("1e-5") cast as xs:decimal
xs:untypedAtomic("1e-5") cast as xs:double
xs:untypedAtomic("1e-5") cast as xs:float
xs:untypedAtomic("1e-5") cast as xs:integer
(xs:untypedAtomic("1"), xs:anyURI("example.com")) = (xs:untypedAtomic("2.0"), 3.0)
(xs:untypedAtomic("1"), xs:untypedAtomic("2")) = (xs:untypedAtomic("2.0"), 2.0)
xs:untypedAtomic("2000-01-16T00:00:00Z") castable as xs:dateTime
xs:untypedAtomic("2000-01-16T00:00:00Z") cast as xs:dateTime
xs:untypedAtomic("2") != 1
(xs:untypedAtomic("3") - 1.1) instance of xs:double
xs:untypedAtomic("---31") castable as xs:gDay
xs:untypedAtomic("---31") cast as xs:gDay
xs:untypedAtomic("---31Z") castable as xs:gDay
xs:untypedAtomic("---31Z") cast as xs:gDay
xs:untypedAtomic("3") - "3"
(xs:untypedAtomic("3") + 3.0) eq 6
(xs:untypedAtomic("3") - 3) eq 0
(xs:untypedAtomic("3"), 3) eq 3
xs:untypedAtomic("3") + 3 eq 6
(xs:untypedAtomic(3) * 3) eq 9
(xs:untypedAtomic("3") + 3) instance of xs:double
(xs:untypedAtomic("3") div xs:double(3)) eq 1
(xs:untypedAtomic("3") - xs:untypedAtomic("3")) eq 0
(xs:untypedAtomic("3") - xs:untypedAtomic("3")) instance of xs:double
xs:untypedAtomic("5.5432") castable as xs:decimal
xs:untypedAtomic("5.5432") cast as xs:decimal
(xs:untypedAtomic("5") mod xs:double(3)) eq 2
xs:untypedAtomic("6") = remove(("a string", 6), 1)
(xs:untypedAtomic("9") idiv xs:float(5)) eq 1
xs:untypedAtomic('abc') and xs:untypedAtomic("")
xs:untypedAtomic('abc') and xs:untypedAtomic("0")
xs:untypedAtomic('abc') or xs:untypedAtomic("")
xs:untypedAtomic('abc') or xs:untypedAtomic("0")
xs:untypedAtomic( "an arbitrary string(untypedAtomic source)" , "an arbitrary string(untypedAtomic source)" )
xs:untypedAtomic("an arbitrary string(untypedAtomic source)") castable as xs:string
xs:untypedAtomic("an arbitrary string(untypedAtomic source)") castable as xs:untypedAtomic
xs:untypedAtomic("an arbitrary string(untypedAtomic source)") cast as xs:string ne xs:string("an arbitrary string")
xs:untypedAtomic("an arbitrary string(untypedAtomic source)") cast as xs:untypedAtomic eq xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:untypedAtomic(" an arbitrary string(untypedAtomic source) ") eq xs:untypedAtomic(" an arbitrary string(untypedAtomic source) ")
xs:untypedAtomic('') and xs:untypedAtomic("")
xs:untypedAtomic('') and xs:untypedAtomic("0")
xs:untypedAtomic("a string") and xs:untypedAtomic("a string")
xs:untypedAtomic("a string") = "a string"
xs:untypedAtomic("a string") != "a stringDIFF"
xs:untypedAtomic("a string") eq "a string"
xs:untypedAtomic("a string") or 0
xs:untypedAtomic("a string") = xs:untypedAtomic("a stringDIFF")
xs:untypedAtomic("D74D35D35D35") castable as xs:base64Binary
xs:untypedAtomic("D74D35D35D35") castable as xs:hexBinary
xs:untypedAtomic("D74D35D35D35") cast as xs:base64Binary
xs:untypedAtomic("D74D35D35D35") cast as xs:hexBinary
xs:untypedAtomic("") eq xs:untypedAtomic("")
xs:untypedAtomic("example.com/") cast as xs:anyURI eq xs:anyURI('example.com/')
xs:untypedAtomic("example.com/") eq xs:anyURI("example.com/")
xs:untypedAtomic("example.com/") ne xs:anyURI("example.com/No")
xs:untypedAtomic("falseERR") != false()
xs:untypedAtomic("falseERR") = false()
xs:untypedAtomic("false") <= false()
xs:untypedAtomic("false") = false()
xs:untypedAtomic("false") >= false()
xs:untypedAtomic("false") < true()
xs:untypedAtomic("http://www.example.com/~b%C3%A9b%C3%A9") castable as xs:anyURI
xs:untypedAtomic("http://www.example.com/~b%C3%A9b%C3%A9") cast as xs:anyURI
xs:untypedAtomic("http://www.ietf.org/rfc/rfc2396.txt") castable as xs:anyURI
xs:untypedAtomic("http://www.ietf.org/rfc/rfc2396.txt") cast as xs:anyURI
xs:untypedAtomic("INF") castable as xs:string
xs:untypedAtomic("INF") castable as xs:untypedAtomic
xs:untypedAtomic("INF") cast as xs:string
xs:untypedAtomic("INF") cast as xs:untypedAtomic
xs:untypedAtomic("NaN") castable as xs:decimal
xs:untypedAtomic("NaN") castable as xs:double
xs:untypedAtomic("NaN") castable as xs:float
xs:untypedAtomic("NaN") castable as xs:integer
xs:untypedAtomic("NaN") cast as xs:decimal
xs:untypedAtomic("NaN") cast as xs:double
xs:untypedAtomic("NaN") cast as xs:float
xs:untypedAtomic("NaN") cast as xs:integer
(xs:untypedAtomic("nine") idiv xs:float(5)) eq 1
xs:untypedAtomic('') or xs:untypedAtomic("")
xs:untypedAtomic('') or xs:untypedAtomic("0")
xs:untypedAtomic("P1999Y10M") = xs:yearMonthDuration("P1999Y10M")
xs:untypedAtomic("-P1Y1M1DT1H1M1.123S") castable as xs:dayTimeDuration
xs:untypedAtomic("-P1Y1M1DT1H1M1.123S") castable as xs:duration
xs:untypedAtomic("-P1Y1M1DT1H1M1.123S") castable as xs:yearMonthDuration
xs:untypedAtomic("-P1Y1M1DT1H1M1.123S") cast as xs:dayTimeDuration
xs:untypedAtomic("-P1Y1M1DT1H1M1.123S") cast as xs:yearMonthDuration
xs:untypedAtomic("P1Y2M3DT10H30M23S") castable as xs:duration
xs:untypedAtomic("P1Y2M3DT10H30M23S") cast as xs:duration
xs:untypedAtomic("-P21M") castable as xs:yearMonthDuration
xs:untypedAtomic("-P21M") cast as xs:yearMonthDuration
xs:untypedAtomic("P24M") castable as xs:yearMonthDuration
xs:untypedAtomic("P24M") cast as xs:yearMonthDuration
xs:untypedAtomic("P3DT10H30M") castable as xs:dayTimeDuration
xs:untypedAtomic("P3DT10H30M") cast as xs:dayTimeDuration
xs:untypedAtomic("-PT100M") castable as xs:dayTimeDuration
xs:untypedAtomic("-PT100M") cast as xs:dayTimeDuration
xs:untypedAtomic("three") != 3
xs:untypedAtomic("three") + 3
xs:untypedAtomic("three") = 3
xs:untypedAtomic("true") castable as xs:anyURI
xs:untypedAtomic("true") castable as xs:base64Binary
xs:untypedAtomic("true") castable as xs:boolean
xs:untypedAtomic("true") castable as xs:date
xs:untypedAtomic("true") castable as xs:dateTime
xs:untypedAtomic("true") castable as xs:dayTimeDuration
xs:untypedAtomic("true") castable as xs:decimal
xs:untypedAtomic("true") castable as xs:double
xs:untypedAtomic("true") castable as xs:duration
xs:untypedAtomic("true") castable as xs:float
xs:untypedAtomic("true") castable as xs:gDay
xs:untypedAtomic("true") castable as xs:gMonth
xs:untypedAtomic("true") castable as xs:gMonthDay
xs:untypedAtomic("true") castable as xs:gYear
xs:untypedAtomic("true") castable as xs:gYearMonth
xs:untypedAtomic("true") castable as xs:hexBinary
xs:untypedAtomic("true") castable as xs:integer
xs:untypedAtomic("true") castable as xs:string
xs:untypedAtomic("true") castable as xs:time
xs:untypedAtomic("true") castable as xs:untypedAtomic
xs:untypedAtomic("true") castable as xs:yearMonthDuration
xs:untypedAtomic("true") cast as xs:anyURI
xs:untypedAtomic("true") cast as xs:base64Binary
xs:untypedAtomic("true") cast as xs:boolean
xs:untypedAtomic("true") cast as xs:date
xs:untypedAtomic("true") cast as xs:dateTime
xs:untypedAtomic("true") cast as xs:dayTimeDuration
xs:untypedAtomic("true") cast as xs:decimal
xs:untypedAtomic("true") cast as xs:double
xs:untypedAtomic("true") cast as xs:duration
xs:untypedAtomic("true") cast as xs:float
xs:untypedAtomic("true") cast as xs:gDay
xs:untypedAtomic("true") cast as xs:gMonth
xs:untypedAtomic("true") cast as xs:gMonthDay
xs:untypedAtomic("true") cast as xs:gYear
xs:untypedAtomic("true") cast as xs:gYearMonth
xs:untypedAtomic("true") cast as xs:hexBinary
xs:untypedAtomic("true") cast as xs:integer
xs:untypedAtomic("true") cast as xs:string
xs:untypedAtomic("true") cast as xs:time
xs:untypedAtomic("true") cast as xs:untypedAtomic
xs:untypedAtomic("true") cast as xs:yearMonthDuration
xs:untypedAtomic("true") != false()
xs:untypedAtomic("true") > false()
xs:untypedAtomic(xs:anyURI('example.com/')) eq 'example.com/'
xs:untypedAtomic(xs:byte(3))
xs:untypedAtomic(xs:decimal(3)) eq '3'
xs:untypedAtomic(xs:double(3)) eq '3'
xs:untypedAtomic(xs:ENTITY("foo"))
xs:untypedAtomic(xs:ID("foo"))
xs:untypedAtomic(xs:IDREF("foo"))
xs:untypedAtomic(xs:int(3))
xs:untypedAtomic(xs:integer(3)) eq '3'
xs:untypedAtomic(xs:language("foo"))
xs:untypedAtomic(xs:long(3))
xs:untypedAtomic(xs:Name("foo"))
xs:untypedAtomic(xs:NCName("foo"))
xs:untypedAtomic(xs:negativeInteger(-3))
xs:untypedAtomic(xs:NMTOKEN("foo"))
xs:untypedAtomic(xs:nonNegativeInteger(3))
xs:untypedAtomic(xs:nonPositiveInteger(0))
xs:untypedAtomic(xs:normalizedString("foo"))
xs:untypedAtomic(xs:short(3))
xs:untypedAtomic(xs:string(3)) eq '3'
xs:untypedAtomic(xs:token("foo"))
xs:untypedAtomic(xs:unsignedByte(3))
xs:untypedAtomic(xs:unsignedInt(3))
xs:untypedAtomic(xs:unsignedLong(3))
xs:untypedAtomic(xs:unsignedShort(3))
xs:untypedAtomic(xs:untypedAtomic( "an arbitrary string(untypedAtomic source)" )) eq xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:yearMonthDuration("")
xs:yearMonthDuration()
xs:yearMonthDuration("20Y15M")
xs:yearMonthDuration("-P")
xs:yearMonthDuration("P")
(xs:yearMonthDuration("P01Y01M") div xs:yearMonthDuration("P02Y02M")) and (xs:yearMonthDuration("P02Y03M") div xs:yearMonthDuration("P04Y04M"))
(xs:yearMonthDuration("P05Y02M") div xs:yearMonthDuration("P03Y04M")) or (xs:yearMonthDuration("P05Y03M") div xs:yearMonthDuration("P01Y03M"))
xs:yearMonthDuration("P0M") eq xs:dayTimeDuration("PT0S")
xs:yearMonthDuration("P0M") eq xs:duration("PT0S")
xs:yearMonthDuration("P0M") eq xs:yearMonthDuration("P0M")
xs:yearMonthDuration("P0M") + xs:yearMonthDuration("P3Y3M") eq xs:yearMonthDuration("P3Y3M")
xs:yearMonthDuration("P0M") - xs:yearMonthDuration("P3Y3M") eq xs:yearMonthDuration("-P3Y3M")
xs:yearMonthDuration("P0Y0M") div xs:double("0.1")
xs:yearMonthDuration("P0Y0M") div xs:double("-1.7976931348623157E308")
xs:yearMonthDuration("P0Y0M") div xs:double("1.7976931348623157E308")
xs:yearMonthDuration("P0Y0M") div xs:yearMonthDuration("P0Y1M")
xs:yearMonthDuration("P0Y0M") div xs:yearMonthDuration("P1000Y6M")
xs:yearMonthDuration("P0Y0M") div xs:yearMonthDuration("P2030Y12M")
xs:yearMonthDuration("P0Y0M") eq xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P0Y0M") eq xs:yearMonthDuration("P1000Y6M")
xs:yearMonthDuration("P0Y0M") eq xs:yearMonthDuration("P2030Y12M")
xs:yearMonthDuration("P0Y0M") ge xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P0Y0M") ge xs:yearMonthDuration("P1000Y6M")
xs:yearMonthDuration("P0Y0M") ge xs:yearMonthDuration("P2030Y12M")
xs:yearMonthDuration("P0Y0M") gt xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P0Y0M") gt xs:yearMonthDuration("P1000Y6M")
xs:yearMonthDuration("P0Y0M") gt xs:yearMonthDuration("P2030Y12M")
xs:yearMonthDuration("P0Y0M") le xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P0Y0M") le xs:yearMonthDuration("P1000Y6M")
xs:yearMonthDuration("P0Y0M") le xs:yearMonthDuration("P2030Y12M")
xs:yearMonthDuration("P0Y0M") lt xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P0Y0M") lt xs:yearMonthDuration("P1000Y6M")
xs:yearMonthDuration("P0Y0M") lt xs:yearMonthDuration("P2030Y12M")
xs:yearMonthDuration("P0Y0M") ne xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P0Y0M") ne xs:yearMonthDuration("P1000Y6M")
xs:yearMonthDuration("P0Y0M") ne xs:yearMonthDuration("P2030Y12M")
xs:yearMonthDuration("P0Y0M") * xs:double("0")
xs:yearMonthDuration("P0Y0M") * xs:double("-1.7976931348623157E308")
xs:yearMonthDuration("P0Y0M") * xs:double("1.7976931348623157E308")
xs:yearMonthDuration("P0Y0M") + xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P0Y0M") - xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P0Y0M") + xs:yearMonthDuration("P1000Y6M")
xs:yearMonthDuration("P0Y0M") - xs:yearMonthDuration("P1000Y6M")
xs:yearMonthDuration("P0Y0M") + xs:yearMonthDuration("P2030Y12M")
xs:yearMonthDuration("P0Y0M") - xs:yearMonthDuration("P2030Y12M")
xs:yearMonthDuration('P0Y') eq xs:dayTimeDuration('P0D')
xs:yearMonthDuration("P1000Y6M") div xs:double("-1.7976931348623157E308")
xs:yearMonthDuration("P1000Y6M") div xs:yearMonthDuration("P0Y1M")
xs:yearMonthDuration("P1000Y6M") eq xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P1000Y6M") ge xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P1000Y6M") gt xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P1000Y6M") le xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P1000Y6M") lt xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P1000Y6M") ne xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P1000Y6M") * xs:double("-0")
xs:yearMonthDuration("P1000Y6M") + xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P1000Y6M") - xs:yearMonthDuration("P0Y0M")
(xs:yearMonthDuration("P10Y01M") * -2.0)
(xs:yearMonthDuration("P10Y01M") * 2.0) le xs:yearMonthDuration("P17Y02M")
(xs:yearMonthDuration("P10Y01M") div -2.0)
(xs:yearMonthDuration("P10Y01M") div 2.0) le xs:yearMonthDuration("P17Y02M")
(xs:yearMonthDuration("P10Y01M") div xs:yearMonthDuration("-P10Y01M"))
(xs:yearMonthDuration("P10Y01M") div xs:yearMonthDuration("P17Y02M")) le xs:decimal(2.0)
(xs:yearMonthDuration("P10Y01M") ge xs:yearMonthDuration("P09Y05M")) or (fn:true())
(xs:yearMonthDuration("P10Y01M") ge xs:yearMonthDuration("P09Y06M")) or (xs:yearMonthDuration("P15Y01M") ge xs:yearMonthDuration("P02Y04M"))
(xs:yearMonthDuration("P10Y01M") le xs:yearMonthDuration("P09Y05M")) or (fn:true())
(xs:yearMonthDuration("P10Y01M") le xs:yearMonthDuration("P09Y06M")) or (xs:yearMonthDuration("P15Y01M") le xs:yearMonthDuration("P02Y04M"))
(xs:yearMonthDuration("P10Y01M") + xs:yearMonthDuration("-P11Y02M"))
(xs:yearMonthDuration("P10Y01M") - xs:yearMonthDuration("P11Y02M"))
(xs:yearMonthDuration("P10Y01M") + xs:yearMonthDuration("P17Y02M")) le xs:yearMonthDuration("P17Y02M")
(xs:yearMonthDuration("P10Y01M") - xs:yearMonthDuration("P17Y02M")) le xs:yearMonthDuration("P17Y02M")
(xs:yearMonthDuration("P10Y02M") gt xs:yearMonthDuration("P01Y10M")) or (fn:true())
(xs:yearMonthDuration("P10Y02M") lt xs:yearMonthDuration("P01Y10M")) or (fn:true())
(xs:yearMonthDuration("P10Y05M") ge xs:yearMonthDuration("P20Y10M")) or (fn:false())
(xs:yearMonthDuration("P10Y05M") le xs:yearMonthDuration("P20Y10M")) or (fn:false())
(xs:yearMonthDuration("P10Y08M") gt xs:yearMonthDuration("P10Y07M")) or (xs:yearMonthDuration("P10Y09M") gt xs:yearMonthDuration("P10Y09M"))
(xs:yearMonthDuration("P10Y08M") lt xs:yearMonthDuration("P10Y07M")) or (xs:yearMonthDuration("P10Y09M") lt xs:yearMonthDuration("P10Y09M"))
(xs:yearMonthDuration("P10Y09M") ge xs:yearMonthDuration("P10Y01M")) and (xs:yearMonthDuration("P02Y04M") ge xs:yearMonthDuration("P09Y07M"))
(xs:yearMonthDuration("P10Y09M") gt xs:yearMonthDuration("P09Y10M")) and (xs:yearMonthDuration("P10Y01M") gt xs:yearMonthDuration("P08Y06M"))
(xs:yearMonthDuration("P10Y09M") le xs:yearMonthDuration("P10Y01M")) and (xs:yearMonthDuration("P02Y04M") le xs:yearMonthDuration("P09Y07M"))
(xs:yearMonthDuration("P10Y09M") lt xs:yearMonthDuration("P09Y10M")) and (xs:yearMonthDuration("P10Y01M") lt xs:yearMonthDuration("P08Y06M"))
(xs:yearMonthDuration("P10Y11M") div xs:yearMonthDuration("P05Y07M")) and (fn:true())
xs:yearMonthDuration("P10Y11M") div xs:yearMonthDuration("P12Y07M") and fn:false()
(xs:yearMonthDuration("P13Y09M") div 2.0) ge xs:yearMonthDuration("P18Y02M")
(xs:yearMonthDuration("P13Y09M") div xs:yearMonthDuration("P18Y02M")) ge xs:decimal(2.0)
xs:yearMonthDuration("P13Y09M") * fn:number(())
(xs:yearMonthDuration("P13Y09M") + xs:yearMonthDuration("P18Y02M")) ge xs:yearMonthDuration("P18Y02M")
(xs:yearMonthDuration("P13Y09M") - xs:yearMonthDuration("P18Y02M")) ge xs:yearMonthDuration("P18Y02M")
xs:yearMonthDuration("P1999Y01M") ne xs:yearMonthDuration("P1999Y10M")
xs:yearMonthDuration("P1999Y10M") eq xs:yearMonthDuration("P1999Y10M")
xs:yearMonthDuration("P1999Y10M") ge xs:dayTimeDuration("P3DT08H34M12.143S")
xs:yearMonthDuration("P1999Y10M") ge xs:duration("P3DT08H34M12.143S")
xs:yearMonthDuration("P1999Y10M") ge xs:yearMonthDuration("P1999Y10M")
xs:yearMonthDuration("P1999Y10M") gt xs:dayTimeDuration("P3DT08H34M12.143S")
xs:yearMonthDuration("P1999Y10M") gt xs:duration("P3DT08H34M12.143S")
xs:yearMonthDuration("P1999Y10M") gt xs:yearMonthDuration("P1999Y9M")
xs:yearMonthDuration("P1999Y10M") le xs:dayTimeDuration("P3DT08H34M12.143S")
xs:yearMonthDuration("P1999Y10M") le xs:duration("P3DT08H34M12.143S")
xs:yearMonthDuration("P1999Y10M") le xs:yearMonthDuration("P1999Y10M")
xs:yearMonthDuration("P1999Y10M") lt xs:dayTimeDuration("P3DT08H34M12.143S")
xs:yearMonthDuration("P1999Y10M") lt xs:duration("P3DT08H34M12.143S")
xs:yearMonthDuration("P1999Y11M") ge xs:yearMonthDuration("P1999Y10M")
xs:yearMonthDuration("P1999Y9M") le xs:yearMonthDuration("P1999Y10M")
xs:yearMonthDuration("P1999Y9M") lt xs:yearMonthDuration("P1999Y10M")
xs:yearMonthDuration("P1999Y") = xs:untypedAtomic("1999")
xs:yearMonthDuration("P1M") ne xs:dayTimeDuration("P31D")
xs:yearMonthDuration("P1M") ne xs:duration("P31D")
xs:yearMonthDuration("P1Y12M") castable as xs:dayTimeDuration
xs:yearMonthDuration("P1Y12M") castable as xs:duration
xs:yearMonthDuration("P1Y12M") castable as xs:string
xs:yearMonthDuration("P1Y12M") castable as xs:untypedAtomic
xs:yearMonthDuration("P1Y12M") castable as xs:yearMonthDuration
xs:yearMonthDuration("P1Y12M") cast as xs:anyURI
xs:yearMonthDuration("P1Y12M") cast as xs:base64Binary
xs:yearMonthDuration("P1Y12M") cast as xs:boolean
xs:yearMonthDuration("P1Y12M") cast as xs:date
xs:yearMonthDuration("P1Y12M") cast as xs:dateTime
xs:yearMonthDuration("P1Y12M") cast as xs:dayTimeDuration ne xs:dayTimeDuration("P3DT2H")
xs:yearMonthDuration("P1Y12M") cast as xs:decimal
xs:yearMonthDuration("P1Y12M") cast as xs:double
xs:yearMonthDuration("P1Y12M") cast as xs:duration ne xs:duration("P1Y2M3DT10H30M")
xs:yearMonthDuration("P1Y12M") cast as xs:float
xs:yearMonthDuration("P1Y12M") cast as xs:gDay
xs:yearMonthDuration("P1Y12M") cast as xs:gMonth
xs:yearMonthDuration("P1Y12M") cast as xs:gMonthDay
xs:yearMonthDuration("P1Y12M") cast as xs:gYear
xs:yearMonthDuration("P1Y12M") cast as xs:gYearMonth
xs:yearMonthDuration("P1Y12M") cast as xs:hexBinary
xs:yearMonthDuration("P1Y12M") cast as xs:integer
xs:yearMonthDuration("P1Y12M") cast as xs:string ne xs:string("an arbitrary string")
xs:yearMonthDuration("P1Y12M") cast as xs:time
xs:yearMonthDuration("P1Y12M") cast as xs:untypedAtomic ne xs:untypedAtomic("an arbitrary string(untypedAtomic source)")
xs:yearMonthDuration("P1Y12M") cast as xs:yearMonthDuration eq xs:yearMonthDuration("P1Y12M")
xs:yearMonthDuration("P1Y12M") eq xs:duration("P1Y12M0D")
xs:yearMonthDuration(" P1Y12M ") eq xs:yearMonthDuration(" P1Y12M ")
xs:yearMonthDuration( "P1Y12M" , "P1Y12M" )
xs:yearMonthDuration("P1Y24MT")
xs:yearMonthDuration("P1Y2M") castable as xs:anyURI
xs:yearMonthDuration("P1Y2M") castable as xs:base64Binary
xs:yearMonthDuration("P1Y2M") castable as xs:boolean
xs:yearMonthDuration("P1Y2M") castable as xs:date
xs:yearMonthDuration("P1Y2M") castable as xs:dateTime
xs:yearMonthDuration("P1Y2M") castable as xs:dayTimeDuration
xs:yearMonthDuration("P1Y2M") castable as xs:decimal
xs:yearMonthDuration("P1Y2M") castable as xs:double
xs:yearMonthDuration("P1Y2M") castable as xs:duration
xs:yearMonthDuration("P1Y2M") castable as xs:float
xs:yearMonthDuration("P1Y2M") castable as xs:gDay
xs:yearMonthDuration("P1Y2M") castable as xs:gMonth
xs:yearMonthDuration("P1Y2M") castable as xs:gMonthDay
xs:yearMonthDuration("P1Y2M") castable as xs:gYear
xs:yearMonthDuration("P1Y2M") castable as xs:gYearMonth
xs:yearMonthDuration("P1Y2M") castable as xs:hexBinary
xs:yearMonthDuration("P1Y2M") castable as xs:integer
xs:yearMonthDuration("P1Y2M") castable as xs:string
xs:yearMonthDuration("P1Y2M") castable as xs:time
xs:yearMonthDuration("P1Y2M") castable as xs:untypedAtomic
xs:yearMonthDuration("P1Y2M") castable as xs:yearMonthDuration
xs:yearMonthDuration("P1Y2M") cast as xs:anyURI
xs:yearMonthDuration("P1Y2M") cast as xs:base64Binary
xs:yearMonthDuration("P1Y2M") cast as xs:boolean
xs:yearMonthDuration("P1Y2M") cast as xs:date
xs:yearMonthDuration("P1Y2M") cast as xs:dateTime
xs:yearMonthDuration("P1Y2M") cast as xs:dayTimeDuration
xs:yearMonthDuration("P1Y2M") cast as xs:decimal
xs:yearMonthDuration("P1Y2M") cast as xs:double
xs:yearMonthDuration("P1Y2M") cast as xs:duration
xs:yearMonthDuration("P1Y2M") cast as xs:float
xs:yearMonthDuration("P1Y2M") cast as xs:gDay
xs:yearMonthDuration("P1Y2M") cast as xs:gMonth
xs:yearMonthDuration("P1Y2M") cast as xs:gMonthDay
xs:yearMonthDuration("P1Y2M") cast as xs:gYear
xs:yearMonthDuration("P1Y2M") cast as xs:gYearMonth
xs:yearMonthDuration("P1Y2M") cast as xs:hexBinary
xs:yearMonthDuration("P1Y2M") cast as xs:integer
xs:yearMonthDuration("P1Y2M") cast as xs:string
xs:yearMonthDuration("P1Y2M") cast as xs:time
xs:yearMonthDuration("P1Y2M") cast as xs:untypedAtomic
xs:yearMonthDuration("P1Y2M") cast as xs:yearMonthDuration
xs:yearMonthDuration('P1Y') eq xs:dayTimeDuration('P365D')
xs:yearMonthDuration("P2030Y12M") div xs:double("-1.7976931348623157E308")
xs:yearMonthDuration("P2030Y12M") div xs:yearMonthDuration("P0Y1M")
xs:yearMonthDuration("P2030Y12M") eq xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P2030Y12M") ge xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P2030Y12M") gt xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P2030Y12M") le xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P2030Y12M") lt xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P2030Y12M") ne xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P2030Y12M") * xs:double("-0")
xs:yearMonthDuration("P2030Y12M") + xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P2030Y12M") - xs:yearMonthDuration("P0Y0M")
xs:yearMonthDuration("P20Y10M") div xs:yearMonthDuration("P19Y10M") or fn:false()
(xs:yearMonthDuration("P20Y11M") * 2.0) div (xs:yearMonthDuration("P20Y11M") * 2.0)
(xs:yearMonthDuration("P20Y11M") div 2.0) div (xs:yearMonthDuration("P20Y11M") div 2.0)
xs:yearMonthDuration("+P20Y15M")
xs:yearMonthDuration("P20Y15M+08:00")
xs:yearMonthDuration("-P21M") castable as xs:yearMonthDuration
xs:yearMonthDuration("-P21M") cast as xs:yearMonthDuration
(xs:yearMonthDuration("P21Y12M") * 2.0) ne xs:yearMonthDuration("P08Y05M")
(xs:yearMonthDuration("P21Y12M") div 2.0) ne xs:yearMonthDuration("P08Y05M")
(xs:yearMonthDuration("P21Y12M") div xs:yearMonthDuration("P08Y05M")) ne xs:decimal(2.0)
(xs:yearMonthDuration("P21Y12M") + xs:yearMonthDuration("P08Y05M")) ne xs:yearMonthDuration("P08Y05M")
(xs:yearMonthDuration("P21Y12M") - xs:yearMonthDuration("P08Y05M")) ne xs:yearMonthDuration("P08Y05M")
(xs:yearMonthDuration("P23Y11M") * 2.0) eq xs:yearMonthDuration("P23Y11M")
(xs:yearMonthDuration("P23Y11M") div 2.0) eq xs:yearMonthDuration("P23Y11M")
(xs:yearMonthDuration("P23Y11M") div xs:yearMonthDuration("P23Y11M")) eq xs:decimal(2.0)
(xs:yearMonthDuration("P23Y11M") + xs:yearMonthDuration("P23Y11M")) eq xs:yearMonthDuration("P23Y11M")
(xs:yearMonthDuration("P23Y11M") - xs:yearMonthDuration("P23Y11M")) eq xs:yearMonthDuration("P23Y11M")
xs:yearMonthDuration("P2Y11M") * 2.3
(xs:yearMonthDuration("P2Y11M") div 1.5)
(xs:yearMonthDuration("P2Y11M") - xs:yearMonthDuration("P3Y3M"))
xs:yearMonthDuration("P2Y11M") + xs:yearMonthDuration("P3Y3M")
xs:yearMonthDuration("P2Y") * xs:double('NaN')
xs:yearMonthDuration("-P3")
(xs:yearMonthDuration("P30Y10M") gt xs:yearMonthDuration("P01Y02M")) or (fn:false())
(xs:yearMonthDuration("P30Y10M") lt xs:yearMonthDuration("P01Y02M")) or (fn:false())
xs:yearMonthDuration("P32Y43M") - xs:yearMonthDuration("P12Y13M") eq xs:yearMonthDuration("P22Y6M")
xs:yearMonthDuration("P32Y43M") + xs:yearMonthDuration("P12Y13M") eq xs:yearMonthDuration("P48Y8M")
xs:yearMonthDuration("P3Y36M") * 0 eq xs:yearMonthDuration("P0M")
xs:yearMonthDuration("P3Y36M") * 3 eq xs:yearMonthDuration("P18Y")
xs:yearMonthDuration("P3Y36M") div 0
xs:yearMonthDuration("P3Y36M") div 3 eq xs:yearMonthDuration("P2Y")
xs:yearMonthDuration("P3Y36M") div xs:double("-0")
xs:yearMonthDuration("P3Y36M") div xs:double("-INF") eq xs:yearMonthDuration("P0M")
xs:yearMonthDuration("P3Y36M") div xs:double("INF") eq xs:yearMonthDuration("P0M")
xs:yearMonthDuration("P3Y36M") div xs:double("NaN")
xs:yearMonthDuration("P3Y36M") div xs:yearMonthDuration("P60Y") eq 0.1
xs:yearMonthDuration("P3Y3M") div xs:dayTimeDuration("P3D")
xs:yearMonthDuration("P3Y3M") div xs:duration("P3D")
xs:yearMonthDuration("P3Y3M") * xs:dayTimeDuration("P3D")
xs:yearMonthDuration("P3Y3M") + xs:dayTimeDuration("P3D")
xs:yearMonthDuration("P3Y3M") - xs:dayTimeDuration("P3D")
xs:yearMonthDuration("P3Y3M") * xs:double("-INF")
xs:yearMonthDuration("P3Y3M") * xs:double("INF")
xs:yearMonthDuration("P3Y3M") * xs:double("NaN")
xs:yearMonthDuration("P3Y3M") + xs:duration("P3D")
xs:yearMonthDuration("P3Y3M") - xs:duration("P3D")
xs:yearMonthDuration("P3Y3M") + xs:yearMonthDuration("P0M") eq xs:yearMonthDuration("P3Y3M")
xs:yearMonthDuration("P3Y3M") - xs:yearMonthDuration("P0M") eq xs:yearMonthDuration("P3Y3M")
xs:yearMonthDuration("P3Y3M") * xs:yearMonthDuration("P3Y3M")
xs:yearMonthDuration("P3Y4M") div xs:yearMonthDuration("-P1Y4M")
xs:yearMonthDuration("-P3Y8M") ne xs:yearMonthDuration("P3Y8M")
(xs:yearMonthDuration("P42Y10M") - xs:yearMonthDuration("P20Y10M")) div (xs:yearMonthDuration("P20Y11M") - xs:yearMonthDuration("P18Y11M"))
(xs:yearMonthDuration("P42Y10M") + xs:yearMonthDuration("P28Y10M")) div (xs:yearMonthDuration("P10Y10M") + xs:yearMonthDuration("P60Y10M"))
xs:yearMonthDuration("P731D")
xs:yearMonthDuration('P768614336404564650Y0M') * 2
xs:yearMonthDuration('P768614336404564650Y0M') div 0.5
xs:yearMonthDuration('P768614336404564650Y0M') - xs:yearMonthDuration('-P768614336404564650Y0M')
xs:yearMonthDuration('P768614336404564650Y0M') + xs:yearMonthDuration('P768614336404564650Y1M')
xs:yearMonthDuration(xs:untypedAtomic( "P1Y12M" )) eq xs:yearMonthDuration("P1Y12M")
"&#xW20;"
<x> <x> <y id="0"/> </x> <y id="1"/> </x>/descendant-or-self::x/child::y
(<x/>, <?y?>)[self::processing-instruction()]
"xyz" , xs:string(" "), "b"
year-from-date()
year-from-date(current-date()) = 1 to 5000
year-from-date(current-date()) = 5000 to 10000
year-from-date(current-date()) to 4000 = 1500 to 2500
year-from-date(()) instance of xs:integer?
year-from-dateTime()
year-from-dateTime(()) instance of xs:integer?
year-from-dateTime((), "Wrong param")
year-from-dateTime(xs:dateTime("2001-02-03T08:23:12.43")) eq 2001
(year-from-dateTime( xs:dateTime('2006-08-15T10:30:23')))
year-from-date((), "Wrong param")
year-from-date(xs:date("2000-02-03")) eq 2000
(year-from-date(xs:date('2006-08-15')))
years-from-duration()
years-from-duration(()) instance of xs:integer?
years-from-duration((), "Wrong param")
years-from-duration(xs:duration("-P3Y4M4DT1H23M2.34S")) eq -3
years-from-duration(xs:yearMonthDuration("-P0003Y2M")) eq -3
years-from-duration(xs:yearMonthDuration("P0003Y2M")) eq 3
(years-from-duration( xs:yearMonthDuration('P12M')))
(years-from-duration( xs:yearMonthDuration('-P18M')))
(years-from-duration( xs:yearMonthDuration('P1Y18M')))
(years-from-duration( xs:yearMonthDuration('P3Y')))
(years-from-duration( xs:yearMonthDuration('P3Y11M')))
(years-from-duration( xs:yearMonthDuration('P3Y')), years-from-duration( xs:yearMonthDuration('P3Y11M')), years-from-duration( xs:yearMonthDuration('-P18M')), years-from-duration( xs:yearMonthDuration('P1Y18M')), years-from-duration( xs:yearMonthDuration('P12M')))
zero-or-more(1)
(zero-or-one( () ))
zero-or-one()
zero-or-one(1, 2)
zero-or-one( (1, 2, 3) )
(zero-or-one('a'))
zero-or-one(true())
(zero-or-one( () ), zero-or-one('a'))
(("zzz" || "zz") || "123")
